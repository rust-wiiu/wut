/* automatically generated by rust-bindgen 0.70.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 18;
pub const __clang_minor__: u32 = 1;
pub const __clang_patchlevel__: u32 = 3;
#[allow(unsafe_code)]
pub const __clang_version__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"18.1.3 (1ubuntu1)\0") };
pub const __GNUC__: u32 = 4;
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __MEMORY_SCOPE_SYSTEM: u32 = 0;
pub const __MEMORY_SCOPE_DEVICE: u32 = 1;
pub const __MEMORY_SCOPE_WRKGRP: u32 = 2;
pub const __MEMORY_SCOPE_WVFRNT: u32 = 3;
pub const __MEMORY_SCOPE_SINGLE: u32 = 4;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __FPCLASS_SNAN: u32 = 1;
pub const __FPCLASS_QNAN: u32 = 2;
pub const __FPCLASS_NEGINF: u32 = 4;
pub const __FPCLASS_NEGNORMAL: u32 = 8;
pub const __FPCLASS_NEGSUBNORMAL: u32 = 16;
pub const __FPCLASS_NEGZERO: u32 = 32;
pub const __FPCLASS_POSZERO: u32 = 64;
pub const __FPCLASS_POSSUBNORMAL: u32 = 128;
pub const __FPCLASS_POSNORMAL: u32 = 256;
pub const __FPCLASS_POSINF: u32 = 512;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
#[allow(unsafe_code)]
pub const __VERSION__: &::core::ffi::CStr = unsafe {
    ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Ubuntu Clang 18.1.3 (1ubuntu1)\0")
};
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
#[allow(unsafe_code)]
pub const __clang_literal_encoding__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"UTF-8\0") };
#[allow(unsafe_code)]
pub const __clang_wide_literal_encoding__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"UTF-32\0") };
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 4321;
pub const __BIG_ENDIAN__: u32 = 1;
pub const _ILP32: u32 = 1;
pub const __ILP32__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __BOOL_WIDTH__: u32 = 8;
pub const __SHRT_WIDTH__: u32 = 16;
pub const __INT_WIDTH__: u32 = 32;
pub const __LONG_WIDTH__: u32 = 32;
pub const __LLONG_WIDTH__: u32 = 64;
pub const __BITINT_MAXWIDTH__: u32 = 128;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u32 = 2147483647;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_MAX__: u32 = 2147483647;
pub const __WINT_WIDTH__: u32 = 32;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __SIZE_MAX__: u32 = 4294967295;
pub const __SIZE_WIDTH__: u32 = 32;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_MAX__: u32 = 2147483647;
pub const __PTRDIFF_WIDTH__: u32 = 32;
pub const __INTPTR_MAX__: u32 = 2147483647;
pub const __INTPTR_WIDTH__: u32 = 32;
pub const __UINTPTR_MAX__: u32 = 4294967295;
pub const __UINTPTR_WIDTH__: u32 = 32;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 4;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 4;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 4;
pub const __SIZEOF_SIZE_T__: u32 = 4;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
#[allow(unsafe_code)]
pub const __INTMAX_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INTMAX_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
#[allow(unsafe_code)]
pub const __PTRDIFF_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const __PTRDIFF_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const __INTPTR_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const __INTPTR_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __UINTPTR_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 31;
pub const __LDBL_DECIMAL_DIG__: u32 = 33;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 106;
pub const __LDBL_MAX_10_EXP__: u32 = 308;
pub const __LDBL_MAX_EXP__: u32 = 1024;
pub const __LDBL_MIN_10_EXP__: i32 = -291;
pub const __LDBL_MIN_EXP__: i32 = -968;
pub const __POINTER_WIDTH__: u32 = 32;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __CHAR_UNSIGNED__: u32 = 1;
#[allow(unsafe_code)]
pub const __INT8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
#[allow(unsafe_code)]
pub const __INT16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
#[allow(unsafe_code)]
pub const __INT32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
#[allow(unsafe_code)]
pub const __INT64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
#[allow(unsafe_code)]
pub const __UINT16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
#[allow(unsafe_code)]
pub const __UINT32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
#[allow(unsafe_code)]
pub const __UINT64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_WIDTH__: u32 = 8;
#[allow(unsafe_code)]
pub const __INT_LEAST8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
pub const __UINT_LEAST8_MAX__: u32 = 255;
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_WIDTH__: u32 = 16;
#[allow(unsafe_code)]
pub const __INT_LEAST16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
pub const __UINT_LEAST16_MAX__: u32 = 65535;
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __INT_LEAST32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_WIDTH__: u32 = 64;
#[allow(unsafe_code)]
pub const __INT_LEAST64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
pub const __UINT_LEAST64_MAX__: i32 = -1;
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_WIDTH__: u32 = 8;
#[allow(unsafe_code)]
pub const __INT_FAST8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT_FAST8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
pub const __UINT_FAST8_MAX__: u32 = 255;
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_WIDTH__: u32 = 16;
#[allow(unsafe_code)]
pub const __INT_FAST16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT_FAST16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
pub const __UINT_FAST16_MAX__: u32 = 65535;
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __INT_FAST32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT_FAST32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_WIDTH__: u32 = 64;
#[allow(unsafe_code)]
pub const __INT_FAST64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT_FAST64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
pub const __UINT_FAST64_MAX__: i32 = -1;
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 33;
pub const __ELF__: u32 = 1;
pub const __ppc__: u32 = 1;
pub const __PPC__: u32 = 1;
pub const _ARCH_PPC: u32 = 1;
pub const __powerpc__: u32 = 1;
pub const __POWERPC__: u32 = 1;
pub const _BIG_ENDIAN: u32 = 1;
pub const __NATURAL_ALIGNMENT__: u32 = 1;
pub const __LONG_DOUBLE_128__: u32 = 1;
pub const __LONGDOUBLE128: u32 = 1;
pub const __LONG_DOUBLE_IBM128__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __HAVE_BSWAP__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201710;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
#[allow(unsafe_code)]
pub const _NEWLIB_VERSION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"4.4.0\0") };
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
#[allow(unsafe_code)]
pub const __INT8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __INT16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __INT64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
#[allow(unsafe_code)]
pub const __FAST8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __FAST16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __FAST64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
#[allow(unsafe_code)]
pub const __LEAST8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __LEAST16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __LEAST64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST16_MAX: u32 = 32767;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const UINTMAX_MAX: i32 = -1;
pub const SIZE_MAX: u32 = 4294967295;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const OS_MESSAGE_QUEUE_TAG: u32 = 1834182481;
pub const OS_FAST_MUTEX_TAG: u32 = 1716352088;
pub const OS_CONTEXT_TAG: u64 = 5715986497936849012;
pub const OS_ALARM_QUEUE_TAG: u32 = 1632398673;
pub const OS_ALARM_TAG: u32 = 1632399949;
pub const FS_MAX_PATH: u32 = 639;
pub const FS_MODE_LENGTH: u32 = 16;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const GX2_FALSE: u32 = 0;
pub const GX2_TRUE: u32 = 1;
pub const GX2_DISABLE: u32 = 0;
pub const GX2_ENABLE: u32 = 1;
pub const GX2_COMMAND_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_CONTEXT_STATE_ALIGNMENT: u32 = 256;
pub const GX2_SCAN_BUFFER_ALIGNMENT: u32 = 4096;
pub const GX2_SHADER_PROGRAM_ALIGNMENT: u32 = 256;
pub const GX2_VERTEX_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_INDEX_BUFFER_ALIGNMENT: u32 = 32;
pub const GX2_UNIFORM_BLOCK_ALIGNMENT: u32 = 256;
pub const GX2_COMMAND_BUFFER_SIZE: u32 = 4194304;
pub const GFD_HEADER_MAGIC: u32 = 1197897778;
pub const GFD_BLOCK_HEADER_MAGIC: u32 = 1112296315;
pub const GFD_RELOCATION_HEADER_MAGIC: u32 = 2101496907;
pub const GFD_FILE_VERSION_MAJOR: u32 = 7;
pub const GFD_FILE_VERSION_MINOR: u32 = 1;
pub const GFD_BLOCK_VERSION_MAJOR: u32 = 1;
pub const GFD_PATCH_MASK: u32 = 4293918720;
pub const GFD_PATCH_DATA: u32 = 3495952384;
pub const GFD_PATCH_TEXT: u32 = 3396337664;
pub const FD_SETSIZE: u32 = 32;
pub const IOCPARM_SHIFT: u32 = 13;
pub const IOCPARM_MASK: u32 = 8191;
pub const IOCPARM_MAX: u32 = 8192;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOC_DIRMASK: u32 = 3758096384;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 4321;
pub const _QUAD_HIGHWORD: u32 = 0;
pub const _QUAD_LOWWORD: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 4321;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG2STR_MAX: u32 = 17;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: i32 = -1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_DONTWAIT: u32 = 32;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_TCPSACK: u32 = 512;
pub const SO_WINSCALE: u32 = 1024;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_HOPCNT: u32 = 4105;
pub const SO_MAXMSG: u32 = 4112;
pub const SO_RXDATA: u32 = 4113;
pub const SO_TXDATA: u32 = 4114;
pub const SO_MYADDR: u32 = 4115;
pub const SO_NBIO: u32 = 4116;
pub const SO_BIO: u32 = 4117;
pub const SO_NONBLOCK: u32 = 4118;
pub const SO_UNKNOWN1019: u32 = 4121;
pub const SO_UNKNOWN101A: u32 = 4122;
pub const SO_UNKNOWN101B: u32 = 4123;
pub const SO_NOSLOWSTART: u32 = 16384;
pub const SO_RUSRBUF: u32 = 65536;
pub const OS_THREAD_TAG: u32 = 1950904900;
pub const CAMERA_WIDTH: u32 = 640;
pub const CAMERA_PITCH: u32 = 768;
pub const CAMERA_HEIGHT: u32 = 480;
pub const CAMERA_Y_BUFFER_SIZE: u32 = 368640;
pub const CAMERA_UV_BUFFER_SIZE: u32 = 184320;
pub const CAMERA_YUV_BUFFER_SIZE: u32 = 552960;
pub const CAMERA_YUV_BUFFER_ALIGNMENT: u32 = 256;
pub const CCR_CDC_IRDA_DATA_TRANSFER_SIZE: u32 = 520;
pub const SOL_TCP: u32 = 6;
pub const TCP_ACKDELAYTIME: u32 = 8193;
pub const TCP_NOACKDELAY: u32 = 8194;
pub const TCP_MAXSEG: u32 = 8195;
pub const TCP_NODELAY: u32 = 8196;
pub const TCP_UNKNOWN: u32 = 8197;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_UNKNOWN: u32 = 14;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const OS_EVENT_TAG: u32 = 1700163156;
pub const HPAD_STICK_AXIS_MIN: i32 = -56;
pub const HPAD_STICK_AXIS_MAX: u32 = 56;
pub const HPAD_SUBSTICK_AXIS_MIN: i32 = -44;
pub const HPAD_SUBSTICK_AXIS_MAX: u32 = 44;
pub const HPAD_TRIGGER_MIN: u32 = 0;
pub const HPAD_TRIGGER_MAX: u32 = 150;
pub const WHB_SERVER_BUFFER_SIZE: u32 = 1024;
pub const NSYSNET_FD_SETSIZE: u32 = 32;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_NUMERICSCOPE: u32 = 32;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const USBCLASS_DEVICE: u32 = 0;
pub const USBCLASS_AUDIO: u32 = 1;
pub const USBCLASS_HID: u32 = 3;
pub const USBCLASS_STORAGE: u32 = 8;
pub const MATCH_ANY: u32 = 0;
pub const MATCH_DEV_VID: u32 = 1;
pub const MATCH_DEV_PID: u32 = 2;
pub const MATCH_DEV_CLASS: u32 = 16;
pub const MATCH_DEV_SUBCLASS: u32 = 32;
pub const MATCH_DEV_PROTOCOL: u32 = 64;
pub const MATCH_IF_CLASS: u32 = 128;
pub const MATCH_IF_SUBCLASS: u32 = 256;
pub const MATCH_IF_PROTOCOL: u32 = 512;
pub const UHS_CONFIG_BUFFER_SIZE: u32 = 4991;
pub const ENDPOINT_TRANSFER_OUT: u32 = 1;
pub const ENDPOINT_TRANSFER_IN: u32 = 2;
pub const TIMEOUT_NONE: i32 = -1;
pub const OS_SEMAPHORE_TAG: u32 = 1934649426;
pub const OS_MUTEX_TAG: u32 = 1834316888;
pub const IPC_BUF_POOL_MAGIC: u32 = 195948557;
pub const OS_FAST_CONDITION_TAG: u32 = 1716413526;
pub const OS_CONDITION_TAG: u32 = 1666081878;
pub const OS_TITLE_ID_COLDBOOT: i32 = -3;
pub const OS_TITLE_ID_REBOOT: i32 = -2;
pub const OS_PAGE_SIZE: u32 = 131072;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_long;
pub type __uintptr_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type BOOL = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadLink {
    pub next: *mut OSThread,
    pub prev: *mut OSThread,
}
impl Default for OSThreadLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk0: [::core::ffi::c_char; 4usize],
}
impl Default for OSThreadQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadSimpleQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
}
impl Default for OSThreadSimpleQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitThreadQueue(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSInitThreadQueueEx(queue: *mut OSThreadQueue, parent: *mut ::core::ffi::c_void);
}
pub const OS_MESSAGE_FLAGS_NONE: OSMessageFlags = 0;
pub const OS_MESSAGE_FLAGS_BLOCKING: OSMessageFlags = 1;
pub const OS_MESSAGE_FLAGS_HIGH_PRIORITY: OSMessageFlags = 2;
pub type OSMessageFlags = ::core::ffi::c_uint;
pub const OS_FUNCTION_TYPE_HIO_OPEN: OSFunctionType = 1;
pub const OS_FUNCTION_TYPE_HIO_READ_ASYNC: OSFunctionType = 2;
pub const OS_FUNCTION_TYPE_HIO_WRITE_ASYNC: OSFunctionType = 3;
pub const OS_FUNCTION_TYPE_FSA_CMD_ASYNC: OSFunctionType = 4;
pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC: OSFunctionType = 5;
pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC_NO_ALLOC: OSFunctionType = 6;
pub const OS_FUNCTION_TYPE_FSA_ATTACH_EVENT: OSFunctionType = 7;
pub const OS_FUNCTION_TYPE_FS_CMD_ASYNC: OSFunctionType = 8;
pub const OS_FUNCTION_TYPE_FS_CMD_HANDLER: OSFunctionType = 9;
pub const OS_FUNCTION_TYPE_FS_ATTACH_EVENT: OSFunctionType = 10;
pub const OS_FUNCTION_TYPE_FS_STATE_CHANGE_EVENT: OSFunctionType = 11;
pub type OSFunctionType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessage {
    pub message: *mut ::core::ffi::c_void,
    pub args: [u32; 3usize],
}
impl Default for OSMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessageQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk1: [::core::ffi::c_char; 4usize],
    pub sendQueue: OSThreadQueue,
    pub recvQueue: OSThreadQueue,
    pub messages: *mut OSMessage,
    pub size: u32,
    pub first: u32,
    pub used: u32,
}
impl Default for OSMessageQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitMessageQueue(queue: *mut OSMessageQueue, messages: *mut OSMessage, size: i32);
}
extern "C" {
    pub fn OSInitMessageQueueEx(
        queue: *mut OSMessageQueue,
        messages: *mut OSMessage,
        size: i32,
        name: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSSendMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags,
    ) -> BOOL;
}
extern "C" {
    pub fn OSReceiveMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags,
    ) -> BOOL;
}
extern "C" {
    pub fn OSPeekMessage(queue: *mut OSMessageQueue, message: *mut OSMessage) -> BOOL;
}
extern "C" {
    pub fn OSGetSystemMessageQueue() -> *mut OSMessageQueue;
}
extern "C" {
    pub fn OSGetDefaultAppIOQueue() -> *mut OSMessageQueue;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSSystemInfo {
    pub busClockSpeed: u32,
    pub coreClockSpeed: u32,
    pub baseTime: i64,
    pub __unk2: [::core::ffi::c_char; 16usize],
}
extern "C" {
    pub fn OSGetSystemInfo() -> *mut OSSystemInfo;
}
extern "C" {
    pub fn OSEnableHomeButtonMenu(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSIsHomeButtonMenuEnabled() -> BOOL;
}
extern "C" {
    pub fn OSGetOSID() -> u64;
}
extern "C" {
    pub fn __OSGetProcessSDKVersion() -> u32;
}
pub type OSTick = i32;
pub type OSTime = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSCalendarTime {
    pub tm_sec: i32,
    pub tm_min: i32,
    pub tm_hour: i32,
    pub tm_mday: i32,
    pub tm_mon: i32,
    pub tm_year: i32,
    pub tm_wday: i32,
    pub tm_yday: i32,
    pub tm_msec: i32,
    pub tm_usec: i32,
}
extern "C" {
    pub fn OSGetTime() -> OSTime;
}
extern "C" {
    pub fn OSGetSystemTime() -> OSTime;
}
extern "C" {
    pub fn OSGetTick() -> OSTick;
}
extern "C" {
    pub fn OSGetSystemTick() -> OSTick;
}
extern "C" {
    pub fn OSCalendarTimeToTicks(calendarTime: *mut OSCalendarTime) -> OSTime;
}
extern "C" {
    pub fn OSTicksToCalendarTime(time: OSTime, calendarTime: *mut OSCalendarTime);
}
extern "C" {
    pub fn __OSSetAbsoluteSystemTime(time: OSTime) -> BOOL;
}
pub type IOSHandle = i32;
pub const IOS_OPEN_READ: IOSOpenMode = 1;
pub const IOS_OPEN_WRITE: IOSOpenMode = 2;
pub const IOS_OPEN_READWRITE: IOSOpenMode = 3;
pub type IOSOpenMode = ::core::ffi::c_uint;
pub const IOS_ERROR_OK: IOSError = 0;
pub const IOS_ERROR_ACCESS: IOSError = -1;
pub const IOS_ERROR_EXISTS: IOSError = -2;
pub const IOS_ERROR_INTR: IOSError = -3;
pub const IOS_ERROR_INVALID: IOSError = -4;
pub const IOS_ERROR_MAX: IOSError = -5;
pub const IOS_ERROR_NOEXISTS: IOSError = -6;
pub const IOS_ERROR_QEMPTY: IOSError = -7;
pub const IOS_ERROR_QFULL: IOSError = -8;
pub const IOS_ERROR_UNKNOWN: IOSError = -9;
pub const IOS_ERROR_NOTREADY: IOSError = -10;
pub const IOS_ERROR_ECC: IOSError = -11;
pub const IOS_ERROR_ECCCRIT: IOSError = -12;
pub const IOS_ERROR_BADBLOCK: IOSError = -13;
pub const IOS_ERROR_INVALIDOBJTYPE: IOSError = -14;
pub const IOS_ERROR_INVALIDRNG: IOSError = -15;
pub const IOS_ERROR_INVALIDFLAG: IOSError = -16;
pub const IOS_ERROR_INVALIDFORMAT: IOSError = -17;
pub const IOS_ERROR_INVALIDVERSION: IOSError = -18;
pub const IOS_ERROR_INVALIDSIGNER: IOSError = -19;
pub const IOS_ERROR_FAILCHECKVALUE: IOSError = -20;
pub const IOS_ERROR_FAILINTERNAL: IOSError = -21;
pub const IOS_ERROR_FAILALLOC: IOSError = -22;
pub const IOS_ERROR_INVALIDSIZE: IOSError = -23;
pub const IOS_ERROR_NOLINK: IOSError = -24;
pub const IOS_ERROR_ANFAILED: IOSError = -25;
pub const IOS_ERROR_MAXSEMCOUNT: IOSError = -26;
pub const IOS_ERROR_SEMUNAVAILABLE: IOSError = -27;
pub const IOS_ERROR_INVALIDHANDLE: IOSError = -28;
pub const IOS_ERROR_INVALIDARG: IOSError = -29;
pub const IOS_ERROR_NORESOURCE: IOSError = -30;
pub const IOS_ERROR_BUSY: IOSError = -31;
pub const IOS_ERROR_TIMEOUT: IOSError = -32;
pub const IOS_ERROR_ALIGNMENT: IOSError = -33;
pub const IOS_ERROR_BSP: IOSError = -34;
pub const IOS_ERROR_DATAPENDING: IOSError = -35;
pub const IOS_ERROR_EXPIRED: IOSError = -36;
pub const IOS_ERROR_NOREADACCESS: IOSError = -37;
pub const IOS_ERROR_NOWRITEACCESS: IOSError = -38;
pub const IOS_ERROR_NOREADWRITEACCESS: IOSError = -39;
pub const IOS_ERROR_CLIENTTXNLIMIT: IOSError = -40;
pub const IOS_ERROR_STALEHANDLE: IOSError = -41;
pub const IOS_ERROR_UNKNOWNVALUE: IOSError = -42;
pub type IOSError = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOSVec {
    pub vaddr: *mut ::core::ffi::c_void,
    pub len: u32,
    pub paddr: *mut ::core::ffi::c_void,
}
impl Default for IOSVec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IOSAsyncCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: IOSError, arg2: *mut ::core::ffi::c_void)>;
extern "C" {
    pub fn IOS_Open(device: *const ::core::ffi::c_char, mode: IOSOpenMode) -> IOSError;
}
extern "C" {
    pub fn IOS_OpenAsync(
        device: *const ::core::ffi::c_char,
        mode: IOSOpenMode,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IOS_Close(handle: IOSHandle) -> IOSError;
}
extern "C" {
    pub fn IOS_CloseAsync(
        handle: IOSHandle,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IOS_Ioctl(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
    ) -> IOSError;
}
extern "C" {
    pub fn IOS_IoctlAsync(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IOS_Ioctlv(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
    ) -> IOSError;
}
extern "C" {
    pub fn IOS_IoctlvAsync(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexLink {
    pub next: *mut OSFastMutex,
    pub prev: *mut OSFastMutex,
}
impl Default for OSFastMutexLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk3: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadSimpleQueue,
    pub link: OSFastMutexLink,
    pub __unk4: [::core::ffi::c_char; 16usize],
}
impl Default for OSFastMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSFastMutex_Init(mutex: *mut OSFastMutex, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSFastMutex_Lock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_Unlock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_TryLock(mutex: *mut OSFastMutex) -> BOOL;
}
pub type OSContextState = u16;
pub const OS_CONTEXT_STATE_OSCALLBACK: OS_CONTEXT_STATE = 8;
pub const OS_CONTEXT_STATE_USERMODE_SAVED: OS_CONTEXT_STATE = 16;
pub type OS_CONTEXT_STATE = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSContext {
    pub tag: u64,
    pub gpr: [u32; 32usize],
    pub cr: u32,
    pub lr: u32,
    pub ctr: u32,
    pub xer: u32,
    pub srr0: u32,
    pub srr1: u32,
    pub dsisr: u32,
    pub dar: u32,
    pub __unk5: [::core::ffi::c_char; 12usize],
    pub fpscr: u32,
    pub fpr: [f64; 32usize],
    pub spinLockCount: u16,
    pub state: OSContextState,
    pub gqr: [u32; 8usize],
    pub upir: u32,
    pub psf: [f64; 32usize],
    pub coretime: [u64; 3usize],
    pub starttime: u64,
    pub error: u32,
    pub __unk6: [::core::ffi::c_char; 4usize],
    pub pmc1: u32,
    pub pmc2: u32,
    pub pmc3: u32,
    pub pmc4: u32,
    pub mmcr0: u32,
    pub mmcr1: u32,
}
extern "C" {
    pub fn OSInitContext(
        context: *mut OSContext,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn OSDumpContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSLoadContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveContext(context: *mut OSContext) -> u32;
}
extern "C" {
    pub fn OSLoadFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSGetCurrentContext() -> *mut OSContext;
}
extern "C" {
    pub fn OSSetCurrentContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSwitchStack(stack: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSSetCurrentUserContext(context: *mut OSContext);
}
extern "C" {
    pub fn __OSSetAndLoadContext(context: *mut OSContext);
}
pub type OSAlarmCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut OSAlarm, arg2: *mut OSContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk7: [::core::ffi::c_char; 4usize],
    pub threadQueue: OSThreadQueue,
    pub head: *mut OSAlarm,
    pub tail: *mut OSAlarm,
}
impl Default for OSAlarmQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmLink {
    pub prev: *mut OSAlarm,
    pub next: *mut OSAlarm,
}
impl Default for OSAlarmLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarm {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk8: [::core::ffi::c_char; 4usize],
    pub callback: OSAlarmCallback,
    pub group: u32,
    pub __unk9: [::core::ffi::c_char; 4usize],
    pub nextFire: OSTime,
    pub link: OSAlarmLink,
    pub period: OSTime,
    pub start: OSTime,
    pub userData: *mut ::core::ffi::c_void,
    pub state: u32,
    pub threadQueue: OSThreadQueue,
    pub alarmQueue: *mut OSAlarmQueue,
    pub context: *mut OSContext,
}
impl Default for OSAlarm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSCancelAlarm(alarm: *mut OSAlarm) -> BOOL;
}
extern "C" {
    pub fn OSCancelAlarms(group: u32);
}
extern "C" {
    pub fn OSCreateAlarm(alarm: *mut OSAlarm);
}
extern "C" {
    pub fn OSCreateAlarmEx(alarm: *mut OSAlarm, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSGetAlarmUserData(alarm: *mut OSAlarm) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSInitAlarmQueue(queue: *mut OSAlarmQueue);
}
extern "C" {
    pub fn OSInitAlarmQueueEx(queue: *mut OSAlarmQueue, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSSetAlarm(alarm: *mut OSAlarm, time: OSTime, callback: OSAlarmCallback) -> BOOL;
}
extern "C" {
    pub fn OSSetPeriodicAlarm(
        alarm: *mut OSAlarm,
        start: OSTime,
        interval: OSTime,
        callback: OSAlarmCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSetAlarmTag(alarm: *mut OSAlarm, group: u32);
}
extern "C" {
    pub fn OSSetAlarmUserData(alarm: *mut OSAlarm, data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSWaitAlarm(alarm: *mut OSAlarm) -> BOOL;
}
pub type FSDirectoryHandle = u32;
pub type FSFileHandle = u32;
pub type FSPriority = u32;
pub type FSTime = u64;
pub type FSStateChangeInfo = FSStateChangeParams;
pub const FS_ERROR_FLAG_NONE: FSErrorFlag = 0;
pub const FS_ERROR_FLAG_MAX: FSErrorFlag = 1;
pub const FS_ERROR_FLAG_ALREADY_OPEN: FSErrorFlag = 2;
pub const FS_ERROR_FLAG_EXISTS: FSErrorFlag = 4;
pub const FS_ERROR_FLAG_NOT_FOUND: FSErrorFlag = 8;
pub const FS_ERROR_FLAG_NOT_FILE: FSErrorFlag = 16;
pub const FS_ERROR_FLAG_NOT_DIR: FSErrorFlag = 32;
pub const FS_ERROR_FLAG_ACCESS_ERROR: FSErrorFlag = 64;
pub const FS_ERROR_FLAG_PERMISSION_ERROR: FSErrorFlag = 128;
pub const FS_ERROR_FLAG_FILE_TOO_BIG: FSErrorFlag = 256;
pub const FS_ERROR_FLAG_STORAGE_FULL: FSErrorFlag = 512;
pub const FS_ERROR_FLAG_UNSUPPORTED_CMD: FSErrorFlag = 1024;
pub const FS_ERROR_FLAG_JOURNAL_FULL: FSErrorFlag = 2048;
pub const FS_ERROR_FLAG_ALL: FSErrorFlag = 4294967295;
pub type FSErrorFlag = ::core::ffi::c_uint;
pub const FS_STATUS_OK: FSStatus = 0;
pub const FS_STATUS_CANCELLED: FSStatus = -1;
pub const FS_STATUS_END: FSStatus = -2;
pub const FS_STATUS_MAX: FSStatus = -3;
pub const FS_STATUS_ALREADY_OPEN: FSStatus = -4;
pub const FS_STATUS_EXISTS: FSStatus = -5;
pub const FS_STATUS_NOT_FOUND: FSStatus = -6;
pub const FS_STATUS_NOT_FILE: FSStatus = -7;
pub const FS_STATUS_NOT_DIR: FSStatus = -8;
pub const FS_STATUS_ACCESS_ERROR: FSStatus = -9;
pub const FS_STATUS_PERMISSION_ERROR: FSStatus = -10;
pub const FS_STATUS_FILE_TOO_BIG: FSStatus = -11;
pub const FS_STATUS_STORAGE_FULL: FSStatus = -12;
pub const FS_STATUS_JOURNAL_FULL: FSStatus = -13;
pub const FS_STATUS_UNSUPPORTED_CMD: FSStatus = -14;
pub const FS_STATUS_MEDIA_NOT_READY: FSStatus = -15;
pub const FS_STATUS_MEDIA_ERROR: FSStatus = -17;
pub const FS_STATUS_CORRUPTED: FSStatus = -18;
pub const FS_STATUS_FATAL_ERROR: FSStatus = -1024;
pub type FSStatus = ::core::ffi::c_int;
pub const FS_ERROR_OK: FSError = 0;
pub const FS_ERROR_NOT_INIT: FSError = -196609;
pub const FS_ERROR_BUSY: FSError = -196610;
pub const FS_ERROR_CANCELLED: FSError = -196611;
pub const FS_ERROR_END_OF_DIR: FSError = -196612;
pub const FS_ERROR_END_OF_FILE: FSError = -196613;
pub const FS_ERROR_MAX_MOUNT_POINTS: FSError = -196624;
pub const FS_ERROR_MAX_VOLUMES: FSError = -196625;
pub const FS_ERROR_MAX_CLIENTS: FSError = -196626;
pub const FS_ERROR_MAX_FILES: FSError = -196627;
pub const FS_ERROR_MAX_DIRS: FSError = -196628;
pub const FS_ERROR_ALREADY_OPEN: FSError = -196629;
pub const FS_ERROR_ALREADY_EXISTS: FSError = -196630;
pub const FS_ERROR_NOT_FOUND: FSError = -196631;
pub const FS_ERROR_NOT_EMPTY: FSError = -196632;
pub const FS_ERROR_ACCESS_ERROR: FSError = -196633;
pub const FS_ERROR_PERMISSION_ERROR: FSError = -196634;
pub const FS_ERROR_DATA_CORRUPTED: FSError = -196635;
pub const FS_ERROR_STORAGE_FULL: FSError = -196636;
pub const FS_ERROR_JOURNAL_FULL: FSError = -196637;
pub const FS_ERROR_UNAVAILABLE_COMMAND: FSError = -196639;
pub const FS_ERROR_UNSUPPORTED_COMMAND: FSError = -196640;
pub const FS_ERROR_INVALID_PARAM: FSError = -196641;
pub const FS_ERROR_INVALID_PATH: FSError = -196642;
pub const FS_ERROR_INVALID_BUFFER: FSError = -196643;
pub const FS_ERROR_INVALID_ALIGNMENT: FSError = -196644;
pub const FS_ERROR_INVALID_CLIENTHANDLE: FSError = -196645;
pub const FS_ERROR_INVALID_FILEHANDLE: FSError = -196646;
pub const FS_ERROR_INVALID_DIRHANDLE: FSError = -196647;
pub const FS_ERROR_NOT_FILE: FSError = -196648;
pub const FS_ERROR_NOT_DIR: FSError = -196649;
pub const FS_ERROR_FILE_TOO_BIG: FSError = -196650;
pub const FS_ERROR_OUT_OF_RANGE: FSError = -196651;
pub const FS_ERROR_OUT_OF_RESOURCES: FSError = -196652;
pub const FS_ERROR_MEDIA_NOT_READY: FSError = -196672;
pub const FS_ERROR_MEDIA_ERROR: FSError = -196673;
pub const FS_ERROR_WRITE_PROTECTED: FSError = -196674;
pub const FS_ERROR_INVALID_MEDIA: FSError = -196675;
pub type FSError = ::core::ffi::c_int;
pub const FS_MODE_READ_OWNER: FSMode = 1024;
pub const FS_MODE_WRITE_OWNER: FSMode = 512;
pub const FS_MODE_EXEC_OWNER: FSMode = 256;
pub const FS_MODE_READ_GROUP: FSMode = 64;
pub const FS_MODE_WRITE_GROUP: FSMode = 32;
pub const FS_MODE_EXEC_GROUP: FSMode = 16;
pub const FS_MODE_READ_OTHER: FSMode = 4;
pub const FS_MODE_WRITE_OTHER: FSMode = 2;
pub const FS_MODE_EXEC_OTHER: FSMode = 1;
pub type FSMode = ::core::ffi::c_uint;
pub const FS_STAT_DIRECTORY: FSStatFlags = 2147483648;
pub const FS_STAT_QUOTA: FSStatFlags = 1610612736;
pub const FS_STAT_FILE: FSStatFlags = 16777216;
pub const FS_STAT_ENCRYPTED_FILE: FSStatFlags = 8388608;
pub const FS_STAT_LINK: FSStatFlags = 65536;
pub type FSStatFlags = ::core::ffi::c_uint;
pub const FS_VOLUME_STATE_INITIAL: FSVolumeState = 0;
pub const FS_VOLUME_STATE_READY: FSVolumeState = 1;
pub const FS_VOLUME_STATE_NO_MEDIA: FSVolumeState = 2;
pub const FS_VOLUME_STATE_INVALID_MEDIA: FSVolumeState = 3;
pub const FS_VOLUME_STATE_DIRTY_MEDIA: FSVolumeState = 4;
pub const FS_VOLUME_STATE_WRONG_MEDIA: FSVolumeState = 5;
pub const FS_VOLUME_STATE_MEDIA_ERROR: FSVolumeState = 6;
pub const FS_VOLUME_STATE_DATA_CORRUPTED: FSVolumeState = 7;
pub const FS_VOLUME_STATE_WRITE_PROTECTED: FSVolumeState = 8;
pub const FS_VOLUME_STATE_JOURNAL_FULL: FSVolumeState = 9;
pub const FS_VOLUME_STATE_FATAL: FSVolumeState = 10;
pub const FS_VOLUME_STATE_INVALID: FSVolumeState = 11;
pub type FSVolumeState = ::core::ffi::c_uint;
pub const FS_MEDIA_STATE_READY: FSMediaState = 0;
pub const FS_MEDIA_STATE_NO_MEDIA: FSMediaState = 1;
pub const FS_MEDIA_STATE_INVALID_MEDIA: FSMediaState = 2;
pub const FS_MEDIA_STATE_DIRTY_MEDIA: FSMediaState = 3;
pub const FS_MEDIA_STATE_MEDIA_ERROR: FSMediaState = 4;
pub type FSMediaState = ::core::ffi::c_uint;
pub const FS_MOUNT_SOURCE_SD: FSMountSourceType = 0;
pub const FS_MOUNT_SOURCE_UNK: FSMountSourceType = 1;
pub type FSMountSourceType = ::core::ffi::c_uint;
pub const FS_OPEN_FLAG_NONE: FSOpenFileFlags = 0;
pub const FS_OPEN_FLAG_UNENCRYPTED: FSOpenFileFlags = 1;
pub const FS_OPEN_FLAG_PREALLOC_SIZE: FSOpenFileFlags = 2;
pub type FSOpenFileFlags = ::core::ffi::c_uint;
pub type FSAsyncCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut FSClient, arg2: *mut FSCmdBlock, arg3: FSStatus, arg4: u32),
>;
pub type FSStateChangeCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut FSClient, arg2: FSVolumeState, arg3: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSFsm {
    pub __unk10: [::core::ffi::c_char; 56usize],
}
impl Default for FSFsm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdQueue {
    pub __unk11: [::core::ffi::c_char; 68usize],
}
impl Default for FSCmdQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMessage {
    pub data: *mut ::core::ffi::c_void,
    pub __unk12: [::core::ffi::c_char; 8usize],
    pub type_: OSFunctionType,
}
impl Default for FSMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBodyLink {
    pub next: *mut FSClientBody,
    pub prev: *mut FSClientBody,
}
impl Default for FSClientBodyLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBody {
    pub __unk13: [::core::ffi::c_char; 5188usize],
    pub clientHandle: IOSHandle,
    pub fsm: FSFsm,
    pub cmdQueue: FSCmdQueue,
    pub lastDequeuedCommand: *mut FSCmdBlockBody,
    pub emulatedError: FSError,
    pub __unk14: [::core::ffi::c_char; 148usize],
    pub mutex: OSFastMutex,
    pub __unk15: [::core::ffi::c_char; 4usize],
    pub fsmAlarm: OSAlarm,
    pub lastError: FSError,
    pub isLastErrorWithoutVolume: bool,
    pub fsCmdHandlerMsg: FSMessage,
    pub lastMountSourceDevice: [::core::ffi::c_char; 16usize],
    pub findMountSourceType: FSMountSourceType,
    pub link: FSClientBodyLink,
    pub client: *mut FSClient,
}
impl Default for FSClientBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClient {
    pub __unk16: [::core::ffi::c_char; 5888usize],
}
impl Default for FSClient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlock {
    pub __unk17: [::core::ffi::c_char; 2688usize],
}
impl Default for FSCmdBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSStat {
    pub flags: FSStatFlags,
    pub mode: FSMode,
    pub owner: u32,
    pub group: u32,
    pub size: u32,
    pub allocSize: u32,
    pub quotaSize: u64,
    pub entryId: u32,
    pub created: FSTime,
    pub modified: FSTime,
    pub __unk18: [::core::ffi::c_char; 48usize],
}
impl Default for FSStat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSStateChangeParams {
    pub callback: FSStateChangeCallback,
    pub param: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSStateChangeParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncData {
    pub callback: FSAsyncCallback,
    pub param: u32,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSAsyncData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncResult {
    pub asyncData: FSAsyncData,
    pub ioMsg: FSMessage,
    pub client: *mut FSClient,
    pub block: *mut FSCmdBlock,
    pub status: FSStatus,
}
impl Default for FSAsyncResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlockBody {
    pub __unk19: [::core::ffi::c_char; 2412usize],
    pub asyncResult: FSAsyncResult,
    pub __unk20: [::core::ffi::c_char; 104usize],
}
impl Default for FSCmdBlockBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSDirectoryEntry {
    pub info: FSStat,
    pub name: [::core::ffi::c_char; 256usize],
}
impl Default for FSDirectoryEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMountSource {
    pub __unk21: [::core::ffi::c_char; 768usize],
}
impl Default for FSMountSource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSVolumeInfo {
    pub flags: u32,
    pub mediaState: FSMediaState,
    pub __unk22: [::core::ffi::c_char; 4usize],
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub unk0x14: i32,
    pub unk0x18: i32,
    pub __unk23: [::core::ffi::c_char; 16usize],
    pub volumeLabel: [::core::ffi::c_char; 128usize],
    pub volumeId: [::core::ffi::c_char; 128usize],
    pub devicePath: [::core::ffi::c_char; 16usize],
    pub mountPath: [::core::ffi::c_char; 128usize],
}
impl Default for FSVolumeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn FSInit();
}
extern "C" {
    pub fn FSShutdown();
}
extern "C" {
    pub fn FSAddClient(client: *mut FSClient, errorMask: FSErrorFlag) -> FSStatus;
}
extern "C" {
    pub fn FSDelClient(client: *mut FSClient, errorMask: FSErrorFlag) -> FSStatus;
}
extern "C" {
    pub fn FSGetClientNum() -> u32;
}
extern "C" {
    pub fn FSInitCmdBlock(block: *mut FSCmdBlock);
}
extern "C" {
    pub fn FSSetCmdPriority(block: *mut FSCmdBlock, priority: FSPriority) -> FSStatus;
}
extern "C" {
    pub fn FSSetStateChangeNotification(client: *mut FSClient, info: *mut FSStateChangeParams);
}
extern "C" {
    pub fn FSGetCwd(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetAsyncResult(message: *mut FSMessage) -> *mut FSAsyncResult;
}
extern "C" {
    pub fn FSGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSCloseFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSCloseFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenFileEx(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode,
        openFlag: FSOpenFileFlags,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenFileExAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode,
        openFlag: FSOpenFileFlags,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSRewindDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSCloseDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetVolumeInfo(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetVolumeInfoAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSCloseDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSChangeMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        modeMask: FSMode,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSChangeModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        modeMask: FSMode,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetStatFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetStatFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSReadFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSWriteFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSWriteFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSWriteFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSWriteFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSSetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSSetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSFlushFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSFlushFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSTruncateFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSTruncateFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSGetVolumeState(client: *mut FSClient) -> FSVolumeState;
}
extern "C" {
    pub fn FSGetLastError(client: *mut FSClient) -> FSError;
}
extern "C" {
    pub fn FSGetLastErrorCodeForViewer(client: *mut FSClient) -> FSError;
}
extern "C" {
    pub fn FSGetMountSource(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        type_: FSMountSourceType,
        out: *mut FSMountSource,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *mut FSMountSource,
        target: *const ::core::ffi::c_char,
        bytes: u32,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSBindMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSBindUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn FSTimeToCalendarTime(time: FSTime, outCalendarTime: *mut OSCalendarTime);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NNResult {
    pub value: i32,
}
pub const WPAD_CHAN_0: WPADChan = 0;
pub const WPAD_CHAN_1: WPADChan = 1;
pub const WPAD_CHAN_2: WPADChan = 2;
pub const WPAD_CHAN_3: WPADChan = 3;
pub const WPAD_CHAN_4: WPADChan = 4;
pub const WPAD_CHAN_5: WPADChan = 5;
pub const WPAD_CHAN_6: WPADChan = 6;
pub type WPADChan = ::core::ffi::c_uint;
pub const WPAD_FMT_CORE: WPADDataFormat = 0;
pub const WPAD_FMT_CORE_ACC: WPADDataFormat = 1;
pub const WPAD_FMT_CORE_ACC_DPD: WPADDataFormat = 2;
pub const WPAD_FMT_NUNCHUK: WPADDataFormat = 3;
pub const WPAD_FMT_NUNCHUK_ACC: WPADDataFormat = 4;
pub const WPAD_FMT_NUNCHUK_ACC_DPD: WPADDataFormat = 5;
pub const WPAD_FMT_CLASSIC: WPADDataFormat = 6;
pub const WPAD_FMT_CLASSIC_ACC: WPADDataFormat = 7;
pub const WPAD_FMT_CLASSIC_ACC_DPD: WPADDataFormat = 8;
pub const WPAD_FMT_CORE_ACC_DPD_FULL: WPADDataFormat = 9;
pub const WPAD_FMT_TRAIN: WPADDataFormat = 10;
pub const WPAD_FMT_GUITAR: WPADDataFormat = 11;
pub const WPAD_FMT_BALANCE_BOARD: WPADDataFormat = 12;
pub const WPAD_FMT_DRUM: WPADDataFormat = 15;
pub const WPAD_FMT_MPLUS: WPADDataFormat = 16;
pub const WPAD_FMT_TAIKO: WPADDataFormat = 17;
pub const WPAD_FMT_PRO_CONTROLLER: WPADDataFormat = 22;
pub type WPADDataFormat = ::core::ffi::c_uint;
pub const WPAD_EXT_CORE: WPADExtensionType = 0;
pub const WPAD_EXT_NUNCHUK: WPADExtensionType = 1;
pub const WPAD_EXT_CLASSIC: WPADExtensionType = 2;
pub const WPAD_EXT_MPLUS: WPADExtensionType = 5;
pub const WPAD_EXT_MPLUS_NUNCHUK: WPADExtensionType = 6;
pub const WPAD_EXT_MPLUS_CLASSIC: WPADExtensionType = 7;
pub const WPAD_EXT_PRO_CONTROLLER: WPADExtensionType = 31;
pub const WPAD_EXT_DEV_NOT_FOUND: WPADExtensionType = 253;
pub const WPAD_EXT_UNKNOWN: WPADExtensionType = 255;
pub type WPADExtensionType = ::core::ffi::c_uint;
pub const WPAD_BUTTON_LEFT: WPADButton = 1;
pub const WPAD_BUTTON_RIGHT: WPADButton = 2;
pub const WPAD_BUTTON_DOWN: WPADButton = 4;
pub const WPAD_BUTTON_UP: WPADButton = 8;
pub const WPAD_BUTTON_PLUS: WPADButton = 16;
pub const WPAD_BUTTON_2: WPADButton = 256;
pub const WPAD_BUTTON_1: WPADButton = 512;
pub const WPAD_BUTTON_B: WPADButton = 1024;
pub const WPAD_BUTTON_A: WPADButton = 2048;
pub const WPAD_BUTTON_MINUS: WPADButton = 4096;
pub const WPAD_BUTTON_Z: WPADButton = 8192;
pub const WPAD_BUTTON_C: WPADButton = 16384;
pub const WPAD_BUTTON_HOME: WPADButton = 32768;
pub type WPADButton = ::core::ffi::c_uint;
pub const WPAD_NUNCHUK_STICK_EMULATION_LEFT: WPADNunchukButton = 1;
pub const WPAD_NUNCHUK_STICK_EMULATION_RIGHT: WPADNunchukButton = 2;
pub const WPAD_NUNCHUK_STICK_EMULATION_DOWN: WPADNunchukButton = 4;
pub const WPAD_NUNCHUK_STICK_EMULATION_UP: WPADNunchukButton = 8;
pub const WPAD_NUNCHUK_BUTTON_Z: WPADNunchukButton = 8192;
pub const WPAD_NUNCHUK_BUTTON_C: WPADNunchukButton = 16384;
pub type WPADNunchukButton = ::core::ffi::c_uint;
pub const WPAD_CLASSIC_BUTTON_UP: WPADClassicButton = 1;
pub const WPAD_CLASSIC_BUTTON_LEFT: WPADClassicButton = 2;
pub const WPAD_CLASSIC_BUTTON_ZR: WPADClassicButton = 4;
pub const WPAD_CLASSIC_BUTTON_X: WPADClassicButton = 8;
pub const WPAD_CLASSIC_BUTTON_A: WPADClassicButton = 16;
pub const WPAD_CLASSIC_BUTTON_Y: WPADClassicButton = 32;
pub const WPAD_CLASSIC_BUTTON_B: WPADClassicButton = 64;
pub const WPAD_CLASSIC_BUTTON_ZL: WPADClassicButton = 128;
pub const WPAD_CLASSIC_BUTTON_R: WPADClassicButton = 512;
pub const WPAD_CLASSIC_BUTTON_PLUS: WPADClassicButton = 1024;
pub const WPAD_CLASSIC_BUTTON_HOME: WPADClassicButton = 2048;
pub const WPAD_CLASSIC_BUTTON_MINUS: WPADClassicButton = 4096;
pub const WPAD_CLASSIC_BUTTON_L: WPADClassicButton = 8192;
pub const WPAD_CLASSIC_BUTTON_DOWN: WPADClassicButton = 16384;
pub const WPAD_CLASSIC_BUTTON_RIGHT: WPADClassicButton = 32768;
pub const WPAD_CLASSIC_STICK_L_EMULATION_LEFT: WPADClassicButton = 65536;
pub const WPAD_CLASSIC_STICK_L_EMULATION_RIGHT: WPADClassicButton = 131072;
pub const WPAD_CLASSIC_STICK_L_EMULATION_DOWN: WPADClassicButton = 262144;
pub const WPAD_CLASSIC_STICK_L_EMULATION_UP: WPADClassicButton = 524288;
pub const WPAD_CLASSIC_STICK_R_EMULATION_LEFT: WPADClassicButton = 1048576;
pub const WPAD_CLASSIC_STICK_R_EMULATION_RIGHT: WPADClassicButton = 2097152;
pub const WPAD_CLASSIC_STICK_R_EMULATION_DOWN: WPADClassicButton = 4194304;
pub const WPAD_CLASSIC_STICK_R_EMULATION_UP: WPADClassicButton = 8388608;
pub type WPADClassicButton = ::core::ffi::c_uint;
pub const WPAD_PRO_BUTTON_UP: WPADProButton = 1;
pub const WPAD_PRO_BUTTON_LEFT: WPADProButton = 2;
pub const WPAD_PRO_TRIGGER_ZR: WPADProButton = 4;
pub const WPAD_PRO_BUTTON_X: WPADProButton = 8;
pub const WPAD_PRO_BUTTON_A: WPADProButton = 16;
pub const WPAD_PRO_BUTTON_Y: WPADProButton = 32;
pub const WPAD_PRO_BUTTON_B: WPADProButton = 64;
pub const WPAD_PRO_TRIGGER_ZL: WPADProButton = 128;
pub const WPAD_PRO_RESERVED: WPADProButton = 256;
pub const WPAD_PRO_TRIGGER_R: WPADProButton = 512;
pub const WPAD_PRO_BUTTON_PLUS: WPADProButton = 1024;
pub const WPAD_PRO_BUTTON_HOME: WPADProButton = 2048;
pub const WPAD_PRO_BUTTON_MINUS: WPADProButton = 4096;
pub const WPAD_PRO_TRIGGER_L: WPADProButton = 8192;
pub const WPAD_PRO_BUTTON_DOWN: WPADProButton = 16384;
pub const WPAD_PRO_BUTTON_RIGHT: WPADProButton = 32768;
pub const WPAD_PRO_BUTTON_STICK_R: WPADProButton = 65536;
pub const WPAD_PRO_BUTTON_STICK_L: WPADProButton = 131072;
pub const WPAD_PRO_STICK_L_EMULATION_UP: WPADProButton = 2097152;
pub const WPAD_PRO_STICK_L_EMULATION_DOWN: WPADProButton = 1048576;
pub const WPAD_PRO_STICK_L_EMULATION_LEFT: WPADProButton = 262144;
pub const WPAD_PRO_STICK_L_EMULATION_RIGHT: WPADProButton = 524288;
pub const WPAD_PRO_STICK_R_EMULATION_UP: WPADProButton = 33554432;
pub const WPAD_PRO_STICK_R_EMULATION_DOWN: WPADProButton = 16777216;
pub const WPAD_PRO_STICK_R_EMULATION_LEFT: WPADProButton = 4194304;
pub const WPAD_PRO_STICK_R_EMULATION_RIGHT: WPADProButton = 8388608;
pub type WPADProButton = ::core::ffi::c_uint;
pub const WPAD_LED_ONE: WPADLed = 1;
pub const WPAD_LED_TWO: WPADLed = 2;
pub const WPAD_LED_THREE: WPADLed = 4;
pub const WPAD_LED_FOUR: WPADLed = 8;
pub type WPADLed = ::core::ffi::c_uint;
pub const WPAD_DPD_FMT_NONE: WPADDpdFormat = 0;
pub const WPAD_DPD_FMT_BASIC: WPADDpdFormat = 1;
pub const WPAD_DPD_FMT_EXTENDED: WPADDpdFormat = 3;
pub const WPAD_DPD_FMT_FULL: WPADDpdFormat = 5;
pub type WPADDpdFormat = ::core::ffi::c_uint;
pub const WPAD_SPEAKER_CMD_OFF: WPADSpeakerCmd = 0;
pub const WPAD_SPEAKER_CMD_ON: WPADSpeakerCmd = 1;
pub const WPAD_SPEAKER_CMD_MUTE: WPADSpeakerCmd = 2;
pub const WPAD_SPEAKER_CMD_UNMUTE: WPADSpeakerCmd = 3;
pub const WPAD_SPEAKER_CMD_PLAY: WPADSpeakerCmd = 4;
pub const WPAD_SPEAKER_CMD_ON_ALT: WPADSpeakerCmd = 5;
pub type WPADSpeakerCmd = ::core::ffi::c_uint;
pub const WPAD_MPLS_MODE_DISABLE: WPADMplsMode = 0;
pub const WPAD_MPLS_MODE_MPLS_ONLY: WPADMplsMode = 4;
pub const WPAD_MPLS_MODE_MPLS_NUNCHUK: WPADMplsMode = 5;
pub const WPAD_MPLS_MODE_MPLS_CLASSIC: WPADMplsMode = 7;
pub type WPADMplsMode = ::core::ffi::c_uint;
pub const WPAD_PERIPHERAL_SPACE_SPEAKER: WPADPeripheralSpace = 162;
pub const WPAD_PERIPHERAL_SPACE_EXTENSION: WPADPeripheralSpace = 164;
pub const WPAD_PERIPHERAL_SPACE_MOTIONPLUS: WPADPeripheralSpace = 166;
pub const WPAD_PERIPHERAL_SPACE_DPD: WPADPeripheralSpace = 176;
pub type WPADPeripheralSpace = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADVec2D {
    pub x: i16,
    pub y: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADStatusProController {
    pub __unk24: [::core::ffi::c_char; 40usize],
    pub extensionType: u8,
    pub err: u8,
    pub __unk25: [::core::ffi::c_char; 2usize],
    pub buttons: u32,
    pub leftStick: WPADVec2D,
    pub rightStick: WPADVec2D,
    pub __unk26: [::core::ffi::c_char; 8usize],
    pub dataFormat: WPADDataFormat,
}
impl Default for WPADStatusProController {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADInfo {
    pub irEnabled: u32,
    pub speakerEnabled: u32,
    pub extensionAttached: u32,
    pub batteryLow: u32,
    pub batteryNearEmpty: u32,
    pub batteryLevel: u8,
    pub led: u8,
    pub protocol: u8,
    pub firmware: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueueElement {
    pub data: [u8; 48usize],
}
impl Default for WPADiQueueElement {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueue {
    pub frontIndex: u8,
    pub backIndex: u8,
    pub __unk27: [::core::ffi::c_char; 2usize],
    pub elements: *mut WPADiQueueElement,
    pub capacity: u32,
}
impl Default for WPADiQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADAddress {
    pub btDeviceAddress: [u8; 6usize],
}
pub type WPADIsMplsAttachedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADControlLedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADControlDpdCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADControlSpeakerCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADGetInfoCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADReadMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADWriteMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: WPADChan)>;
pub type WPADExtensionCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, ext: WPADExtensionType)>;
pub type WPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADiSendCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
pub type WPADiWriteGameDataCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan, status: i32)>;
extern "C" {
    pub fn WPADInit();
}
extern "C" {
    pub fn WPADShutdown();
}
extern "C" {
    pub fn WPADDisconnect(chan: WPADChan);
}
extern "C" {
    pub fn WPADProbe(chan: WPADChan, outExtensionType: *mut WPADExtensionType) -> i32;
}
extern "C" {
    pub fn WPADSetDataFormat(chan: WPADChan, format: WPADDataFormat) -> i32;
}
extern "C" {
    pub fn WPADGetDataFormat(chan: WPADChan) -> WPADDataFormat;
}
extern "C" {
    pub fn WPADRead(chan: WPADChan, data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn WPADControlLed(channel: WPADChan, led: WPADLed, callback: WPADControlLedCallback)
        -> i32;
}
extern "C" {
    pub fn WPADControlDpd(
        channel: WPADChan,
        mode: WPADDpdFormat,
        callback: WPADControlDpdCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADGetDpdFormat(chan: WPADChan) -> WPADDpdFormat;
}
extern "C" {
    pub fn WPADControlMotor(chan: WPADChan, motorEnabled: BOOL);
}
extern "C" {
    pub fn WPADControlSpeaker(
        chan: WPADChan,
        mode: WPADSpeakerCmd,
        arg1: WPADControlSpeakerCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADIsSpeakerEnabled(chan: WPADChan) -> BOOL;
}
extern "C" {
    pub fn WPADCanSendStreamData(chan: WPADChan) -> BOOL;
}
extern "C" {
    pub fn WPADSendStreamData(chan: WPADChan, data: *mut ::core::ffi::c_void, size: u32) -> i32;
}
extern "C" {
    pub fn WPADGetSpeakerVolume() -> u8;
}
extern "C" {
    pub fn WPADSetSpeakerVolume(volume: u8);
}
extern "C" {
    pub fn WPADIsMplsAttached(
        channel: WPADChan,
        enabled: *mut BOOL,
        callback: WPADIsMplsAttachedCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADIsMplsIntegrated(channel: WPADChan) -> i32;
}
extern "C" {
    pub fn WPADGetInfo(channel: WPADChan, outInfo: *mut WPADInfo) -> i32;
}
extern "C" {
    pub fn WPADGetInfoAsync(
        channel: WPADChan,
        outInfo: *mut WPADInfo,
        arg1: WPADGetInfoCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADReadMemoryAsync(
        channel: WPADChan,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADWriteMemoryAsync(
        channel: WPADChan,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADReadExtReg(
        channel: WPADChan,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        peripheral: WPADPeripheralSpace,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADWriteExtReg(
        channel: WPADChan,
        source: *mut ::core::ffi::c_void,
        size: u32,
        peripheral: WPADPeripheralSpace,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADGetBLCalibration(
        channel: WPADChan,
        destination: *mut ::core::ffi::c_void,
        address: u32,
        size: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADSetPowerSaveMode(chan: WPADChan, powerSave: BOOL);
}
extern "C" {
    pub fn WPADGetPowerSaveMode(chan: WPADChan) -> BOOL;
}
extern "C" {
    pub fn WPADGetAddress(chan: WPADChan, outAddress: *mut WPADAddress);
}
extern "C" {
    pub fn WPADEnableMotor(enable: BOOL);
}
extern "C" {
    pub fn WPADIsMotorEnabled() -> BOOL;
}
extern "C" {
    pub fn WPADEnableURCC(enable: BOOL);
}
extern "C" {
    pub fn WPADIsEnabledURC() -> BOOL;
}
extern "C" {
    pub fn WPADEnableWBC(enable: BOOL);
}
extern "C" {
    pub fn WPADIsEnableWBC() -> BOOL;
}
extern "C" {
    pub fn WPADEnableWiiRemote(enable: BOOL);
}
extern "C" {
    pub fn WPADSetAutoSleepTime(time: u8);
}
extern "C" {
    pub fn WPADStartSyncDevice() -> BOOL;
}
extern "C" {
    pub fn WPADStartSyncDeviceEx(
        deviceAddress: *mut WPADAddress,
        deviceName: *const ::core::ffi::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADSetConnectCallback(
        chan: WPADChan,
        callback: WPADConnectCallback,
    ) -> WPADConnectCallback;
}
extern "C" {
    pub fn WPADSetExtensionCallback(
        chan: WPADChan,
        callback: WPADExtensionCallback,
    ) -> WPADExtensionCallback;
}
extern "C" {
    pub fn WPADSetSamplingCallback(
        chan: WPADChan,
        callback: WPADSamplingCallback,
    ) -> WPADSamplingCallback;
}
extern "C" {
    pub fn WPADiShutdown();
}
extern "C" {
    pub fn WPADiClearQueue(queue: *mut WPADiQueue);
}
extern "C" {
    pub fn WPADiIsAvailableCmdQueue(queue: *mut WPADiQueue, count: u32) -> bool;
}
extern "C" {
    pub fn WPADiHIDParser(channel: WPADChan, hidData: *mut u8) -> i32;
}
extern "C" {
    pub fn WPADiSendSetVibrator(cmdQueue: *mut WPADiQueue) -> BOOL;
}
extern "C" {
    pub fn WPADiSendSetPort(
        cmdQueue: *mut WPADiQueue,
        led: WPADLed,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendSetReportType(
        cmdQueue: *mut WPADiQueue,
        dataFormat: WPADDataFormat,
        powerSave: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendGetContStat(
        cmdQueue: *mut WPADiQueue,
        outInfo: *mut WPADInfo,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableDPD(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableDPDCSB(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableSpeaker(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendMuteSpeaker(
        cmdQueue: *mut WPADiQueue,
        mute: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendStreamData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendWriteDataCmd(
        cmdQueue: *mut WPADiQueue,
        byte: u8,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendWriteData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendReadData(
        cmdQueue: *mut WPADiQueue,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiGetGameCode() -> *mut u32;
}
extern "C" {
    pub fn WPADiGetGameType() -> u8;
}
extern "C" {
    pub fn WPADSetGameTitleUtf16(title: *mut u16);
}
extern "C" {
    pub fn WPADGetGameTitleUtf16(chan: WPADChan, outTitle: *mut *mut u16) -> i32;
}
extern "C" {
    pub fn WPADGetGameDataTimestamp(chan: WPADChan, timestamp: *mut OSTime) -> i32;
}
extern "C" {
    pub fn WPADiWriteGameData(
        channel: WPADChan,
        source: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADiReadGameData(
        channel: WPADChan,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADiGetMplsStatus() -> WPADMplsMode;
}
pub use self::WPADChan as KPADChan;
pub use self::WPADDataFormat as KPADDataFormat;
pub use self::WPADExtensionType as KPADExtensionType;
pub use self::WPADMplsMode as KPADMplsMode;
pub const KPAD_ERROR_OK: KPADError = 0;
pub const KPAD_ERROR_NO_SAMPLES: KPADError = -1;
pub const KPAD_ERROR_INVALID_CONTROLLER: KPADError = -2;
pub const KPAD_ERROR_WPAD_UNINIT: KPADError = -3;
pub const KPAD_ERROR_BUSY: KPADError = -4;
pub const KPAD_ERROR_UNINITIALIZED: KPADError = -5;
pub type KPADError = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub pos: KPADVec2D,
    pub __unk28: [::core::ffi::c_char; 12usize],
    pub angle: KPADVec2D,
    pub __unk29: [::core::ffi::c_char; 32usize],
    pub extensionType: u8,
    pub error: i8,
    pub posValid: i8,
    pub format: u8,
    pub __bindgen_anon_1: KPADStatus__bindgen_ty_1,
    pub __unk31: [::core::ffi::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union KPADStatus__bindgen_ty_1 {
    pub nunchuk: KPADStatus__bindgen_ty_1__bindgen_ty_1,
    pub classic: KPADStatus__bindgen_ty_1__bindgen_ty_2,
    pub pro: KPADStatus__bindgen_ty_1__bindgen_ty_3,
    pub __unk30: [::core::ffi::c_char; 80usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_1 {
    pub stick: KPADVec2D,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_2 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub leftTrigger: f32,
    pub rightTrigger: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_3 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub charging: i32,
    pub wired: i32,
}
impl Default for KPADStatus__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for KPADStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KPADConnectCallback = WPADConnectCallback;
extern "C" {
    pub fn KPADInit();
}
extern "C" {
    pub fn KPADShutdown();
}
extern "C" {
    pub fn KPADRead(chan: KPADChan, data: *mut KPADStatus, size: u32) -> i32;
}
extern "C" {
    pub fn KPADReadEx(
        chan: KPADChan,
        data: *mut KPADStatus,
        size: u32,
        error: *mut KPADError,
    ) -> i32;
}
extern "C" {
    pub fn KPADSetMaxControllers(maxControllers: u32) -> i32;
}
extern "C" {
    pub fn KPADGetMaxControllers() -> u32;
}
extern "C" {
    pub fn KPADGetGameMaxControllers() -> u32;
}
extern "C" {
    pub fn KPADSetConnectCallback(
        chan: KPADChan,
        callback: KPADConnectCallback,
    ) -> KPADConnectCallback;
}
extern "C" {
    pub fn KPADEnableMpls(channel: KPADChan, mode: KPADMplsMode);
}
extern "C" {
    pub fn KPADDisableMpls(channel: KPADChan);
}
extern "C" {
    pub fn KPADGetMplsStatus(chan: KPADChan) -> KPADMplsMode;
}
extern "C" {
    pub fn KPADEnableDPD(chan: KPADChan);
}
extern "C" {
    pub fn KPADDisableDPD(chan: KPADChan);
}
pub const VPAD_CHAN_0: VPADChan = 0;
pub const VPAD_CHAN_1: VPADChan = 1;
pub type VPADChan = ::core::ffi::c_uint;
pub const VPAD_IRC_STATUS_FLAG_HAS_DATA: VPADIRCStatusFlags = 1;
pub const VPAD_IRC_STATUS_FLAG_CONNECTED: VPADIRCStatusFlags = 2;
pub type VPADIRCStatusFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn VPADBASEInit();
}
extern "C" {
    pub fn VPADBASEShutdown();
}
extern "C" {
    pub fn VPADBASEIsInit() -> BOOL;
}
extern "C" {
    pub fn VPADBASEGetMotorOnRemainingCount(chan: VPADChan) -> i32;
}
extern "C" {
    pub fn VPADBASESetMotorOnRemainingCount(chan: VPADChan, counter: i32) -> i32;
}
extern "C" {
    pub fn VPADBASESetSensorBarSetting(chan: VPADChan, setting: i8);
}
extern "C" {
    pub fn VPADBASEGetSensorBarSetting(chan: VPADChan, outSetting: *mut i8);
}
extern "C" {
    pub fn VPADBASEGetHeadphoneStatus(chan: VPADChan) -> i32;
}
extern "C" {
    pub fn VPADBASEGetGameControllerMode(chan: VPADChan, mode: *mut i32);
}
extern "C" {
    pub fn VPADBASESetGameControllerMode(chan: VPADChan, mode: i32);
}
extern "C" {
    pub fn VPADBASEGetPowerButtonPressStatus(chan: VPADChan, tick: *mut u32, status: *mut u32);
}
extern "C" {
    pub fn VPADBASESetPowerButtonPressStatus(chan: VPADChan, tick: u32, status: u32);
}
extern "C" {
    pub fn VPADBASESetPowerButtonDisableMode(chan: VPADChan, mode: u32);
}
extern "C" {
    pub fn VPADBASEClearIRCEvent(chan: VPADChan);
}
extern "C" {
    pub fn VPADBASEGetIRCStatus(chan: VPADChan) -> VPADIRCStatusFlags;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADGyroStatus {
    _unused: [u8; 0],
}
pub const VPAD_BUTTON_A: VPADButtons = 32768;
pub const VPAD_BUTTON_B: VPADButtons = 16384;
pub const VPAD_BUTTON_X: VPADButtons = 8192;
pub const VPAD_BUTTON_Y: VPADButtons = 4096;
pub const VPAD_BUTTON_LEFT: VPADButtons = 2048;
pub const VPAD_BUTTON_RIGHT: VPADButtons = 1024;
pub const VPAD_BUTTON_UP: VPADButtons = 512;
pub const VPAD_BUTTON_DOWN: VPADButtons = 256;
pub const VPAD_BUTTON_ZL: VPADButtons = 128;
pub const VPAD_BUTTON_ZR: VPADButtons = 64;
pub const VPAD_BUTTON_L: VPADButtons = 32;
pub const VPAD_BUTTON_R: VPADButtons = 16;
pub const VPAD_BUTTON_PLUS: VPADButtons = 8;
pub const VPAD_BUTTON_MINUS: VPADButtons = 4;
pub const VPAD_BUTTON_HOME: VPADButtons = 2;
pub const VPAD_BUTTON_SYNC: VPADButtons = 1;
pub const VPAD_BUTTON_STICK_R: VPADButtons = 131072;
pub const VPAD_BUTTON_STICK_L: VPADButtons = 262144;
pub const VPAD_BUTTON_TV: VPADButtons = 65536;
pub const VPAD_STICK_R_EMULATION_LEFT: VPADButtons = 67108864;
pub const VPAD_STICK_R_EMULATION_RIGHT: VPADButtons = 33554432;
pub const VPAD_STICK_R_EMULATION_UP: VPADButtons = 16777216;
pub const VPAD_STICK_R_EMULATION_DOWN: VPADButtons = 8388608;
pub const VPAD_STICK_L_EMULATION_LEFT: VPADButtons = 1073741824;
pub const VPAD_STICK_L_EMULATION_RIGHT: VPADButtons = 536870912;
pub const VPAD_STICK_L_EMULATION_UP: VPADButtons = 268435456;
pub const VPAD_STICK_L_EMULATION_DOWN: VPADButtons = 134217728;
pub type VPADButtons = ::core::ffi::c_uint;
pub const VPAD_VALID: VPADTouchPadValidity = 0;
pub const VPAD_INVALID_X: VPADTouchPadValidity = 1;
pub const VPAD_INVALID_Y: VPADTouchPadValidity = 2;
pub type VPADTouchPadValidity = ::core::ffi::c_uint;
pub const VPAD_TP_1920X1080: VPADTouchPadResolution = 0;
pub const VPAD_TP_1280X720: VPADTouchPadResolution = 1;
pub const VPAD_TP_854X480: VPADTouchPadResolution = 2;
pub type VPADTouchPadResolution = ::core::ffi::c_uint;
pub const VPAD_READ_SUCCESS: VPADReadError = 0;
pub const VPAD_READ_NO_SAMPLES: VPADReadError = -1;
pub const VPAD_READ_INVALID_CONTROLLER: VPADReadError = -2;
pub const VPAD_READ_BUSY: VPADReadError = -4;
pub const VPAD_READ_UNINITIALIZED: VPADReadError = -5;
pub type VPADReadError = ::core::ffi::c_int;
pub const VPAD_LCD_STANDBY: VPADLcdMode = 0;
pub const VPAD_LCD_OFF: VPADLcdMode = 1;
pub const VPAD_LCD_ON: VPADLcdMode = 255;
pub type VPADLcdMode = ::core::ffi::c_uint;
pub const VPAD_GYRO_ZERODRIFT_LOOSE: VPADGyroZeroDriftMode = 0;
pub const VPAD_GYRO_ZERODRIFT_STANDARD: VPADGyroZeroDriftMode = 1;
pub const VPAD_GYRO_ZERODRIFT_TIGHT: VPADGyroZeroDriftMode = 2;
pub const VPAD_GYRO_ZERODRIFT_NONE: VPADGyroZeroDriftMode = 3;
pub type VPADGyroZeroDriftMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADDirection {
    pub x: VPADVec3D,
    pub y: VPADVec3D,
    pub z: VPADVec3D,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADTouchCalibrationParam {
    pub adjustX: u16,
    pub adjustY: u16,
    pub scaleX: f32,
    pub scaleY: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADTouchData {
    pub x: u16,
    pub y: u16,
    pub touched: u16,
    pub validity: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADAccStatus {
    pub acc: VPADVec3D,
    pub magnitude: f32,
    pub variation: f32,
    pub vertical: VPADVec2D,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: VPADVec2D,
    pub rightStick: VPADVec2D,
    pub accelorometer: VPADAccStatus,
    pub gyro: VPADVec3D,
    pub angle: VPADVec3D,
    pub error: u8,
    pub __unk32: [::core::ffi::c_char; 1usize],
    pub tpNormal: VPADTouchData,
    pub tpFiltered1: VPADTouchData,
    pub tpFiltered2: VPADTouchData,
    pub __unk33: [::core::ffi::c_char; 2usize],
    pub direction: VPADDirection,
    pub usingHeadphones: BOOL,
    pub mag: VPADVec3D,
    pub slideVolume: u8,
    pub battery: u8,
    pub micStatus: u8,
    pub slideVolumeEx: u8,
    pub __unk34: [::core::ffi::c_char; 8usize],
}
pub type VPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: VPADChan)>;
extern "C" {
    pub fn VPADInit();
}
extern "C" {
    pub fn VPADShutdown();
}
extern "C" {
    pub fn VPADRead(
        chan: VPADChan,
        buffers: *mut VPADStatus,
        count: u32,
        outError: *mut VPADReadError,
    ) -> i32;
}
extern "C" {
    pub fn VPADGetTPCalibrationParam(chan: VPADChan, outParam: *mut VPADTouchCalibrationParam);
}
extern "C" {
    pub fn VPADSetTPCalibrationParam(chan: VPADChan, param: *const VPADTouchCalibrationParam);
}
extern "C" {
    pub fn VPADGetTPCalibratedPoint(
        chan: VPADChan,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    pub fn VPADGetTPCalibratedPointEx(
        chan: VPADChan,
        tpResolution: VPADTouchPadResolution,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    pub fn VPADSetAccParam(chan: VPADChan, playRadius: f32, sensitivity: f32);
}
extern "C" {
    pub fn VPADGetAccParam(chan: VPADChan, outPlayRadius: *mut f32, outSensitivity: *mut f32);
}
extern "C" {
    pub fn VPADSetBtnRepeat(chan: VPADChan, delaySec: f32, pulseSec: f32);
}
extern "C" {
    pub fn VPADEnableStickCrossClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableStickCrossClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADSetLStickClampThreshold(chan: VPADChan, max: i32, min: i32);
}
extern "C" {
    pub fn VPADSetRStickClampThreshold(chan: VPADChan, max: i32, min: i32);
}
extern "C" {
    pub fn VPADGetGyroDirReviseParam(chan: VPADChan, param: *mut f32);
}
extern "C" {
    pub fn VPADGetGyroZeroDriftMode(chan: VPADChan, mode: *mut VPADGyroZeroDriftMode);
}
extern "C" {
    pub fn VPADGetLStickClampThreshold(chan: VPADChan, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADGetRStickClampThreshold(chan: VPADChan, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADSetStickOrigin(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableLStickZeroClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableRStickZeroClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADEnableLStickZeroClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADEnableRStickZeroClamp(chan: VPADChan);
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsL(
        chan: VPADChan,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsR(
        chan: VPADChan,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsL(
        chan: VPADChan,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsR(
        chan: VPADChan,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADSetGyroAngle(chan: VPADChan, ax: f32, ay: f32, az: f32);
}
extern "C" {
    pub fn VPADSetGyroDirReviseBase(chan: VPADChan, base: *mut VPADDirection);
}
extern "C" {
    pub fn VPADSetGyroDirReviseParam(chan: VPADChan, param: f32);
}
extern "C" {
    pub fn VPADSetGyroDirection(chan: VPADChan, dir: *mut VPADDirection);
}
extern "C" {
    pub fn VPADSetGyroDirectionMag(chan: VPADChan, mag: f32);
}
extern "C" {
    pub fn VPADSetGyroMagnification(chan: VPADChan, pitch: f32, yaw: f32, roll: f32);
}
extern "C" {
    pub fn VPADSetGyroZeroDriftMode(chan: VPADChan, mode: VPADGyroZeroDriftMode);
}
extern "C" {
    pub fn VPADEnableGyroZeroPlay(chan: VPADChan);
}
extern "C" {
    pub fn VPADEnableGyroDirRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADEnableGyroAccRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableGyroZeroPlay(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableGyroDirRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADDisableGyroAccRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADIsEnableGyroZeroPlay(chan: VPADChan) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroZeroDrift(chan: VPADChan) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroDirRevise(chan: VPADChan) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroAccRevise(chan: VPADChan) -> f32;
}
extern "C" {
    pub fn VPADSetGyroZeroPlayParam(chan: VPADChan, radius: f32);
}
extern "C" {
    pub fn VPADInitGyroZeroPlayParam(chan: VPADChan);
}
extern "C" {
    pub fn VPADInitGyroDirReviseParam(chan: VPADChan);
}
extern "C" {
    pub fn VPADInitGyroAccReviseParam(chan: VPADChan);
}
extern "C" {
    pub fn VPADStartGyroMagRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADStopGyroMagRevise(chan: VPADChan);
}
extern "C" {
    pub fn VPADInitGyroZeroDriftMode(chan: VPADChan);
}
extern "C" {
    pub fn VPADGetTVMenuStatus(chan: VPADChan) -> BOOL;
}
extern "C" {
    pub fn VPADSetTVMenuInvalid(chan: VPADChan, invalid: BOOL);
}
extern "C" {
    pub fn VPADDisablePowerButton(chan: VPADChan);
}
extern "C" {
    pub fn VPADEnablePowerButton(chan: VPADChan);
}
extern "C" {
    pub fn VPADControlMotor(chan: VPADChan, pattern: *mut u8, length: u8) -> i32;
}
extern "C" {
    pub fn VPADStopMotor(chan: VPADChan);
}
extern "C" {
    pub fn VPADSetLcdMode(chan: VPADChan, lcdMode: VPADLcdMode) -> i32;
}
extern "C" {
    pub fn VPADGetLcdMode(chan: VPADChan, outLcdMode: *mut VPADLcdMode) -> i32;
}
extern "C" {
    pub fn VPADSetSensorBar(chan: VPADChan, on: BOOL) -> i32;
}
extern "C" {
    pub fn VPADSetSamplingCallback(
        chan: VPADChan,
        callback: VPADSamplingCallback,
    ) -> VPADSamplingCallback;
}
extern "C" {
    pub fn VPADGetButtonProcMode(chan: VPADChan) -> BOOL;
}
pub type wint_t = ::core::ffi::c_int;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::core::ffi::c_int;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_ulong;
pub type _ssize_t = ::core::ffi::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::core::ffi::c_ulong;
pub type _LOCK_T = ::core::ffi::c_int;
pub type _LOCK_RECURSIVE_T = ::core::ffi::c_int;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::core::ffi::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub deviceData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
pub type MICHandle = ::core::ffi::c_int;
pub const MIC_ERROR_OK: MICError = 0;
pub const MIC_ERROR_NOT_OPENED: MICError = -1;
pub const MIC_ERROR_INVALID_HANDLE: MICError = -2;
pub const MIC_ERROR_INIT: MICError = -5;
pub const MIC_ERROR_ALREADY_CLOSED: MICError = -7;
pub const MIC_ERROR_INVALID_INSTANCE: MICError = -8;
pub type MICError = ::core::ffi::c_int;
pub const MIC_INSTANCE_0: MICInstance = 0;
pub const MIC_INSTANCE_1: MICInstance = 1;
pub type MICInstance = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MICWorkMemory {
    pub sampleMaxCount: usize,
    pub sampleBuffer: *mut ::core::ffi::c_void,
}
impl Default for MICWorkMemory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MICStatus {
    pub state: ::core::ffi::c_int,
    pub availableData: ::core::ffi::c_int,
    pub bufferPos: ::core::ffi::c_int,
}
extern "C" {
    pub fn MICInit(
        instance: MICInstance,
        unused: ::core::ffi::c_int,
        workMemory: *mut MICWorkMemory,
        outError: *mut MICError,
    ) -> MICHandle;
}
extern "C" {
    pub fn MICOpen(handle: MICHandle) -> MICError;
}
extern "C" {
    pub fn MICGetState(
        handle: MICHandle,
        state: ::core::ffi::c_int,
        outStateVal: *mut u32,
    ) -> MICError;
}
extern "C" {
    pub fn MICSetState(handle: MICHandle, state: ::core::ffi::c_int, stateVal: u32) -> MICError;
}
extern "C" {
    pub fn MICGetStatus(handle: MICHandle, outStatus: *mut MICStatus) -> MICError;
}
extern "C" {
    pub fn MICSetDataConsumed(
        handle: MICHandle,
        dataAmountConsumed: ::core::ffi::c_int,
    ) -> MICError;
}
extern "C" {
    pub fn MICClose(handle: MICHandle) -> MICError;
}
extern "C" {
    pub fn MICUninit(handle: MICHandle) -> MICError;
}
pub type NFCError = i32;
pub type NFCProtocol = u8;
pub type NFCTechnology = u8;
pub type NFCTechnologyMask = u8;
pub type NFCNDEFFlags = u8;
pub const NFC_MODE_INVALID: NFCMode = -1;
pub const NFC_MODE_IDLE: NFCMode = 0;
pub const NFC_MODE_ACTIVE: NFCMode = 1;
pub type NFCMode = ::core::ffi::c_int;
pub const NFC_PROTOCOL_UNKNOWN: NFCProtocolEnum = 0;
pub const NFC_PROTOCOL_T1T: NFCProtocolEnum = 1;
pub const NFC_PROTOCOL_T2T: NFCProtocolEnum = 2;
pub const NFC_PROTOCOL_T3T: NFCProtocolEnum = 3;
pub const NFC_PROTOCOL_ISO_DEP: NFCProtocolEnum = 4;
pub const NFC_PROTOCOL_15693: NFCProtocolEnum = 131;
pub type NFCProtocolEnum = ::core::ffi::c_uint;
pub const NFC_TECHNOLOGY_A: NFCTechnologyEnum = 0;
pub const NFC_TECHNOLOGY_B: NFCTechnologyEnum = 1;
pub const NFC_TECHNOLOGY_F: NFCTechnologyEnum = 2;
pub const NFC_TECHNOLOGY_ISO15693: NFCTechnologyEnum = 6;
pub type NFCTechnologyEnum = ::core::ffi::c_uint;
pub const NFC_TECHNOLOGY_MASK_ALL: NFCTechnologyMaskEnum = 0;
pub const NFC_TECHNOLOGY_MASK_A: NFCTechnologyMaskEnum = 1;
pub const NFC_TECHNOLOGY_MASK_B: NFCTechnologyMaskEnum = 2;
pub const NFC_TECHNOLOGY_MASK_F: NFCTechnologyMaskEnum = 4;
pub const NFC_TECHNOLOGY_MASK_ISO15693: NFCTechnologyMaskEnum = 8;
pub type NFCTechnologyMaskEnum = ::core::ffi::c_uint;
pub const NFC_NDEF_FLAG_READ_ONLY: NFCNDEFFlagsEnum = 1;
pub const NFC_NDEF_FLAG_FORMATED: NFCNDEFFlagsEnum = 2;
pub const NFC_NDEF_FLAG_SUPPORTED: NFCNDEFFlagsEnum = 4;
pub const NFC_NDEF_FLAG_UNKNOWN: NFCNDEFFlagsEnum = 8;
pub const NFC_NDEF_FLAG_FORMATABLE: NFCNDEFFlagsEnum = 16;
pub const NFC_NDEF_FLAG_SOFT_LOCKABLE: NFCNDEFFlagsEnum = 32;
pub const NFC_NDEF_FLAG_HARD_LOCKABLE: NFCNDEFFlagsEnum = 64;
pub const NFC_NDEF_FLAG_OTP: NFCNDEFFlagsEnum = 128;
pub type NFCNDEFFlagsEnum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCUid {
    pub uid: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCTagInfo {
    pub uidSize: u8,
    pub uid: [u8; 10usize],
    pub technology: NFCTechnology,
    pub protocol: NFCProtocol,
    pub __unk35: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCNTAGVersion {
    pub header: u8,
    pub vendorId: u8,
    pub productType: u8,
    pub productSubtype: u8,
    pub majorProductVersion: u8,
    pub minorProductversion: u8,
    pub storageSize: u8,
    pub protocolType: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCReadT2TResult {
    pub numReads: u8,
    pub read0Start: u8,
    pub read0End: u8,
    pub read1Start: u8,
    pub read1End: u8,
    pub read2Start: u8,
    pub read2End: u8,
    pub read3Start: u8,
    pub read3End: u8,
    pub data: [u8; 928usize],
}
impl Default for NFCReadT2TResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NFCCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(chan: VPADChan, error: NFCError, userContext: *mut ::core::ffi::c_void),
>;
pub type NFCTagDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(chan: VPADChan, hasTag: BOOL, userContext: *mut ::core::ffi::c_void),
>;
pub type NFCDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        hasLockedData: BOOL,
        flags: NFCNDEFFlags,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        responseSize: u32,
        responseData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataTwiceCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        numCompleted: u8,
        response0Size: u32,
        response0Data: *mut ::core::ffi::c_void,
        response1Size: u32,
        response1Data: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        dataSize: u32,
        data: *mut ::core::ffi::c_void,
        lockedDataSize: u32,
        lockedData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        rfDiscId: u8,
        protocol: NFCProtocol,
        technology: NFCTechnology,
        uidSize: u8,
        uid: *mut u8,
        version: *mut NFCNTAGVersion,
        result: *mut NFCReadT2TResult,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        tagInfo: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoMultiCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NFCError,
        numTagInfos: u8,
        tagInfo0: *mut NFCTagInfo,
        tagInfo1: *mut NFCTagInfo,
        tagInfo2: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn NFCInit(chan: VPADChan) -> NFCError;
}
extern "C" {
    pub fn NFCInitEx(chan: VPADChan, powerMode: u32) -> NFCError;
}
extern "C" {
    pub fn NFCShutdown(chan: VPADChan) -> NFCError;
}
extern "C" {
    pub fn NFCIsInit(chan: VPADChan) -> BOOL;
}
extern "C" {
    pub fn NFCProc(chan: VPADChan);
}
extern "C" {
    pub fn NFCSetTagDetectCallback(
        chan: VPADChan,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn NFCGetMode(chan: VPADChan) -> NFCMode;
}
extern "C" {
    pub fn NFCSetMode(chan: VPADChan, mode: NFCMode) -> NFCError;
}
extern "C" {
    pub fn NFCAbort(
        chan: VPADChan,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCAntennaCheck(
        chan: VPADChan,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCDetect(
        chan: VPADChan,
        discoveryTimeout: u32,
        callback: NFCDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSetLockBitsForT1T(
        chan: VPADChan,
        numBlocks: u8,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCRead(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCWrite(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        size: u32,
        data: *mut ::core::ffi::c_void,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawData(
        chan: VPADChan,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataEx(
        chan: VPADChan,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataEx2(
        chan: VPADChan,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        techMask: NFCTechnologyMask,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataWithPrePolling(
        chan: VPADChan,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataWithPrePollingEx(
        chan: VPADChan,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataTwice(
        chan: VPADChan,
        command0Timeout: u32,
        command0Size: u32,
        response0Size: u32,
        command0Data: *mut ::core::ffi::c_void,
        command1Timeout: u32,
        command1Size: u32,
        response1Size: u32,
        command1Data: *mut ::core::ffi::c_void,
        callback: NFCRawDataTwiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCFormat(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetTagInfo(
        chan: VPADChan,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetTagInfoMulti(
        chan: VPADChan,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoMultiCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCIsTagPresent(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSetReadOnly(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCReadT2T(
        chan: VPADChan,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numReads: u8,
        read0Start: u8,
        read0End: u8,
        read1Start: u8,
        read1End: u8,
        read2Start: u8,
        read2End: u8,
        read3Start: u8,
        read3End: u8,
        authenticate: u8,
        callback: NFCReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCWriteT2T(
        chan: VPADChan,
        discoveryTimeout: u16,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numWrites: u8,
        write0Start: u8,
        write0Size: u8,
        write0Data: *mut ::core::ffi::c_void,
        write1Start: u8,
        write1Size: u8,
        write1Data: *mut ::core::ffi::c_void,
        write2Start: u8,
        write2Size: u8,
        write2Data: *mut ::core::ffi::c_void,
        write3Start: u8,
        write3Size: u8,
        write3Data: *mut ::core::ffi::c_void,
        activationStart: u8,
        deactivationData: *mut u32,
        activationData: *mut u32,
        authenticate: u8,
        activate: u8,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetUIDFromActivationEventData(
        data: *mut ::core::ffi::c_void,
        outProtocol: *mut NFCProtocol,
        outTechnology: *mut NFCTechnology,
        outUidSize: *mut u8,
        outUid: *mut u8,
    );
}
extern "C" {
    pub fn __NFCSystemAbort(chan: VPADChan) -> NFCError;
}
pub const GX2_AA_MODE1X: GX2AAMode = 0;
pub const GX2_AA_MODE2X: GX2AAMode = 1;
pub const GX2_AA_MODE4X: GX2AAMode = 2;
pub const GX2_AA_MODE8X: GX2AAMode = 3;
pub type GX2AAMode = ::core::ffi::c_uint;
pub const GX2_ALPHA_TO_MASK_MODE_NON_DITHERED: GX2AlphaToMaskMode = 0;
pub const GX2_ALPHA_TO_MASK_MODE_DITHER_0: GX2AlphaToMaskMode = 1;
pub const GX2_ALPHA_TO_MASK_MODE_DITHER_90: GX2AlphaToMaskMode = 2;
pub const GX2_ALPHA_TO_MASK_MODE_DITHER_180: GX2AlphaToMaskMode = 3;
pub const GX2_ALPHA_TO_MASK_MODE_DITHER_270: GX2AlphaToMaskMode = 4;
pub type GX2AlphaToMaskMode = ::core::ffi::c_uint;
pub const GX2_ASPECT_RATIO_4_3: GX2AspectRatio = 0;
pub const GX2_ASPECT_RATIO_16_9: GX2AspectRatio = 1;
pub type GX2AspectRatio = ::core::ffi::c_uint;
pub const GX2_ATTRIB_TYPE_8: GX2AttribFormat = 0;
pub const GX2_ATTRIB_TYPE_4_4: GX2AttribFormat = 1;
pub const GX2_ATTRIB_TYPE_16: GX2AttribFormat = 2;
pub const GX2_ATTRIB_TYPE_16_FLOAT: GX2AttribFormat = 3;
pub const GX2_ATTRIB_TYPE_8_8: GX2AttribFormat = 4;
pub const GX2_ATTRIB_TYPE_32: GX2AttribFormat = 5;
pub const GX2_ATTRIB_TYPE_32_FLOAT: GX2AttribFormat = 6;
pub const GX2_ATTRIB_TYPE_16_16: GX2AttribFormat = 7;
pub const GX2_ATTRIB_TYPE_16_16_FLOAT: GX2AttribFormat = 8;
pub const GX2_ATTRIB_TYPE_10_11_11_FLOAT: GX2AttribFormat = 9;
pub const GX2_ATTRIB_TYPE_8_8_8_8: GX2AttribFormat = 10;
pub const GX2_ATTRIB_TYPE_10_10_10_2: GX2AttribFormat = 11;
pub const GX2_ATTRIB_TYPE_32_32: GX2AttribFormat = 12;
pub const GX2_ATTRIB_TYPE_32_32_FLOAT: GX2AttribFormat = 13;
pub const GX2_ATTRIB_TYPE_16_16_16_16: GX2AttribFormat = 14;
pub const GX2_ATTRIB_TYPE_16_16_16_16_FLOAT: GX2AttribFormat = 15;
pub const GX2_ATTRIB_TYPE_32_32_32: GX2AttribFormat = 16;
pub const GX2_ATTRIB_TYPE_32_32_32_FLOAT: GX2AttribFormat = 17;
pub const GX2_ATTRIB_TYPE_32_32_32_32: GX2AttribFormat = 18;
pub const GX2_ATTRIB_TYPE_32_32_32_32_FLOAT: GX2AttribFormat = 19;
pub const GX2_ATTRIB_FLAG_INTEGER: GX2AttribFormat = 256;
pub const GX2_ATTRIB_FLAG_SIGNED: GX2AttribFormat = 512;
pub const GX2_ATTRIB_FLAG_DEGAMMA: GX2AttribFormat = 1024;
pub const GX2_ATTRIB_FLAG_SCALED: GX2AttribFormat = 2048;
pub const GX2_ATTRIB_FORMAT_UNORM_8: GX2AttribFormat = 0;
pub const GX2_ATTRIB_FORMAT_UNORM_8_8: GX2AttribFormat = 4;
pub const GX2_ATTRIB_FORMAT_UNORM_8_8_8_8: GX2AttribFormat = 10;
pub const GX2_ATTRIB_FORMAT_UINT_8: GX2AttribFormat = 256;
pub const GX2_ATTRIB_FORMAT_UINT_8_8: GX2AttribFormat = 260;
pub const GX2_ATTRIB_FORMAT_UINT_8_8_8_8: GX2AttribFormat = 266;
pub const GX2_ATTRIB_FORMAT_SNORM_8: GX2AttribFormat = 512;
pub const GX2_ATTRIB_FORMAT_SNORM_8_8: GX2AttribFormat = 516;
pub const GX2_ATTRIB_FORMAT_SNORM_8_8_8_8: GX2AttribFormat = 522;
pub const GX2_ATTRIB_FORMAT_SINT_8: GX2AttribFormat = 768;
pub const GX2_ATTRIB_FORMAT_SINT_8_8: GX2AttribFormat = 772;
pub const GX2_ATTRIB_FORMAT_SINT_8_8_8_8: GX2AttribFormat = 778;
pub const GX2_ATTRIB_FORMAT_FLOAT_32: GX2AttribFormat = 2054;
pub const GX2_ATTRIB_FORMAT_FLOAT_32_32: GX2AttribFormat = 2061;
pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32: GX2AttribFormat = 2065;
pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32: GX2AttribFormat = 2067;
pub type GX2AttribFormat = ::core::ffi::c_uint;
pub const GX2_ATTRIB_INDEX_PER_VERTEX: GX2AttribIndexType = 0;
pub const GX2_ATTRIB_INDEX_PER_INSTANCE: GX2AttribIndexType = 1;
pub type GX2AttribIndexType = ::core::ffi::c_uint;
pub const GX2_BLEND_MODE_ZERO: GX2BlendMode = 0;
pub const GX2_BLEND_MODE_ONE: GX2BlendMode = 1;
pub const GX2_BLEND_MODE_SRC_COLOR: GX2BlendMode = 2;
pub const GX2_BLEND_MODE_INV_SRC_COLOR: GX2BlendMode = 3;
pub const GX2_BLEND_MODE_SRC_ALPHA: GX2BlendMode = 4;
pub const GX2_BLEND_MODE_INV_SRC_ALPHA: GX2BlendMode = 5;
pub const GX2_BLEND_MODE_DST_ALPHA: GX2BlendMode = 6;
pub const GX2_BLEND_MODE_INV_DST_ALPHA: GX2BlendMode = 7;
pub const GX2_BLEND_MODE_DST_COLOR: GX2BlendMode = 8;
pub const GX2_BLEND_MODE_INV_DST_COLOR: GX2BlendMode = 9;
pub const GX2_BLEND_MODE_SRC_ALPHA_SAT: GX2BlendMode = 10;
pub const GX2_BLEND_MODE_BOTH_SRC_ALPHA: GX2BlendMode = 11;
pub const GX2_BLEND_MODE_BOTH_INV_SRC_ALPHA: GX2BlendMode = 12;
pub const GX2_BLEND_MODE_BLEND_FACTOR: GX2BlendMode = 13;
pub const GX2_BLEND_MODE_INV_BLEND_FACTOR: GX2BlendMode = 14;
pub const GX2_BLEND_MODE_SRC1_COLOR: GX2BlendMode = 15;
pub const GX2_BLEND_MODE_INV_SRC1_COLOR: GX2BlendMode = 16;
pub const GX2_BLEND_MODE_SRC1_ALPHA: GX2BlendMode = 17;
pub const GX2_BLEND_MODE_INV_SRC1_ALPHA: GX2BlendMode = 18;
pub const GX2_BLEND_MODE_CONSTANT_ALPHA: GX2BlendMode = 19;
pub const GX2_BLEND_MODE_INV_CONSTANT_ALPHA: GX2BlendMode = 20;
pub type GX2BlendMode = ::core::ffi::c_uint;
pub const GX2_BLEND_COMBINE_MODE_ADD: GX2BlendCombineMode = 0;
pub const GX2_BLEND_COMBINE_MODE_SUB: GX2BlendCombineMode = 1;
pub const GX2_BLEND_COMBINE_MODE_MIN: GX2BlendCombineMode = 2;
pub const GX2_BLEND_COMBINE_MODE_MAX: GX2BlendCombineMode = 3;
pub const GX2_BLEND_COMBINE_MODE_REV_SUB: GX2BlendCombineMode = 4;
pub type GX2BlendCombineMode = ::core::ffi::c_uint;
pub const GX2_BUFFERING_MODE_SINGLE: GX2BufferingMode = 1;
pub const GX2_BUFFERING_MODE_DOUBLE: GX2BufferingMode = 2;
pub const GX2_BUFFERING_MODE_TRIPLE: GX2BufferingMode = 3;
pub type GX2BufferingMode = ::core::ffi::c_uint;
pub const GX2_CHANNEL_MASK_R: GX2ChannelMask = 1;
pub const GX2_CHANNEL_MASK_G: GX2ChannelMask = 2;
pub const GX2_CHANNEL_MASK_RG: GX2ChannelMask = 3;
pub const GX2_CHANNEL_MASK_B: GX2ChannelMask = 4;
pub const GX2_CHANNEL_MASK_RB: GX2ChannelMask = 5;
pub const GX2_CHANNEL_MASK_GB: GX2ChannelMask = 6;
pub const GX2_CHANNEL_MASK_RGB: GX2ChannelMask = 7;
pub const GX2_CHANNEL_MASK_A: GX2ChannelMask = 8;
pub const GX2_CHANNEL_MASK_RA: GX2ChannelMask = 9;
pub const GX2_CHANNEL_MASK_GA: GX2ChannelMask = 10;
pub const GX2_CHANNEL_MASK_RGA: GX2ChannelMask = 11;
pub const GX2_CHANNEL_MASK_BA: GX2ChannelMask = 12;
pub const GX2_CHANNEL_MASK_RBA: GX2ChannelMask = 13;
pub const GX2_CHANNEL_MASK_GBA: GX2ChannelMask = 14;
pub const GX2_CHANNEL_MASK_RGBA: GX2ChannelMask = 15;
pub type GX2ChannelMask = ::core::ffi::c_uint;
pub const GX2_CLEAR_FLAGS_DEPTH: GX2ClearFlags = 1;
pub const GX2_CLEAR_FLAGS_STENCIL: GX2ClearFlags = 2;
pub const GX2_CLEAR_FLAGS_BOTH: GX2ClearFlags = 3;
pub type GX2ClearFlags = ::core::ffi::c_uint;
pub const GX2_COMPARE_FUNC_NEVER: GX2CompareFunction = 0;
pub const GX2_COMPARE_FUNC_LESS: GX2CompareFunction = 1;
pub const GX2_COMPARE_FUNC_EQUAL: GX2CompareFunction = 2;
pub const GX2_COMPARE_FUNC_LEQUAL: GX2CompareFunction = 3;
pub const GX2_COMPARE_FUNC_GREATER: GX2CompareFunction = 4;
pub const GX2_COMPARE_FUNC_NOT_EQUAL: GX2CompareFunction = 5;
pub const GX2_COMPARE_FUNC_GEQUAL: GX2CompareFunction = 6;
pub const GX2_COMPARE_FUNC_ALWAYS: GX2CompareFunction = 7;
pub type GX2CompareFunction = ::core::ffi::c_uint;
pub const GX2_DRC_RENDER_MODE_DISABLED: GX2DrcRenderMode = 0;
pub const GX2_DRC_RENDER_MODE_SINGLE: GX2DrcRenderMode = 1;
pub const GX2_DRC_RENDER_MODE_DOUBLE: GX2DrcRenderMode = 2;
pub type GX2DrcRenderMode = ::core::ffi::c_uint;
pub const GX2_EVENT_TYPE_START_OF_PIPE_INTERRUPT: GX2EventType = 0;
pub const GX2_EVENT_TYPE_END_OF_PIPE_INTERRUPT: GX2EventType = 1;
pub const GX2_EVENT_TYPE_VSYNC: GX2EventType = 2;
pub const GX2_EVENT_TYPE_FLIP: GX2EventType = 3;
pub const GX2_EVENT_TYPE_DISPLAY_LIST_OVERRUN: GX2EventType = 4;
pub type GX2EventType = ::core::ffi::c_uint;
pub const GX2_ENDIAN_SWAP_NONE: GX2EndianSwapMode = 0;
pub const GX2_ENDIAN_SWAP_8_IN_16: GX2EndianSwapMode = 1;
pub const GX2_ENDIAN_SWAP_8_IN_32: GX2EndianSwapMode = 2;
pub const GX2_ENDIAN_SWAP_DEFAULT: GX2EndianSwapMode = 3;
pub type GX2EndianSwapMode = ::core::ffi::c_uint;
pub const GX2_FETCH_SHADER_TESSELLATION_NONE: GX2FetchShaderType = 0;
pub const GX2_FETCH_SHADER_TESSELLATION_LINE: GX2FetchShaderType = 1;
pub const GX2_FETCH_SHADER_TESSELLATION_TRIANGLE: GX2FetchShaderType = 2;
pub const GX2_FETCH_SHADER_TESSELLATION_QUAD: GX2FetchShaderType = 3;
pub type GX2FetchShaderType = ::core::ffi::c_uint;
pub const GX2_FRONT_FACE_CCW: GX2FrontFace = 0;
pub const GX2_FRONT_FACE_CW: GX2FrontFace = 1;
pub type GX2FrontFace = ::core::ffi::c_uint;
pub const GX2_INDEX_TYPE_U16_LE: GX2IndexType = 0;
pub const GX2_INDEX_TYPE_U32_LE: GX2IndexType = 1;
pub const GX2_INDEX_TYPE_U16: GX2IndexType = 4;
pub const GX2_INDEX_TYPE_U32: GX2IndexType = 9;
pub type GX2IndexType = ::core::ffi::c_uint;
pub const GX2_INVALIDATE_MODE_NONE: GX2InvalidateMode = 0;
pub const GX2_INVALIDATE_MODE_ATTRIBUTE_BUFFER: GX2InvalidateMode = 1;
pub const GX2_INVALIDATE_MODE_TEXTURE: GX2InvalidateMode = 2;
pub const GX2_INVALIDATE_MODE_UNIFORM_BLOCK: GX2InvalidateMode = 4;
pub const GX2_INVALIDATE_MODE_SHADER: GX2InvalidateMode = 8;
pub const GX2_INVALIDATE_MODE_COLOR_BUFFER: GX2InvalidateMode = 16;
pub const GX2_INVALIDATE_MODE_DEPTH_BUFFER: GX2InvalidateMode = 32;
pub const GX2_INVALIDATE_MODE_CPU: GX2InvalidateMode = 64;
pub const GX2_INVALIDATE_MODE_STREAM_OUT_BUFFER: GX2InvalidateMode = 128;
pub const GX2_INVALIDATE_MODE_EXPORT_BUFFER: GX2InvalidateMode = 256;
pub const GX2_INVALIDATE_MODE_CPU_ATTRIBUTE_BUFFER: GX2InvalidateMode = 65;
pub const GX2_INVALIDATE_MODE_CPU_TEXTURE: GX2InvalidateMode = 66;
pub const GX2_INVALIDATE_MODE_CPU_SHADER: GX2InvalidateMode = 72;
pub type GX2InvalidateMode = ::core::ffi::c_uint;
pub const GX2_INIT_END: GX2InitAttributes = 0;
pub const GX2_INIT_CMD_BUF_BASE: GX2InitAttributes = 1;
pub const GX2_INIT_CMD_BUF_POOL_SIZE: GX2InitAttributes = 2;
pub const GX2_INIT_ARGC: GX2InitAttributes = 7;
pub const GX2_INIT_ARGV: GX2InitAttributes = 8;
pub const GX2_INIT_PROFILE_MODE: GX2InitAttributes = 9;
pub const GX2_INIT_TOSS_STAGE: GX2InitAttributes = 10;
pub const GX2_INIT_APP_IO_THREAD_STACK_SIZE: GX2InitAttributes = 11;
pub type GX2InitAttributes = ::core::ffi::c_uint;
pub const GX2_LOGIC_OP_CLEAR: GX2LogicOp = 0;
pub const GX2_LOGIC_OP_NOR: GX2LogicOp = 17;
pub const GX2_LOGIC_OP_INV_AND: GX2LogicOp = 34;
pub const GX2_LOGIC_OP_INV_COPY: GX2LogicOp = 51;
pub const GX2_LOGIC_OP_REV_AND: GX2LogicOp = 68;
pub const GX2_LOGIC_OP_INV: GX2LogicOp = 85;
pub const GX2_LOGIC_OP_XOR: GX2LogicOp = 102;
pub const GX2_LOGIC_OP_NOT_AND: GX2LogicOp = 119;
pub const GX2_LOGIC_OP_AND: GX2LogicOp = 136;
pub const GX2_LOGIC_OP_EQUIV: GX2LogicOp = 153;
pub const GX2_LOGIC_OP_NOP: GX2LogicOp = 170;
pub const GX2_LOGIC_OP_INV_OR: GX2LogicOp = 187;
pub const GX2_LOGIC_OP_COPY: GX2LogicOp = 204;
pub const GX2_LOGIC_OP_REV_OR: GX2LogicOp = 221;
pub const GX2_LOGIC_OP_OR: GX2LogicOp = 238;
pub const GX2_LOGIC_OP_SET: GX2LogicOp = 255;
pub type GX2LogicOp = ::core::ffi::c_uint;
pub const GX2_PRIMITIVE_MODE_POINTS: GX2PrimitiveMode = 1;
pub const GX2_PRIMITIVE_MODE_LINES: GX2PrimitiveMode = 2;
pub const GX2_PRIMITIVE_MODE_LINE_STRIP: GX2PrimitiveMode = 3;
pub const GX2_PRIMITIVE_MODE_TRIANGLES: GX2PrimitiveMode = 4;
pub const GX2_PRIMITIVE_MODE_TRIANGLE_FAN: GX2PrimitiveMode = 5;
pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP: GX2PrimitiveMode = 6;
pub const GX2_PRIMITIVE_MODE_LINES_ADJACENCY: GX2PrimitiveMode = 10;
pub const GX2_PRIMITIVE_MODE_LINE_STRIP_ADJACENCY: GX2PrimitiveMode = 11;
pub const GX2_PRIMITIVE_MODE_TRIANGLES_ADJACENCY: GX2PrimitiveMode = 12;
pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP_ADJACENCY: GX2PrimitiveMode = 13;
pub const GX2_PRIMITIVE_MODE_RECTS: GX2PrimitiveMode = 17;
pub const GX2_PRIMITIVE_MODE_LINE_LOOP: GX2PrimitiveMode = 18;
pub const GX2_PRIMITIVE_MODE_QUADS: GX2PrimitiveMode = 19;
pub const GX2_PRIMITIVE_MODE_QUAD_STRIP: GX2PrimitiveMode = 20;
pub type GX2PrimitiveMode = ::core::ffi::c_uint;
pub const GX2_POLYGON_MODE_POINT: GX2PolygonMode = 0;
pub const GX2_POLYGON_MODE_LINE: GX2PolygonMode = 1;
pub const GX2_POLYGON_MODE_TRIANGLE: GX2PolygonMode = 2;
pub type GX2PolygonMode = ::core::ffi::c_uint;
pub const GX2_RENDER_TARGET_0: GX2RenderTarget = 0;
pub const GX2_RENDER_TARGET_1: GX2RenderTarget = 1;
pub const GX2_RENDER_TARGET_2: GX2RenderTarget = 2;
pub const GX2_RENDER_TARGET_3: GX2RenderTarget = 3;
pub const GX2_RENDER_TARGET_4: GX2RenderTarget = 4;
pub const GX2_RENDER_TARGET_5: GX2RenderTarget = 5;
pub const GX2_RENDER_TARGET_6: GX2RenderTarget = 6;
pub const GX2_RENDER_TARGET_7: GX2RenderTarget = 7;
pub type GX2RenderTarget = ::core::ffi::c_uint;
pub const GX2_ROUNDING_MODE_ROUND_TO_EVEN: GX2RoundingMode = 0;
pub const GX2_ROUNDING_MODE_TRUNCATE: GX2RoundingMode = 1;
pub type GX2RoundingMode = ::core::ffi::c_uint;
pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_1D: GX2SamplerVarType = 0;
pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_2D: GX2SamplerVarType = 1;
pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_3D: GX2SamplerVarType = 3;
pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_CUBE: GX2SamplerVarType = 4;
pub type GX2SamplerVarType = ::core::ffi::c_uint;
pub const GX2_SCAN_TARGET_TV0: GX2ScanTarget = 1;
pub const GX2_SCAN_TARGET_TV1: GX2ScanTarget = 2;
pub const GX2_SCAN_TARGET_DRC0: GX2ScanTarget = 4;
pub const GX2_SCAN_TARGET_DRC1: GX2ScanTarget = 8;
pub const GX2_SCAN_TARGET_TV: GX2ScanTarget = 1;
pub const GX2_SCAN_TARGET_DRC: GX2ScanTarget = 4;
pub type GX2ScanTarget = ::core::ffi::c_uint;
pub const GX2_SHADER_MODE_UNIFORM_REGISTER: GX2ShaderMode = 0;
pub const GX2_SHADER_MODE_UNIFORM_BLOCK: GX2ShaderMode = 1;
pub const GX2_SHADER_MODE_GEOMETRY_SHADER: GX2ShaderMode = 2;
pub const GX2_SHADER_MODE_COMPUTE_SHADER: GX2ShaderMode = 3;
pub type GX2ShaderMode = ::core::ffi::c_uint;
pub const GX2_SHADER_VAR_TYPE_VOID: GX2ShaderVarType = 0;
pub const GX2_SHADER_VAR_TYPE_BOOL: GX2ShaderVarType = 1;
pub const GX2_SHADER_VAR_TYPE_INT: GX2ShaderVarType = 2;
pub const GX2_SHADER_VAR_TYPE_UINT: GX2ShaderVarType = 3;
pub const GX2_SHADER_VAR_TYPE_FLOAT: GX2ShaderVarType = 4;
pub const GX2_SHADER_VAR_TYPE_DOUBLE: GX2ShaderVarType = 5;
pub const GX2_SHADER_VAR_TYPE_DOUBLE2: GX2ShaderVarType = 6;
pub const GX2_SHADER_VAR_TYPE_DOUBLE3: GX2ShaderVarType = 7;
pub const GX2_SHADER_VAR_TYPE_DOUBLE4: GX2ShaderVarType = 8;
pub const GX2_SHADER_VAR_TYPE_FLOAT2: GX2ShaderVarType = 9;
pub const GX2_SHADER_VAR_TYPE_FLOAT3: GX2ShaderVarType = 10;
pub const GX2_SHADER_VAR_TYPE_FLOAT4: GX2ShaderVarType = 11;
pub const GX2_SHADER_VAR_TYPE_BOOL2: GX2ShaderVarType = 12;
pub const GX2_SHADER_VAR_TYPE_BOOL3: GX2ShaderVarType = 13;
pub const GX2_SHADER_VAR_TYPE_BOOL4: GX2ShaderVarType = 14;
pub const GX2_SHADER_VAR_TYPE_INT2: GX2ShaderVarType = 15;
pub const GX2_SHADER_VAR_TYPE_INT3: GX2ShaderVarType = 16;
pub const GX2_SHADER_VAR_TYPE_INT4: GX2ShaderVarType = 17;
pub const GX2_SHADER_VAR_TYPE_UINT2: GX2ShaderVarType = 18;
pub const GX2_SHADER_VAR_TYPE_UINT3: GX2ShaderVarType = 19;
pub const GX2_SHADER_VAR_TYPE_UINT4: GX2ShaderVarType = 20;
pub const GX2_SHADER_VAR_TYPE_FLOAT2X2: GX2ShaderVarType = 21;
pub const GX2_SHADER_VAR_TYPE_FLOAT2X3: GX2ShaderVarType = 22;
pub const GX2_SHADER_VAR_TYPE_FLOAT2X4: GX2ShaderVarType = 23;
pub const GX2_SHADER_VAR_TYPE_FLOAT3X2: GX2ShaderVarType = 24;
pub const GX2_SHADER_VAR_TYPE_FLOAT3X3: GX2ShaderVarType = 25;
pub const GX2_SHADER_VAR_TYPE_FLOAT3X4: GX2ShaderVarType = 26;
pub const GX2_SHADER_VAR_TYPE_FLOAT4X2: GX2ShaderVarType = 27;
pub const GX2_SHADER_VAR_TYPE_FLOAT4X3: GX2ShaderVarType = 28;
pub const GX2_SHADER_VAR_TYPE_FLOAT4X4: GX2ShaderVarType = 29;
pub const GX2_SHADER_VAR_TYPE_DOUBLE2X2: GX2ShaderVarType = 30;
pub const GX2_SHADER_VAR_TYPE_DOUBLE2X3: GX2ShaderVarType = 31;
pub const GX2_SHADER_VAR_TYPE_DOUBLE2X4: GX2ShaderVarType = 32;
pub const GX2_SHADER_VAR_TYPE_DOUBLE3X2: GX2ShaderVarType = 33;
pub const GX2_SHADER_VAR_TYPE_DOUBLE3X3: GX2ShaderVarType = 34;
pub const GX2_SHADER_VAR_TYPE_DOUBLE3X4: GX2ShaderVarType = 35;
pub const GX2_SHADER_VAR_TYPE_DOUBLE4X2: GX2ShaderVarType = 36;
pub const GX2_SHADER_VAR_TYPE_DOUBLE4X3: GX2ShaderVarType = 37;
pub const GX2_SHADER_VAR_TYPE_DOUBLE4X4: GX2ShaderVarType = 38;
pub type GX2ShaderVarType = ::core::ffi::c_uint;
pub const GX2_STENCIL_FUNCTION_KEEP: GX2StencilFunction = 0;
pub const GX2_STENCIL_FUNCTION_ZERO: GX2StencilFunction = 1;
pub const GX2_STENCIL_FUNCTION_REPLACE: GX2StencilFunction = 2;
pub const GX2_STENCIL_FUNCTION_INCR_CLAMP: GX2StencilFunction = 3;
pub const GX2_STENCIL_FUNCTION_DECR_CLAMP: GX2StencilFunction = 4;
pub const GX2_STENCIL_FUNCTION_INV: GX2StencilFunction = 5;
pub const GX2_STENCIL_FUNCTION_INCR_WRAP: GX2StencilFunction = 6;
pub const GX2_STENCIL_FUNCTION_DECR_WRAP: GX2StencilFunction = 7;
pub type GX2StencilFunction = ::core::ffi::c_uint;
pub const GX2_SURFACE_DIM_TEXTURE_1D: GX2SurfaceDim = 0;
pub const GX2_SURFACE_DIM_TEXTURE_2D: GX2SurfaceDim = 1;
pub const GX2_SURFACE_DIM_TEXTURE_3D: GX2SurfaceDim = 2;
pub const GX2_SURFACE_DIM_TEXTURE_CUBE: GX2SurfaceDim = 3;
pub const GX2_SURFACE_DIM_TEXTURE_1D_ARRAY: GX2SurfaceDim = 4;
pub const GX2_SURFACE_DIM_TEXTURE_2D_ARRAY: GX2SurfaceDim = 5;
pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA: GX2SurfaceDim = 6;
pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA_ARRAY: GX2SurfaceDim = 7;
pub type GX2SurfaceDim = ::core::ffi::c_uint;
pub const GX2_SURFACE_FORMAT_INVALID: GX2SurfaceFormat = 0;
pub const GX2_SURFACE_FORMAT_UNORM_R4_G4: GX2SurfaceFormat = 2;
pub const GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4: GX2SurfaceFormat = 11;
pub const GX2_SURFACE_FORMAT_UNORM_R8: GX2SurfaceFormat = 1;
pub const GX2_SURFACE_FORMAT_UNORM_R8_G8: GX2SurfaceFormat = 7;
pub const GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8: GX2SurfaceFormat = 26;
pub const GX2_SURFACE_FORMAT_UNORM_R16: GX2SurfaceFormat = 5;
pub const GX2_SURFACE_FORMAT_UNORM_R16_G16: GX2SurfaceFormat = 15;
pub const GX2_SURFACE_FORMAT_UNORM_R16_G16_B16_A16: GX2SurfaceFormat = 31;
pub const GX2_SURFACE_FORMAT_UNORM_R5_G6_B5: GX2SurfaceFormat = 8;
pub const GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1: GX2SurfaceFormat = 10;
pub const GX2_SURFACE_FORMAT_UNORM_A1_B5_G5_R5: GX2SurfaceFormat = 12;
pub const GX2_SURFACE_FORMAT_UNORM_R24_X8: GX2SurfaceFormat = 17;
pub const GX2_SURFACE_FORMAT_UNORM_A2_B10_G10_R10: GX2SurfaceFormat = 27;
pub const GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2: GX2SurfaceFormat = 25;
pub const GX2_SURFACE_FORMAT_UNORM_BC1: GX2SurfaceFormat = 49;
pub const GX2_SURFACE_FORMAT_UNORM_BC2: GX2SurfaceFormat = 50;
pub const GX2_SURFACE_FORMAT_UNORM_BC3: GX2SurfaceFormat = 51;
pub const GX2_SURFACE_FORMAT_UNORM_BC4: GX2SurfaceFormat = 52;
pub const GX2_SURFACE_FORMAT_UNORM_BC5: GX2SurfaceFormat = 53;
pub const GX2_SURFACE_FORMAT_UNORM_NV12: GX2SurfaceFormat = 129;
pub const GX2_SURFACE_FORMAT_UINT_R8: GX2SurfaceFormat = 257;
pub const GX2_SURFACE_FORMAT_UINT_R8_G8: GX2SurfaceFormat = 263;
pub const GX2_SURFACE_FORMAT_UINT_R8_G8_B8_A8: GX2SurfaceFormat = 282;
pub const GX2_SURFACE_FORMAT_UINT_R16: GX2SurfaceFormat = 261;
pub const GX2_SURFACE_FORMAT_UINT_R16_G16: GX2SurfaceFormat = 271;
pub const GX2_SURFACE_FORMAT_UINT_R16_G16_B16_A16: GX2SurfaceFormat = 287;
pub const GX2_SURFACE_FORMAT_UINT_R32: GX2SurfaceFormat = 269;
pub const GX2_SURFACE_FORMAT_UINT_R32_G32: GX2SurfaceFormat = 285;
pub const GX2_SURFACE_FORMAT_UINT_R32_G32_B32_A32: GX2SurfaceFormat = 290;
pub const GX2_SURFACE_FORMAT_UINT_A2_B10_G10_R10: GX2SurfaceFormat = 283;
pub const GX2_SURFACE_FORMAT_UINT_R10_G10_B10_A2: GX2SurfaceFormat = 281;
pub const GX2_SURFACE_FORMAT_UINT_X24_G8: GX2SurfaceFormat = 273;
pub const GX2_SURFACE_FORMAT_UINT_G8_X24: GX2SurfaceFormat = 284;
pub const GX2_SURFACE_FORMAT_SNORM_R8: GX2SurfaceFormat = 513;
pub const GX2_SURFACE_FORMAT_SNORM_R8_G8: GX2SurfaceFormat = 519;
pub const GX2_SURFACE_FORMAT_SNORM_R8_G8_B8_A8: GX2SurfaceFormat = 538;
pub const GX2_SURFACE_FORMAT_SNORM_R16: GX2SurfaceFormat = 517;
pub const GX2_SURFACE_FORMAT_SNORM_R16_G16: GX2SurfaceFormat = 527;
pub const GX2_SURFACE_FORMAT_SNORM_R16_G16_B16_A16: GX2SurfaceFormat = 543;
pub const GX2_SURFACE_FORMAT_SNORM_R10_G10_B10_A2: GX2SurfaceFormat = 537;
pub const GX2_SURFACE_FORMAT_SNORM_BC4: GX2SurfaceFormat = 564;
pub const GX2_SURFACE_FORMAT_SNORM_BC5: GX2SurfaceFormat = 565;
pub const GX2_SURFACE_FORMAT_SINT_R8: GX2SurfaceFormat = 769;
pub const GX2_SURFACE_FORMAT_SINT_R8_G8: GX2SurfaceFormat = 775;
pub const GX2_SURFACE_FORMAT_SINT_R8_G8_B8_A8: GX2SurfaceFormat = 794;
pub const GX2_SURFACE_FORMAT_SINT_R16: GX2SurfaceFormat = 773;
pub const GX2_SURFACE_FORMAT_SINT_R16_G16: GX2SurfaceFormat = 783;
pub const GX2_SURFACE_FORMAT_SINT_R16_G16_B16_A16: GX2SurfaceFormat = 799;
pub const GX2_SURFACE_FORMAT_SINT_R32: GX2SurfaceFormat = 781;
pub const GX2_SURFACE_FORMAT_SINT_R32_G32: GX2SurfaceFormat = 797;
pub const GX2_SURFACE_FORMAT_SINT_R32_G32_B32_A32: GX2SurfaceFormat = 802;
pub const GX2_SURFACE_FORMAT_SINT_R10_G10_B10_A2: GX2SurfaceFormat = 793;
pub const GX2_SURFACE_FORMAT_SRGB_R8_G8_B8_A8: GX2SurfaceFormat = 1050;
pub const GX2_SURFACE_FORMAT_SRGB_BC1: GX2SurfaceFormat = 1073;
pub const GX2_SURFACE_FORMAT_SRGB_BC2: GX2SurfaceFormat = 1074;
pub const GX2_SURFACE_FORMAT_SRGB_BC3: GX2SurfaceFormat = 1075;
pub const GX2_SURFACE_FORMAT_FLOAT_R32: GX2SurfaceFormat = 2062;
pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32: GX2SurfaceFormat = 2078;
pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32_B32_A32: GX2SurfaceFormat = 2083;
pub const GX2_SURFACE_FORMAT_FLOAT_R16: GX2SurfaceFormat = 2054;
pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16: GX2SurfaceFormat = 2064;
pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16_B16_A16: GX2SurfaceFormat = 2080;
pub const GX2_SURFACE_FORMAT_FLOAT_R11_G11_B10: GX2SurfaceFormat = 2070;
pub const GX2_SURFACE_FORMAT_FLOAT_D24_S8: GX2SurfaceFormat = 2065;
pub const GX2_SURFACE_FORMAT_FLOAT_X8_X24: GX2SurfaceFormat = 2076;
pub type GX2SurfaceFormat = ::core::ffi::c_uint;
pub const GX2_SURFACE_USE_NONE: GX2SurfaceUse = 0;
pub const GX2_SURFACE_USE_TEXTURE: GX2SurfaceUse = 1;
pub const GX2_SURFACE_USE_COLOR_BUFFER: GX2SurfaceUse = 2;
pub const GX2_SURFACE_USE_DEPTH_BUFFER: GX2SurfaceUse = 4;
pub const GX2_SURFACE_USE_SCAN_BUFFER: GX2SurfaceUse = 8;
pub const GX2_SURFACE_USE_TV: GX2SurfaceUse = -2147483648;
pub const GX2_SURFACE_USE_TEXTURE_COLOR_BUFFER_TV: GX2SurfaceUse = -2147483645;
pub type GX2SurfaceUse = ::core::ffi::c_int;
pub const GX2_TESSELLATION_MODE_DISCRETE: GX2TessellationMode = 0;
pub const GX2_TESSELLATION_MODE_CONTINUOUS: GX2TessellationMode = 1;
pub const GX2_TESSELLATION_MODE_ADAPTIVE: GX2TessellationMode = 2;
pub type GX2TessellationMode = ::core::ffi::c_uint;
pub const GX2_TEX_BORDER_TYPE_TRANSPARENT_BLACK: GX2TexBorderType = 0;
pub const GX2_TEX_BORDER_TYPE_BLACK: GX2TexBorderType = 1;
pub const GX2_TEX_BORDER_TYPE_WHITE: GX2TexBorderType = 2;
pub const GX2_TEX_BORDER_TYPE_VARIABLE: GX2TexBorderType = 3;
pub type GX2TexBorderType = ::core::ffi::c_uint;
pub const GX2_TEX_CLAMP_MODE_WRAP: GX2TexClampMode = 0;
pub const GX2_TEX_CLAMP_MODE_MIRROR: GX2TexClampMode = 1;
pub const GX2_TEX_CLAMP_MODE_CLAMP: GX2TexClampMode = 2;
pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE: GX2TexClampMode = 3;
pub const GX2_TEX_CLAMP_MODE_CLAMP_HALF_BORDER: GX2TexClampMode = 4;
pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_HALF_BORDER: GX2TexClampMode = 5;
pub const GX2_TEX_CLAMP_MODE_CLAMP_BORDER: GX2TexClampMode = 6;
pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_BORDER: GX2TexClampMode = 7;
pub type GX2TexClampMode = ::core::ffi::c_uint;
pub const GX2_TEX_MIP_FILTER_MODE_NONE: GX2TexMipFilterMode = 0;
pub const GX2_TEX_MIP_FILTER_MODE_POINT: GX2TexMipFilterMode = 1;
pub const GX2_TEX_MIP_FILTER_MODE_LINEAR: GX2TexMipFilterMode = 2;
pub type GX2TexMipFilterMode = ::core::ffi::c_uint;
pub const GX2_TEX_MIP_PERF_MODE_DISABLE: GX2TexMipPerfMode = 0;
pub type GX2TexMipPerfMode = ::core::ffi::c_uint;
pub const GX2_TEX_XY_FILTER_MODE_POINT: GX2TexXYFilterMode = 0;
pub const GX2_TEX_XY_FILTER_MODE_LINEAR: GX2TexXYFilterMode = 1;
pub const GX2_TEX_XY_FILTER_MODE_BICUBIC: GX2TexXYFilterMode = 2;
pub type GX2TexXYFilterMode = ::core::ffi::c_uint;
pub const GX2_TEX_ANISO_RATIO_NONE: GX2TexAnisoRatio = 0;
pub const GX2_TEX_ANISO_RATIO_2_TO_1: GX2TexAnisoRatio = 1;
pub const GX2_TEX_ANISO_RATIO_4_TO_1: GX2TexAnisoRatio = 2;
pub const GX2_TEX_ANISO_RATIO_8_TO_1: GX2TexAnisoRatio = 3;
pub const GX2_TEX_ANISO_RATIO_16_TO_1: GX2TexAnisoRatio = 4;
pub type GX2TexAnisoRatio = ::core::ffi::c_uint;
pub const GX2_TEX_Z_FILTER_MODE_NONE: GX2TexZFilterMode = 0;
pub const GX2_TEX_Z_FILTER_MODE_POINT: GX2TexZFilterMode = 1;
pub const GX2_TEX_Z_FILTER_MODE_LINEAR: GX2TexZFilterMode = 2;
pub type GX2TexZFilterMode = ::core::ffi::c_uint;
pub const GX2_TEX_Z_PERF_MODE_DISABLED: GX2TexZPerfMode = 0;
pub type GX2TexZPerfMode = ::core::ffi::c_uint;
pub const GX2_TILE_MODE_DEFAULT: GX2TileMode = 0;
pub const GX2_TILE_MODE_LINEAR_ALIGNED: GX2TileMode = 1;
pub const GX2_TILE_MODE_TILED_1D_THIN1: GX2TileMode = 2;
pub const GX2_TILE_MODE_TILED_1D_THICK: GX2TileMode = 3;
pub const GX2_TILE_MODE_TILED_2D_THIN1: GX2TileMode = 4;
pub const GX2_TILE_MODE_TILED_2D_THIN2: GX2TileMode = 5;
pub const GX2_TILE_MODE_TILED_2D_THIN4: GX2TileMode = 6;
pub const GX2_TILE_MODE_TILED_2D_THICK: GX2TileMode = 7;
pub const GX2_TILE_MODE_TILED_2B_THIN1: GX2TileMode = 8;
pub const GX2_TILE_MODE_TILED_2B_THIN2: GX2TileMode = 9;
pub const GX2_TILE_MODE_TILED_2B_THIN4: GX2TileMode = 10;
pub const GX2_TILE_MODE_TILED_2B_THICK: GX2TileMode = 11;
pub const GX2_TILE_MODE_TILED_3D_THIN1: GX2TileMode = 12;
pub const GX2_TILE_MODE_TILED_3D_THICK: GX2TileMode = 13;
pub const GX2_TILE_MODE_TILED_3B_THIN1: GX2TileMode = 14;
pub const GX2_TILE_MODE_TILED_3B_THICK: GX2TileMode = 15;
pub const GX2_TILE_MODE_LINEAR_SPECIAL: GX2TileMode = 16;
pub type GX2TileMode = ::core::ffi::c_uint;
pub const GX2_TV_RENDER_MODE_DISABLED: GX2TVRenderMode = 0;
pub const GX2_TV_RENDER_MODE_STANDARD_480P: GX2TVRenderMode = 1;
pub const GX2_TV_RENDER_MODE_WIDE_480P: GX2TVRenderMode = 2;
pub const GX2_TV_RENDER_MODE_WIDE_720P: GX2TVRenderMode = 3;
pub const GX2_TV_RENDER_MODE_WIDE_1080P: GX2TVRenderMode = 5;
pub type GX2TVRenderMode = ::core::ffi::c_uint;
pub const GX2_TV_SCAN_MODE_NONE: GX2TVScanMode = 0;
pub const GX2_TV_SCAN_MODE_576I: GX2TVScanMode = 1;
pub const GX2_TV_SCAN_MODE_480I: GX2TVScanMode = 2;
pub const GX2_TV_SCAN_MODE_480P: GX2TVScanMode = 3;
pub const GX2_TV_SCAN_MODE_720P: GX2TVScanMode = 4;
pub const GX2_TV_SCAN_MODE_1080I: GX2TVScanMode = 6;
pub const GX2_TV_SCAN_MODE_1080P: GX2TVScanMode = 7;
pub type GX2TVScanMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Sampler {
    pub regs: [u32; 3usize],
}
extern "C" {
    pub fn GX2InitSampler(
        sampler: *mut GX2Sampler,
        clampMode: GX2TexClampMode,
        minMagFilterMode: GX2TexXYFilterMode,
    );
}
extern "C" {
    pub fn GX2InitSamplerBorderType(sampler: *mut GX2Sampler, borderType: GX2TexBorderType);
}
extern "C" {
    pub fn GX2InitSamplerClamping(
        sampler: *mut GX2Sampler,
        clampX: GX2TexClampMode,
        clampY: GX2TexClampMode,
        clampZ: GX2TexClampMode,
    );
}
extern "C" {
    pub fn GX2InitSamplerDepthCompare(sampler: *mut GX2Sampler, depthCompare: GX2CompareFunction);
}
extern "C" {
    pub fn GX2InitSamplerFilterAdjust(
        sampler: *mut GX2Sampler,
        highPrecision: BOOL,
        perfMip: GX2TexMipPerfMode,
        perfZ: GX2TexZPerfMode,
    );
}
extern "C" {
    pub fn GX2InitSamplerLOD(sampler: *mut GX2Sampler, lodMin: f32, lodMax: f32, lodBias: f32);
}
extern "C" {
    pub fn GX2InitSamplerLODAdjust(sampler: *mut GX2Sampler, unk1: f32, unk2: BOOL);
}
extern "C" {
    pub fn GX2InitSamplerRoundingMode(sampler: *mut GX2Sampler, roundingMode: GX2RoundingMode);
}
extern "C" {
    pub fn GX2InitSamplerXYFilter(
        sampler: *mut GX2Sampler,
        filterMag: GX2TexXYFilterMode,
        filterMin: GX2TexXYFilterMode,
        maxAniso: GX2TexAnisoRatio,
    );
}
extern "C" {
    pub fn GX2InitSamplerZMFilter(
        sampler: *mut GX2Sampler,
        filterZ: GX2TexZFilterMode,
        filterMip: GX2TexMipFilterMode,
    );
}
pub const GX2R_RESOURCE_BIND_NONE: GX2RResourceFlags = 0;
pub const GX2R_RESOURCE_BIND_TEXTURE: GX2RResourceFlags = 1;
pub const GX2R_RESOURCE_BIND_COLOR_BUFFER: GX2RResourceFlags = 2;
pub const GX2R_RESOURCE_BIND_DEPTH_BUFFER: GX2RResourceFlags = 4;
pub const GX2R_RESOURCE_BIND_SCAN_BUFFER: GX2RResourceFlags = 8;
pub const GX2R_RESOURCE_BIND_VERTEX_BUFFER: GX2RResourceFlags = 16;
pub const GX2R_RESOURCE_BIND_INDEX_BUFFER: GX2RResourceFlags = 32;
pub const GX2R_RESOURCE_BIND_UNIFORM_BLOCK: GX2RResourceFlags = 64;
pub const GX2R_RESOURCE_BIND_SHADER_PROGRAM: GX2RResourceFlags = 128;
pub const GX2R_RESOURCE_BIND_STREAM_OUTPUT: GX2RResourceFlags = 256;
pub const GX2R_RESOURCE_BIND_DISPLAY_LIST: GX2RResourceFlags = 512;
pub const GX2R_RESOURCE_BIND_GS_RING_BUFFER: GX2RResourceFlags = 1024;
pub const GX2R_RESOURCE_USAGE_CPU_READ: GX2RResourceFlags = 2048;
pub const GX2R_RESOURCE_USAGE_CPU_WRITE: GX2RResourceFlags = 4096;
pub const GX2R_RESOURCE_USAGE_GPU_READ: GX2RResourceFlags = 8192;
pub const GX2R_RESOURCE_USAGE_GPU_WRITE: GX2RResourceFlags = 16384;
pub const GX2R_RESOURCE_USAGE_DMA_READ: GX2RResourceFlags = 32768;
pub const GX2R_RESOURCE_USAGE_DMA_WRITE: GX2RResourceFlags = 65536;
pub const GX2R_RESOURCE_USAGE_FORCE_MEM1: GX2RResourceFlags = 131072;
pub const GX2R_RESOURCE_USAGE_FORCE_MEM2: GX2RResourceFlags = 262144;
pub const GX2R_RESOURCE_DISABLE_CPU_INVALIDATE: GX2RResourceFlags = 1048576;
pub const GX2R_RESOURCE_DISABLE_GPU_INVALIDATE: GX2RResourceFlags = 2097152;
pub const GX2R_RESOURCE_LOCKED_READ_ONLY: GX2RResourceFlags = 4194304;
pub const GX2R_RESOURCE_GX2R_ALLOCATED: GX2RResourceFlags = 536870912;
pub const GX2R_RESOURCE_LOCKED: GX2RResourceFlags = 1073741824;
pub type GX2RResourceFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2RBuffer {
    pub flags: GX2RResourceFlags,
    pub elemSize: u32,
    pub elemCount: u32,
    pub buffer: *mut ::core::ffi::c_void,
}
impl Default for GX2RBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn GX2RBufferExists(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBuffer(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBufferUserMemory(
        buffer: *mut GX2RBuffer,
        memory: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroyBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags);
}
extern "C" {
    pub fn GX2RGetBufferAlignment(flags: GX2RResourceFlags) -> u32;
}
extern "C" {
    pub fn GX2RGetBufferAllocationSize(buffer: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RInvalidateBuffer(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags);
}
extern "C" {
    pub fn GX2RLockBufferEx(
        buffer: *mut GX2RBuffer,
        flags: GX2RResourceFlags,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn GX2RUnlockBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags);
}
extern "C" {
    pub fn GX2RSetVertexUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetPixelUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetGeometryUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader {
    pub type_: GX2FetchShaderType,
    pub regs: GX2FetchShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub attribCount: u32,
    pub numDivisors: u32,
    pub divisors: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2FetchShader__bindgen_ty_1 {
    pub sq_pgm_resources_fs: u32,
}
impl Default for GX2FetchShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformBlock {
    pub name: *const ::core::ffi::c_char,
    pub offset: u32,
    pub size: u32,
}
impl Default for GX2UniformBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType,
    pub count: u32,
    pub offset: u32,
    pub block: i32,
}
impl Default for GX2UniformVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2UniformInitialValue {
    pub value: [f32; 4usize],
    pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2LoopVar {
    pub offset: u32,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2SamplerVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2SamplerVarType,
    pub location: u32,
}
impl Default for GX2SamplerVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType,
    pub count: u32,
    pub location: u32,
}
impl Default for GX2AttribVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader {
    pub regs: GX2VertexShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub attribVarCount: u32,
    pub attribVars: *mut GX2AttribVar,
    pub ringItemsize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2VertexShader__bindgen_ty_1 {
    pub sq_pgm_resources_vs: u32,
    pub vgt_primitiveid_en: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub pa_cl_vs_out_cntl: u32,
    pub sq_vtx_semantic_clear: u32,
    pub num_sq_vtx_semantic: u32,
    pub sq_vtx_semantic: [u32; 32usize],
    pub vgt_strmout_buffer_en: u32,
    pub vgt_vertex_reuse_block_cntl: u32,
    pub vgt_hos_reuse_depth: u32,
}
impl Default for GX2VertexShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader {
    pub regs: GX2PixelShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PixelShader__bindgen_ty_1 {
    pub sq_pgm_resources_ps: u32,
    pub sq_pgm_exports_ps: u32,
    pub spi_ps_in_control_0: u32,
    pub spi_ps_in_control_1: u32,
    pub num_spi_ps_input_cntl: u32,
    pub spi_ps_input_cntls: [u32; 32usize],
    pub cb_shader_mask: u32,
    pub cb_shader_control: u32,
    pub db_shader_control: u32,
    pub spi_input_z: u32,
}
impl Default for GX2PixelShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader {
    pub regs: GX2GeometryShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub vertexProgramSize: u32,
    pub vertexProgram: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub ringItemSize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2GeometryShader__bindgen_ty_1 {
    pub sq_pgm_resources_gs: u32,
    pub vgt_gs_out_prim_type: u32,
    pub vgt_gs_mode: u32,
    pub pa_cl_vs_out_cntl: u32,
    pub sq_pgm_resources_vs: u32,
    pub sq_gs_vert_itemsize: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub vgt_strmout_buffer_en: u32,
}
impl Default for GX2GeometryShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribStream {
    pub location: u32,
    pub buffer: u32,
    pub offset: u32,
    pub format: GX2AttribFormat,
    pub type_: GX2AttribIndexType,
    pub aluDivisor: u32,
    pub mask: u32,
    pub endianSwap: GX2EndianSwapMode,
}
impl Default for GX2AttribStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn GX2CalcGeometryShaderInputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcGeometryShaderOutputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcFetchShaderSizeEx(
        attribs: u32,
        fetchShaderType: GX2FetchShaderType,
        tesellationMode: GX2TessellationMode,
    ) -> u32;
}
extern "C" {
    pub fn GX2InitFetchShaderEx(
        fetchShader: *mut GX2FetchShader,
        buffer: *mut u8,
        attribCount: u32,
        attribs: *const GX2AttribStream,
        type_: GX2FetchShaderType,
        tessMode: GX2TessellationMode,
    );
}
extern "C" {
    pub fn GX2SetFetchShader(shader: *const GX2FetchShader);
}
extern "C" {
    pub fn GX2SetVertexShader(shader: *const GX2VertexShader);
}
extern "C" {
    pub fn GX2SetPixelShader(shader: *const GX2PixelShader);
}
extern "C" {
    pub fn GX2SetGeometryShader(shader: *const GX2GeometryShader);
}
extern "C" {
    pub fn GX2SetVertexSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetPixelSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetGeometrySampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetVertexUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetVertexUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetGeometryUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetShaderModeEx(
        mode: GX2ShaderMode,
        numVsGpr: u32,
        numVsStackEntries: u32,
        numGsGpr: u32,
        numGsStackEntries: u32,
        numPsGpr: u32,
        numPsStackEntries: u32,
    );
}
extern "C" {
    pub fn GX2SetStreamOutEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetGeometryShaderInputRingBuffer(buffer: *const ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn GX2SetGeometryShaderOutputRingBuffer(buffer: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn GX2GetPixelShaderGPRs(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetPixelShaderStackEntries(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderGPRs(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderStackEntries(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderGPRs(shader: *const GX2GeometryShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderStackEntries(shader: *const GX2GeometryShader) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Surface {
    pub dim: GX2SurfaceDim,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mipLevels: u32,
    pub format: GX2SurfaceFormat,
    pub aa: GX2AAMode,
    pub __bindgen_anon_1: GX2Surface__bindgen_ty_1,
    pub imageSize: u32,
    pub image: *mut ::core::ffi::c_void,
    pub mipmapSize: u32,
    pub mipmaps: *mut ::core::ffi::c_void,
    pub tileMode: GX2TileMode,
    pub swizzle: u32,
    pub alignment: u32,
    pub pitch: u32,
    pub mipLevelOffset: [u32; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GX2Surface__bindgen_ty_1 {
    pub use_: GX2SurfaceUse,
    pub resourceFlags: GX2RResourceFlags,
}
impl Default for GX2Surface__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GX2Surface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2DepthBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub hiZPtr: *mut ::core::ffi::c_void,
    pub hiZSize: u32,
    pub depthClear: f32,
    pub stencilClear: u32,
    pub regs: [u32; 7usize],
}
impl Default for GX2DepthBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ColorBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub aaBuffer: *mut ::core::ffi::c_void,
    pub aaSize: u32,
    pub regs: [u32; 5usize],
}
impl Default for GX2ColorBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Rect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Point {
    pub x: i32,
    pub y: i32,
}
extern "C" {
    pub fn GX2CalcSurfaceSizeAndAlignment(surface: *mut GX2Surface);
}
extern "C" {
    pub fn GX2CalcDepthBufferHiZInfo(
        depthBuffer: *mut GX2DepthBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcColorBufferAuxInfo(
        surface: *mut GX2ColorBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetColorBuffer(colorBuffer: *const GX2ColorBuffer, target: GX2RenderTarget);
}
extern "C" {
    pub fn GX2SetDepthBuffer(depthBuffer: *const GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitColorBufferRegs(colorBuffer: *mut GX2ColorBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferRegs(depthBuffer: *mut GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferHiZEnable(depthBuffer: *mut GX2DepthBuffer, enable: BOOL);
}
extern "C" {
    pub fn GX2GetSurfaceSwizzle(surface: *const GX2Surface) -> u32;
}
extern "C" {
    pub fn GX2SetSurfaceSwizzle(surface: *mut GX2Surface, swizzle: u32);
}
extern "C" {
    pub fn GX2CopySurface(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
    );
}
extern "C" {
    pub fn GX2CopySurfaceEx(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
        numRects: u32,
        srcRects: *mut GX2Rect,
        dstPoints: *mut GX2Point,
    );
}
extern "C" {
    pub fn GX2ResolveAAColorBuffer(
        srcColorBuffer: *const GX2ColorBuffer,
        dstSurface: *mut GX2Surface,
        dstMip: u32,
        dstSlice: u32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Texture {
    pub surface: GX2Surface,
    pub viewFirstMip: u32,
    pub viewNumMips: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub compMap: u32,
    pub regs: [u32; 5usize],
}
impl Default for GX2Texture {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn GX2InitTextureRegs(texture: *mut GX2Texture);
}
extern "C" {
    pub fn GX2SetPixelTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetVertexTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetGeometryTexture(texture: *const GX2Texture, unit: u32);
}
pub const GFD_BLOCK_END_OF_FILE: GFDBlockType = 1;
pub const GFD_BLOCK_PADDING: GFDBlockType = 2;
pub const GFD_BLOCK_VERTEX_SHADER_HEADER: GFDBlockType = 3;
pub const GFD_BLOCK_VERTEX_SHADER_PROGRAM: GFDBlockType = 5;
pub const GFD_BLOCK_PIXEL_SHADER_HEADER: GFDBlockType = 6;
pub const GFD_BLOCK_PIXEL_SHADER_PROGRAM: GFDBlockType = 7;
pub const GFD_BLOCK_GEOMETRY_SHADER_HEADER: GFDBlockType = 8;
pub const GFD_BLOCK_GEOMETRY_SHADER_PROGRAM: GFDBlockType = 9;
pub const GFD_BLOCK_GEOMETRY_SHADER_COPY_PROGRAM: GFDBlockType = 10;
pub const GFD_BLOCK_TEXTURE_HEADER: GFDBlockType = 11;
pub const GFD_BLOCK_TEXTURE_IMAGE: GFDBlockType = 12;
pub const GFD_BLOCK_TEXTURE_MIPMAP: GFDBlockType = 13;
pub const GFD_BLOCK_COMPUTE_SHADER_HEADER: GFDBlockType = 14;
pub const GFD_BLOCK_COMPUTE_SHADER_PROGRAM: GFDBlockType = 15;
pub type GFDBlockType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFDHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub gpuVersion: u32,
    pub align: u32,
    pub unk1: u32,
    pub unk2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFDBlockHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub type_: GFDBlockType,
    pub dataSize: u32,
    pub id: u32,
    pub index: u32,
}
impl Default for GFDBlockHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFDRelocationHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub unk1: u32,
    pub dataSize: u32,
    pub dataOffset: u32,
    pub textSize: u32,
    pub textOffset: u32,
    pub patchBase: u32,
    pub patchCount: u32,
    pub patchOffset: u32,
}
extern "C" {
    pub fn GFDGetLastErrorString() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn GFDGetGeometryShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderCopyProgramSize(index: u32, file: *const ::core::ffi::c_void)
        -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShader(
        shader: *mut GX2GeometryShader,
        program: *mut ::core::ffi::c_void,
        copyProgram: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetPixelShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShader(
        shader: *mut GX2PixelShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetVertexShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShader(
        shader: *mut GX2VertexShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetTextureCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureMipImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureAlignmentSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTexture(
        texture: *mut GX2Texture,
        image: *mut ::core::ffi::c_void,
        mipmap: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetGX2RTexture(
        texture: *mut GX2Texture,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetTexturePointer(index: u32, file: *const ::core::ffi::c_void) -> *const GX2Texture;
}
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
extern "C" {
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ioctl(fd: ::core::ffi::c_int, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiodgname_arg {
    pub len: ::core::ffi::c_int,
    pub buf: *mut ::core::ffi::c_void,
}
impl Default for fiodgname_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ulong = ::core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::core::ffi::c_int,
    pub contentionscope: ::core::ffi::c_int,
    pub inheritsched: ::core::ffi::c_int,
    pub schedpolicy: ::core::ffi::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::core::ffi::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub recursive: ::core::ffi::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::core::ffi::c_int,
    pub init_executed: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::core::ffi::c_long;
}
extern "C" {
    pub static mut _daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::core::ffi::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_value: sigval,
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_flags: ::core::ffi::c_int,
    pub ss_size: usize,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::core::ffi::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::core::ffi::c_int, arg3: sigval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn str2sig(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type sig_atomic_t = ::core::ffi::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: _sig_func_ptr,
    ) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn signal(arg1: ::core::ffi::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::core::ffi::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::core::ffi::c_int, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::core::ffi::c_int, __value: *mut itimerval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::core::ffi::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub ss_padding: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::core::ffi::c_int,
    pub l_linger: ::core::ffi::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bind(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::core::ffi::c_int, backlog: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn send(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::core::ffi::c_int, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn GX2SetTessellation(
        tessellationMode: GX2TessellationMode,
        primitiveMode: GX2PrimitiveMode,
        indexType: GX2IndexType,
    );
}
extern "C" {
    pub fn GX2SetMinTessellationLevel(min: f32);
}
extern "C" {
    pub fn GX2SetMaxTessellationLevel(max: f32);
}
extern "C" {
    pub fn GX2ClearColor(
        colorBuffer: *mut GX2ColorBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2ClearDepthStencilEx(
        depthBuffer: *mut GX2DepthBuffer,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags,
    );
}
extern "C" {
    pub fn GX2ClearBuffersEx(
        colorBuffer: *mut GX2ColorBuffer,
        depthBuffer: *mut GX2DepthBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags,
    );
}
extern "C" {
    pub fn GX2SetClearDepth(depthBuffer: *mut GX2DepthBuffer, depth: f32);
}
extern "C" {
    pub fn GX2SetClearStencil(depthBuffer: *mut GX2DepthBuffer, stencil: u8);
}
extern "C" {
    pub fn GX2SetClearDepthStencil(depthBuffer: *mut GX2DepthBuffer, depth: f32, stencil: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ShadowState {
    pub config: [u32; 2816usize],
    pub context: [u32; 1024usize],
    pub alu: [u32; 2048usize],
    pub loop_: [u32; 96usize],
    pub __unk36: [::core::ffi::c_char; 128usize],
    pub resource: [u32; 3486usize],
    pub __unk37: [::core::ffi::c_char; 136usize],
    pub sampler: [u32; 162usize],
    pub __unk38: [::core::ffi::c_char; 120usize],
}
impl Default for GX2ShadowState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ContextState {
    pub shadowState: GX2ShadowState,
    pub __unk39: [::core::ffi::c_char; 4usize],
    pub shadowDisplayListSize: u32,
    pub __unk40: [::core::ffi::c_char; 1528usize],
    pub shadowDisplayList: [u32; 192usize],
}
impl Default for GX2ContextState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn GX2SetupContextStateEx(state: *mut GX2ContextState, unk1: BOOL);
}
extern "C" {
    pub fn GX2GetContextStateDisplayList(
        state: *const GX2ContextState,
        outDisplayList: *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetContextState(state: *mut GX2ContextState);
}
extern "C" {
    pub fn GX2SetDefaultState();
}
extern "C" {
    pub fn GX2CopyColorBufferToScanBuffer(buffer: *const GX2ColorBuffer, scanTarget: GX2ScanTarget);
}
extern "C" {
    pub fn GX2SwapScanBuffers();
}
extern "C" {
    pub fn GX2GetLastFrame(scanTarget: GX2ScanTarget, texture: *mut GX2Texture) -> BOOL;
}
extern "C" {
    pub fn GX2GetLastFrameGamma(scanTarget: GX2ScanTarget, gammaOut: *mut f32) -> BOOL;
}
extern "C" {
    pub fn GX2GetSwapInterval() -> u32;
}
extern "C" {
    pub fn GX2SetSwapInterval(interval: u32);
}
pub type GX2DRCConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(drcSlot: u32, attached: BOOL)>;
extern "C" {
    pub fn GX2SetTVEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetDRCEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2CalcTVSize(
        tvRenderMode: GX2TVRenderMode,
        surfaceFormat: GX2SurfaceFormat,
        bufferingMode: GX2BufferingMode,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcDRCSize(
        drcRenderMode: GX2DrcRenderMode,
        surfaceFormat: GX2SurfaceFormat,
        bufferingMode: GX2BufferingMode,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetTVBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        tvRenderMode: GX2TVRenderMode,
        surfaceFormat: GX2SurfaceFormat,
        bufferingMode: GX2BufferingMode,
    );
}
extern "C" {
    pub fn GX2SetDRCBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        drcRenderMode: GX2DrcRenderMode,
        surfaceFormat: GX2SurfaceFormat,
        bufferingMode: GX2BufferingMode,
    );
}
extern "C" {
    pub fn GX2SetTVScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2SetDRCScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2GetSystemTVAspectRatio() -> GX2AspectRatio;
}
extern "C" {
    pub fn GX2GetSystemTVScanMode() -> GX2TVScanMode;
}
extern "C" {
    pub fn GX2GetSystemDRCScanMode() -> GX2DrcRenderMode;
}
extern "C" {
    pub fn GX2GetSystemDRCMode() -> GX2DrcRenderMode;
}
extern "C" {
    pub fn GX2SetDRCConnectCallback(
        drcSlot: u32,
        callback: GX2DRCConnectCallback,
    ) -> GX2DRCConnectCallback;
}
extern "C" {
    pub fn GX2Init(attributes: *mut u32);
}
extern "C" {
    pub fn GX2Shutdown();
}
extern "C" {
    pub fn GX2Flush();
}
extern "C" {
    pub fn GX2ResetGPU(unknown: u32);
}
extern "C" {
    pub fn GX2GetMainCoreId() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn GX2TempGetGPUVersion() -> u32;
}
pub const GX2_DEBUG_CAPTURE_INTERFACE_VERSION: GX2DebugCaptureInterfaceVersion = 1;
pub type GX2DebugCaptureInterfaceVersion = ::core::ffi::c_uint;
pub const GX2_DEBUG_CAPTURE_START_FLAGS_NONE: GX2DebugCaptureStartFlags = 0;
pub const GX2_DEBUG_CAPTURE_START_FLAGS_DISABLE_GX2DRAWDONE: GX2DebugCaptureStartFlags = 1;
pub type GX2DebugCaptureStartFlags = ::core::ffi::c_uint;
pub const GX2_DEBUG_CAPTURE_END_FLAGS_NONE: GX2DebugCaptureEndFlags = 0;
pub const GX2_DEBUG_CAPTURE_END_FLAGS_DISABLE_GX2FLUSH: GX2DebugCaptureEndFlags = 1;
pub type GX2DebugCaptureEndFlags = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2DebugCaptureInterface {
    pub version: u32,
    pub onShutdown: ::core::option::Option<unsafe extern "C" fn()>,
    pub setAllocator: ::core::option::Option<unsafe extern "C" fn()>,
    pub onCaptureStart:
        ::core::option::Option<unsafe extern "C" fn(filename: *const ::core::ffi::c_char)>,
    pub onCaptureEnd: ::core::option::Option<unsafe extern "C" fn()>,
    pub isCaptureEnabled: ::core::option::Option<unsafe extern "C" fn() -> BOOL>,
    pub onAlloc: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32, align: u32),
    >,
    pub onFree: ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>,
    pub onUnknownMemory:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32)>,
    pub setOutputSurface: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub onSwapScanBuffers: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub submitToRing: ::core::option::Option<
        unsafe extern "C" fn(
            unk1: *mut ::core::ffi::c_void,
            unk2: u32,
            unk3: *mut u32,
            outSubmitTimestamp: *mut u64,
        ),
    >,
}
extern "C" {
    pub fn _GX2DebugSetCaptureInterface(interface: *mut GX2DebugCaptureInterface) -> BOOL;
}
extern "C" {
    pub fn GX2DebugCaptureStart(
        filename: *const ::core::ffi::c_char,
        flags: GX2DebugCaptureStartFlags,
    );
}
extern "C" {
    pub fn GX2DebugCaptureEnd(flags: GX2DebugCaptureEndFlags);
}
extern "C" {
    pub fn GX2DebugCaptureFrame(filename: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn GX2DebugCaptureFrames(filename: *const ::core::ffi::c_char, count: u32);
}
extern "C" {
    pub fn GX2SetAttribBuffer(
        index: u32,
        size: u32,
        stride: u32,
        buffer: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2DrawEx(mode: GX2PrimitiveMode, count: u32, offset: u32, numInstances: u32);
}
extern "C" {
    pub fn GX2DrawEx2(
        mode: GX2PrimitiveMode,
        count: u32,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx(
        mode: GX2PrimitiveMode,
        count: u32,
        indexType: GX2IndexType,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx2(
        mode: GX2PrimitiveMode,
        count: u32,
        indexType: GX2IndexType,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedImmediateEx(
        mode: GX2PrimitiveMode,
        count: u32,
        indexType: GX2IndexType,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2SetPrimitiveRestartIndex(index: u32);
}
extern "C" {
    pub fn GX2BeginDisplayListEx(displayList: *mut ::core::ffi::c_void, bytes: u32, unk1: BOOL);
}
extern "C" {
    pub fn GX2EndDisplayList(displayList: *mut ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GX2DirectCallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2CallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2GetDisplayListWriteStatus() -> BOOL;
}
extern "C" {
    pub fn GX2GetCurrentDisplayList(
        outDisplayList: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2CopyDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
pub const GX2_SQ_SEL_X: GX2_SQ_SEL = 0;
pub const GX2_SQ_SEL_Y: GX2_SQ_SEL = 1;
pub const GX2_SQ_SEL_Z: GX2_SQ_SEL = 2;
pub const GX2_SQ_SEL_W: GX2_SQ_SEL = 3;
pub const GX2_SQ_SEL_R: GX2_SQ_SEL = 0;
pub const GX2_SQ_SEL_G: GX2_SQ_SEL = 1;
pub const GX2_SQ_SEL_B: GX2_SQ_SEL = 2;
pub const GX2_SQ_SEL_A: GX2_SQ_SEL = 3;
pub const GX2_SQ_SEL_0: GX2_SQ_SEL = 4;
pub const GX2_SQ_SEL_1: GX2_SQ_SEL = 5;
pub const GX2_SQ_SEL_MASK: GX2_SQ_SEL = 7;
pub type GX2_SQ_SEL = ::core::ffi::c_uint;
pub type GX2EventCallbackFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2EventType, arg2: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DisplayListOverrunData {
    pub oldList: *mut ::core::ffi::c_void,
    pub oldSize: u32,
    pub newList: *mut ::core::ffi::c_void,
    pub newSize: u32,
    pub __unk41: [::core::ffi::c_char; 8usize],
}
impl Default for GX2DisplayListOverrunData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn GX2DrawDone() -> BOOL;
}
extern "C" {
    pub fn GX2WaitForVsync();
}
extern "C" {
    pub fn GX2WaitForFlip();
}
extern "C" {
    pub fn GX2SetEventCallback(
        type_: GX2EventType,
        func: GX2EventCallbackFunction,
        userData: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2GetEventCallback(
        type_: GX2EventType,
        funcOut: *mut GX2EventCallbackFunction,
        userDataOut: *mut *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2GetRetiredTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetLastSubmittedTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetSwapStatus(
        swapCount: *mut u32,
        flipCount: *mut u32,
        lastFlip: *mut OSTime,
        lastVsync: *mut OSTime,
    );
}
extern "C" {
    pub fn GX2WaitTimeStamp(time: OSTime) -> BOOL;
}
extern "C" {
    pub fn GX2Invalidate(mode: GX2InvalidateMode, buffer: *mut ::core::ffi::c_void, size: u32);
}
pub type GX2ApertureHandle = u32;
extern "C" {
    pub fn GX2AllocateTilingApertureEx(
        surface: *mut GX2Surface,
        level: u32,
        depth: u32,
        endian: GX2EndianSwapMode,
        outHandle: *mut GX2ApertureHandle,
        outAddress: *mut *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2FreeTilingAperture(handle: GX2ApertureHandle);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AAMaskReg {
    pub pa_sc_aa_mask: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AlphaTestReg {
    pub sx_alpha_test_control: u32,
    pub sx_alpha_ref: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AlphaToMaskReg {
    pub db_alpha_to_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendControlReg {
    pub target: GX2RenderTarget,
    pub cb_blend_control: u32,
}
impl Default for GX2BlendControlReg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2BlendConstantColorReg {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ColorControlReg {
    pub cb_color_control: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2DepthStencilControlReg {
    pub db_depth_control: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2StencilMaskReg {
    pub db_stencilrefmask: u32,
    pub db_stencilrefmask_bf: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2LineWidthReg {
    pub pa_su_line_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PointSizeReg {
    pub pa_su_point_size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PointLimitsReg {
    pub pa_su_point_minmax: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PolygonControlReg {
    pub pa_su_sc_mode_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PolygonOffsetReg {
    pub pa_su_poly_offset_front_scale: u32,
    pub pa_su_poly_offset_front_offset: u32,
    pub pa_su_poly_offset_back_scale: u32,
    pub pa_su_poly_offset_back_offset: u32,
    pub pa_su_poly_offset_clamp: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ScissorReg {
    pub pa_sc_generic_scissor_tl: u32,
    pub pa_sc_generic_scissor_br: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2TargetChannelMaskReg {
    pub cb_target_mask: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ViewportReg {
    pub pa_cl_vport_xscale: u32,
    pub pa_cl_vport_xoffset: u32,
    pub pa_cl_vport_yscale: u32,
    pub pa_cl_vport_yoffset: u32,
    pub pa_cl_vport_zscale: u32,
    pub pa_cl_vport_zoffset: u32,
    pub pa_cl_gb_vert_clip_adj: u32,
    pub pa_cl_gb_vert_disc_adj: u32,
    pub pa_cl_gb_horz_clip_adj: u32,
    pub pa_cl_gb_horz_disc_adj: u32,
    pub pa_sc_vport_zmin: u32,
    pub pa_sc_vport_zmax: u32,
}
extern "C" {
    pub fn GX2SetAAMask(upperLeft: u8, upperRight: u8, lowerLeft: u8, lowerRight: u8);
}
extern "C" {
    pub fn GX2InitAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: u8,
        upperRight: u8,
        lowerLeft: u8,
        lowerRight: u8,
    );
}
extern "C" {
    pub fn GX2GetAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: *mut u8,
        upperRight: *mut u8,
        lowerLeft: *mut u8,
        lowerRight: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetAAMaskReg(reg: *const GX2AAMaskReg);
}
extern "C" {
    pub fn GX2SetAlphaTest(alphaTest: BOOL, func: GX2CompareFunction, ref_: f32);
}
extern "C" {
    pub fn GX2InitAlphaTestReg(
        reg: *mut GX2AlphaTestReg,
        alphaTest: BOOL,
        func: GX2CompareFunction,
        ref_: f32,
    );
}
extern "C" {
    pub fn GX2GetAlphaTestReg(
        reg: *const GX2AlphaTestReg,
        alphaTest: *mut BOOL,
        func: *mut GX2CompareFunction,
        ref_: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetAlphaTestReg(reg: *const GX2AlphaTestReg);
}
extern "C" {
    pub fn GX2SetAlphaToMask(alphaToMask: BOOL, mode: GX2AlphaToMaskMode);
}
extern "C" {
    pub fn GX2InitAlphaToMaskReg(
        reg: *mut GX2AlphaToMaskReg,
        alphaToMask: BOOL,
        mode: GX2AlphaToMaskMode,
    );
}
extern "C" {
    pub fn GX2GetAlphaToMaskReg(
        reg: *const GX2AlphaToMaskReg,
        alphaToMask: *mut BOOL,
        mode: *mut GX2AlphaToMaskMode,
    );
}
extern "C" {
    pub fn GX2SetAlphaToMaskReg(reg: *const GX2AlphaToMaskReg);
}
extern "C" {
    pub fn GX2SetBlendConstantColor(red: f32, green: f32, blue: f32, alpha: f32);
}
extern "C" {
    pub fn GX2InitBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2GetBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: *mut f32,
        green: *mut f32,
        blue: *mut f32,
        alpha: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetBlendConstantColorReg(reg: *const GX2BlendConstantColorReg);
}
extern "C" {
    pub fn GX2SetBlendControl(
        target: GX2RenderTarget,
        colorSrcBlend: GX2BlendMode,
        colorDstBlend: GX2BlendMode,
        colorCombine: GX2BlendCombineMode,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode,
        alphaDstBlend: GX2BlendMode,
        alphaCombine: GX2BlendCombineMode,
    );
}
extern "C" {
    pub fn GX2InitBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: GX2RenderTarget,
        colorSrcBlend: GX2BlendMode,
        colorDstBlend: GX2BlendMode,
        colorCombine: GX2BlendCombineMode,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode,
        alphaDstBlend: GX2BlendMode,
        alphaCombine: GX2BlendCombineMode,
    );
}
extern "C" {
    pub fn GX2GetBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: *mut GX2RenderTarget,
        colorSrcBlend: *mut GX2BlendMode,
        colorDstBlend: *mut GX2BlendMode,
        colorCombine: *mut GX2BlendCombineMode,
        useAlphaBlend: *mut BOOL,
        alphaSrcBlend: *mut GX2BlendMode,
        alphaDstBlend: *mut GX2BlendMode,
        alphaCombine: *mut GX2BlendCombineMode,
    );
}
extern "C" {
    pub fn GX2SetBlendControlReg(reg: *const GX2BlendControlReg);
}
extern "C" {
    pub fn GX2SetColorControl(
        rop3: GX2LogicOp,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: GX2LogicOp,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: *mut GX2LogicOp,
        targetBlendEnable: *mut u8,
        multiWriteEnable: *mut BOOL,
        colorWriteEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetColorControlReg(reg: *const GX2ColorControlReg);
}
extern "C" {
    pub fn GX2SetDepthOnlyControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction,
        frontStencilZPass: GX2StencilFunction,
        frontStencilZFail: GX2StencilFunction,
        frontStencilFail: GX2StencilFunction,
        backStencilFunc: GX2CompareFunction,
        backStencilZPass: GX2StencilFunction,
        backStencilZFail: GX2StencilFunction,
        backStencilFail: GX2StencilFunction,
    );
}
extern "C" {
    pub fn GX2InitDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction,
        frontStencilZPass: GX2StencilFunction,
        frontStencilZFail: GX2StencilFunction,
        frontStencilFail: GX2StencilFunction,
        backStencilFunc: GX2CompareFunction,
        backStencilZPass: GX2StencilFunction,
        backStencilZFail: GX2StencilFunction,
        backStencilFail: GX2StencilFunction,
    );
}
extern "C" {
    pub fn GX2GetDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: *mut BOOL,
        depthWrite: *mut BOOL,
        depthCompare: *mut GX2CompareFunction,
        stencilTest: *mut BOOL,
        backfaceStencil: *mut BOOL,
        frontStencilFunc: *mut GX2CompareFunction,
        frontStencilZPass: *mut GX2StencilFunction,
        frontStencilZFail: *mut GX2StencilFunction,
        frontStencilFail: *mut GX2StencilFunction,
        backStencilFunc: *mut GX2CompareFunction,
        backStencilZPass: *mut GX2StencilFunction,
        backStencilZFail: *mut GX2StencilFunction,
        backStencilFail: *mut GX2StencilFunction,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControlReg(reg: *const GX2DepthStencilControlReg);
}
extern "C" {
    pub fn GX2SetStencilMask(
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2InitStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2GetStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: *mut u8,
        frontWriteMask: *mut u8,
        frontRef: *mut u8,
        backMask: *mut u8,
        backWriteMask: *mut u8,
        backRef: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetStencilMaskReg(reg: *const GX2StencilMaskReg);
}
extern "C" {
    pub fn GX2SetLineWidth(width: f32);
}
extern "C" {
    pub fn GX2InitLineWidthReg(reg: *mut GX2LineWidthReg, width: f32);
}
extern "C" {
    pub fn GX2GetLineWidthReg(reg: *mut GX2LineWidthReg, width: *mut f32);
}
extern "C" {
    pub fn GX2SetLineWidthReg(reg: *const GX2LineWidthReg);
}
extern "C" {
    pub fn GX2SetPointSize(width: f32, height: f32);
}
extern "C" {
    pub fn GX2InitPointSizeReg(reg: *mut GX2PointSizeReg, width: f32, height: f32);
}
extern "C" {
    pub fn GX2GetPointSizeReg(reg: *mut GX2PointSizeReg, width: *mut f32, height: *mut f32);
}
extern "C" {
    pub fn GX2SetPointSizeReg(reg: *const GX2PointSizeReg);
}
extern "C" {
    pub fn GX2SetPointLimits(min: f32, max: f32);
}
extern "C" {
    pub fn GX2InitPointLimitsReg(reg: *mut GX2PointLimitsReg, min: f32, max: f32);
}
extern "C" {
    pub fn GX2GetPointLimitsReg(reg: *mut GX2PointLimitsReg, min: *mut f32, max: *mut f32);
}
extern "C" {
    pub fn GX2SetPointLimitsReg(reg: *const GX2PointLimitsReg);
}
extern "C" {
    pub fn GX2SetCullOnlyControl(frontFace: GX2FrontFace, cullFront: BOOL, cullBack: BOOL);
}
extern "C" {
    pub fn GX2SetPolygonControl(
        frontFace: GX2FrontFace,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode,
        polyModeBack: GX2PolygonMode,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: GX2FrontFace,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode,
        polyModeBack: GX2PolygonMode,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: *mut GX2FrontFace,
        cullFront: *mut BOOL,
        cullBack: *mut BOOL,
        polyMode: *mut BOOL,
        polyModeFront: *mut GX2PolygonMode,
        polyModeBack: *mut GX2PolygonMode,
        polyOffsetFrontEnable: *mut BOOL,
        polyOffsetBackEnable: *mut BOOL,
        polyOffsetParaEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetPolygonControlReg(reg: *const GX2PolygonControlReg);
}
extern "C" {
    pub fn GX2SetPolygonOffset(
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2InitPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2GetPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: *mut f32,
        frontScale: *mut f32,
        backOffset: *mut f32,
        backScale: *mut f32,
        clamp: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetPolygonOffsetReg(reg: *const GX2PolygonOffsetReg);
}
extern "C" {
    pub fn GX2SetScissor(x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2InitScissorReg(reg: *mut GX2ScissorReg, x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2GetScissorReg(
        reg: *mut GX2ScissorReg,
        x: *mut u32,
        y: *mut u32,
        width: *mut u32,
        height: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetScissorReg(reg: *const GX2ScissorReg);
}
extern "C" {
    pub fn GX2SetTargetChannelMasks(
        mask0: GX2ChannelMask,
        mask1: GX2ChannelMask,
        mask2: GX2ChannelMask,
        mask3: GX2ChannelMask,
        mask4: GX2ChannelMask,
        mask5: GX2ChannelMask,
        mask6: GX2ChannelMask,
        mask7: GX2ChannelMask,
    );
}
extern "C" {
    pub fn GX2InitTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: GX2ChannelMask,
        mask1: GX2ChannelMask,
        mask2: GX2ChannelMask,
        mask3: GX2ChannelMask,
        mask4: GX2ChannelMask,
        mask5: GX2ChannelMask,
        mask6: GX2ChannelMask,
        mask7: GX2ChannelMask,
    );
}
extern "C" {
    pub fn GX2GetTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: *mut GX2ChannelMask,
        mask1: *mut GX2ChannelMask,
        mask2: *mut GX2ChannelMask,
        mask3: *mut GX2ChannelMask,
        mask4: *mut GX2ChannelMask,
        mask5: *mut GX2ChannelMask,
        mask6: *mut GX2ChannelMask,
        mask7: *mut GX2ChannelMask,
    );
}
extern "C" {
    pub fn GX2SetTargetChannelMasksReg(reg: *const GX2TargetChannelMaskReg);
}
extern "C" {
    pub fn GX2SetViewport(x: f32, y: f32, width: f32, height: f32, nearZ: f32, farZ: f32);
}
extern "C" {
    pub fn GX2InitViewportReg(
        reg: *mut GX2ViewportReg,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        nearZ: f32,
        farZ: f32,
    );
}
extern "C" {
    pub fn GX2GetViewportReg(
        reg: *mut GX2ViewportReg,
        x: *mut f32,
        y: *mut f32,
        width: *mut f32,
        height: *mut f32,
        nearZ: *mut f32,
        farZ: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetViewportReg(reg: *const GX2ViewportReg);
}
extern "C" {
    pub fn GX2SetRasterizerClipControl(rasterizer: BOOL, zclipEnable: BOOL);
}
extern "C" {
    pub fn GX2SetRasterizerClipControlEx(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
}
extern "C" {
    pub fn GX2SetRasterizerClipControlHalfZ(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
}
pub type H264DECFptrOutputFn =
    ::core::option::Option<unsafe extern "C" fn(output: *mut H264DecodeOutput)>;
pub const H264_ERROR_OK: H264Error = 0;
pub const H264_ERROR_INVALID_PPS: H264Error = 24;
pub const H264_ERROR_INVALID_SPS: H264Error = 26;
pub const H264_ERROR_INVALID_SLICEHEADER: H264Error = 61;
pub const H264_ERROR_GENERIC: H264Error = 16777216;
pub const H264_ERROR_INVALID_PARAMETER: H264Error = 16842752;
pub const H264_ERROR_OUT_OF_MEMORY: H264Error = 16908288;
pub const H264_ERROR_INVALID_PROFILE: H264Error = 17301504;
pub type H264Error = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct H264DecodedVuiParameters {
    pub aspect_ratio_info_present_flag: u8,
    pub aspect_ratio_idc: u8,
    pub sar_width: i16,
    pub sar_height: i16,
    pub overscan_info_present_flag: u8,
    pub overscan_appropriate_flag: u8,
    pub video_signal_type_present_flag: u8,
    pub video_format: u8,
    pub video_full_range_flag: u8,
    pub colour_description_present_flag: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub chroma_loc_info_present_flag: u8,
    pub chroma_sample_loc_type_top_field: u8,
    pub chroma_sample_loc_type_bottom_field: u8,
    pub timing_info_present_flag: u8,
    pub __unk42: [::core::ffi::c_char; 1usize],
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub fixed_frame_rate_flag: u8,
    pub nal_hrd_parameters_present_flag: u8,
    pub vcl_hrd_parameters_present_flag: u8,
    pub low_delay_hrd_flag: u8,
    pub pic_struct_present_flag: u8,
    pub bitstream_restriction_flag: u8,
    pub motion_vectors_over_pic_boundaries_flag: u8,
    pub __unk43: [::core::ffi::c_char; 1usize],
    pub max_bytes_per_pic_denom: i16,
    pub max_bits_per_mb_denom: i16,
    pub log2_max_mv_length_horizontal: i16,
    pub log2_max_mv_length_vertical: i16,
    pub num_reorder_frames: i16,
    pub max_dec_frame_buffering: i16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeResult {
    pub status: i32,
    pub __unk44: [::core::ffi::c_char; 4usize],
    pub timestamp: f64,
    pub width: i32,
    pub height: i32,
    pub nextLine: i32,
    pub cropEnableFlag: u8,
    pub __unk45: [::core::ffi::c_char; 3usize],
    pub cropTop: i32,
    pub cropBottom: i32,
    pub cropLeft: i32,
    pub cropRight: i32,
    pub panScanEnableFlag: u8,
    pub __unk46: [::core::ffi::c_char; 3usize],
    pub panScanTop: i32,
    pub panScanBottom: i32,
    pub panScanLeft: i32,
    pub panScanRight: i32,
    pub framebuffer: *mut ::core::ffi::c_void,
    pub vui_parameters_present_flag: u8,
    pub __unk47: [::core::ffi::c_char; 3usize],
    pub vui_parameters: *mut H264DecodedVuiParameters,
    pub __unk48: [::core::ffi::c_char; 40usize],
}
impl Default for H264DecodeResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeOutput {
    pub frameCount: i32,
    pub decodeResults: *mut *mut H264DecodeResult,
    pub userMemory: *mut ::core::ffi::c_void,
}
impl Default for H264DecodeOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn H264DECCheckDecunitLength(
        memory: *mut ::core::ffi::c_void,
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outLength: *mut i32,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECCheckSkipableFrame(
        buffer: *const u8,
        bufferLength: i32,
        outSkippable: *mut BOOL,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECFindDecstartpoint(
        buffer: *const u8,
        bufferLength: i32,
        outOffset: *mut i32,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECFindIdrpoint(buffer: *const u8, bufferLength: i32, outOffset: *mut i32) -> i32;
}
extern "C" {
    pub fn H264DECGetImageSize(
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outWidth: *mut i32,
        outHeight: *mut i32,
    ) -> H264Error;
}
pub const H264_PARAMETER_FRAME_POINTER_OUTPUT: H264Parameter = 1;
pub const H264_PARAMETER_OUTPUT_PER_FRAME: H264Parameter = 536870914;
pub const H264_PARAMETER_UNKNOWN_20000010: H264Parameter = 536870928;
pub const H264_PARAMETER_UNKNOWN_20000030: H264Parameter = 536870960;
pub const H264_PARAMETER_UNKNOWN_20000040: H264Parameter = 536870976;
pub const H264_PARAMETER_USER_MEMORY: H264Parameter = 1879048193;
pub type H264Parameter = ::core::ffi::c_uint;
extern "C" {
    pub fn H264DECMemoryRequirement(
        profile: i32,
        level: i32,
        maxWidth: i32,
        maxHeight: i32,
        outMemoryRequirement: *mut u32,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECInitParam(memorySize: i32, memory: *mut ::core::ffi::c_void) -> H264Error;
}
extern "C" {
    pub fn H264DECSetParam(
        memory: *mut ::core::ffi::c_void,
        parameter: H264Parameter,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECSetParam_FPTR_OUTPUT(
        memory: *mut ::core::ffi::c_void,
        value: H264DECFptrOutputFn,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECSetParam_OUTPUT_PER_FRAME(
        memory: *mut ::core::ffi::c_void,
        value: u32,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECSetParam_USER_MEMORY(
        memory: *mut ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECCheckMemSegmentation(memory: *mut ::core::ffi::c_void, size: u32) -> H264Error;
}
extern "C" {
    pub fn H264DECOpen(memory: *mut ::core::ffi::c_void) -> H264Error;
}
extern "C" {
    pub fn H264DECBegin(memory: *mut ::core::ffi::c_void) -> H264Error;
}
extern "C" {
    pub fn H264DECSetBitstream(
        memory: *mut ::core::ffi::c_void,
        buffer: *mut u8,
        bufferLength: u32,
        timestamp: f64,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECExecute(
        memory: *mut ::core::ffi::c_void,
        frameBuffer: *mut ::core::ffi::c_void,
    ) -> H264Error;
}
extern "C" {
    pub fn H264DECFlush(memory: *mut ::core::ffi::c_void) -> H264Error;
}
extern "C" {
    pub fn H264DECEnd(memory: *mut ::core::ffi::c_void) -> H264Error;
}
extern "C" {
    pub fn H264DECClose(memory: *mut ::core::ffi::c_void) -> H264Error;
}
pub const HID_DEVICE_DETACH: HIDAttachEvent = 0;
pub const HID_DEVICE_ATTACH: HIDAttachEvent = 1;
pub type HIDAttachEvent = ::core::ffi::c_uint;
pub type HIDAttachCallback = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut HIDClient,
        device: *mut HIDDevice,
        attach: HIDAttachEvent,
    ) -> i32,
>;
pub type HIDCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: u32,
        error: i32,
        buffer: *mut u8,
        bytesTransferred: u32,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HIDDevice {
    pub handle: u32,
    pub physicalDeviceInst: u32,
    pub vid: u16,
    pub pid: u16,
    pub interfaceIndex: u8,
    pub subClass: u8,
    pub protocol: u8,
    pub __unk49: [::core::ffi::c_char; 1usize],
    pub maxPacketSizeRx: u16,
    pub maxPacketSizeTx: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDClient {
    pub next: *mut HIDClient,
    pub attachCallback: HIDAttachCallback,
}
impl Default for HIDClient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn HIDSetup() -> i32;
}
extern "C" {
    pub fn HIDTeardown() -> i32;
}
extern "C" {
    pub fn HIDAddClient(client: *mut HIDClient, attachCallback: HIDAttachCallback) -> i32;
}
extern "C" {
    pub fn HIDDelClient(client: *mut HIDClient) -> i32;
}
extern "C" {
    pub fn HIDGetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDRead(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDWrite(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        hc: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type OSExceptionCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut OSContext) -> BOOL>;
pub const OS_EXCEPTION_MODE_SYSTEM: OSExceptionMode = 0;
pub const OS_EXCEPTION_MODE_THREAD: OSExceptionMode = 1;
pub const OS_EXCEPTION_MODE_GLOBAL: OSExceptionMode = 2;
pub const OS_EXCEPTION_MODE_THREAD_ALL_CORES: OSExceptionMode = 3;
pub const OS_EXCEPTION_MODE_GLOBAL_ALL_CORES: OSExceptionMode = 4;
pub type OSExceptionMode = ::core::ffi::c_uint;
pub const OS_EXCEPTION_TYPE_SYSTEM_RESET: OSExceptionType = 0;
pub const OS_EXCEPTION_TYPE_MACHINE_CHECK: OSExceptionType = 1;
pub const OS_EXCEPTION_TYPE_DSI: OSExceptionType = 2;
pub const OS_EXCEPTION_TYPE_ISI: OSExceptionType = 3;
pub const OS_EXCEPTION_TYPE_EXTERNAL_INTERRUPT: OSExceptionType = 4;
pub const OS_EXCEPTION_TYPE_ALIGNMENT: OSExceptionType = 5;
pub const OS_EXCEPTION_TYPE_PROGRAM: OSExceptionType = 6;
pub const OS_EXCEPTION_TYPE_FLOATING_POINT: OSExceptionType = 7;
pub const OS_EXCEPTION_TYPE_DECREMENTER: OSExceptionType = 8;
pub const OS_EXCEPTION_TYPE_SYSTEM_CALL: OSExceptionType = 9;
pub const OS_EXCEPTION_TYPE_TRACE: OSExceptionType = 10;
pub const OS_EXCEPTION_TYPE_PERFORMANCE_MONITOR: OSExceptionType = 11;
pub const OS_EXCEPTION_TYPE_BREAKPOINT: OSExceptionType = 12;
pub const OS_EXCEPTION_TYPE_SYSTEM_INTERRUPT: OSExceptionType = 13;
pub const OS_EXCEPTION_TYPE_ICI: OSExceptionType = 14;
pub type OSExceptionType = ::core::ffi::c_uint;
extern "C" {
    pub fn OSSetExceptionCallback(
        exceptionType: OSExceptionType,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
extern "C" {
    pub fn OSSetExceptionCallbackEx(
        mode: OSExceptionMode,
        exceptionType: OSExceptionType,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
pub type OSThreadState = u8;
pub type OSThreadRequest = u32;
pub type OSThreadAttributes = u8;
pub type OSThreadType = u32;
pub type OSThreadEntryPointFn = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
pub type OSThreadCleanupCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub type OSThreadDeallocatorFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub const OS_THREAD_SPECIFIC_0: OSThreadSpecificID = 0;
pub const OS_THREAD_SPECIFIC_1: OSThreadSpecificID = 1;
pub const OS_THREAD_SPECIFIC_2: OSThreadSpecificID = 2;
pub const OS_THREAD_SPECIFIC_3: OSThreadSpecificID = 3;
pub const OS_THREAD_SPECIFIC_4: OSThreadSpecificID = 4;
pub const OS_THREAD_SPECIFIC_5: OSThreadSpecificID = 5;
pub const OS_THREAD_SPECIFIC_6: OSThreadSpecificID = 6;
pub const OS_THREAD_SPECIFIC_7: OSThreadSpecificID = 7;
pub const OS_THREAD_SPECIFIC_8: OSThreadSpecificID = 8;
pub const OS_THREAD_SPECIFIC_9: OSThreadSpecificID = 9;
pub const OS_THREAD_SPECIFIC_10: OSThreadSpecificID = 10;
pub const OS_THREAD_SPECIFIC_11: OSThreadSpecificID = 11;
pub const OS_THREAD_SPECIFIC_12: OSThreadSpecificID = 12;
pub const OS_THREAD_SPECIFIC_13: OSThreadSpecificID = 13;
pub const OS_THREAD_SPECIFIC_WUT_RESERVED_0: OSThreadSpecificID = 14;
pub const OS_THREAD_SPECIFIC_WUT_RESERVED_1: OSThreadSpecificID = 15;
pub type OSThreadSpecificID = ::core::ffi::c_uint;
pub const OS_THREAD_STATE_NONE: OS_THREAD_STATE = 0;
pub const OS_THREAD_STATE_READY: OS_THREAD_STATE = 1;
pub const OS_THREAD_STATE_RUNNING: OS_THREAD_STATE = 2;
pub const OS_THREAD_STATE_WAITING: OS_THREAD_STATE = 4;
pub const OS_THREAD_STATE_MORIBUND: OS_THREAD_STATE = 8;
pub type OS_THREAD_STATE = ::core::ffi::c_uint;
pub const OS_THREAD_REQUEST_NONE: OS_THREAD_REQUEST = 0;
pub const OS_THREAD_REQUEST_SUSPEND: OS_THREAD_REQUEST = 1;
pub const OS_THREAD_REQUEST_CANCEL: OS_THREAD_REQUEST = 2;
pub type OS_THREAD_REQUEST = ::core::ffi::c_uint;
pub const OS_THREAD_ATTRIB_AFFINITY_CPU0: OS_THREAD_ATTRIB = 1;
pub const OS_THREAD_ATTRIB_AFFINITY_CPU1: OS_THREAD_ATTRIB = 2;
pub const OS_THREAD_ATTRIB_AFFINITY_CPU2: OS_THREAD_ATTRIB = 4;
pub const OS_THREAD_ATTRIB_AFFINITY_ANY: OS_THREAD_ATTRIB = 7;
pub const OS_THREAD_ATTRIB_DETACHED: OS_THREAD_ATTRIB = 8;
pub const OS_THREAD_ATTRIB_STACK_USAGE: OS_THREAD_ATTRIB = 32;
pub const OS_THREAD_ATTRIB_UNKNOWN: OS_THREAD_ATTRIB = 128;
pub type OS_THREAD_ATTRIB = ::core::ffi::c_uint;
pub const OS_THREAD_TYPE_DRIVER: OS_THREAD_TYPE = 0;
pub const OS_THREAD_TYPE_IO: OS_THREAD_TYPE = 1;
pub const OS_THREAD_TYPE_APP: OS_THREAD_TYPE = 2;
pub type OS_THREAD_TYPE = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadGHSExceptionHandling {
    pub __unk50: [::core::ffi::c_char; 104usize],
    pub eh_globals: *mut ::core::ffi::c_void,
    pub eh_mem_manage: [*mut ::core::ffi::c_void; 9usize],
    pub eh_store_globals: [*mut ::core::ffi::c_void; 6usize],
    pub eh_store_globals_tdeh: [*mut ::core::ffi::c_void; 76usize],
}
impl Default for OSThreadGHSExceptionHandling {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexQueue {
    pub head: *mut OSMutex,
    pub tail: *mut OSMutex,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk51: [::core::ffi::c_char; 4usize],
}
impl Default for OSMutexQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexQueue {
    pub head: *mut OSFastMutex,
    pub tail: *mut OSFastMutex,
}
impl Default for OSFastMutexQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSTLSSection {
    pub data: *mut ::core::ffi::c_void,
    pub __unk52: [::core::ffi::c_char; 4usize],
}
impl Default for OSTLSSection {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThread {
    pub context: OSContext,
    pub tag: u32,
    pub state: OSThreadState,
    pub attr: OSThreadAttributes,
    pub id: u16,
    pub suspendCounter: i32,
    pub priority: i32,
    pub basePriority: i32,
    pub exitValue: i32,
    pub coreRunQueue: [*mut OSThreadQueue; 3usize],
    pub coreRunQueueLink: [OSThreadLink; 3usize],
    pub queue: *mut OSThreadQueue,
    pub link: OSThreadLink,
    pub joinQueue: OSThreadQueue,
    pub mutex: *mut OSMutex,
    pub mutexQueue: OSMutexQueue,
    pub activeLink: OSThreadLink,
    pub stackStart: *mut ::core::ffi::c_void,
    pub stackEnd: *mut ::core::ffi::c_void,
    pub entryPoint: OSThreadEntryPointFn,
    pub ghsExceptionHandling: OSThreadGHSExceptionHandling,
    pub alarmCancelled: BOOL,
    pub specific: [*mut ::core::ffi::c_void; 16usize],
    pub type_: OSThreadType,
    pub name: *const ::core::ffi::c_char,
    pub waitEventTimeoutAlarm: *mut OSAlarm,
    pub userStackPointer: *mut ::core::ffi::c_void,
    pub cleanupCallback: OSThreadCleanupCallbackFn,
    pub deallocator: OSThreadDeallocatorFn,
    pub cancelState: BOOL,
    pub requestFlag: OSThreadRequest,
    pub needSuspend: i32,
    pub suspendResult: i32,
    pub suspendQueue: OSThreadQueue,
    pub __unk53: [::core::ffi::c_char; 4usize],
    pub runQuantumTicks: i64,
    pub coreTimeConsumedNs: u64,
    pub wakeCount: u64,
    pub unk0x610: OSTime,
    pub unk0x618: OSTime,
    pub unk0x620: OSTime,
    pub unk0x628: OSTime,
    pub dsiCallback: [OSExceptionCallbackFn; 3usize],
    pub isiCallback: [OSExceptionCallbackFn; 3usize],
    pub programCallback: [OSExceptionCallbackFn; 3usize],
    pub perfMonCallback: [OSExceptionCallbackFn; 3usize],
    pub stackSyncObjAllowed: BOOL,
    pub tlsSectionCount: u16,
    pub __unk54: [::core::ffi::c_char; 2usize],
    pub tlsSections: *mut OSTLSSection,
    pub fastMutex: *mut OSFastMutex,
    pub contendedFastMutexes: OSFastMutexQueue,
    pub fastMutexQueue: OSFastMutexQueue,
    pub alignCallback: [OSExceptionCallbackFn; 3usize],
    pub reserved: [u32; 5usize],
}
impl Default for OSThread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSCancelThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSCheckActiveThreads() -> i32;
}
extern "C" {
    pub fn OSCheckThreadStackUsage(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSClearThreadStackUsage(thread: *mut OSThread);
}
extern "C" {
    pub fn OSContinueThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSCreateThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: i32,
        argv: *mut ::core::ffi::c_char,
        stack: *mut ::core::ffi::c_void,
        stackSize: u32,
        priority: i32,
        attributes: OSThreadAttributes,
    ) -> BOOL;
}
extern "C" {
    pub fn OSDetachThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSExitThread(result: i32);
}
extern "C" {
    pub fn OSGetActiveThreadLink(thread: *mut OSThread, link: *mut OSThreadLink);
}
extern "C" {
    pub fn OSGetCurrentThread() -> *mut OSThread;
}
extern "C" {
    pub fn OSGetDefaultThread(coreID: u32) -> *mut OSThread;
}
extern "C" {
    pub fn OSGetStackPointer() -> u32;
}
extern "C" {
    pub fn OSGetThreadAffinity(thread: *mut OSThread) -> u32;
}
extern "C" {
    pub fn OSGetThreadName(thread: *mut OSThread) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn OSGetThreadPriority(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSGetThreadSpecific(id: OSThreadSpecificID) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSIsThreadSuspended(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSIsThreadTerminated(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSJoinThread(thread: *mut OSThread, threadResult: *mut ::core::ffi::c_int) -> BOOL;
}
extern "C" {
    pub fn OSResumeThread(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSRunThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadAffinity(thread: *mut OSThread, affinity: u32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadCancelState(state: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadCleanupCallback(
        thread: *mut OSThread,
        callback: OSThreadCleanupCallbackFn,
    ) -> OSThreadCleanupCallbackFn;
}
extern "C" {
    pub fn OSSetThreadDeallocator(
        thread: *mut OSThread,
        deallocator: OSThreadDeallocatorFn,
    ) -> OSThreadDeallocatorFn;
}
extern "C" {
    pub fn OSSetThreadName(thread: *mut OSThread, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSSetThreadPriority(thread: *mut OSThread, priority: i32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadRunQuantum(thread: *mut OSThread, quantum: u32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadSpecific(id: OSThreadSpecificID, value: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSSetThreadStackUsage(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSSleepThread(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSSleepTicks(ticks: OSTime);
}
extern "C" {
    pub fn OSSuspendThread(thread: *mut OSThread) -> u32;
}
extern "C" {
    pub fn __OSSuspendThreadNolock(thread: *mut OSThread);
}
extern "C" {
    pub fn OSTestThreadCancel();
}
extern "C" {
    pub fn OSWakeupThread(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSYieldThread();
}
pub type CAMHandle = ::core::ffi::c_int;
pub type CAMError = ::core::ffi::c_int;
pub const CAMERA_ERROR_OK: CamError = 0;
pub const CAMERA_ERROR_INVALID_ARG: CamError = -1;
pub const CAMERA_ERROR_INVALID_HANDLE: CamError = -2;
pub const CAMERA_ERROR_TOO_MANY_SURFACES: CamError = -4;
pub const CAMERA_ERROR_INSUFFICIENT_MEMORY: CamError = -5;
pub const CAMERA_ERROR_NOT_READY: CamError = -6;
pub const CAMERA_ERROR_UNINITIALIZED: CamError = -8;
pub const CAMERA_ERROR_UVC: CamError = -9;
pub const CAMERA_ERROR_UVD_CONTEXT: CamError = -10;
pub const CAMERA_ERROR_DEVICE_IN_USE: CamError = -12;
pub const CAMERA_ERROR_UVD_SESSION: CamError = -13;
pub const CAMERA_ERROR_SEGMENT_VIOLATION: CamError = -15;
pub type CamError = ::core::ffi::c_int;
pub const CAMERA_FPS_15: CamFps = 0;
pub const CAMERA_FPS_30: CamFps = 1;
pub type CamFps = ::core::ffi::c_uint;
pub const CAMERA_STREAM_TYPE_1: CamStreamType = 0;
pub type CamStreamType = ::core::ffi::c_uint;
pub const CAMERA_DECODE_DONE: CamEventType = 0;
pub const CAMERA_DRC_DETACH: CamEventType = 1;
pub type CamEventType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CAMEventData {
    pub eventType: CamEventType,
    pub __bindgen_anon_1: CAMEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CAMEventData__bindgen_ty_1 {
    pub decode: CAMEventData__bindgen_ty_1__bindgen_ty_1,
    pub detach: CAMEventData__bindgen_ty_1__bindgen_ty_2,
    pub args: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_1 {
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub handle: CAMHandle,
    pub failed: BOOL,
}
impl Default for CAMEventData__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_2 {
    pub connected: BOOL,
    pub handle: CAMHandle,
}
impl Default for CAMEventData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CAMEventData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CAMEventHandler =
    ::core::option::Option<unsafe extern "C" fn(camEventData: *mut CAMEventData)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMMode {
    pub forceDrc: BOOL,
    pub fps: CamFps,
}
impl Default for CAMMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMWorkMem {
    pub size: u32,
    pub pMem: *mut ::core::ffi::c_void,
}
impl Default for CAMWorkMem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMStreamInfo {
    pub type_: CamStreamType,
    pub height: u32,
    pub width: u32,
}
impl Default for CAMStreamInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSetupInfo {
    pub streamInfo: CAMStreamInfo,
    pub workMem: CAMWorkMem,
    pub eventHandler: CAMEventHandler,
    pub mode: CAMMode,
    pub threadAffinity: u32,
    pub __unk55: [::core::ffi::c_char; 16usize],
}
impl Default for CAMSetupInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSurface {
    pub surfaceSize: i32,
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub height: i32,
    pub width: i32,
    pub pitch: i32,
    pub alignment: i32,
    pub tileMode: i32,
    pub pixelFormat: i32,
}
impl Default for CAMSurface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn CAMInit(
        instance: ::core::ffi::c_int,
        setupInfo: *mut CAMSetupInfo,
        err: *mut CAMError,
    ) -> CAMHandle;
}
extern "C" {
    pub fn CAMExit(handle: CAMHandle);
}
extern "C" {
    pub fn CAMOpen(handle: CAMHandle) -> CAMError;
}
extern "C" {
    pub fn CAMClose(handle: CAMHandle) -> CAMError;
}
extern "C" {
    pub fn CAMGetMemReq(streamInfo: *mut CAMStreamInfo) -> i32;
}
extern "C" {
    pub fn CAMSubmitTargetSurface(handle: CAMHandle, surface: *mut CAMSurface) -> CAMError;
}
extern "C" {
    pub fn CAMCheckMemSegmentation(pMem: *mut ::core::ffi::c_void, size: u32) -> CAMError;
}
pub type ProcUISaveCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type ProcUISaveCallbackEx =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub type ProcUICallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub const PROCUI_CALLBACK_ACQUIRE: ProcUICallbackType = 0;
pub const PROCUI_CALLBACK_RELEASE: ProcUICallbackType = 1;
pub const PROCUI_CALLBACK_EXIT: ProcUICallbackType = 2;
pub const PROCUI_CALLBACK_NET_IO_START: ProcUICallbackType = 3;
pub const PROCUI_CALLBACK_NET_IO_STOP: ProcUICallbackType = 4;
pub const PROCUI_CALLBACK_HOME_BUTTON_DENIED: ProcUICallbackType = 5;
pub type ProcUICallbackType = ::core::ffi::c_uint;
pub const PROCUI_STATUS_IN_FOREGROUND: ProcUIStatus = 0;
pub const PROCUI_STATUS_IN_BACKGROUND: ProcUIStatus = 1;
pub const PROCUI_STATUS_RELEASE_FOREGROUND: ProcUIStatus = 2;
pub const PROCUI_STATUS_EXITING: ProcUIStatus = 3;
pub type ProcUIStatus = ::core::ffi::c_uint;
extern "C" {
    pub fn ProcUIClearCallbacks();
}
extern "C" {
    pub fn ProcUIDrawDoneRelease();
}
extern "C" {
    pub fn ProcUIInForeground() -> BOOL;
}
extern "C" {
    pub fn ProcUIInShutdown() -> BOOL;
}
extern "C" {
    pub fn ProcUIInit(saveCallback: ProcUISaveCallback);
}
extern "C" {
    pub fn ProcUIInitEx(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn ProcUIIsRunning() -> BOOL;
}
extern "C" {
    pub fn ProcUIProcessMessages(block: BOOL) -> ProcUIStatus;
}
extern "C" {
    pub fn ProcUIRegisterCallback(
        type_: ProcUICallbackType,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
    );
}
extern "C" {
    pub fn ProcUIRegisterCallbackCore(
        type_: ProcUICallbackType,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
        core: u32,
    );
}
extern "C" {
    pub fn ProcUIRegisterBackgroundCallback(
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        interval: OSTime,
    );
}
extern "C" {
    pub fn ProcUISetSaveCallback(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn ProcUIShutdown();
}
extern "C" {
    pub fn ProcUISubProcessMessages(block: BOOL) -> ProcUIStatus;
}
extern "C" {
    pub fn ProcUICalcMemorySize(numCallbacks: u32) -> u32;
}
extern "C" {
    pub fn ProcUISetMemoryPool(pool: *mut ::core::ffi::c_void, size: u32) -> i32;
}
extern "C" {
    pub fn ProcUISetCallbackStackSize(size: u32);
}
extern "C" {
    pub fn ProcUISetBucketStorage(buf: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn ProcUISetMEM1Storage(buf: *mut ::core::ffi::c_void, size: u32);
}
pub type CCRCDCDestination = u8;
pub type CCRCDCWpsStatusType = u32;
pub type CCRCDCWakeState = u8;
pub type CCRCDCUicConfigId = u8;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCRegisterCallbackData {
    pub attached: i32,
    pub chan: u32,
    pub __unk56: [::core::ffi::c_char; 6usize],
}
pub type CCRCDCRegisterCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut CCRCDCRegisterCallbackData, arg2: *mut ::core::ffi::c_void),
>;
pub const CCR_CDC_DESTINATION_DRH: CCRCDCDestinationEnum = 1;
pub const CCR_CDC_DESTINATION_DRC0: CCRCDCDestinationEnum = 2;
pub const CCR_CDC_DESTINATION_DRC1: CCRCDCDestinationEnum = 3;
pub type CCRCDCDestinationEnum = ::core::ffi::c_uint;
pub const CCR_CDC_WPS_STATUS_PAIRED: CCRCDCWpsStatusEnum = 0;
pub const CCR_CDC_WPS_STATUS_SEARCHING: CCRCDCWpsStatusEnum = 1;
pub const CCR_CDC_WPS_STATUS_PAIRING: CCRCDCWpsStatusEnum = 2;
pub type CCRCDCWpsStatusEnum = ::core::ffi::c_uint;
pub const CCR_CDC_DRC_STATE_ACTIVE: CCRCDCDrcStateEnum = 0;
pub const CCR_CDC_DRC_STATE_PAIRING: CCRCDCDrcStateEnum = 1;
pub const CCR_CDC_DRC_STATE_FWUPDATE: CCRCDCDrcStateEnum = 2;
pub const CCR_CDC_DRC_STATE_STANDALONE: CCRCDCDrcStateEnum = 3;
pub const CCR_CDC_DRC_STATE_BACKGROUND: CCRCDCDrcStateEnum = 4;
pub const CCR_CDC_DRC_STATE_SLEEP: CCRCDCDrcStateEnum = 5;
pub const CCR_CDC_DRC_STATE_STANDBY: CCRCDCDrcStateEnum = 6;
pub const CCR_CDC_DRC_STATE_WOWLSETTING: CCRCDCDrcStateEnum = 7;
pub const CCR_CDC_DRC_STATE_DKSETTING: CCRCDCDrcStateEnum = 8;
pub const CCR_CDC_DRC_STATE_UNKNOWN9: CCRCDCDrcStateEnum = 9;
pub const CCR_CDC_DRC_STATE_WIIACTIVE: CCRCDCDrcStateEnum = 10;
pub const CCR_CDC_DRC_STATE_LOW_BATTERY: CCRCDCDrcStateEnum = 11;
pub const CCR_CDC_DRC_STATE_SUBACTIVE: CCRCDCDrcStateEnum = 12;
pub type CCRCDCDrcStateEnum = ::core::ffi::c_uint;
pub const CCR_CDC_WAKE_STATE_ACTIVE: CCRCDCWakeStateEnum = 1;
pub const CCR_CDC_WAKE_STATE_BACKGROUND: CCRCDCWakeStateEnum = 2;
pub type CCRCDCWakeStateEnum = ::core::ffi::c_uint;
pub const CCR_CDC_BOARD_VERSION_DK1: CCRCDCBoardVersion = 0;
pub const CCR_CDC_BOARD_VERSION_DK1_EP_DK2: CCRCDCBoardVersion = 1;
pub const CCR_CDC_BOARD_VERSION_DP1: CCRCDCBoardVersion = 2;
pub const CCR_CDC_BOARD_VERSION_DP2: CCRCDCBoardVersion = 3;
pub const CCR_CDC_BOARD_VERSION_DK3: CCRCDCBoardVersion = 4;
pub const CCR_CDC_BOARD_VERSION_DK4: CCRCDCBoardVersion = 5;
pub const CCR_CDC_BOARD_VERSION_PREDP3_DP3: CCRCDCBoardVersion = 6;
pub const CCR_CDC_BOARD_VERSION_DK5: CCRCDCBoardVersion = 7;
pub const CCR_CDC_BOARD_VERSION_DP4: CCRCDCBoardVersion = 8;
pub const CCR_CDC_BOARD_VERSION_DKMP: CCRCDCBoardVersion = 9;
pub const CCR_CDC_BOARD_VERSION_DP5: CCRCDCBoardVersion = 10;
pub const CCR_CDC_BOARD_VERSION_MASS: CCRCDCBoardVersion = 11;
pub const CCR_CDC_BOARD_VERSION_DKMP2: CCRCDCBoardVersion = 12;
pub const CCR_CDC_BOARD_VERSION_DRC_I: CCRCDCBoardVersion = 13;
pub const CCR_CDC_BOARD_VERSION_DKTVMP: CCRCDCBoardVersion = 14;
pub type CCRCDCBoardVersion = ::core::ffi::c_uint;
pub const CCR_CDC_CHIP_VERSION_TS: CCRCDCChipVersion = 16;
pub const CCR_CDC_CHIP_VERSION_ES1: CCRCDCChipVersion = 32;
pub const CCR_CDC_CHIP_VERSION_ES2: CCRCDCChipVersion = 48;
pub const CCR_CDC_CHIP_VERSION_ES3: CCRCDCChipVersion = 64;
pub const CCR_CDC_CHIP_VERSION_MS01: CCRCDCChipVersion = 65;
pub type CCRCDCChipVersion = ::core::ffi::c_uint;
pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_BANK: CCRCDCUicConfigIdEnum = 0;
pub const CCR_CDC_UIC_CONFIG_ID_MIC_CONFIG: CCRCDCUicConfigIdEnum = 2;
pub const CCR_CDC_UIC_CONFIG_ID_ACC_CALIBRATION_VALUE: CCRCDCUicConfigIdEnum = 3;
pub const CCR_CDC_UIC_CONFIG_ID_TP_CALIBRATION_VALUE: CCRCDCUicConfigIdEnum = 5;
pub const CCR_CDC_UIC_CONFIG_ID_UNK7: CCRCDCUicConfigIdEnum = 7;
pub const CCR_CDC_UIC_CONFIG_ID_UNK8: CCRCDCUicConfigIdEnum = 8;
pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_EXT_ID: CCRCDCUicConfigIdEnum = 9;
pub const CCR_CDC_UIC_CONFIG_ID_TV_CONTROL_ID: CCRCDCUicConfigIdEnum = 10;
pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_2: CCRCDCUicConfigIdEnum = 11;
pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_3: CCRCDCUicConfigIdEnum = 12;
pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_4: CCRCDCUicConfigIdEnum = 13;
pub const CCR_CDC_UIC_CONFIG_ID_INIT_BOOT_FLAG: CCRCDCUicConfigIdEnum = 14;
pub const CCR_CDC_UIC_CONFIG_ID_UNK15: CCRCDCUicConfigIdEnum = 15;
pub const CCR_CDC_UIC_CONFIG_ID_LCD_MODE: CCRCDCUicConfigIdEnum = 16;
pub const CCR_CDC_UIC_CONFIG_ID_RC_DATABASE_EXT_ID: CCRCDCUicConfigIdEnum = 17;
pub const CCR_CDC_UIC_CONFIG_ID_UNK18: CCRCDCUicConfigIdEnum = 18;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_ENABLE_FLAG: CCRCDCUicConfigIdEnum = 19;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_INITIAL_BOOT_FLAG: CCRCDCUicConfigIdEnum = 20;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_CAFFEINE_SLOT: CCRCDCUicConfigIdEnum = 21;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_SOUND_MODE: CCRCDCUicConfigIdEnum = 22;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_INFO: CCRCDCUicConfigIdEnum = 23;
pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_READ_COUNT: CCRCDCUicConfigIdEnum = 24;
pub type CCRCDCUicConfigIdEnum = ::core::ffi::c_uint;
pub const CCR_CDC_EXT_LANGUAGE: CCRCDCExt = 0;
pub const CCR_CDC_EXT_RC_DATABASE: CCRCDCExt = 1;
pub const CCR_CDC_EXT_UNK2: CCRCDCExt = 2;
pub const CCR_CDC_EXT_UNK3: CCRCDCExt = 3;
pub const CCR_CDC_EXT_UNK4: CCRCDCExt = 4;
pub type CCRCDCExt = ::core::ffi::c_uint;
pub const CCR_CDC_SYS_DRH_STATE_NORADIO: CCRCDCDrhStateEnum = 0;
pub const CCR_CDC_SYS_DRH_STATE_WII: CCRCDCDrhStateEnum = 1;
pub const CCR_CDC_SYS_DRH_STATE_UNK2: CCRCDCDrhStateEnum = 2;
pub const CCR_CDC_SYS_DRH_STATE_NODRC: CCRCDCDrhStateEnum = 3;
pub const CCR_CDC_SYS_DRH_STATE_ECO: CCRCDCDrhStateEnum = 4;
pub const CCR_CDC_SYS_DRH_STATE_UNK7F: CCRCDCDrhStateEnum = 127;
pub const CCR_CDC_SYS_DRH_STATE_CAFE: CCRCDCDrhStateEnum = 255;
pub type CCRCDCDrhStateEnum = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCMacAddress {
    pub device: CCRCDCDestination,
    pub address: [u8; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCWpsArgs {
    pub hasArgs: u8,
    pub pin: [::core::ffi::c_char; 8usize],
    pub timeout: u16,
    pub pairDestination: CCRCDCDestination,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCSysMessage {
    pub message: u16,
    pub timeout: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCSysInfo {
    pub boardVersion: CCRCDCBoardVersion,
    pub chipVersion: CCRCDCChipVersion,
    pub lvcVersion: u32,
    pub umiVersion: u32,
    pub unknown: u32,
    pub sdCis: u32,
    pub splId: u32,
}
impl Default for CCRCDCSysInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCEepromData {
    pub version: u32,
    pub data: [u8; 768usize],
}
impl Default for CCRCDCEepromData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCWowlWakeDrcArg {
    pub __unk57: [::core::ffi::c_char; 6usize],
    pub state: CCRCDCWakeState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCUicConfig {
    pub configId: CCRCDCUicConfigId,
    pub size: u8,
    pub data: [u8; 256usize],
}
impl Default for CCRCDCUicConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCFWInfo {
    pub imageSize: u32,
    pub blockSize: u32,
    pub imageVersion: u32,
    pub sequencePerSession: u32,
    pub updateProgress: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCSoftwareVersion {
    pub runningVersion: u32,
    pub activeVersion: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCDrcState {
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCDrhState {
    pub state: u8,
}
extern "C" {
    pub fn CCRCDCCommand(
        unk: u8,
        fragment: u8,
        dest: CCRCDCDestination,
        flags0: u8,
        flags1: u8,
        service: u8,
        method: u8,
        payload: *mut ::core::ffi::c_void,
        payloadSize: u32,
        reply: *mut ::core::ffi::c_void,
        replySize: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCDevicePing(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSetStationId(id: *mut CCRCDCMacAddress) -> i32;
}
extern "C" {
    pub fn CCRCDCGetMacAddress(dest: CCRCDCDestination, mac: *mut CCRCDCMacAddress) -> i32;
}
extern "C" {
    pub fn CCRCDCGetMultiDrc(numDrcs: *mut u8) -> i32;
}
extern "C" {
    pub fn CCRCDCSetMultiDrc(numDrcs: u8) -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysSetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetDrhState(state: *mut CCRCDCDrhState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysSetDrhState(state: *mut CCRCDCDrhState) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStart() -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStartEx(args: *mut CCRCDCWpsArgs) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStatus(status: *mut CCRCDCWpsStatusType) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStop() -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetInfo(dest: CCRCDCDestination, info: *mut CCRCDCSysInfo) -> i32;
}
extern "C" {
    pub fn CCRCDCSysDrcDisplayMessage(
        dest: CCRCDCDestination,
        message: *mut CCRCDCSysMessage,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCPerGetUicEeprom(dest: CCRCDCDestination, eeprom: *mut CCRCDCEepromData) -> i32;
}
extern "C" {
    pub fn CCRCDCPerGetUicEepromEx(
        dest: CCRCDCDestination,
        eeprom: *mut CCRCDCEepromData,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSysConsoleShutdownInd(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCWowlWakeDrc(arg: *mut CCRCDCWowlWakeDrcArg) -> i32;
}
extern "C" {
    pub fn CCRCDCPerClearUicConfig(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCPerSetUicConfig(dest: CCRCDCDestination, config: *mut CCRCDCUicConfig) -> i32;
}
extern "C" {
    pub fn CCRCDCCalcCRC16(data: *mut ::core::ffi::c_void, dataSize: u32) -> u16;
}
extern "C" {
    pub fn CCRCDCGetFWInfo(dest: CCRCDCDestination, outInfo: *mut CCRCDCFWInfo) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareGetVersion(
        dest: CCRCDCDestination,
        outVersion: *mut CCRCDCSoftwareVersion,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareAbort(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareActivate(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareLangUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        outVersion: *mut u32,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareLangActivate(
        dest: CCRCDCDestination,
        version: u32,
        outActivationResult: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareGetExtId(dest: CCRCDCDestination, ext: CCRCDCExt, outId: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareExtUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        imageSize: u32,
        extId: u32,
        ext: CCRCDCExt,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterAOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterCFGAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterHIDAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterSYSAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterUACAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterUVCAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterVOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type CCRCDCIrdaCommand = u8;
pub type CCRCDCIrdaBitrate = u8;
pub type CCRCDCIrdaConnectionType = u8;
pub const CCR_IRDA_COMMAND_CONNECT: CCRCDCIrdaCommandEnum = 0;
pub const CCR_IRDA_COMMAND_SEND: CCRCDCIrdaCommandEnum = 1;
pub const CCR_IRDA_COMMAND_RECEIVE: CCRCDCIrdaCommandEnum = 2;
pub const CCR_IRDA_COMMAND_DISCONNECT: CCRCDCIrdaCommandEnum = 3;
pub type CCRCDCIrdaCommandEnum = ::core::ffi::c_uint;
pub const CCR_IRDA_BITRATE_115200: CCRCDCIrdaBitrateEnum = 0;
pub const CCR_IRDA_BITRATE_96000: CCRCDCIrdaBitrateEnum = 1;
pub const CCR_IRDA_BITRATE_72000: CCRCDCIrdaBitrateEnum = 2;
pub const CCR_IRDA_BITRATE_57600: CCRCDCIrdaBitrateEnum = 3;
pub const CCR_IRDA_BITRATE_48000: CCRCDCIrdaBitrateEnum = 4;
pub const CCR_IRDA_BITRATE_38400: CCRCDCIrdaBitrateEnum = 5;
pub const CCR_IRDA_BITRATE_36000: CCRCDCIrdaBitrateEnum = 6;
pub const CCR_IRDA_BITRATE_24000: CCRCDCIrdaBitrateEnum = 7;
pub const CCR_IRDA_BITRATE_19200: CCRCDCIrdaBitrateEnum = 8;
pub const CCR_IRDA_BITRATE_18000: CCRCDCIrdaBitrateEnum = 9;
pub const CCR_IRDA_BITRATE_12000: CCRCDCIrdaBitrateEnum = 10;
pub const CCR_IRDA_BITRATE_9600: CCRCDCIrdaBitrateEnum = 11;
pub const CCR_IRDA_BITRATE_7200: CCRCDCIrdaBitrateEnum = 13;
pub const CCR_IRDA_BITRATE_6000: CCRCDCIrdaBitrateEnum = 13;
pub const CCR_IRDA_BITRATE_4800: CCRCDCIrdaBitrateEnum = 14;
pub const CCR_IRDA_BITRATE_3000: CCRCDCIrdaBitrateEnum = 15;
pub type CCRCDCIrdaBitrateEnum = ::core::ffi::c_uint;
pub const CCR_IRDA_CONNECTION_WAIT: CCRCDCIrdaConnectionTypeEnum = 0;
pub const CCR_IRDA_CONNECTION_REQUIRE: CCRCDCIrdaConnectionTypeEnum = 1;
pub const CCR_IRDA_CONNECTION_ANY: CCRCDCIrdaConnectionTypeEnum = 2;
pub type CCRCDCIrdaConnectionTypeEnum = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaConnectRequest {
    pub command: CCRCDCIrdaCommand,
    pub timeout: u16,
    pub bitrate: CCRCDCIrdaBitrate,
    pub receiveSize: u16,
    pub targetId: u8,
    pub type_: CCRCDCIrdaConnectionType,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaConnectReply {
    pub result: u8,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaSendRequest {
    pub command: CCRCDCIrdaCommand,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
impl Default for CCRCDCIrdaSendRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaSendReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaReceiveRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaReceiveReply {
    pub result: u8,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
impl Default for CCRCDCIrdaReceiveReply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaSmallPacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaSmallPacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let dataSize: u8 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaLargePacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaLargePacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let dataSize: u16 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn CCRCDCPerIrdaControl(
        dest: CCRCDCDestination,
        request: *mut ::core::ffi::c_void,
        requestSize: u32,
        response: *mut ::core::ffi::c_void,
        responseSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCConnect(
        drcIndex: i32,
        result: *mut u8,
        timeout: u16,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        targetId: u8,
        type_: CCRCDCIrdaConnectionType,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCSend(
        drcIndex: i32,
        result: *mut u8,
        size: u32,
        receiveSize: u32,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCReceive(
        drcIndex: i32,
        result: *mut u8,
        receivedSize: *mut u16,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCDisconnect(drcIndex: i32, result: *mut u8) -> i32;
}
pub const IRC_RESULT_SUCCESS: IRCResult = 0;
pub const IRC_RESULT_INVALID_RECEIVE_SIZE: IRCResult = 3;
pub const IRC_RESULT_INVALID_PACKET: IRCResult = 5;
pub const IRC_RESULT_NO_DATA: IRCResult = 6;
pub const IRC_RESULT_ALREADY_CONNECTED: IRCResult = 11;
pub const IRC_IR_UNAVAILABLE: IRCResult = 12;
pub const IRC_RESULT_UNINITIALIZED: IRCResult = 13;
pub const IRC_RESULT_NOT_CONNECTED: IRCResult = 13;
pub const IRC_RESULT_CONNECT_FAILED: IRCResult = 15;
pub const IRC_RESULT_RECEIVE_FAILED: IRCResult = 16;
pub const IRC_RESULT_SEND_FAILED: IRCResult = 17;
pub const IRC_RESULT_DISCONNECT_FAILED: IRCResult = 18;
pub type IRCResult = ::core::ffi::c_uint;
pub type IRCConnectCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type IRCReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void, size: u16, result: IRCResult),
>;
extern "C" {
    pub fn IRCInit(channel: VPADChan, targetId: u8) -> BOOL;
}
extern "C" {
    pub fn IRCConnect(
        channel: VPADChan,
        timeout: u16,
        type_: CCRCDCIrdaConnectionType,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        callback: IRCConnectCallback,
    ) -> IRCResult;
}
extern "C" {
    pub fn IRCProc(channel: VPADChan) -> IRCResult;
}
extern "C" {
    pub fn IRCSend(
        channel: VPADChan,
        data: *mut ::core::ffi::c_void,
        dataSize: u32,
        receiveSize: u32,
    ) -> IRCResult;
}
extern "C" {
    pub fn IRCIsConnect(channel: VPADChan) -> BOOL;
}
extern "C" {
    pub fn IRCDisconnect(channel: VPADChan) -> IRCResult;
}
extern "C" {
    pub fn IRCSetReceiveCallback(
        channel: VPADChan,
        receiveCallback: IRCReceiveCallback,
    ) -> IRCReceiveCallback;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KBDAttachEvent {
    pub channel: u8,
    pub __unk58: [::core::ffi::c_char; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KBDKeyEvent {
    pub channel: u8,
    pub hidCode: u8,
    pub __unk59: [::core::ffi::c_char; 2usize],
    pub isPressedDown: BOOL,
    pub __unk60: [::core::ffi::c_char; 4usize],
    pub asUTF16Character: u16,
    pub __unk61: [::core::ffi::c_char; 2usize],
}
pub type KDBAttachCallback =
    ::core::option::Option<unsafe extern "C" fn(channel: *mut KBDAttachEvent)>;
pub type KDBKeyCallback = ::core::option::Option<unsafe extern "C" fn(event: *mut KBDKeyEvent)>;
pub const KDB_COUNTRY_UNKNOWN_0: KDBCountry = 0;
pub const KDB_COUNTRY_UNKNOWN_1: KDBCountry = 1;
pub const KDB_COUNTRY_UNKNOWN_2: KDBCountry = 2;
pub const KDB_COUNTRY_UNKNOWN_3: KDBCountry = 3;
pub const KDB_COUNTRY_UNKNOWN_4: KDBCountry = 4;
pub const KDB_COUNTRY_UNKNOWN_5: KDBCountry = 5;
pub const KDB_COUNTRY_UNKNOWN_6: KDBCountry = 6;
pub const KDB_COUNTRY_UNKNOWN_7: KDBCountry = 7;
pub const KDB_COUNTRY_UNKNOWN_8: KDBCountry = 8;
pub const KDB_COUNTRY_UNKNOWN_9: KDBCountry = 9;
pub const KDB_COUNTRY_UNKNOWN_10: KDBCountry = 10;
pub const KDB_COUNTRY_UNKNOWN_11: KDBCountry = 11;
pub const KDB_COUNTRY_UNKNOWN_12: KDBCountry = 12;
pub const KDB_COUNTRY_UNKNOWN_13: KDBCountry = 13;
pub const KDB_COUNTRY_UNKNOWN_14: KDBCountry = 14;
pub const KDB_COUNTRY_UNKNOWN_15: KDBCountry = 15;
pub const KDB_COUNTRY_UNKNOWN_16: KDBCountry = 16;
pub const KDB_COUNTRY_UNKNOWN_17: KDBCountry = 17;
pub const KDB_COUNTRY_UNKNOWN_18: KDBCountry = 18;
pub type KDBCountry = ::core::ffi::c_uint;
pub const KDB_ERROR_NONE: KDBError = 0;
pub const KDB_ERROR_NOT_INITIALIZED: KDBError = 2;
pub const KDB_ERROR_ALREADY_INITIALIZED: KDBError = 3;
pub const KDB_ERROR_INVALID_COUNTRY: KDBError = 4;
pub type KDBError = ::core::ffi::c_uint;
extern "C" {
    pub fn KBDInit(
        unused: u32,
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError;
}
extern "C" {
    pub fn KBDSetup(
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError;
}
extern "C" {
    pub fn KBDTeardown() -> KDBError;
}
extern "C" {
    pub fn KBDSetCountry(channel: u8, country: KDBCountry) -> KDBError;
}
pub type nfds_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pollfd {
    pub fd: ::core::ffi::c_int,
    pub events: ::core::ffi::c_int,
    pub revents: ::core::ffi::c_int,
}
extern "C" {
    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type DMAETimeStamp = u64;
extern "C" {
    pub fn DMAEWaitDone(timestamp: DMAETimeStamp) -> BOOL;
}
pub const DMAE_SWAP_NONE: DMAESwapMode = 0;
pub const DMAE_SWAP_16: DMAESwapMode = 1;
pub const DMAE_SWAP_32: DMAESwapMode = 2;
pub const DMAE_SWAP_64: DMAESwapMode = 3;
pub type DMAESwapMode = ::core::ffi::c_uint;
extern "C" {
    pub fn DMAECopyMem(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        wordCount: u32,
        swap: DMAESwapMode,
    ) -> DMAETimeStamp;
}
extern "C" {
    pub fn DMAEFillMem(dst: *mut ::core::ffi::c_void, val: u32, wordCount: u32) -> DMAETimeStamp;
}
extern "C" {
    pub fn DMAEFillMemPhys(
        dst: *mut ::core::ffi::c_void,
        val: u32,
        wordCount: u32,
    ) -> DMAETimeStamp;
}
extern "C" {
    pub fn htonl(hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(hostshort: u16) -> u16;
}
extern "C" {
    pub fn ntohl(netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(netshort: u16) -> u16;
}
extern "C" {
    pub fn inet_addr(cp: *const ::core::ffi::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_aton(cp: *const ::core::ffi::c_char, inp: *mut in_addr) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn inet_ntoa(in_: in_addr) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_ntoa_r(in_: in_addr, buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
pub const SOMEMOPT_REQUEST_INIT: SOMemOptRequest = 1;
pub const SOMEMOPT_REQUEST_GET_BYTES_USED: SOMemOptRequest = 2;
pub const SOMEMOPT_REQUEST_WAIT_FOR_INIT: SOMemOptRequest = 3;
pub const SOMEMOPT_REQUEST_CANCEL_WAIT: SOMemOptRequest = 4;
pub type SOMemOptRequest = ::core::ffi::c_uint;
pub const SOMEMOPT_FLAGS_NONE: SOMemOptFlags = 0;
pub const SOMEMOPT_FLAGS_BIG_BUFFERS: SOMemOptFlags = 1;
pub type SOMemOptFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn somemopt(
        request: SOMemOptRequest,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_somemopt(
        request: SOMemOptRequest,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags,
    ) -> ::core::ffi::c_int;
}
pub const FFL_CREATE_ID_FLAG_WII_U: FFLCreateIDFlags = 5;
pub const FFL_CREATE_ID_FLAG_TEMPORARY: FFLCreateIDFlags = 2;
pub const FFL_CREATE_ID_FLAG_NORMAL: FFLCreateIDFlags = 8;
pub type FFLCreateIDFlags = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLCreateID {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub deviceHash: [u8; 6usize],
}
impl Default for FFLCreateID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FFLCreateID {
    #[inline]
    pub fn flags(&self) -> FFLCreateIDFlags {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: FFLCreateIDFlags) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: FFLCreateIDFlags,
        timestamp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataCore {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mii_version: u8,
    pub author_id: u64,
    pub mii_id: FFLCreateID,
    pub unk_0x16: u16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub mii_name: [u16; 10usize],
    pub size: u8,
    pub fatness: u8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hair_type: u8,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 20usize]>,
}
impl Default for FFLiMiiDataCore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FFLiMiiDataCore {
    #[inline]
    pub fn birth_platform(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_birth_platform(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x00_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x00_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn font_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_font_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn region_move(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_move(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x02_b6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x02_b6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copyable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_copyable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        birth_platform: u8,
        unk_0x00_b4: u8,
        unk_0x01_b0: u8,
        unk_0x01_b4: u8,
        font_region: u8,
        region_move: u8,
        unk_0x02_b6: u8,
        copyable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let birth_platform: u8 = unsafe { ::core::mem::transmute(birth_platform) };
            birth_platform as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unk_0x00_b4: u8 = unsafe { ::core::mem::transmute(unk_0x00_b4) };
            unk_0x00_b4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let unk_0x01_b0: u8 = unsafe { ::core::mem::transmute(unk_0x01_b0) };
            unk_0x01_b0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let unk_0x01_b4: u8 = unsafe { ::core::mem::transmute(unk_0x01_b4) };
            unk_0x01_b4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let font_region: u8 = unsafe { ::core::mem::transmute(font_region) };
            font_region as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let region_move: u8 = unsafe { ::core::mem::transmute(region_move) };
            region_move as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unk_0x02_b6: u8 = unsafe { ::core::mem::transmute(unk_0x02_b6) };
            unk_0x02_b6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let copyable: u8 = unsafe { ::core::mem::transmute(copyable) };
            copyable as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn unk_0x18_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x18_b1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_day(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_birth_day(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_month(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_birth_month(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn gender(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gender(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        unk_0x18_b0: u16,
        unk_0x18_b1: u16,
        color: u16,
        birth_day: u16,
        birth_month: u16,
        gender: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk_0x18_b0: u16 = unsafe { ::core::mem::transmute(unk_0x18_b0) };
            unk_0x18_b0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unk_0x18_b1: u16 = unsafe { ::core::mem::transmute(unk_0x18_b1) };
            unk_0x18_b1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let birth_day: u16 = unsafe { ::core::mem::transmute(birth_day) };
            birth_day as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let birth_month: u16 = unsafe { ::core::mem::transmute(birth_month) };
            birth_month as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let gender: u16 = unsafe { ::core::mem::transmute(gender) };
            gender as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn blush_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blush_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_style(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_style(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_face_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn face_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn local_only(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_local_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hair_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hair_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        blush_type: u8,
        face_style: u8,
        face_color: u8,
        face_type: u8,
        local_only: u8,
        hair_mirrored: u8,
        hair_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let blush_type: u8 = unsafe { ::core::mem::transmute(blush_type) };
            blush_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let face_style: u8 = unsafe { ::core::mem::transmute(face_style) };
            face_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let face_color: u8 = unsafe { ::core::mem::transmute(face_color) };
            face_color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let face_type: u8 = unsafe { ::core::mem::transmute(face_type) };
            face_type as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let local_only: u8 = unsafe { ::core::mem::transmute(local_only) };
            local_only as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let hair_mirrored: u8 = unsafe { ::core::mem::transmute(hair_mirrored) };
            hair_mirrored as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let hair_color: u8 = unsafe { ::core::mem::transmute(hair_color) };
            hair_color as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eye_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_eye_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eye_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eye_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(43usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(43usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(48usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(48usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(55usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(55usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(59usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_nose_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(71usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_nose_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(71usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(75usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_nose_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(75usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(80usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(80usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(83usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(83usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(87usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(87usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(90usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(90usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x40(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unk_0x40(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(104usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(104usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(107usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(107usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(112usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(112usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(118usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(118usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(122usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(122usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(125usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_height(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(128usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_glass_height(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(128usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(133usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(133usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(137usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_glass_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(137usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_type(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(140usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(140usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x46_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(144usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x46_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_ypos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(145usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_ypos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(145usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_xpos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(150usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_xpos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(150usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(155usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_mole_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(155usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_enabled(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(159usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mole_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        eye_thickness: u32,
        eye_scale: u32,
        eye_color: u32,
        eye_type: u32,
        eye_height: u32,
        eye_distance: u32,
        eye_rotation: u32,
        eyebrow_thickness: u32,
        eyebrow_scale: u32,
        eyebrow_color: u32,
        eyebrow_type: u32,
        eyebrow_height: u32,
        eyebrow_distance: u32,
        eyebrow_rotation: u32,
        nose_height: u32,
        nose_scale: u32,
        nose_type: u32,
        mouth_thickness: u32,
        mouth_scale: u32,
        mouth_color: u32,
        mouth_type: u32,
        unk_0x40: u32,
        mustache_type: u32,
        mouth_height: u32,
        mustache_height: u32,
        mustache_scale: u32,
        beard_color: u32,
        beard_type: u32,
        glass_height: u16,
        glass_scale: u16,
        glass_color: u16,
        glass_type: u16,
        unk_0x46_b0: u16,
        mole_ypos: u16,
        mole_xpos: u16,
        mole_scale: u16,
        mole_enabled: u16,
    ) -> __BindgenBitfieldUnit<[u8; 20usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 20usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let eye_thickness: u32 = unsafe { ::core::mem::transmute(eye_thickness) };
            eye_thickness as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let eye_scale: u32 = unsafe { ::core::mem::transmute(eye_scale) };
            eye_scale as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let eye_color: u32 = unsafe { ::core::mem::transmute(eye_color) };
            eye_color as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let eye_type: u32 = unsafe { ::core::mem::transmute(eye_type) };
            eye_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let eye_height: u32 = unsafe { ::core::mem::transmute(eye_height) };
            eye_height as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let eye_distance: u32 = unsafe { ::core::mem::transmute(eye_distance) };
            eye_distance as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let eye_rotation: u32 = unsafe { ::core::mem::transmute(eye_rotation) };
            eye_rotation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let eyebrow_thickness: u32 = unsafe { ::core::mem::transmute(eyebrow_thickness) };
            eyebrow_thickness as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let eyebrow_scale: u32 = unsafe { ::core::mem::transmute(eyebrow_scale) };
            eyebrow_scale as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let eyebrow_color: u32 = unsafe { ::core::mem::transmute(eyebrow_color) };
            eyebrow_color as u64
        });
        __bindgen_bitfield_unit.set(43usize, 5u8, {
            let eyebrow_type: u32 = unsafe { ::core::mem::transmute(eyebrow_type) };
            eyebrow_type as u64
        });
        __bindgen_bitfield_unit.set(48usize, 7u8, {
            let eyebrow_height: u32 = unsafe { ::core::mem::transmute(eyebrow_height) };
            eyebrow_height as u64
        });
        __bindgen_bitfield_unit.set(55usize, 4u8, {
            let eyebrow_distance: u32 = unsafe { ::core::mem::transmute(eyebrow_distance) };
            eyebrow_distance as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let eyebrow_rotation: u32 = unsafe { ::core::mem::transmute(eyebrow_rotation) };
            eyebrow_rotation as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let nose_height: u32 = unsafe { ::core::mem::transmute(nose_height) };
            nose_height as u64
        });
        __bindgen_bitfield_unit.set(71usize, 4u8, {
            let nose_scale: u32 = unsafe { ::core::mem::transmute(nose_scale) };
            nose_scale as u64
        });
        __bindgen_bitfield_unit.set(75usize, 5u8, {
            let nose_type: u32 = unsafe { ::core::mem::transmute(nose_type) };
            nose_type as u64
        });
        __bindgen_bitfield_unit.set(80usize, 3u8, {
            let mouth_thickness: u32 = unsafe { ::core::mem::transmute(mouth_thickness) };
            mouth_thickness as u64
        });
        __bindgen_bitfield_unit.set(83usize, 4u8, {
            let mouth_scale: u32 = unsafe { ::core::mem::transmute(mouth_scale) };
            mouth_scale as u64
        });
        __bindgen_bitfield_unit.set(87usize, 3u8, {
            let mouth_color: u32 = unsafe { ::core::mem::transmute(mouth_color) };
            mouth_color as u64
        });
        __bindgen_bitfield_unit.set(90usize, 6u8, {
            let mouth_type: u32 = unsafe { ::core::mem::transmute(mouth_type) };
            mouth_type as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let unk_0x40: u32 = unsafe { ::core::mem::transmute(unk_0x40) };
            unk_0x40 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 3u8, {
            let mustache_type: u32 = unsafe { ::core::mem::transmute(mustache_type) };
            mustache_type as u64
        });
        __bindgen_bitfield_unit.set(107usize, 5u8, {
            let mouth_height: u32 = unsafe { ::core::mem::transmute(mouth_height) };
            mouth_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 6u8, {
            let mustache_height: u32 = unsafe { ::core::mem::transmute(mustache_height) };
            mustache_height as u64
        });
        __bindgen_bitfield_unit.set(118usize, 4u8, {
            let mustache_scale: u32 = unsafe { ::core::mem::transmute(mustache_scale) };
            mustache_scale as u64
        });
        __bindgen_bitfield_unit.set(122usize, 3u8, {
            let beard_color: u32 = unsafe { ::core::mem::transmute(beard_color) };
            beard_color as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let beard_type: u32 = unsafe { ::core::mem::transmute(beard_type) };
            beard_type as u64
        });
        __bindgen_bitfield_unit.set(128usize, 5u8, {
            let glass_height: u16 = unsafe { ::core::mem::transmute(glass_height) };
            glass_height as u64
        });
        __bindgen_bitfield_unit.set(133usize, 4u8, {
            let glass_scale: u16 = unsafe { ::core::mem::transmute(glass_scale) };
            glass_scale as u64
        });
        __bindgen_bitfield_unit.set(137usize, 3u8, {
            let glass_color: u16 = unsafe { ::core::mem::transmute(glass_color) };
            glass_color as u64
        });
        __bindgen_bitfield_unit.set(140usize, 4u8, {
            let glass_type: u16 = unsafe { ::core::mem::transmute(glass_type) };
            glass_type as u64
        });
        __bindgen_bitfield_unit.set(144usize, 1u8, {
            let unk_0x46_b0: u16 = unsafe { ::core::mem::transmute(unk_0x46_b0) };
            unk_0x46_b0 as u64
        });
        __bindgen_bitfield_unit.set(145usize, 5u8, {
            let mole_ypos: u16 = unsafe { ::core::mem::transmute(mole_ypos) };
            mole_ypos as u64
        });
        __bindgen_bitfield_unit.set(150usize, 5u8, {
            let mole_xpos: u16 = unsafe { ::core::mem::transmute(mole_xpos) };
            mole_xpos as u64
        });
        __bindgen_bitfield_unit.set(155usize, 4u8, {
            let mole_scale: u16 = unsafe { ::core::mem::transmute(mole_scale) };
            mole_scale as u64
        });
        __bindgen_bitfield_unit.set(159usize, 1u8, {
            let mole_enabled: u16 = unsafe { ::core::mem::transmute(mole_enabled) };
            mole_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataOfficial {
    pub core: FFLiMiiDataCore,
    pub creator_name: [u16; 10usize],
}
impl Default for FFLiMiiDataOfficial {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLStoreData {
    pub data: FFLiMiiDataOfficial,
    pub unk_0x5C: u16,
    pub checksum: u16,
}
impl Default for FFLStoreData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OS_EVENT_MODE_MANUAL: OSEventMode = 0;
pub const OS_EVENT_MODE_AUTO: OSEventMode = 1;
pub type OSEventMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSEvent {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk62: [::core::ffi::c_char; 4usize],
    pub value: BOOL,
    pub queue: OSThreadQueue,
    pub mode: OSEventMode,
}
impl Default for OSEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitEvent(event: *mut OSEvent, value: BOOL, mode: OSEventMode);
}
extern "C" {
    pub fn OSInitEventEx(
        event: *mut OSEvent,
        value: BOOL,
        mode: OSEventMode,
        name: *mut ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSSignalEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSSignalEventAll(event: *mut OSEvent);
}
extern "C" {
    pub fn OSWaitEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSResetEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSWaitEventWithTimeout(event: *mut OSEvent, timeout: OSTime) -> BOOL;
}
pub type SYSArgID = u32;
pub type SYSArgType = u32;
pub type SYSDeserializeCallback = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut SYSDeserializeArg, userArg: *mut ::core::ffi::c_void),
>;
pub const SYS_ARG_ID_END: SYSArgIDEnum = 0;
pub const SYS_ARG_ID_ANCHOR: SYSArgIDEnum = 100;
pub const SYS_ARG_ID_RESULT: SYSArgIDEnum = 101;
pub const SYS_ARG_ID_URL: SYSArgIDEnum = 200;
pub const SYS_ARG_ID_MIV_DATA: SYSArgIDEnum = 300;
pub const SYS_ARG_ID_JOIN_PID: SYSArgIDEnum = 400;
pub type SYSArgIDEnum = ::core::ffi::c_uint;
pub const SYS_ARG_TYPE_UINT32: SYSArgTypeEnum = 1;
pub const SYS_ARG_TYPE_UINT64: SYSArgTypeEnum = 2;
pub const SYS_ARG_TYPE_DATA: SYSArgTypeEnum = 3;
pub const SYS_ARG_TYPE_STRING: SYSArgTypeEnum = 4;
pub type SYSArgTypeEnum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SYSArgDataBlock {
    pub id: SYSArgID,
    pub type_: SYSArgType,
    pub __bindgen_anon_1: SYSArgDataBlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSArgDataBlock__bindgen_ty_1 {
    pub uint32: u32,
    pub uint64: u64,
    pub data: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1,
    pub string: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2 {
    pub ptr: *const ::core::ffi::c_char,
    pub size: u32,
}
impl Default for SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SYSArgDataBlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SYSArgDataBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SYSCallerInfo {
    pub upid: u32,
    pub __unk63: [::core::ffi::c_char; 4usize],
    pub titleID: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSDeserializeArg {
    pub argName: *const ::core::ffi::c_char,
    pub size: u32,
    pub data: *mut ::core::ffi::c_void,
}
impl Default for SYSDeserializeArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsOut {
    pub data: *const ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SYSStandardArgsOut {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsIn {
    pub argString: *const ::core::ffi::c_char,
    pub size: u32,
}
impl Default for SYSStandardArgsIn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgs {
    pub anchorData: *mut ::core::ffi::c_void,
    pub anchorSize: u32,
    pub resultData: *mut ::core::ffi::c_void,
    pub resultSize: u32,
}
impl Default for SYSStandardArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SYSGetArguments(args: *mut SYSArgDataBlock, callerInfo: *mut SYSCallerInfo) -> i32;
}
extern "C" {
    pub fn SYSGetStandardArgs(stdArgs: *mut SYSStandardArgs) -> i32;
}
extern "C" {
    pub fn SYSClearSysArgs();
}
extern "C" {
    pub fn SYSPackArgs() -> i32;
}
extern "C" {
    pub fn SYSSerializeSysArgs(
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn SYSSerializeSysArgsToBuffer(
        buffer: *mut ::core::ffi::c_char,
        bytesWritten: *mut u32,
        bufferSize: u32,
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        dataSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn SYSDeserializeSysArgs(
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn SYSDeserializeSysArgsFromBlock(
        block: *mut ::core::ffi::c_void,
        blockSize: u32,
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn _SYSDirectlyReturnToCaller(arg: *mut SYSStandardArgsOut) -> i32;
}
extern "C" {
    pub fn _SYSSerializeStandardArgsIn(arg: *mut SYSStandardArgsIn) -> i32;
}
extern "C" {
    pub fn _SYSDeserializeStandardArg(
        deserializeArg: *mut SYSDeserializeArg,
        standardArg: *mut SYSStandardArgs,
    ) -> BOOL;
}
pub const ACP_RESULT_SUCCESS: ACPResult = 0;
pub const ACP_RESULT_INVALID: ACPResult = -200;
pub const ACP_RESULT_INVALID_PARAMETER: ACPResult = -201;
pub const ACP_RESULT_INVALID_FILE: ACPResult = -202;
pub const ACP_RESULT_INVALID_XML_FILE: ACPResult = -203;
pub const ACP_RESULT_FILE_ACCESS_MODE: ACPResult = -204;
pub const ACP_RESULT_INVALID_NETWORK_TIME: ACPResult = -205;
pub const ACP_RESULT_NOT_FOUND: ACPResult = -500;
pub const ACP_RESULT_FILE_NOT_FOUND: ACPResult = -501;
pub const ACP_RESULT_DIR_NOT_FOUND: ACPResult = -502;
pub const ACP_RESULT_DEVICE_NOT_FOUND: ACPResult = -503;
pub const ACP_RESULT_TITLE_NOT_FOUND: ACPResult = -504;
pub const ACP_RESULT_APPLICATION_NOT_FOUND: ACPResult = -505;
pub const ACP_RESULT_SYSTEM_CONFIG_NOT_FOUND: ACPResult = -506;
pub const ACP_RESULT_XML_ITEM_NOT_FOUND: ACPResult = -507;
pub const ACP_RESULT_ALREADY_EXISTS: ACPResult = -600;
pub const ACP_RESULT_FILE_ALREADY_EXISTS: ACPResult = -601;
pub const ACP_RESULT_DIR_ALREADY_EXISTS: ACPResult = -602;
pub const ACP_RESULT_ALREADY_DONE: ACPResult = -700;
pub const ACP_RESULT_AUTHENTICATION: ACPResult = -1000;
pub const ACP_RESULT_INVALID_REGION: ACPResult = -1001;
pub const ACP_RESULT_RESTRICTED_RATING: ACPResult = -1002;
pub const ACP_RESULT_NOT_PRESENT_RATING: ACPResult = -1003;
pub const ACP_RESULT_PENDING_RATING: ACPResult = -1004;
pub const ACP_RESULT_NET_SETTING_REQUIRED: ACPResult = -1005;
pub const ACP_RESULT_NET_ACCOUNT_REQUIRED: ACPResult = -1006;
pub const ACP_RESULT_NET_ACCOUNT_ERROR: ACPResult = -1007;
pub const ACP_RESULT_BROWSER_REQUIRED: ACPResult = -1008;
pub const ACP_RESULT_OLV_REQUIRED: ACPResult = -1009;
pub const ACP_RESULT_PINCODE_REQUIRED: ACPResult = -1010;
pub const ACP_RESULT_INCORRECT_PINCODE: ACPResult = -1011;
pub const ACP_RESULT_INVALID_LOGO: ACPResult = -1012;
pub const ACP_RESULT_DEMO_EXPIRED_NUMBER: ACPResult = -1013;
pub const ACP_RESULT_DRC_REQUIRED: ACPResult = -1014;
pub const ACP_RESULT_NO_PERMISSION: ACPResult = -1100;
pub const ACP_RESULT_NO_FILE_PERMISSION: ACPResult = -1101;
pub const ACP_RESULT_NO_DIR_PERMISSION: ACPResult = -1102;
pub const ACP_RESULT_BUSY: ACPResult = -1300;
pub const ACP_RESULT_USB_STORAGE_NOT_READY: ACPResult = -1301;
pub const ACP_RESULT_CANCELLED: ACPResult = -1400;
pub const ACP_RESULT_RESOURCE: ACPResult = -1500;
pub const ACP_RESULT_DEVICE_FULL: ACPResult = -1501;
pub const ACP_RESULT_JOURNAL_FULL: ACPResult = -1502;
pub const ACP_RESULT_SYSTEM_MEMORY: ACPResult = -1503;
pub const ACP_RESULT_FS_RESOURCE: ACPResult = -1504;
pub const ACP_RESULT_IPC_RESOURCE: ACPResult = -1505;
pub const ACP_RESULT_NOT_INITIALISED: ACPResult = -1600;
pub const ACP_RESULT_ACCOUNT_ERROR: ACPResult = -1700;
pub const ACP_RESULT_UNSUPPORTED: ACPResult = -1800;
pub const ACP_RESULT_DATA_CORRUPTED: ACPResult = -2000;
pub const ACP_RESULT_DEVICE: ACPResult = -2001;
pub const ACP_RESULT_SLC_DATA_CORRUPTED: ACPResult = -2002;
pub const ACP_RESULT_MLC_DATA_CORRUPTED: ACPResult = -2003;
pub const ACP_RESULT_USB_DATA_CORRUPTED: ACPResult = -2004;
pub const ACP_RESULT_MEDIA: ACPResult = -2100;
pub const ACP_RESULT_MEDIA_NOT_READY: ACPResult = -2101;
pub const ACP_RESULT_MEDIA_BROKEN: ACPResult = -2102;
pub const ACP_RESULT_ODD_MEDIA_NOT_READY: ACPResult = -2103;
pub const ACP_RESULT_ODD_MEDIA_BROKEN: ACPResult = -2104;
pub const ACP_RESULT_USB_MEDIA_NOT_READY: ACPResult = -2105;
pub const ACP_RESULT_USB_MEDIA_BROKEN: ACPResult = -2106;
pub const ACP_RESULT_MEDIA_WRITE_PROTECTED: ACPResult = -2107;
pub const ACP_RESULT_USB_WRITE_PROTECTED: ACPResult = -2108;
pub const ACP_RESULT_MII: ACPResult = -2200;
pub const ACP_RESULT_ENCRYPTION_ERROR: ACPResult = -2201;
pub const ACP_RESULT_GENERIC_ERROR: ACPResult = -4096;
pub type ACPResult = ::core::ffi::c_int;
pub const ACP_DEVICE_TYPE_AUTO: ACPDeviceType = 1;
pub const ACP_DEVICE_TYPE_ODD: ACPDeviceType = 2;
pub const ACP_DEVICE_TYPE_HFIODISC: ACPDeviceType = 2;
pub const ACP_DEVICE_TYPE_MLC: ACPDeviceType = 3;
pub const ACP_DEVICE_TYPE_HFIOMLC: ACPDeviceType = 3;
pub const ACP_DEVICE_TYPE_USB: ACPDeviceType = 4;
pub type ACPDeviceType = ::core::ffi::c_uint;
extern "C" {
    pub fn ACPCheckApplicationDeviceEmulation(emulation: *mut BOOL) -> ACPResult;
}
pub type MCPError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDeviceList {
    _unused: [u8; 0],
}
pub const MCP_APP_TYPE_GAME_UPDATE: MCPAppType = 134217755;
pub const MCP_APP_TYPE_GAME_DLC: MCPAppType = 134217742;
pub const MCP_APP_TYPE_BOOT1: MCPAppType = 268435465;
pub const MCP_APP_TYPE_SYSTEM_LIBRARIES: MCPAppType = 268435466;
pub const MCP_APP_TYPE_BLUETOOTH_FIRMWARE: MCPAppType = 268435474;
pub const MCP_APP_TYPE_DRC_FIRMWARE: MCPAppType = 268435475;
pub const MCP_APP_TYPE_DRH_FIRMWARE: MCPAppType = 268435476;
pub const MCP_APP_TYPE_SYSTEM_VERSION: MCPAppType = 268435477;
pub const MCP_APP_TYPE_DRC_LANGUAGE: MCPAppType = 268435482;
pub const MCP_APP_TYPE_EXCEPTIONS_DATA: MCPAppType = 402653200;
pub const MCP_APP_TYPE_SHARED_DATA: MCPAppType = 402653212;
pub const MCP_APP_TYPE_CERT_STORE: MCPAppType = 402653214;
pub const MCP_APP_TYPE_PATCH_MAP_DATA: MCPAppType = 402653219;
pub const MCP_APP_TYPE_WAGONU_MIGRATION_LIST: MCPAppType = 402653225;
pub const MCP_APP_TYPE_CAFFEINE_TITLE_LIST: MCPAppType = 402653232;
pub const MCP_APP_TYPE_MCP_TITLE_LIST: MCPAppType = 402653233;
pub const MCP_APP_TYPE_GAME: MCPAppType = 2147483648;
pub const MCP_APP_TYPE_GAME_WII: MCPAppType = 2147483694;
pub const MCP_APP_TYPE_SYSTEM_MENU: MCPAppType = 2415919105;
pub const MCP_APP_TYPE_SYSTEM_UPDATER: MCPAppType = 2415919115;
pub const MCP_APP_TYPE_SYSTEM_APPS: MCPAppType = 2415919136;
pub const MCP_APP_TYPE_ACCOUNT_APPS: MCPAppType = 2415919137;
pub const MCP_APP_TYPE_SYSTEM_SETTINGS: MCPAppType = 2415919138;
pub const MCP_APP_TYPE_ECO_PROCESS: MCPAppType = 2415919151;
pub const MCP_APP_TYPE_EMANUAL: MCPAppType = 3489660931;
pub const MCP_APP_TYPE_HOME_MENU: MCPAppType = 3489660932;
pub const MCP_APP_TYPE_ERROR_DISPLAY: MCPAppType = 3489660933;
pub const MCP_APP_TYPE_BROWSER: MCPAppType = 3489660934;
pub const MCP_APP_TYPE_MIIVERSE_POST: MCPAppType = 3489660941;
pub const MCP_APP_TYPE_MIIVERSE: MCPAppType = 3489660950;
pub const MCP_APP_TYPE_ESHOP: MCPAppType = 3489660951;
pub const MCP_APP_TYPE_FRIEND_LIST: MCPAppType = 3489660952;
pub const MCP_APP_TYPE_DOWNLOAD_MANAGEMENT: MCPAppType = 3489660953;
pub const MCP_APP_TYPE_AOC_OVERLAY: MCPAppType = 3489660972;
pub const MCP_APP_TYPE_AMIIBO_SETTINGS: MCPAppType = 3489660979;
pub type MCPAppType = ::core::ffi::c_uint;
pub const MCP_DEVICE_TYPE_AUTO: MCPDeviceType = 1;
pub const MCP_DEVICE_TYPE_ODD: MCPDeviceType = 2;
pub const MCP_DEVICE_TYPE_MLC: MCPDeviceType = 3;
pub const MCP_DEVICE_TYPE_USB: MCPDeviceType = 4;
pub type MCPDeviceType = ::core::ffi::c_uint;
pub const MCP_DEVICE_FLAG_UNK_1: MCPDeviceFlags = 1;
pub const MCP_DEVICE_FLAG_UNK_2: MCPDeviceFlags = 2;
pub const MCP_DEVICE_FLAG_UNK_4: MCPDeviceFlags = 4;
pub const MCP_DEVICE_FLAG_UNK_8: MCPDeviceFlags = 8;
pub type MCPDeviceFlags = ::core::ffi::c_uint;
pub const MCP_INSTALL_TARGET_MLC: MCPInstallTarget = 0;
pub const MCP_INSTALL_TARGET_USB: MCPInstallTarget = 1;
pub type MCPInstallTarget = ::core::ffi::c_uint;
pub const MCP_REGION_JAPAN: MCPRegion = 1;
pub const MCP_REGION_USA: MCPRegion = 2;
pub const MCP_REGION_EUROPE: MCPRegion = 4;
pub const MCP_REGION_CHINA: MCPRegion = 16;
pub const MCP_REGION_KOREA: MCPRegion = 32;
pub const MCP_REGION_TAIWAN: MCPRegion = 64;
pub type MCPRegion = ::core::ffi::c_uint;
pub const MCP_COMPAT_AV_FILE_DMCU: MCPCompatAVFile = 0;
pub const MCP_COMPAT_AV_FILE_DEINT: MCPCompatAVFile = 1;
pub type MCPCompatAVFile = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDevice {
    pub type_: [::core::ffi::c_char; 8usize],
    pub unk0x08: [::core::ffi::c_char; 128usize],
    pub filesystem: [::core::ffi::c_char; 8usize],
    pub path: [::core::ffi::c_char; 639usize],
    pub flags: MCPDeviceFlags,
    pub uid: u32,
    pub index: u32,
}
impl Default for MCPDevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallInfo {
    pub __unk64: [::core::ffi::c_char; 639usize],
}
impl Default for MCPInstallInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MCPInstallProgress {
    pub inProgress: u32,
    pub tid: u64,
    pub sizeTotal: u64,
    pub sizeProgress: u64,
    pub contentsTotal: u32,
    pub contentsProgress: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallTitleInfo {
    pub __unk65: [::core::ffi::c_char; 639usize],
}
impl Default for MCPInstallTitleInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPSysProdSettings {
    pub product_area: MCPRegion,
    pub eeprom_version: u16,
    pub __unk66: [::core::ffi::c_char; 2usize],
    pub game_region: MCPRegion,
    pub __unk67: [::core::ffi::c_char; 4usize],
    pub ntsc_pal: [::core::ffi::c_char; 5usize],
    pub wifi_5ghz_country_code: [::core::ffi::c_char; 4usize],
    pub wifi_5ghz_country_code_revision: u8,
    pub code_id: [::core::ffi::c_char; 8usize],
    pub serial_id: [::core::ffi::c_char; 12usize],
    pub __unk68: [::core::ffi::c_char; 4usize],
    pub model_number: [::core::ffi::c_char; 16usize],
    pub version: u32,
}
impl Default for MCPSysProdSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MCPSystemVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub region: ::core::ffi::c_char,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPTitleListType {
    pub titleId: u64,
    pub groupId: u32,
    pub path: [::core::ffi::c_char; 56usize],
    pub appType: MCPAppType,
    pub titleVersion: u16,
    pub osVersion: u64,
    pub sdkVersion: u32,
    pub indexedDevice: [::core::ffi::c_char; 10usize],
    pub unk0x60: u8,
}
impl Default for MCPTitleListType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn MCP_Open() -> MCPError;
}
extern "C" {
    pub fn MCP_Close(handle: ::core::ffi::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_DeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_FullDeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_GetOwnTitleInfo(handle: i32, titleInfo: *mut MCPTitleListType) -> MCPError;
}
extern "C" {
    pub fn MCP_GetSysProdSettings(handle: i32, settings: *mut MCPSysProdSettings) -> MCPError;
}
extern "C" {
    pub fn MCP_GetSystemVersion(handle: i32, systemVersion: *mut MCPSystemVersion) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleId(handle: i32, outTitleId: *mut u64) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleInfo(
        handle: i32,
        titleId: u64,
        titleInfo: *mut MCPTitleListType,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetDevice(
        handle: ::core::ffi::c_int,
        device: MCPInstallTarget,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetTargetDevice(
        handle: ::core::ffi::c_int,
        deviceOut: *mut MCPInstallTarget,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetUsb(handle: ::core::ffi::c_int, usb: ::core::ffi::c_int)
        -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetInfo(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAsync(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetProgress(
        handle: ::core::ffi::c_int,
        installProgressOut: *mut MCPInstallProgress,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAbort(handle: ::core::ffi::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleCount(handle: i32) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleList(
        handle: i32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppType(
        handle: i32,
        appType: MCPAppType,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueId(
        handle: i32,
        uniqueId: u32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByDevice(
        handle: i32,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByDeviceType(
        handle: i32,
        deviceType: MCPDeviceType,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppAndDevice(
        handle: i32,
        appType: MCPAppType,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppAndDeviceType(
        handle: i32,
        appType: MCPAppType,
        deviceType: MCPDeviceType,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueIdAndIndexedDeviceAndAppType(
        handle: i32,
        uniqueId: u32,
        indexedDevice: *const ::core::ffi::c_char,
        unk0x60: u8,
        appType: MCPAppType,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_UninstallTitleAsync(
        handle: i32,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_CompatLoadAVFile(
        handle: i32,
        ptr: *mut ::core::ffi::c_void,
        size: *mut u32,
        file: MCPCompatAVFile,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TriggerCrashLogCollection(handle: i32) -> MCPError;
}
extern "C" {
    pub fn MCP_ChangeEcoSettings(
        handle: i32,
        enable: u32,
        maxOnTime: u32,
        defaultOffTime: u16,
    ) -> MCPError;
}
pub type ACPTitleId = u64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPMetaXml {
    pub title_id: u64,
    pub boss_id: u64,
    pub os_version: u64,
    pub app_size: u64,
    pub common_save_size: u64,
    pub account_save_size: u64,
    pub common_boss_size: u64,
    pub account_boss_size: u64,
    pub join_game_mode_mask: u64,
    pub version: u32,
    pub product_code: [::core::ffi::c_char; 32usize],
    pub content_platform: [::core::ffi::c_char; 32usize],
    pub company_code: [::core::ffi::c_char; 8usize],
    pub mastering_date: [::core::ffi::c_char; 32usize],
    pub logo_type: u32,
    pub app_launch_type: u32,
    pub invisible_flag: u32,
    pub no_managed_flag: u32,
    pub no_event_log: u32,
    pub no_icon_database: u32,
    pub launching_flag: u32,
    pub install_flag: u32,
    pub closing_msg: u32,
    pub title_version: u32,
    pub group_id: u32,
    pub save_no_rollback: u32,
    pub bg_daemon_enable: u32,
    pub join_game_id: u32,
    pub olv_accesskey: u32,
    pub wood_tin: u32,
    pub e_manual: u32,
    pub e_manual_version: u32,
    pub region: u32,
    pub pc_cero: u32,
    pub pc_esrb: u32,
    pub pc_bbfc: u32,
    pub pc_usk: u32,
    pub pc_pegi_gen: u32,
    pub pc_pegi_fin: u32,
    pub pc_pegi_prt: u32,
    pub pc_pegi_bbfc: u32,
    pub pc_cob: u32,
    pub pc_grb: u32,
    pub pc_cgsrr: u32,
    pub pc_oflc: u32,
    pub pc_reserved0: u32,
    pub pc_reserved1: u32,
    pub pc_reserved2: u32,
    pub pc_reserved3: u32,
    pub ext_dev_nunchaku: u32,
    pub ext_dev_classic: u32,
    pub ext_dev_urcc: u32,
    pub ext_dev_board: u32,
    pub ext_dev_usb_keyboard: u32,
    pub ext_dev_etc: u32,
    pub ext_dev_etc_name: [::core::ffi::c_char; 512usize],
    pub eula_version: u32,
    pub drc_use: u32,
    pub network_use: u32,
    pub online_account_use: u32,
    pub direct_boot: u32,
    pub reserved_flag0: u32,
    pub reserved_flag1: u32,
    pub reserved_flag2: u32,
    pub reserved_flag3: u32,
    pub reserved_flag4: u32,
    pub reserved_flag5: u32,
    pub reserved_flag6: u32,
    pub reserved_flag7: u32,
    pub longname_ja: [::core::ffi::c_char; 512usize],
    pub longname_en: [::core::ffi::c_char; 512usize],
    pub longname_fr: [::core::ffi::c_char; 512usize],
    pub longname_de: [::core::ffi::c_char; 512usize],
    pub longname_it: [::core::ffi::c_char; 512usize],
    pub longname_es: [::core::ffi::c_char; 512usize],
    pub longname_zhs: [::core::ffi::c_char; 512usize],
    pub longname_ko: [::core::ffi::c_char; 512usize],
    pub longname_nl: [::core::ffi::c_char; 512usize],
    pub longname_pt: [::core::ffi::c_char; 512usize],
    pub longname_ru: [::core::ffi::c_char; 512usize],
    pub longname_zht: [::core::ffi::c_char; 512usize],
    pub shortname_ja: [::core::ffi::c_char; 256usize],
    pub shortname_en: [::core::ffi::c_char; 256usize],
    pub shortname_fr: [::core::ffi::c_char; 256usize],
    pub shortname_de: [::core::ffi::c_char; 256usize],
    pub shortname_it: [::core::ffi::c_char; 256usize],
    pub shortname_es: [::core::ffi::c_char; 256usize],
    pub shortname_zhs: [::core::ffi::c_char; 256usize],
    pub shortname_ko: [::core::ffi::c_char; 256usize],
    pub shortname_nl: [::core::ffi::c_char; 256usize],
    pub shortname_pt: [::core::ffi::c_char; 256usize],
    pub shortname_ru: [::core::ffi::c_char; 256usize],
    pub shortname_zht: [::core::ffi::c_char; 256usize],
    pub publisher_ja: [::core::ffi::c_char; 256usize],
    pub publisher_en: [::core::ffi::c_char; 256usize],
    pub publisher_fr: [::core::ffi::c_char; 256usize],
    pub publisher_de: [::core::ffi::c_char; 256usize],
    pub publisher_it: [::core::ffi::c_char; 256usize],
    pub publisher_es: [::core::ffi::c_char; 256usize],
    pub publisher_zhs: [::core::ffi::c_char; 256usize],
    pub publisher_ko: [::core::ffi::c_char; 256usize],
    pub publisher_nl: [::core::ffi::c_char; 256usize],
    pub publisher_pt: [::core::ffi::c_char; 256usize],
    pub publisher_ru: [::core::ffi::c_char; 256usize],
    pub publisher_zht: [::core::ffi::c_char; 256usize],
    pub add_on_unique_id: [u32; 32usize],
    pub __unk69: [::core::ffi::c_char; 52usize],
}
impl Default for ACPMetaXml {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ACPAssignTitlePatch(titleInfo: *mut MCPTitleListType) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleIdOfMainApplication(titleId: *mut ACPTitleId) -> ACPResult;
}
extern "C" {
    pub fn __rplwrap_ACPGetTitleMetaXml(titleId: ACPTitleId, metaXml: *mut ACPMetaXml)
        -> ACPResult;
}
extern "C" {
    pub fn __rplwrap_ACPGetTitleSaveMetaXml(
        titleId: u64,
        metaXml: *mut ACPMetaXml,
        deviceType: ACPDeviceType,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleMetaDir(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleMetaDirByDevice(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
        deviceType: ACPDeviceType,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleMetaDirByTitleListType(
        titleListType: MCPTitleListType,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult;
}
pub type ACPDrcLedStatus = u8;
pub type ACPDrcLedPattern = u32;
extern "C" {
    pub fn ACPDrcLedStartTest();
}
extern "C" {
    pub fn ACPDrcLedStopTest();
}
extern "C" {
    pub fn ACPGetDrcLedStat(ledStatus: *mut ACPDrcLedStatus);
}
extern "C" {
    pub fn ACPGetDrcLedStatusOfPattern(ledStatus: *mut ACPDrcLedStatus, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPSetDrcLedDummyPowerStat(unk1: u8);
}
extern "C" {
    pub fn ACPSetDrcLedTimerLength(unk1: u64, unk2: u64);
}
extern "C" {
    pub fn ACPSetDrcLedTimerSpeed(speed: u32);
}
extern "C" {
    pub fn ACPTurnOffDrcLed();
}
extern "C" {
    pub fn ACPTurnOffDrcLedTest(unk1: u8);
}
extern "C" {
    pub fn ACPTurnOnDrcLed(unk1: u32, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPTurnOnDrcLedTest(unk1: u8, unk2: u32, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPInitialize();
}
extern "C" {
    pub fn ACPFinalize();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPSaveDirInfo {
    pub __unk70: [::core::ffi::c_char; 8usize],
    pub persistentId: u32,
    pub __unk71: [::core::ffi::c_char; 20usize],
    pub path: [::core::ffi::c_char; 64usize],
    pub __unk72: [::core::ffi::c_char; 32usize],
}
impl Default for ACPSaveDirInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ACPCreateSaveDir(persistentId: u32, deviceType: ACPDeviceType) -> ACPResult;
}
extern "C" {
    pub fn ACPIsExternalStorageRequired(required: *mut BOOL) -> ACPResult;
}
extern "C" {
    pub fn ACPMountExternalStorage() -> ACPResult;
}
extern "C" {
    pub fn ACPMountSaveDir() -> ACPResult;
}
extern "C" {
    pub fn ACPRemoveSaveDir(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPRemoveSaveDirWithoutFlush(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPRemoveSaveDirWithoutMetaCheck(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPRepairSaveMetaDir() -> ACPResult;
}
extern "C" {
    pub fn ACPUnmountExternalStorage() -> ACPResult;
}
extern "C" {
    pub fn ACPUnmountSaveDir() -> ACPResult;
}
extern "C" {
    pub fn ACPGetSaveDataTitleIdList(
        deviceType: ACPDeviceType,
        titlesOut: *mut u64,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleSaveDirEx(
        titleId: u64,
        deviceType: ACPDeviceType,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult;
}
extern "C" {
    pub fn ACPGetTitleSaveDirExWithoutMetaCheck(
        titleId: u64,
        deviceType: ACPDeviceType,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult;
}
pub const HPAD_CHAN_0: HPADChan = 0;
pub const HPAD_CHAN_1: HPADChan = 1;
pub const HPAD_CHAN_2: HPADChan = 2;
pub const HPAD_CHAN_3: HPADChan = 3;
pub const HPAD_CHAN_4: HPADChan = 4;
pub const HPAD_CHAN_5: HPADChan = 5;
pub const HPAD_CHAN_6: HPADChan = 6;
pub const HPAD_CHAN_7: HPADChan = 7;
pub type HPADChan = ::core::ffi::c_uint;
pub const HPAD_GGGG_CHAN_0: HPADGGGGChan = 0;
pub const HPAD_GGGG_CHAN_1: HPADGGGGChan = 1;
pub type HPADGGGGChan = ::core::ffi::c_uint;
pub const HPAD_BUTTON_A: HPADButtons = 1;
pub const HPAD_BUTTON_B: HPADButtons = 2;
pub const HPAD_BUTTON_X: HPADButtons = 4;
pub const HPAD_BUTTON_Y: HPADButtons = 8;
pub const HPAD_BUTTON_LEFT: HPADButtons = 16;
pub const HPAD_BUTTON_RIGHT: HPADButtons = 32;
pub const HPAD_BUTTON_DOWN: HPADButtons = 64;
pub const HPAD_BUTTON_UP: HPADButtons = 128;
pub const HPAD_BUTTON_START: HPADButtons = 256;
pub const HPAD_TRIGGER_Z: HPADButtons = 512;
pub const HPAD_TRIGGER_R: HPADButtons = 1024;
pub const HPAD_TRIGGER_L: HPADButtons = 2048;
pub const HPAD_STICK_EMULATION_LEFT: HPADButtons = 4096;
pub const HPAD_STICK_EMULATION_RIGHT: HPADButtons = 8192;
pub const HPAD_STICK_EMULATION_DOWN: HPADButtons = 16384;
pub const HPAD_STICK_EMULATION_UP: HPADButtons = 32768;
pub const HPAD_SUBSTICK_EMULATION_LEFT: HPADButtons = 65536;
pub const HPAD_SUBSTICK_EMULATION_RIGHT: HPADButtons = 131072;
pub const HPAD_SUBSTICK_EMULATION_DOWN: HPADButtons = 262144;
pub const HPAD_SUBSTICK_EMULATION_UP: HPADButtons = 524288;
pub type HPADButtons = ::core::ffi::c_uint;
pub const HPAD_MOTOR_COMMAND_STOP: HPADMotorCommand = 0;
pub const HPAD_MOTOR_COMMAND_RUMBLE: HPADMotorCommand = 1;
pub const HPAD_MOTOR_COMMAND_STOP_HARD: HPADMotorCommand = 2;
pub type HPADMotorCommand = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HPADStatus {
    pub hold: i32,
    pub trigger: i32,
    pub release: i32,
    pub stickX: i8,
    pub stickY: i8,
    pub substickX: i8,
    pub substickY: i8,
    pub triggerL: u8,
    pub triggerR: u8,
    pub status: u8,
    pub __unk73: [::core::ffi::c_char; 1usize],
    pub error: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HPADGGGGStatus {
    pub connected: BOOL,
    pub powerSupplyConnected: BOOL,
    pub active: BOOL,
}
pub type HPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADChan, status: i32)>;
pub type HPADGGGGConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan, connected: BOOL)>;
pub type HPADPowerSupplyCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan, connected: BOOL)>;
pub type HPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan)>;
pub type HPADResetCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan, status: i32)>;
extern "C" {
    pub fn HPADInit() -> i32;
}
extern "C" {
    pub fn HPADShutdown() -> i32;
}
extern "C" {
    pub fn __rplwrap_HPADRead(chan: HPADChan, buffers: *mut HPADStatus, count: i32) -> i32;
}
extern "C" {
    pub fn HPADControlMotor(chan: HPADChan, command: HPADMotorCommand) -> i32;
}
extern "C" {
    pub fn HPADRecalibrate(chan: HPADChan) -> i32;
}
extern "C" {
    pub fn HPADSetConnectCallback(
        chan: HPADChan,
        callback: HPADConnectCallback,
    ) -> HPADConnectCallback;
}
extern "C" {
    pub fn HPADGetGGGGStatus(chan: HPADGGGGChan, status: *mut HPADGGGGStatus) -> i32;
}
extern "C" {
    pub fn HPADSetGgggConnectCallback(
        chan: HPADGGGGChan,
        callback: HPADGGGGConnectCallback,
    ) -> HPADGGGGConnectCallback;
}
extern "C" {
    pub fn HPADSetPowerSupplyCallback(
        chan: HPADGGGGChan,
        callback: HPADPowerSupplyCallback,
    ) -> HPADPowerSupplyCallback;
}
extern "C" {
    pub fn HPADSetSamplingCallback(
        chan: HPADGGGGChan,
        callback: HPADSamplingCallback,
    ) -> HPADSamplingCallback;
}
extern "C" {
    pub fn HPADResetDevice(chan: HPADGGGGChan, callback: HPADResetCallback) -> i32;
}
extern "C" {
    pub fn BETA_DEBUG_DUMP();
}
extern "C" {
    pub fn BETA_DEBUG_GET_QUEUE_SIZE(chan: HPADGGGGChan) -> i32;
}
extern "C" {
    pub fn BETA_DEBUG_SEND_REPT_ID(chan: HPADGGGGChan, reptId: u32);
}
extern "C" {
    pub fn BETA_DEBUG_GET_RAW_DATA();
}
extern "C" {
    pub fn BETA_DEBUG_SET_DUMP_MODE();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSSpinLock {
    pub owner: u32,
    pub __unk74: [::core::ffi::c_char; 4usize],
    pub recursion: u32,
    pub __unk75: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn OSInitSpinLock(spinlock: *mut OSSpinLock);
}
extern "C" {
    pub fn OSAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLockWithTimeout(spinlock: *mut OSSpinLock, timeout: OSTime) -> BOOL;
}
extern "C" {
    pub fn OSReleaseSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Acquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquireWithTimeout(
        spinlock: *mut OSSpinLock,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Release(spinlock: *mut OSSpinLock) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryLink {
    pub prev: *mut ::core::ffi::c_void,
    pub next: *mut ::core::ffi::c_void,
}
impl Default for MEMMemoryLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryList {
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
    pub count: u16,
    pub offsetToMemoryLink: u16,
}
impl Default for MEMMemoryList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn MEMInitList(list: *mut MEMMemoryList, offsetToMemoryLink: u16);
}
extern "C" {
    pub fn MEMAppendListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMPrependListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMInsertListObject(
        list: *mut MEMMemoryList,
        before: *mut ::core::ffi::c_void,
        object: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn MEMRemoveListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMGetNextListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MEMGetPrevListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MEMGetNthListObject(list: *mut MEMMemoryList, n: u16) -> *mut ::core::ffi::c_void;
}
pub type MEMHeapHandle = *mut MEMHeapHeader;
pub const MEM_BASE_HEAP_MEM1: MEMBaseHeapType = 0;
pub const MEM_BASE_HEAP_MEM2: MEMBaseHeapType = 1;
pub const MEM_BASE_HEAP_FG: MEMBaseHeapType = 8;
pub type MEMBaseHeapType = ::core::ffi::c_uint;
pub const MEM_HEAP_FILL_TYPE_UNUSED: MEMHeapFillType = 0;
pub const MEM_HEAP_FILL_TYPE_ALLOCATED: MEMHeapFillType = 1;
pub const MEM_HEAP_FILL_TYPE_FREED: MEMHeapFillType = 2;
pub type MEMHeapFillType = ::core::ffi::c_uint;
pub const MEM_BLOCK_HEAP_TAG: MEMHeapTag = 1112296264;
pub const MEM_EXPANDED_HEAP_TAG: MEMHeapTag = 1163415624;
pub const MEM_FRAME_HEAP_TAG: MEMHeapTag = 1179798856;
pub const MEM_UNIT_HEAP_TAG: MEMHeapTag = 1431196744;
pub const MEM_USER_HEAP_TAG: MEMHeapTag = 1431523912;
pub type MEMHeapTag = ::core::ffi::c_uint;
pub const MEM_HEAP_FLAG_ZERO_ALLOCATED: MEMHeapFlags = 1;
pub const MEM_HEAP_FLAG_DEBUG_MODE: MEMHeapFlags = 2;
pub const MEM_HEAP_FLAG_USE_LOCK: MEMHeapFlags = 4;
pub type MEMHeapFlags = ::core::ffi::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MEMHeapHeader {
    pub tag: MEMHeapTag,
    pub link: MEMMemoryLink,
    pub list: MEMMemoryList,
    pub dataStart: *mut ::core::ffi::c_void,
    pub dataEnd: *mut ::core::ffi::c_void,
    pub lock: OSSpinLock,
    pub flags: u32,
    pub __unk76: [::core::ffi::c_char; 12usize],
}
impl Default for MEMHeapHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn MEMGetArena(handle: MEMHeapHandle) -> MEMBaseHeapType;
}
extern "C" {
    pub fn MEMGetBaseHeapHandle(type_: MEMBaseHeapType) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMSetBaseHeapHandle(type_: MEMBaseHeapType, handle: MEMHeapHandle) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMCreateUserHeapHandle(heap: *mut ::core::ffi::c_void, size: u32) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDumpHeap(heap: MEMHeapHandle);
}
extern "C" {
    pub fn MEMFindContainHeap(block: *mut ::core::ffi::c_void) -> *mut MEMHeapHeader;
}
extern "C" {
    pub fn MEMFindParentHeap(handle: MEMHeapHandle) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMGetFillValForHeap(type_: MEMHeapFillType) -> u32;
}
extern "C" {
    pub fn MEMSetFillValForHeap(type_: MEMHeapFillType, value: u32);
}
extern "C" {
    pub fn MEMCheckHeap(handle: MEMHeapHandle) -> BOOL;
}
pub type MEMAllocFromDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut ::core::ffi::c_void>;
pub type MEMAllocFromDefaultHeapExFn = ::core::option::Option<
    unsafe extern "C" fn(size: u32, alignment: i32) -> *mut ::core::ffi::c_void,
>;
pub type MEMFreeToDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>;
extern "C" {
    pub static mut MEMAllocFromDefaultHeap: MEMAllocFromDefaultHeapFn;
}
extern "C" {
    pub static mut MEMAllocFromDefaultHeapEx: MEMAllocFromDefaultHeapExFn;
}
extern "C" {
    pub static mut MEMFreeToDefaultHeap: MEMFreeToDefaultHeapFn;
}
extern "C" {
    pub fn CoreInitDefaultHeap(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
extern "C" {
    pub fn __preinit_user(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
pub type ACConfigId = u32;
extern "C" {
    pub fn ACInitialize() -> NNResult;
}
extern "C" {
    pub fn ACFinalize();
}
extern "C" {
    pub fn ACConnect() -> NNResult;
}
extern "C" {
    pub fn ACConnectAsync() -> NNResult;
}
extern "C" {
    pub fn ACClose() -> NNResult;
}
extern "C" {
    pub fn ACGetCloseStatus() -> NNResult;
}
extern "C" {
    pub fn ACIsApplicationConnected(connected: *mut BOOL) -> NNResult;
}
extern "C" {
    pub fn ACGetStartupId(configId: *mut ACConfigId) -> NNResult;
}
extern "C" {
    pub fn ACConnectWithConfigId(configId: ACConfigId) -> NNResult;
}
extern "C" {
    pub fn ACGetAssignedAddress(ip: *mut u32) -> NNResult;
}
pub const CCR_SYS_PAIRING_FINISHED: CCRSysPairingState = 0;
pub const CCR_SYS_PAIRING_IN_PROGRESS: CCRSysPairingState = 1;
pub const CCR_SYS_PAIRING_TIMED_OUT: CCRSysPairingState = 2;
pub type CCRSysPairingState = ::core::ffi::c_uint;
pub const CCR_SYS_BOOT_FLAG_NONE: CCRSysInitBootFlag = 0;
pub const CCR_SYS_BOOT_FLAG_FIRST_BOOT: CCRSysInitBootFlag = 1;
pub type CCRSysInitBootFlag = ::core::ffi::c_uint;
pub const CCR_SYS_LCD_MODE_BRIGHTNESS_1: CCRSysLCDMode = 1;
pub const CCR_SYS_LCD_MODE_BRIGHTNESS_2: CCRSysLCDMode = 2;
pub const CCR_SYS_LCD_MODE_BRIGHTNESS_3: CCRSysLCDMode = 3;
pub const CCR_SYS_LCD_MODE_BRIGHTNESS_4: CCRSysLCDMode = 4;
pub const CCR_SYS_LCD_MODE_BRIGHTNESS_5: CCRSysLCDMode = 5;
pub type CCRSysLCDMode = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRSysUpdateState {
    pub state: u32,
    pub progress: u32,
}
extern "C" {
    pub fn CCRSysInit();
}
extern "C" {
    pub fn CCRSysExit();
}
extern "C" {
    pub fn CCRSysDRCShutdown() -> i32;
}
extern "C" {
    pub fn CCRSysInvalidatePairing() -> i32;
}
extern "C" {
    pub fn __CCRSysDRCIsAttached(drcSlot: u32) -> BOOL;
}
extern "C" {
    pub fn CCRSysStartPairing(drcSlot: u32, timeout: u32) -> i32;
}
extern "C" {
    pub fn CCRSysStopPairing() -> i32;
}
extern "C" {
    pub fn CCRSysGetPairingState() -> CCRSysPairingState;
}
extern "C" {
    pub fn CCRSysGetPincode(pin: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetSystemTime(time: OSTime) -> i32;
}
extern "C" {
    pub fn CCRSysNeedsDRCFWUpdate(drcSlot: u32, outNeedsUpdate: *mut BOOL) -> i32;
}
extern "C" {
    pub fn __CCRSysNeedsDRCFWUpdate(
        drcSlot: u32,
        outNeedsUpdate: *mut BOOL,
        allowDowngrade: BOOL,
    ) -> i32;
}
extern "C" {
    pub fn CCRSysDRCFWUpdate(drcSlot: u32) -> i32;
}
extern "C" {
    pub fn __CCRSysDRCFWUpdate(drcSlot: u32, allowDowngrade: BOOL) -> i32;
}
extern "C" {
    pub fn CCRSysDRCFWUpdateForward();
}
extern "C" {
    pub fn CCRSysGetUpdateState(outUpdateState: *mut CCRSysUpdateState);
}
extern "C" {
    pub fn __CCRSysInitReattach(drcSlot: u32);
}
extern "C" {
    pub fn __CCRSysWaitReattach(drcSlot: u32, unknown: BOOL) -> i32;
}
extern "C" {
    pub fn CCRSysGetVersionCheckFlag(outFlag: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetVersionCheckFlag(flag: u32) -> i32;
}
extern "C" {
    pub fn CCRSysCaffeineSetCaffeineSlot(slot: u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetInitBootFlag(flag: CCRSysInitBootFlag) -> i32;
}
extern "C" {
    pub fn CCRSysInitializeSettings() -> i32;
}
extern "C" {
    pub fn CCRSysSetCurrentLCDMode(mode: CCRSysLCDMode) -> i32;
}
extern "C" {
    pub fn CCRSysGetCurrentLCDMode(mode: *mut CCRSysLCDMode) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRAppLaunchParam {
    pub launchInfoDatabaseEntryId: u64,
    pub uuid: [::core::ffi::c_char; 16usize],
    pub __unk77: [::core::ffi::c_char; 231usize],
}
impl Default for CCRAppLaunchParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn CCRSysCaffeineGetAppLaunchParam(data: *mut CCRAppLaunchParam);
}
extern "C" {
    pub fn CCRSysCaffeineBootCheck() -> u32;
}
extern "C" {
    pub fn CCRSysCaffeineBootCheckAbort();
}
extern "C" {
    pub fn CCRSysCaffeineSetDRCEnableFlag(enabled: i32) -> i32;
}
extern "C" {
    pub fn CCRSysCaffeineSetEnableFlag(enabled: i32) -> i32;
}
pub const TEMP_PREF_DEFAULT: TEMPTargetPreference = 0;
pub const TEMP_PREF_USB: TEMPTargetPreference = 1;
pub type TEMPTargetPreference = ::core::ffi::c_uint;
pub type TEMPDirId = u64;
extern "C" {
    pub fn TEMPInit() -> FSStatus;
}
extern "C" {
    pub fn TEMPShutdown();
}
extern "C" {
    pub fn TEMPCreateAndInitTempDir(
        maxSize: u32,
        pref: TEMPTargetPreference,
        outDir: *mut TEMPDirId,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPShutdownTempDir(tempId: TEMPDirId) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetDirGlobalPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetDirPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPChangeOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPChangeOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn TEMPMountTempDir(dirId: TEMPDirId) -> FSStatus;
}
extern "C" {
    pub fn TEMPUnmountTempDir(dirId: TEMPDirId) -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenNewFile() -> FSStatus;
}
extern "C" {
    pub fn TEMPOpenNewFileAsync() -> FSStatus;
}
extern "C" {
    pub fn PDMInitialize() -> u32;
}
extern "C" {
    pub fn PDMFinalize();
}
extern "C" {
    pub fn PDMCloseAllFiles();
}
extern "C" {
    pub fn PDMNotifySetTimeBeginEvent();
}
extern "C" {
    pub fn PDMNotifySetTimeEndEvent();
}
pub const SAVE_STATUS_OK: SAVEStatus = 0;
pub const SAVE_STATUS_NOT_FOUND: SAVEStatus = -6;
pub const SAVE_STATUS_STORAGE_FULL: SAVEStatus = -12;
pub type SAVEStatus = ::core::ffi::c_int;
extern "C" {
    pub fn SAVEInit() -> SAVEStatus;
}
extern "C" {
    pub fn SAVEShutdown();
}
extern "C" {
    pub fn SAVEInitSaveDir(slotNo: u8) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEInitCommonSaveDir() -> SAVEStatus;
}
extern "C" {
    pub fn SAVEInitAccountSaveDir(slotNo: u8) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEInitNoDeleteGroupSaveDir();
}
extern "C" {
    pub fn SAVEUpdateSaveDir() -> SAVEStatus;
}
extern "C" {
    pub fn SAVEChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEChangeGroupAndOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEChangeGroupAndOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEChangeGroupMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEChangeGroupModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVECheckSaveDirRequiredUpdate(
        unk1: *mut ::core::ffi::c_int,
        unk2: *mut u64,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEFlushQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEFlushQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut u64,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut i64,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSizeOfDevice(deviceType: ACPDeviceType) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEGetNoDeleteGroupSaveDirPath(
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEGetNoDeleteSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEGetSharedDataTitlePath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEGetSharedSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEInitSaveDirByAppMeta(
        slotNo: u8,
        metaXmlPath: *const ::core::ffi::c_char,
        metaXmlBuffer: *mut u8,
        metaXmlBufferSize: u32,
        iconPath: *const ::core::ffi::c_char,
        iconBuffer: *mut u8,
        iconBufferSize: u32,
    ) -> SAVEStatus;
}
extern "C" {
    pub fn SAVEMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERollbackQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag,
    ) -> FSStatus;
}
extern "C" {
    pub fn SAVERollbackQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus;
}
pub const CMPT_SCREEN_TYPE_TV: CmptScreenType = 1;
pub const CMPT_SCREEN_TYPE_DRC: CmptScreenType = 2;
pub const CMPT_SCREEN_TYPE_BOTH: CmptScreenType = 3;
pub type CmptScreenType = ::core::ffi::c_uint;
extern "C" {
    pub fn CMPTGetDataSize(outSize: *mut u32) -> i32;
}
extern "C" {
    pub fn CMPTLaunchTitle(
        dataBuffer: *mut ::core::ffi::c_void,
        bufferSize: u32,
        titleId: u64,
    ) -> i32;
}
extern "C" {
    pub fn CMPTLaunchMenu(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
}
extern "C" {
    pub fn CMPTLaunchDataManager(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
}
extern "C" {
    pub fn CMPTAcctSetScreenType(type_: CmptScreenType) -> i32;
}
extern "C" {
    pub fn CMPTCheckScreenState() -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEManualArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub titleId: u64,
}
impl Default for SysAppEManualArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEShopArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub query: *mut ::core::ffi::c_char,
    pub querySize: u32,
}
impl Default for SysAppEShopArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub url: *mut ::core::ffi::c_char,
    pub urlSize: u32,
}
impl Default for SysAppBrowserArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgsWithCallback {
    pub browserArgs: SysAppBrowserArgs,
    pub cbUrl: *mut ::core::ffi::c_char,
    pub cbUrlSize: u32,
    pub hbmDisable: BOOL,
}
impl Default for SysAppBrowserArgsWithCallback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SYSAPP_PFID_WII_U_MENU: SysAppPFID = 2;
pub const SYSAPP_PFID_TVII: SysAppPFID = 3;
pub const SYSAPP_PFID_EMANUAL: SysAppPFID = 4;
pub const SYSAPP_PFID_HOME_MENU: SysAppPFID = 5;
pub const SYSAPP_PFID_MINI_MIIVERSE: SysAppPFID = 7;
pub const SYSAPP_PFID_BROWSER: SysAppPFID = 8;
pub const SYSAPP_PFID_MIIVERSE: SysAppPFID = 9;
pub const SYSAPP_PFID_ESHOP: SysAppPFID = 10;
pub const SYSAPP_PFID_FRIENDLIST: SysAppPFID = 11;
pub const SYSAPP_PFID_DOWNLOAD_MANAGEMENT: SysAppPFID = 12;
pub const SYSAPP_PFID_DOWNLOAD_GAME: SysAppPFID = 15;
pub const SYSAPP_PFID_MINTU: SysAppPFID = 16;
pub const SYSAPP_PFID_CABINETU: SysAppPFID = 17;
pub const SYSAPP_PFID_TEST_OVERLAY: SysAppPFID = 31;
pub type SysAppPFID = ::core::ffi::c_uint;
extern "C" {
    pub fn SYSSwitchToSyncControllerOnHBM() -> i32;
}
extern "C" {
    pub fn SYSSwitchToEManual() -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEManual(arg1: *mut SysAppEManualArgs) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEManualFromHBM(arg1: *mut SysAppEManualArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToEShop(arg1: *mut SysAppEShopArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToEShopTicketList(arg1: *mut SYSStandardArgsIn) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEShopFromHBM(arg1: *mut SysAppEShopArgs) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToMainApp() -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowser(arg1: *mut SysAppBrowserArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowserForViewer(arg1: *mut SysAppBrowserArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowserForCallbackURL(arg1: *mut SysAppBrowserArgsWithCallback) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToBrowserForCallbackURLFromHBM(
        arg1: *mut SysAppBrowserArgsWithCallback,
    ) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToHBMWithMode(arg1: i32) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToOverlayFromHBM(arg1: i32) -> i32;
}
extern "C" {
    pub fn SYSSwitchTo(pfid: SysAppPFID) -> i32;
}
extern "C" {
    pub fn _SYSSwitchTo(pfid: SysAppPFID) -> i32;
}
extern "C" {
    pub fn _SYSDirectlySwitchTo(pfid: SysAppPFID) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
impl Default for SysAppMiiMakerArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
impl Default for _SysAppMiiMakerArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SYS_SETTINGS_JUMP_TO_NONE: SYSSettingsJumpToTarget = 0;
pub const SYS_SETTINGS_JUMP_TO_INTERNET: SYSSettingsJumpToTarget = 1;
pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT: SYSSettingsJumpToTarget = 2;
pub const SYS_SETTINGS_JUMP_TO_TV_REMOTE: SYSSettingsJumpToTarget = 3;
pub const SYS_SETTINGS_JUMP_TO_DATE_TIME: SYSSettingsJumpToTarget = 4;
pub const SYS_SETTINGS_JUMP_TO_COUNTRY: SYSSettingsJumpToTarget = 5;
pub const SYS_SETTINGS_JUMP_TO_SYSTEM_UPDATE: SYSSettingsJumpToTarget = 6;
pub const SYS_SETTINGS_JUMP_TO_INITIAL_SETTINGS: SYSSettingsJumpToTarget = 100;
pub const SYS_SETTINGS_JUMP_TO_UNKNOWN: SYSSettingsJumpToTarget = 101;
pub const SYS_SETTINGS_JUMP_TO_WIPE_CONSOLE: SYSSettingsJumpToTarget = 102;
pub const SYS_SETTINGS_JUMP_TO_QUICK_START_SETTINGS: SYSSettingsJumpToTarget = 103;
pub const SYS_SETTINGS_JUMP_TO_TV_CONNECTION_TYPE: SYSSettingsJumpToTarget = 104;
pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT_2: SYSSettingsJumpToTarget = 105;
pub const SYS_SETTINGS_JUMP_TO_SOFTWARE_TRANSFER: SYSSettingsJumpToTarget = 255;
pub type SYSSettingsJumpToTarget = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppSettingsArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub jumpTo: SYSSettingsJumpToTarget,
    pub firstBootKind: u32,
}
impl Default for SysAppSettingsArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppParentalArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
}
impl Default for SysAppParentalArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppNotificationArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub notificationFile: u32,
}
impl Default for SysAppNotificationArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SYSRelaunchTitle(argc: u32, pa_Argv: *mut *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn SYSLaunchMenu();
}
extern "C" {
    pub fn SYSLaunchTitle(TitleId: u64);
}
extern "C" {
    pub fn _SYSLaunchTitleWithStdArgsInNoSplash(titleId: u64, stdArgs: *mut SYSStandardArgsIn);
}
extern "C" {
    pub fn _SYSLaunchMenuWithCheckingAccount(slot: u8);
}
extern "C" {
    pub fn SYSLaunchMiiStudio(args: *mut SysAppMiiMakerArgs);
}
extern "C" {
    pub fn _SYSLaunchMiiStudio(args: *mut _SysAppMiiMakerArgs);
}
extern "C" {
    pub fn _SYSLaunchSettings(args: *mut SysAppSettingsArgs);
}
extern "C" {
    pub fn _SYSLaunchParental(args: *mut SysAppParentalArgs);
}
extern "C" {
    pub fn _SYSLaunchNotifications(args: *mut SysAppNotificationArgs);
}
extern "C" {
    pub fn _SYSLaunchTitleByPathFromLauncher(path: *const ::core::ffi::c_char, unused: u32);
}
pub const SYSTEM_APP_ID_WII_U_MENU: SYSTEM_APP_ID = 0;
pub const SYSTEM_APP_ID_SYSTEM_SETTINGS: SYSTEM_APP_ID = 1;
pub const SYSTEM_APP_ID_PARENTAL_CONTROLS: SYSTEM_APP_ID = 2;
pub const SYSTEM_APP_ID_USER_SETTINGS: SYSTEM_APP_ID = 3;
pub const SYSTEM_APP_ID_MII_MAKER: SYSTEM_APP_ID = 4;
pub const SYSTEM_APP_ID_ACCOUNT_SETTINGS: SYSTEM_APP_ID = 5;
pub const SYSTEM_APP_ID_DAILY_LOG: SYSTEM_APP_ID = 6;
pub const SYSTEM_APP_ID_NOTIFICATIONS: SYSTEM_APP_ID = 7;
pub const SYSTEM_APP_ID_HEALTH_AND_SAFETY: SYSTEM_APP_ID = 8;
pub const SYSTEM_APP_ID_ELECTRONIC_MANUAL: SYSTEM_APP_ID = 9;
pub const SYSTEM_APP_ID_WIIU_CHAT: SYSTEM_APP_ID = 10;
pub const SYSTEM_APP_ID_SOFTWARE_DATA_TRANSFER: SYSTEM_APP_ID = 11;
pub type SYSTEM_APP_ID = ::core::ffi::c_uint;
extern "C" {
    pub static SYSTEM_APP_ID_UPDATER: SYSTEM_APP_ID;
}
extern "C" {
    pub static SYSTEM_APP_ID_HOME_MENU: SYSTEM_APP_ID;
}
extern "C" {
    pub fn SYSCheckTitleExists(TitleId: u64) -> BOOL;
}
extern "C" {
    pub fn SYSGetPFIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    pub fn SYSGetUPIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    pub fn SYSGetCallerUPID() -> i32;
}
extern "C" {
    pub fn SYSGetCallerPFID() -> i32;
}
extern "C" {
    pub fn _SYSGetSystemApplicationTitleId(id: SYSTEM_APP_ID) -> u64;
}
extern "C" {
    pub fn _SYSGetSystemApplicationTitleIdByProdArea(
        id: SYSTEM_APP_ID,
        prod_area: MCPRegion,
    ) -> u64;
}
extern "C" {
    pub fn SYSGetCallerTitleId() -> u64;
}
pub type LogHandlerFn =
    ::core::option::Option<unsafe extern "C" fn(msg: *const ::core::ffi::c_char)>;
extern "C" {
    pub fn WHBAddLogHandler(fn_: LogHandlerFn) -> BOOL;
}
extern "C" {
    pub fn WHBRemoveLogHandler(fn_: LogHandlerFn) -> BOOL;
}
extern "C" {
    pub fn WHBLogWrite(str_: *const ::core::ffi::c_char) -> BOOL;
}
extern "C" {
    pub fn WHBLogPrint(str_: *const ::core::ffi::c_char) -> BOOL;
}
extern "C" {
    pub fn WHBLogWritef(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
}
extern "C" {
    pub fn WHBLogPrintf(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
}
pub const WHB_FILE_OK: WHBFileError = 0;
pub const WHB_FILE_FATAL_ERROR: WHBFileError = -1;
pub type WHBFileError = ::core::ffi::c_int;
extern "C" {
    pub fn WHBDeInitFileSystem() -> BOOL;
}
extern "C" {
    pub fn WHBOpenFile(path: *const ::core::ffi::c_char, mode: *const ::core::ffi::c_char) -> i32;
}
extern "C" {
    pub fn WHBGetFileSize(handle: i32) -> u32;
}
extern "C" {
    pub fn WHBReadFile(handle: i32, buf: *mut ::core::ffi::c_void, size: u32, count: u32) -> u32;
}
extern "C" {
    pub fn WHBCloseFile(handle: i32) -> i32;
}
extern "C" {
    pub fn WHBReadWholeFile(
        path: *const ::core::ffi::c_char,
        outSize: *mut u32,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn WHBFreeWholeFile(file: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn WHBProcInit();
}
extern "C" {
    pub fn WHBProcShutdown();
}
extern "C" {
    pub fn WHBProcStopRunning();
}
extern "C" {
    pub fn WHBProcIsRunning() -> BOOL;
}
extern "C" {
    pub fn WHBLogConsoleInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogConsoleFree();
}
extern "C" {
    pub fn WHBLogConsoleSetColor(color: u32);
}
extern "C" {
    pub fn WHBLogConsoleDraw();
}
extern "C" {
    pub fn WHBLogModuleInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogModuleDeinit() -> BOOL;
}
extern "C" {
    pub fn WHBMountSdCard() -> BOOL;
}
extern "C" {
    pub fn WHBGetSdCardMountPath() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn WHBUnmountSdCard() -> BOOL;
}
extern "C" {
    pub fn WHBInitializeSocketLibrary();
}
extern "C" {
    pub fn WHBDeinitializeSocketLibrary();
}
extern "C" {
    pub fn WHBLogCafeInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogCafeDeinit() -> BOOL;
}
extern "C" {
    pub fn WHBInitCrashHandler() -> BOOL;
}
extern "C" {
    pub fn WHBLogUdpInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogUdpDeinit() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHBGfxShaderGroup {
    pub fetchShader: GX2FetchShader,
    pub fetchShaderProgram: *mut ::core::ffi::c_void,
    pub pixelShader: *mut GX2PixelShader,
    pub vertexShader: *mut GX2VertexShader,
    pub numAttributes: u32,
    pub attributes: [GX2AttribStream; 16usize],
}
impl Default for WHBGfxShaderGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn WHBGfxInit() -> BOOL;
}
extern "C" {
    pub fn WHBGfxShutdown();
}
extern "C" {
    pub fn WHBGfxBeginRender();
}
extern "C" {
    pub fn WHBGfxFinishRender();
}
extern "C" {
    pub fn WHBGfxClearColor(r: f32, g: f32, b: f32, a: f32);
}
extern "C" {
    pub fn WHBGfxBeginRenderDRC();
}
extern "C" {
    pub fn WHBGfxFinishRenderDRC();
}
extern "C" {
    pub fn WHBGfxBeginRenderTV();
}
extern "C" {
    pub fn WHBGfxFinishRenderTV();
}
extern "C" {
    pub fn WHBGfxLoadGFDPixelShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2PixelShader;
}
extern "C" {
    pub fn WHBGfxFreePixelShader(shader: *mut GX2PixelShader) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDVertexShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2VertexShader;
}
extern "C" {
    pub fn WHBGfxFreeVertexShader(shader: *mut GX2VertexShader) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDShaderGroup(
        group: *mut WHBGfxShaderGroup,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn WHBGfxInitShaderAttribute(
        group: *mut WHBGfxShaderGroup,
        name: *const ::core::ffi::c_char,
        buffer: u32,
        offset: u32,
        format: GX2AttribFormat,
    ) -> BOOL;
}
extern "C" {
    pub fn WHBGfxInitFetchShader(group: *mut WHBGfxShaderGroup) -> BOOL;
}
extern "C" {
    pub fn WHBGfxFreeShaderGroup(group: *mut WHBGfxShaderGroup) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDTexture(index: u32, file: *const ::core::ffi::c_void) -> *mut GX2Texture;
}
extern "C" {
    pub fn WHBGfxFreeTexture(texture: *mut GX2Texture) -> BOOL;
}
extern "C" {
    pub fn WHBGfxGetTVColourBuffer() -> *mut GX2ColorBuffer;
}
extern "C" {
    pub fn WHBGfxGetTVDepthBuffer() -> *mut GX2DepthBuffer;
}
extern "C" {
    pub fn WHBGfxGetTVContextState() -> *mut GX2ContextState;
}
extern "C" {
    pub fn WHBGfxGetDRCColourBuffer() -> *mut GX2ColorBuffer;
}
extern "C" {
    pub fn WHBGfxGetDRCDepthBuffer() -> *mut GX2DepthBuffer;
}
extern "C" {
    pub fn WHBGfxGetDRCContextState() -> *mut GX2ContextState;
}
pub const TVE_PORT_HDMI: TVEPort = 0;
pub const TVE_PORT_COMPONENT: TVEPort = 1;
pub const TVE_PORT_COMPOSITE: TVEPort = 2;
pub const TVE_PORT_SCART: TVEPort = 3;
pub type TVEPort = ::core::ffi::c_uint;
pub const TVE_HDMI_STATE_NONE: TVEHdmiState = 0;
pub const TVE_HDMI_STATE_HTPG_OFF: TVEHdmiState = 1;
pub const TVE_HDMI_STATE_RXWAIT: TVEHdmiState = 2;
pub const TVE_HDMI_STATE_EDID_COMP: TVEHdmiState = 3;
pub const TVE_HDMI_STATE_DUMMY_TMDS: TVEHdmiState = 4;
pub const TVE_HDMI_STATE_W4WK: TVEHdmiState = 5;
pub const TVE_HDMI_STATE_1STA: TVEHdmiState = 6;
pub const TVE_HDMI_STATE_2NDA: TVEHdmiState = 7;
pub const TVE_HDMI_STATE_3RDA: TVEHdmiState = 8;
pub const TVE_HDMI_STATE_STAV_OFF: TVEHdmiState = 9;
pub const TVE_HDMI_STATE_DONE: TVEHdmiState = 10;
pub const TVE_HDMI_STATE_OTHER: TVEHdmiState = 11;
pub const TVE_HDMI_STATE_TMDSDOWN: TVEHdmiState = 12;
pub const TVE_HDMI_STATE_SHUTDOWN: TVEHdmiState = 13;
pub const TVE_HDMI_STATE_WII: TVEHdmiState = 14;
pub const TVE_HDMI_STATE_ERR_NRESET: TVEHdmiState = 15;
pub const TVE_HDMI_STATE_ERR_INT_LINE: TVEHdmiState = 16;
pub const TVE_HDMI_STATE_ERR_KEY_LOAD: TVEHdmiState = 17;
pub const TVE_HDMI_STATE_ERR_EDID_READ: TVEHdmiState = 18;
pub const TVE_HDMI_STATE_ERR_HOTPLUG: TVEHdmiState = 19;
pub const TVE_HDMI_STATE_ERR_VSYNC: TVEHdmiState = 20;
pub const TVE_HDMI_STATE_ERR_HDCP: TVEHdmiState = 21;
pub const TVE_HDMI_STATE_ERR_SYS: TVEHdmiState = 22;
pub const TVE_HDMI_STATE_ERR_CEC: TVEHdmiState = 23;
pub const TVE_HDMI_STATE_ERR_W41A: TVEHdmiState = 24;
pub const TVE_HDMI_STATE_ERR_W4ED: TVEHdmiState = 25;
pub const TVE_HDMI_STATE_UNKNOWN_1A: TVEHdmiState = 26;
pub type TVEHdmiState = ::core::ffi::c_uint;
extern "C" {
    pub fn TVEGetAnalogStat(outState: *mut u32);
}
extern "C" {
    pub fn TVEGetCurrentPort() -> TVEPort;
}
extern "C" {
    pub fn TVEGetHDMIErrorStat(outState: *mut TVEHdmiState);
}
pub const TVE_CEC_DEVICE_TV: TVECECLogicalAddress = 0;
pub const TVE_CEC_DEVICE_RECORDING_DEVICE_1: TVECECLogicalAddress = 1;
pub const TVE_CEC_DEVICE_RECORDING_DEVICE_2: TVECECLogicalAddress = 2;
pub const TVE_CEC_DEVICE_TUNER_1: TVECECLogicalAddress = 3;
pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_1: TVECECLogicalAddress = 4;
pub const TVE_CEC_DEVICE_AUDIO_SYSTEM: TVECECLogicalAddress = 5;
pub const TVE_CEC_DEVICE_TUNER_2: TVECECLogicalAddress = 6;
pub const TVE_CEC_DEVICE_TUNER_3: TVECECLogicalAddress = 7;
pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_2: TVECECLogicalAddress = 8;
pub const TVE_CEC_DEVICE_RECORDING_DEVICE_3: TVECECLogicalAddress = 9;
pub const TVE_CEC_DEVICE_TUNER_4: TVECECLogicalAddress = 10;
pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_3: TVECECLogicalAddress = 11;
pub const TVE_CEC_DEVICE_RESERVED_1: TVECECLogicalAddress = 12;
pub const TVE_CEC_DEVICE_RESERVED_2: TVECECLogicalAddress = 13;
pub const TVE_CEC_DEVICE_FREE_USE: TVECECLogicalAddress = 14;
pub const TVE_CEC_DEVICE_UNREGISTERED: TVECECLogicalAddress = 15;
pub const TVE_CEC_DEVICE_BROADCAST: TVECECLogicalAddress = 15;
pub type TVECECLogicalAddress = ::core::ffi::c_uint;
pub const TVE_CEC_OPCODE_FEATURE_ABORT: TVECECOpCode = 0;
pub const TVE_CEC_OPCODE_IMAGE_VIEW_ON: TVECECOpCode = 4;
pub const TVE_CEC_OPCODE_TUNER_STEP_INCREMENT: TVECECOpCode = 5;
pub const TVE_CEC_OPCODE_TUNER_STEP_DECREMENT: TVECECOpCode = 6;
pub const TVE_CEC_OPCODE_TUNER_DEVICE_STATUS: TVECECOpCode = 7;
pub const TVE_CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: TVECECOpCode = 8;
pub const TVE_CEC_OPCODE_RECORD_ON: TVECECOpCode = 9;
pub const TVE_CEC_OPCODE_RECORD_STATUS: TVECECOpCode = 10;
pub const TVE_CEC_OPCODE_RECORD_OFF: TVECECOpCode = 11;
pub const TVE_CEC_OPCODE_TEXT_VIEW_ON: TVECECOpCode = 13;
pub const TVE_CEC_OPCODE_RECORD_TV_SCREEN: TVECECOpCode = 15;
pub const TVE_CEC_OPCODE_GIVE_DECK_STATUS: TVECECOpCode = 26;
pub const TVE_CEC_OPCODE_DECK_STATUS: TVECECOpCode = 27;
pub const TVE_CEC_OPCODE_SET_MENU_LANGUAGE: TVECECOpCode = 50;
pub const TVE_CEC_OPCODE_CLEAR_ANALOGUE_TIMER: TVECECOpCode = 51;
pub const TVE_CEC_OPCODE_SET_ANALOGUE_TIMER: TVECECOpCode = 52;
pub const TVE_CEC_OPCODE_TIMER_STATUS: TVECECOpCode = 53;
pub const TVE_CEC_OPCODE_STANDBY: TVECECOpCode = 54;
pub const TVE_CEC_OPCODE_PLAY: TVECECOpCode = 65;
pub const TVE_CEC_OPCODE_DECK_CONTROL: TVECECOpCode = 66;
pub const TVE_CEC_OPCODE_TIMER_CLEARED_STATUS: TVECECOpCode = 67;
pub const TVE_CEC_OPCODE_USER_CONTROL_PRESSED: TVECECOpCode = 68;
pub const TVE_CEC_OPCODE_USER_CONTROL_RELEASE: TVECECOpCode = 69;
pub const TVE_CEC_OPCODE_GIVE_OSD_NAME: TVECECOpCode = 70;
pub const TVE_CEC_OPCODE_SET_OSD_NAME: TVECECOpCode = 71;
pub const TVE_CEC_OPCODE_SET_OSD_STRING: TVECECOpCode = 100;
pub const TVE_CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: TVECECOpCode = 103;
pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: TVECECOpCode = 112;
pub const TVE_CEC_OPCODE_GIVE_AUDIO_STATUS: TVECECOpCode = 113;
pub const TVE_CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: TVECECOpCode = 114;
pub const TVE_CEC_OPCODE_REPORT_AUDIO_STATUS: TVECECOpCode = 122;
pub const TVE_CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: TVECECOpCode = 125;
pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: TVECECOpCode = 126;
pub const TVE_CEC_OPCODE_ROUTING_CHANGE: TVECECOpCode = 128;
pub const TVE_CEC_OPCODE_ROUTING_INFORMATION: TVECECOpCode = 129;
pub const TVE_CEC_OPCODE_ACTIVE_SOURCE: TVECECOpCode = 130;
pub const TVE_CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: TVECECOpCode = 131;
pub const TVE_CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: TVECECOpCode = 132;
pub const TVE_CEC_OPCODE_REQUEST_ACTIVE_SOURCE: TVECECOpCode = 133;
pub const TVE_CEC_OPCODE_SET_STREAM_PATH: TVECECOpCode = 134;
pub const TVE_CEC_OPCODE_DEVICE_VENDOR_ID: TVECECOpCode = 135;
pub const TVE_CEC_OPCODE_VENDOR_COMMAND: TVECECOpCode = 137;
pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: TVECECOpCode = 138;
pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: TVECECOpCode = 139;
pub const TVE_CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: TVECECOpCode = 140;
pub const TVE_CEC_OPCODE_MENU_REQUEST: TVECECOpCode = 141;
pub const TVE_CEC_OPCODE_MENU_STATUS: TVECECOpCode = 142;
pub const TVE_CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: TVECECOpCode = 143;
pub const TVE_CEC_OPCODE_REPORT_POWER_STATUS: TVECECOpCode = 144;
pub const TVE_CEC_OPCODE_GET_MENU_LANGUAGE: TVECECOpCode = 145;
pub const TVE_CEC_OPCODE_SELECT_ANALOGUE_SERVICE: TVECECOpCode = 146;
pub const TVE_CEC_OPCODE_SELECT_DIGITAL_SERVICE: TVECECOpCode = 147;
pub const TVE_CEC_OPCODE_SET_DIGITAL_TIMER: TVECECOpCode = 151;
pub const TVE_CEC_OPCODE_CLEAR_DIGITAL_TIMER: TVECECOpCode = 153;
pub const TVE_CEC_OPCODE_SET_AUDIO_RATE: TVECECOpCode = 154;
pub const TVE_CEC_OPCODE_INACTIVE_SOURCE: TVECECOpCode = 157;
pub const TVE_CEC_OPCODE_CEC_VERSION: TVECECOpCode = 158;
pub const TVE_CEC_OPCODE_GET_CEC_VERSION: TVECECOpCode = 159;
pub const TVE_CEC_OPCODE_VENDOR_COMMAND_WITH_ID: TVECECOpCode = 160;
pub const TVE_CEC_OPCODE_CLEAR_EXTERNAL_TIMER: TVECECOpCode = 161;
pub const TVE_CEC_OPCODE_SET_EXTERNAL_TIMER: TVECECOpCode = 162;
pub const TVE_CEC_OPCODE_ABORT: TVECECOpCode = 255;
pub type TVECECOpCode = ::core::ffi::c_uint;
extern "C" {
    pub fn TVECECInit() -> BOOL;
}
extern "C" {
    pub fn TVESetCECEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn TVEIsCECEnable() -> BOOL;
}
extern "C" {
    pub fn TVECECSendCommand(
        destination: TVECECLogicalAddress,
        opCode: TVECECOpCode,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
}
extern "C" {
    pub fn TVECECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress,
        outOpCode: *mut TVECECOpCode,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
}
pub type AXResult = i32;
pub const AX_RESULT_SUCCESS: AX_RESULT = 0;
pub const AX_RESULT_INVALID_DEVICE_TYPE: AX_RESULT = -1;
pub const AX_RESULT_INVALID_DRC_VS_MODE: AX_RESULT = -13;
pub const AX_RESULT_VOICE_IS_RUNNING: AX_RESULT = -18;
pub const AX_RESULT_DELAY_TOO_BIG: AX_RESULT = -19;
pub type AX_RESULT = ::core::ffi::c_int;
pub type AXDRCVSMode = u32;
pub type AXDRCVSOutput = u32;
pub type AXDRCVSLC = u32;
pub type AXDRCVSSpeakerPosition = u32;
pub type AXDRCVSSurroundLevelGain = u32;
pub const AX_DRC_VS_MODE_UNKNOWN: AX_DRC_VS_MODE = 0;
pub type AX_DRC_VS_MODE = ::core::ffi::c_uint;
pub const AX_DRC_VS_OUTPUT_UNKNOWN: AX_DRC_VS_OUTPUT = 0;
pub type AX_DRC_VS_OUTPUT = ::core::ffi::c_uint;
pub const AX_DRC_VS_LC_UNKNOWN: AX_DRC_VS_LC = 0;
pub type AX_DRC_VS_LC = ::core::ffi::c_uint;
pub const AX_DRC_VS_SPEAKER_POS_UNKNOWN: AX_DRC_VS_SPEAKER_POS = 0;
pub type AX_DRC_VS_SPEAKER_POS = ::core::ffi::c_uint;
pub const AX_DRC_VS_SURROUND_GAIN_UNKNOWN: AX_DRC_VS_SURROUND_GAIN = 0;
pub type AX_DRC_VS_SURROUND_GAIN = ::core::ffi::c_uint;
extern "C" {
    pub fn AXGetDRCVSMode(mode: *mut AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSMode(mode: AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSDownmixBalance(output: AXDRCVSOutput, balance: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLC(lc: AXDRCVSLC) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiter(limit: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiterThreshold(threshold: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSOutputGain(output: AXDRCVSOutput, gain: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSpeakerPosition(
        output: AXDRCVSOutput,
        pos: AXDRCVSSpeakerPosition,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundDepth(output: AXDRCVSOutput, depth: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundLevelGain(gain: AXDRCVSSurroundLevelGain) -> AXResult;
}
pub type AXDeviceFinalMixCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void),
>;
pub type AXDeviceMode = u32;
pub type AXDeviceType = u32;
pub const AX_DEVICE_MODE_UNKNOWN: AX_DEVICE_MODE = 0;
pub type AX_DEVICE_MODE = ::core::ffi::c_uint;
pub const AX_DEVICE_TYPE_TV: AX_DEVICE_TYPE = 0;
pub const AX_DEVICE_TYPE_DRC: AX_DEVICE_TYPE = 1;
pub const AX_DEVICE_TYPE_CONTROLLER: AX_DEVICE_TYPE = 2;
pub type AX_DEVICE_TYPE = ::core::ffi::c_uint;
extern "C" {
    pub fn AXGetDeviceMode(type_: AXDeviceType, mode: *mut AXDeviceMode) -> AXResult;
}
extern "C" {
    pub fn AXGetDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: *mut AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXGetAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: *mut AXAuxCallback,
        userData: *mut *mut ::core::ffi::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: AXAuxCallback,
        userData: *mut ::core::ffi::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceLinearUpsampler(type_: AXDeviceType, unk0: u32, unk1: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceCompressor(type_: AXDeviceType, unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceUpsampleStage(type_: AXDeviceType, postFinalMix: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceVolume(type_: AXDeviceType, id: u32, volume: u16) -> AXResult;
}
pub type AXFrameCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type AXInitRenderer = u32;
pub type AXInitPipeline = u32;
pub const AX_INIT_RENDERER_32KHZ: AX_INIT_RENDERER = 0;
pub const AX_INIT_RENDERER_48KHZ: AX_INIT_RENDERER = 1;
pub type AX_INIT_RENDERER = ::core::ffi::c_uint;
pub const AX_INIT_PIPELINE_SINGLE: AX_INIT_PIPELINE = 0;
pub const AX_INIT_PIPELINE_FOUR_STAGE: AX_INIT_PIPELINE = 1;
pub type AX_INIT_PIPELINE = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXProfile {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXInitParams {
    pub renderer: AXInitRenderer,
    pub __unk78: [::core::ffi::c_char; 4usize],
    pub pipeline: AXInitPipeline,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXTransitionAudioBufferDevice {
    pub mode: AXDeviceMode,
    pub unk1: f32,
    pub unk2: u32,
    pub enabled: BOOL,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXTransitionAudioBuffer {
    pub unk1: u32,
    pub unk2: u32,
    pub length: u32,
    pub loopPoint: u32,
    pub audioBuffer: *mut ::core::ffi::c_void,
    pub audioBufferLen: u32,
    pub tv: AXTransitionAudioBufferDevice,
    pub drc: AXTransitionAudioBufferDevice,
}
impl Default for AXTransitionAudioBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn AXInit();
}
extern "C" {
    pub fn AXQuit();
}
extern "C" {
    pub fn AXInitWithParams(params: *mut AXInitParams);
}
extern "C" {
    pub fn AXIsInit() -> BOOL;
}
extern "C" {
    pub fn AXInitProfile(profile: *mut AXProfile, count: u32);
}
extern "C" {
    pub fn AXGetSwapProfile(profile: *mut AXProfile, count: u32) -> u32;
}
extern "C" {
    pub fn AXSetDefaultMixerSelect(unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
}
extern "C" {
    pub fn AXDeregisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
}
extern "C" {
    pub fn AXRegisterFrameCallback(callback: AXFrameCallback) -> AXFrameCallback;
}
extern "C" {
    pub fn AXGetInputSamplesPerFrame() -> u32;
}
extern "C" {
    pub fn AXGetInputSamplesPerSec() -> u32;
}
extern "C" {
    pub fn AXStartTransitionAudio();
}
extern "C" {
    pub fn AXSetUpTransitionAudio(buffer: *mut AXTransitionAudioBuffer);
}
pub type AXVoiceFormat = u16;
pub type AXVoiceLoop = u16;
pub type AXVoiceSrcType = u32;
pub type AXVoiceState = u32;
pub type AXVoiceRenderer = u32;
pub type AXVoiceSrcRatioResult = i32;
pub type AXVoiceType = u32;
pub type AXVoiceCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXVoiceCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32, arg3: u32),
>;
pub const AX_VOICE_FORMAT_ADPCM: AX_VOICE_FORMAT = 0;
pub const AX_VOICE_FORMAT_LPCM16: AX_VOICE_FORMAT = 10;
pub const AX_VOICE_FORMAT_LPCM8: AX_VOICE_FORMAT = 25;
pub type AX_VOICE_FORMAT = ::core::ffi::c_uint;
pub const AX_VOICE_LOOP_DISABLED: AX_VOICE_LOOP = 0;
pub const AX_VOICE_LOOP_ENABLED: AX_VOICE_LOOP = 1;
pub type AX_VOICE_LOOP = ::core::ffi::c_uint;
pub const AX_VOICE_RENDERER_DSP: AX_VOICE_RENDERER = 0;
pub const AX_VOICE_RENDERER_CPU: AX_VOICE_RENDERER = 1;
pub const AX_VOICE_RENDERER_AUTO: AX_VOICE_RENDERER = 2;
pub type AX_VOICE_RENDERER = ::core::ffi::c_uint;
pub const AX_VOICE_RATIO_RESULT_SUCCESS: AX_VOICE_RATIO_RESULT = 0;
pub const AX_VOICE_RATIO_RESULT_LESS_THAN_ZERO: AX_VOICE_RATIO_RESULT = -1;
pub const AX_VOICE_RATIO_RESULT_GREATER_THAN_SOMETHING: AX_VOICE_RATIO_RESULT = -2;
pub type AX_VOICE_RATIO_RESULT = ::core::ffi::c_int;
pub const AX_VOICE_SRC_TYPE_NONE: AX_VOICE_SRC_TYPE = 0;
pub const AX_VOICE_SRC_TYPE_LINEAR: AX_VOICE_SRC_TYPE = 1;
pub const AX_VOICE_SRC_TYPE_UNK0: AX_VOICE_SRC_TYPE = 2;
pub const AX_VOICE_SRC_TYPE_UNK1: AX_VOICE_SRC_TYPE = 3;
pub const AX_VOICE_SRC_TYPE_UNK2: AX_VOICE_SRC_TYPE = 4;
pub type AX_VOICE_SRC_TYPE = ::core::ffi::c_uint;
pub const AX_VOICE_STATE_STOPPED: AX_VOICE_STATE = 0;
pub const AX_VOICE_STATE_PLAYING: AX_VOICE_STATE = 1;
pub type AX_VOICE_STATE = ::core::ffi::c_uint;
pub const AX_VOICE_TYPE_UNKNOWN: AX_VOICE_TYPE = 0;
pub type AX_VOICE_TYPE = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceLink {
    pub next: *mut AXVoice,
    pub prev: *mut AXVoice,
}
impl Default for AXVoiceLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceOffsets {
    pub dataType: AXVoiceFormat,
    pub loopingEnabled: AXVoiceLoop,
    pub loopOffset: u32,
    pub endOffset: u32,
    pub currentOffset: u32,
    pub data: *const ::core::ffi::c_void,
}
impl Default for AXVoiceOffsets {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoice {
    pub index: u32,
    pub state: AXVoiceState,
    pub volume: u32,
    pub renderer: AXVoiceRenderer,
    pub link: AXVoiceLink,
    pub cbNext: *mut AXVoice,
    pub priority: u32,
    pub callback: AXVoiceCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub syncBits: u32,
    pub __unk79: [::core::ffi::c_char; 8usize],
    pub offsets: AXVoiceOffsets,
    pub callbackEx: AXVoiceCallbackExFn,
    pub callbackReason: u32,
    pub unk0: f32,
    pub unk1: f32,
}
impl Default for AXVoice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceDeviceBusMixData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceDeviceMixData {
    pub bus: [AXVoiceDeviceBusMixData; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceVeData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceAdpcmLoopData {
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceAdpcm {
    pub coefficients: [i16; 16usize],
    pub gain: u16,
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceSrc {
    pub ratio: u32,
    pub currentOffsetFrac: u16,
    pub lastSample: [i16; 4usize],
}
extern "C" {
    pub fn AXVoiceBegin(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXVoiceEnd(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXAcquireVoice(
        priority: u32,
        callback: AXVoiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXAcquireVoiceEx(
        priority: u32,
        callback: AXVoiceCallbackExFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXCheckVoiceOffsets(offsets: *mut AXVoiceOffsets) -> BOOL;
}
extern "C" {
    pub fn AXFreeVoice(voice: *mut AXVoice);
}
extern "C" {
    pub fn AXGetMaxVoices() -> u32;
}
extern "C" {
    pub fn AXGetVoiceCurrentOffsetEx(
        voice: *mut AXVoice,
        samples: *const ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    pub fn AXGetVoiceLoopCount(voice: *mut AXVoice) -> u32;
}
extern "C" {
    pub fn AXGetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXIsVoiceRunning(voice: *mut AXVoice) -> BOOL;
}
extern "C" {
    pub fn AXSetVoiceAdpcm(voice: *mut AXVoice, adpcm: *mut AXVoiceAdpcm);
}
extern "C" {
    pub fn AXSetVoiceAdpcmLoop(voice: *mut AXVoice, loopData: *mut AXVoiceAdpcmLoopData);
}
extern "C" {
    pub fn AXSetVoiceCurrentOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceDeviceMix(
        voice: *mut AXVoice,
        type_: AXDeviceType,
        id: u32,
        mixData: *mut AXVoiceDeviceMixData,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceEndOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceEndOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn AXSetVoiceInitialTimeDelay(voice: *mut AXVoice, delay: u16) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceLoopOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceLoopOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn AXSetVoiceLoop(voice: *mut AXVoice, loop_: AXVoiceLoop);
}
extern "C" {
    pub fn AXSetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXSetVoicePriority(voice: *mut AXVoice, priority: u32);
}
extern "C" {
    pub fn AXSetVoiceRmtIIRCoefs(voice: *mut AXVoice, filter: u16, ...);
}
extern "C" {
    pub fn AXSetVoiceSrc(voice: *mut AXVoice, src: *mut AXVoiceSrc);
}
extern "C" {
    pub fn AXSetVoiceSrcRatio(voice: *mut AXVoice, ratio: f32) -> AXVoiceSrcRatioResult;
}
extern "C" {
    pub fn AXSetVoiceSrcType(voice: *mut AXVoice, type_: AXVoiceSrcType);
}
extern "C" {
    pub fn AXSetVoiceState(voice: *mut AXVoice, state: AXVoiceState);
}
extern "C" {
    pub fn AXSetVoiceType(voice: *mut AXVoice, type_: AXVoiceType);
}
extern "C" {
    pub fn AXSetVoiceVe(voice: *mut AXVoice, veData: *mut AXVoiceVeData);
}
extern "C" {
    pub fn AXSetVoiceVeDelta(voice: *mut AXVoice, delta: i16);
}
extern "C" {
    pub fn GX2RSetAttributeBuffer(buffer: *mut GX2RBuffer, index: u32, stride: u32, offset: u32);
}
extern "C" {
    pub fn GX2RDrawIndexed(
        mode: GX2PrimitiveMode,
        buffer: *mut GX2RBuffer,
        indexType: GX2IndexType,
        count: u32,
        indexOffset: u32,
        vertexOffset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2RCreateSurface(surface: *mut GX2Surface, flags: GX2RResourceFlags) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateSurfaceUserMemory(
        surface: *mut GX2Surface,
        image: *mut u8,
        mipmap: *mut u8,
        flags: GX2RResourceFlags,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroySurfaceEx(surface: *mut GX2Surface, flags: GX2RResourceFlags) -> BOOL;
}
extern "C" {
    pub fn GX2RInvalidateSurface(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RLockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn GX2RUnlockSurfaceEx(surface: *mut GX2Surface, level: i32, flags: GX2RResourceFlags);
}
extern "C" {
    pub fn GX2RBeginDisplayListEx(
        displayList: *mut GX2RBuffer,
        unknown: u32,
        flags: GX2RResourceFlags,
    );
}
extern "C" {
    pub fn GX2REndDisplayList(displayList: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
extern "C" {
    pub fn GX2RDirectCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
pub type GX2RAllocFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags, arg2: u32, arg3: u32) -> *mut ::core::ffi::c_void,
>;
pub type GX2RFreeFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    pub fn GX2RInvalidateMemory(
        flags: GX2RResourceFlags,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
    );
}
extern "C" {
    pub fn GX2RIsUserMemory(flags: GX2RResourceFlags) -> BOOL;
}
extern "C" {
    pub fn GX2RSetAllocator(allocFn: GX2RAllocFunction, freeFn: GX2RFreeFunction);
}
extern "C" {
    pub fn CCRSetCompatMode(compatMode: u32) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRHIDReport {
    pub __unk80: [::core::ffi::c_char; 128usize],
}
impl Default for CCRHIDReport {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn CCRHIDStart(
        drcSlot: u32,
        reportsBuffer: *mut CCRHIDReport,
        numReports: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRHIDStop(
        drcSlot: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRHIDGetData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
}
extern "C" {
    pub fn CCRHIDGetBufferedData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
}
extern "C" {
    pub fn CCRHIDGetFirmwareVersion(report: *mut CCRHIDReport, firmwareVersion: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRHIDGetSequence(report: *mut CCRHIDReport, sequence: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRCFGInit() -> i32;
}
extern "C" {
    pub fn CCRCFGGetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCFGSetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCFGGetVersionCheckFlag(outFlag: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRCFGSetVersionCheckFlag(flag: u32) -> i32;
}
pub type NTAGError = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGFormatSettings {
    pub version: u8,
    pub __unk81: [::core::ffi::c_char; 3usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk82: [::core::ffi::c_char; 28usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGNoftHeader {
    pub magic: u32,
    pub version: u8,
    pub writeCount: u16,
    pub unknown: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGInfoHeader {
    pub rwHeaderOffset: u16,
    pub rwSize: u16,
    pub roHeaderOffset: u16,
    pub roSize: u16,
    pub uid: NFCUid,
    pub formatVersion: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGAreaHeader {
    pub magic: u16,
    pub offset: u16,
    pub size: u16,
    pub __unk83: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGAreaInfo {
    pub data: *mut ::core::ffi::c_void,
    pub size: u16,
    pub __unk84: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk85: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGAreaInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGData {
    pub uid: NFCUid,
    pub readOnly: u8,
    pub formatVersion: u8,
    pub __unk86: [::core::ffi::c_char; 3usize],
    pub rwInfo: NTAGAreaInfo,
    pub roInfo: NTAGAreaInfo,
    pub __unk87: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGInfoT2T {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub characterID: [u8; 3usize],
    pub numberingID: u16,
    pub figureType: u8,
    pub seriesID: u8,
    pub unknown: u32,
    pub applicationAreaWrites: u16,
    pub crcCounter: u16,
    pub crc: u32,
    pub fontRegion: u8,
    pub name: [u16; 10usize],
    pub mii: FFLStoreData,
    pub country: u8,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub accessID: u32,
    pub titleID: u64,
    pub reserved: [u8; 508usize],
}
impl Default for NTAGInfoT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGApplicationDataT2T {
    pub size: u16,
    pub data: [u8; 216usize],
}
impl Default for NTAGApplicationDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T {
    pub uid: [u8; 9usize],
    pub internal: u8,
    pub lockBytes: [u8; 2usize],
    pub capabilityContainer: [u8; 4usize],
    pub section0: NTAGRawDataT2T__bindgen_ty_1,
    pub section1: NTAGRawDataT2T__bindgen_ty_2,
    pub section2: NTAGRawDataT2T__bindgen_ty_3,
    pub applicationData: [u8; 216usize],
    pub dynamicLock: [u8; 3usize],
    pub reserved0: u8,
    pub cfg0: [u8; 4usize],
    pub cfg1: [u8; 4usize],
    pub pwd: [u8; 4usize],
    pub pack: [u8; 2usize],
    pub reserved1: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_1 {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub country: u8,
    pub crcCounter: u16,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub crc: u32,
    pub name: [u16; 10usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_2 {
    pub tagHmac: [u8; 32usize],
    pub characterID: [u8; 3usize],
    pub figureType: u8,
    pub numberingID: u16,
    pub seriesID: u8,
    pub formatVersion: u8,
    pub unknown: u32,
    pub keygenSalt: [u8; 32usize],
    pub dataHmac: [u8; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_3 {
    pub mii: FFLStoreData,
    pub titleID: u64,
    pub applicationAreaWrites: u16,
    pub accessID: u32,
    pub reserved: [u8; 34usize],
}
impl Default for NTAGRawDataT2T__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for NTAGRawDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataContainerT2T {
    pub size: u16,
    pub data: NTAGRawDataT2T,
}
impl Default for NTAGRawDataContainerT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGDataT2T {
    pub tagInfo: NFCTagInfo,
    pub formatVersion: u8,
    pub info: NTAGInfoT2T,
    pub appData: NTAGApplicationDataT2T,
    pub raw: NTAGRawDataContainerT2T,
    pub __unk88: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NTAGCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(chan: VPADChan, error: NTAGError, userContext: *mut ::core::ffi::c_void),
>;
pub type NTAGReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NTAGError,
        data: *mut NTAGData,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NTAGError,
        data: *mut NTAGDataT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan,
        error: NTAGError,
        tagInfo: *mut NFCTagInfo,
        rawData: *mut NTAGRawDataContainerT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn NTAGInit(chan: VPADChan) -> NTAGError;
}
extern "C" {
    pub fn NTAGInitEx(chan: VPADChan) -> NTAGError;
}
extern "C" {
    pub fn NTAGIsInit(chan: VPADChan) -> BOOL;
}
extern "C" {
    pub fn NTAGProc(chan: VPADChan);
}
extern "C" {
    pub fn NTAGShutdown(chan: VPADChan) -> NTAGError;
}
extern "C" {
    pub fn NTAGAbort(
        chan: VPADChan,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGFormat(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGSetReadOnly(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGSetTagDetectCallback(
        chan: VPADChan,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn NTAGSetFormatSettings(settings: *mut NTAGFormatSettings);
}
extern "C" {
    pub fn NTAGRead(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGReadT2T(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGReadT2TRawData(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWrite(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2T(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        dataContainer: *mut NTAGRawDataContainerT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TConfigArea(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        cfg0: *mut u32,
        cfg1: *mut u32,
        pwd: *mut u32,
        pack: *mut u16,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TLockArea(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        lockBytes: *mut u32,
        dynamicLock: *mut u32,
        cc: *mut u32,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TRawData(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TRawDataEx(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
        authenticate: u8,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TWithConvert(
        chan: VPADChan,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGConvertT2T(out: *mut NTAGDataT2T, in_: *mut NTAGDataT2T) -> NTAGError;
}
extern "C" {
    pub fn NTAGParseHeader(
        data: *mut ::core::ffi::c_void,
        outNoftHeader: *mut NTAGNoftHeader,
        outInfoHeader: *mut NTAGInfoHeader,
        outRwHeader: *mut NTAGAreaHeader,
        outRoHeader: *mut NTAGAreaHeader,
    ) -> NTAGError;
}
pub type NetConfEthCfgSpeed = u16;
pub type NetConfEthCfgDuplex = u16;
pub type NetConfEthCfgNegotiation = u16;
pub type NetConfWifiPrivacyMode = u16;
pub type NetConfProxyAuthType = u16;
pub type NetConfProxyStatus = u16;
pub type NetConfInterfaceType = u16;
pub type NetConfLinkState = u16;
pub type NetConfOperState = u16;
pub type NetConfAdminState = u16;
pub const NET_CONF_INTERFACE_TYPE_WIFI: NetConfInterfaceTypeEnum = 0;
pub const NET_CONF_INTERFACE_TYPE_ETHERNET: NetConfInterfaceTypeEnum = 1;
pub type NetConfInterfaceTypeEnum = ::core::ffi::c_uint;
pub const NET_CONF_ETH_CFG_SPEED_10M: NetConfEthCfgSpeedEnum = 10;
pub const NET_CONF_ETH_CFG_SPEED_100M: NetConfEthCfgSpeedEnum = 100;
pub type NetConfEthCfgSpeedEnum = ::core::ffi::c_uint;
pub const NET_CONF_ETH_CFG_DUPLEX_HALF: NetConfEthCfgDuplexEnum = 1;
pub const NET_CONF_ETH_CFG_DUPLEX_FULL: NetConfEthCfgDuplexEnum = 2;
pub type NetConfEthCfgDuplexEnum = ::core::ffi::c_uint;
pub const NET_CONF_ETH_CFG_NEGOTIATION_MANUAL: NetConfEthCfgNegotiationEnum = 1;
pub const NET_CONF_ETH_CFG_NEGOTIATION_AUTO: NetConfEthCfgNegotiationEnum = 2;
pub type NetConfEthCfgNegotiationEnum = ::core::ffi::c_uint;
pub const NET_CONF_IPV4_MODE_DHCP: NetConfIPv4Mode = 0;
pub const NET_CONF_IPV4_MODE_MANUAL: NetConfIPv4Mode = 2;
pub type NetConfIPv4Mode = ::core::ffi::c_uint;
pub const NET_CONF_WIFI_PRIVACY_MODE_NONE: NetConfWifiPrivacyModeEnum = 0;
pub const NET_CONF_WIFI_PRIVACY_MODE_WEP: NetConfWifiPrivacyModeEnum = 1;
pub const NET_CONF_WIFI_PRIVACY_MODE_WPA2_PSK_TKIP: NetConfWifiPrivacyModeEnum = 3;
pub const NET_CONF_WIFI_PRIVACY_MODE_WPA_PSK_TKIP: NetConfWifiPrivacyModeEnum = 4;
pub const NET_CONF_WIFI_PRIVACY_MODE_WPA2_PSK_AES: NetConfWifiPrivacyModeEnum = 5;
pub const NET_CONF_WIFI_PRIVACY_MODE_WPA_PSK_AES: NetConfWifiPrivacyModeEnum = 6;
pub type NetConfWifiPrivacyModeEnum = ::core::ffi::c_uint;
pub const NET_CONF_PROXY_AUTH_TYPE_NONE: NetConfProxyAuthTypeEnum = 0;
pub const NET_CONF_PROXY_AUTH_TYPE_BASIC_AUTHENTICATION: NetConfProxyAuthTypeEnum = 1;
pub type NetConfProxyAuthTypeEnum = ::core::ffi::c_uint;
pub const NET_CONF_PROXY_DISABLED: NetConfProxyStatusEnum = 0;
pub const NET_CONF_PROXY_ENABLED: NetConfProxyStatusEnum = 1;
pub type NetConfProxyStatusEnum = ::core::ffi::c_uint;
pub const NET_CONF_LINK_STATE_UP: NetConfLinkStateEnum = 1;
pub const NET_CONF_LINK_STATE_DOWN: NetConfLinkStateEnum = 2;
pub const NET_CONF_LINK_STATE_NEGOTIATE: NetConfLinkStateEnum = 3;
pub type NetConfLinkStateEnum = ::core::ffi::c_uint;
pub const NET_CONF_OPER_STATE_UP: NetConfOperStateEnum = 1;
pub const NET_CONF_OPER_STATE_DOWN: NetConfOperStateEnum = 2;
pub type NetConfOperStateEnum = ::core::ffi::c_uint;
pub const NET_CONF_ADMIN_STATE_UP: NetConfAdminStateEnum = 1;
pub const NET_CONF_ADMIN_STATE_DOWN: NetConfAdminStateEnum = 2;
pub type NetConfAdminStateEnum = ::core::ffi::c_uint;
pub const NET_CONF_PROFILE_0: NetConfProfile = 0;
pub const NET_CONF_PROFILE_1: NetConfProfile = 1;
pub const NET_CONF_PROFILE_2: NetConfProfile = 2;
pub const NET_CONF_PROFILE_3: NetConfProfile = 3;
pub const NET_CONF_PROFILE_4: NetConfProfile = 4;
pub const NET_CONF_PROFILE_5: NetConfProfile = 5;
pub type NetConfProfile = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NetConfAllProfileState {
    pub __unk89: [::core::ffi::c_char; 24usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NetConfEthCfg {
    pub speed: NetConfEthCfgSpeed,
    pub duplex: NetConfEthCfgDuplex,
    pub negotiation: NetConfEthCfgNegotiation,
    pub __unk90: [::core::ffi::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfIPv4Info {
    pub mode: NetConfIPv4Mode,
    pub addr: u32,
    pub netmask: u32,
    pub nexthop: u32,
    pub ns1: u32,
    pub ns2: u32,
}
impl Default for NetConfIPv4Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NetConfMACAddr {
    pub MACAddr: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfProxyConfig {
    pub use_proxy: NetConfProxyStatus,
    pub port: u16,
    pub __unk91: [::core::ffi::c_char; 2usize],
    pub auth_type: NetConfProxyAuthType,
    pub host: [::core::ffi::c_char; 128usize],
    pub username: [::core::ffi::c_char; 128usize],
    pub password: [::core::ffi::c_char; 64usize],
    pub noproxy_hosts: [::core::ffi::c_char; 128usize],
}
impl Default for NetConfProxyConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NetConfValidFlags {
    pub __unk92: [::core::ffi::c_char; 24usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfigDataPrivacy {
    pub mode: NetConfWifiPrivacyMode,
    pub __unk93: [::core::ffi::c_char; 2usize],
    pub aes_key_len: u16,
    pub aes_key: [u8; 64usize],
    pub __unk94: [::core::ffi::c_char; 2usize],
}
impl Default for NetConfWifiConfigDataPrivacy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfigData {
    pub ssid: [u8; 32usize],
    pub ssidlength: u16,
    pub __unk95: [::core::ffi::c_char; 2usize],
    pub privacy: NetConfWifiConfigDataPrivacy,
}
impl Default for NetConfWifiConfigData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfig {
    pub config_method: u16,
    pub __unk96: [::core::ffi::c_char; 2usize],
    pub config: NetConfWifiConfigData,
}
impl Default for NetConfWifiConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfOpt {
    pub __unk97: [::core::ffi::c_char; 705usize],
}
impl Default for NetConfOpt {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfInterface {
    pub if_index: u16,
    pub if_sate: u16,
    pub if_mtu: u32,
    pub ipv4Info: NetConfIPv4Info,
}
impl Default for NetConfInterface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfCfg {
    pub wl0: NetConfInterface,
    pub wifi: NetConfWifiConfig,
    pub eth0: NetConfInterface,
    pub ethCfg: NetConfEthCfg,
    pub proxy: NetConfProxyConfig,
}
impl Default for NetConfCfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfAOSSConfig {
    pub config: [NetConfWifiConfigData; 4usize],
}
impl Default for NetConfAOSSConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NetConfIfState {
    pub if_state: u16,
    pub linkstate: NetConfLinkState,
    pub operstate: NetConfOperState,
    pub __unk98: [::core::ffi::c_char; 2usize],
}
extern "C" {
    pub fn netconf_init() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_close() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_delete_profile(id: NetConfProfile) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_all_profile_state(state: *mut NetConfAllProfileState) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_address(
        interface: NetConfInterfaceType,
        assignedAddress: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_dns(
        interface: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_gateway(
        unk1: NetConfInterfaceType,
        gateway: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_subnet(
        unk1: NetConfInterfaceType,
        subnet: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_dns(
        unk1: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_eth_cfg(outCfg: *mut NetConfEthCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_adminstate(interface: NetConfInterfaceType) -> NetConfAdminState;
}
extern "C" {
    pub fn netconf_get_if_ipv4_info(info: *mut NetConfIPv4Info) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_ipv4_info_ex(
        interface: NetConfInterfaceType,
        info: *mut NetConfIPv4Info,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_linkstate(interface: NetConfInterfaceType) -> NetConfLinkState;
}
extern "C" {
    pub fn netconf_get_if_macaddr(
        interface: NetConfInterfaceType,
        info: *mut NetConfMACAddr,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_operstate(interface: NetConfInterfaceType) -> NetConfOperState;
}
extern "C" {
    pub fn netconf_get_ifstate(
        interface: NetConfInterfaceType,
        ifState: *mut NetConfIfState,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_interface_mtu(
        NetConfInterfaceType: NetConfInterfaceType,
        mtu: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_last_wifi_link_error(lastError: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_profile_state(
        interface: NetConfInterfaceType,
        profileState: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_proxy_config(proxyConfig: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn SOGetProxyConfig(config: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_running(running: *mut NetConfCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_startup_profile_id() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_valid_flags(validFlags: *mut NetConfValidFlags) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_wifi_cfg(wifiConfig: *mut NetConfWifiConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_getopt(
        unk1: u16,
        buffer: *mut NetConfOpt,
        bufferSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_read(profileId: NetConfProfile, data: *mut NetConfCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_write(profileId: NetConfProfile, data: *mut NetConfCfg)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_load(profileId: NetConfProfile) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_store(profileId: NetConfProfile) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_read_aoss_config(
        profileId: NetConfProfile,
        data: *mut NetConfAOSSConfig,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_write_aoss_config(
        profileId: NetConfProfile,
        data: *mut NetConfAOSSConfig,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_read_compat_profile_id(outProfileId: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_dns(
        interface: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_eth_cfg(config: *mut NetConfEthCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_admin_state(
        interface: NetConfInterfaceType,
        unk2: NetConfAdminStateEnum,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_ipv4_info(info: *mut NetConfIPv4Info) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_ipv4_info_ex(
        interface: NetConfInterfaceType,
        info: *mut NetConfIPv4Info,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_interface_mtu(
        interface: NetConfInterfaceType,
        mtu: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_proxy_config(config: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_running(config: *mut NetConfCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_startup_profile_id(profileId: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_valid_flag(unk1: u32, unk2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_wifi_cfg(config: *mut NetConfWifiConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_setopt(
        unk1: u16,
        buffer: *mut NetConfOpt,
        bufferSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_write_compat_profile_id(unk1: u32) -> ::core::ffi::c_int;
}
pub type nsysnet_fd_mask = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nsysnet_fd_set {
    pub __fds_bits: nsysnet_fd_mask,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nsysnet_timeval {
    pub tv_sec: ::core::ffi::c_long,
    pub tv_usec: ::core::ffi::c_long,
}
extern "C" {
    pub fn socket_lib_init();
}
extern "C" {
    pub fn socket_lib_finish();
}
extern "C" {
    pub fn __rplwrap_accept(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_bind(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socketclose(sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_connect(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getpeername(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getsockname(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_listen(
        sockfd: ::core::ffi::c_int,
        backlog: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_recv(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_recvfrom(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_send(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_sendto(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_setsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_shutdown(
        sockfd: ::core::ffi::c_int,
        how: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_select(
        nfds: ::core::ffi::c_int,
        readfds: *mut nsysnet_fd_set,
        writefds: *mut nsysnet_fd_set,
        exceptfds: *mut nsysnet_fd_set,
        timeout: *mut nsysnet_timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __rplwrap_inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socketlasterr() -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut h_errno: ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::core::ffi::c_char,
    pub h_aliases: *mut *mut ::core::ffi::c_char,
    pub h_addrtype: ::core::ffi::c_int,
    pub h_length: ::core::ffi::c_int,
    pub h_addr_list: *mut *mut ::core::ffi::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::core::ffi::c_char,
    pub s_aliases: *mut *mut ::core::ffi::c_char,
    pub s_port: ::core::ffi::c_int,
    pub s_proto: *mut ::core::ffi::c_char,
}
impl Default for servent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::core::ffi::c_int,
    pub ai_family: ::core::ffi::c_int,
    pub ai_socktype: ::core::ffi::c_int,
    pub ai_protocol: ::core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::core::ffi::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        addr: *const ::core::ffi::c_void,
        len: socklen_t,
        type_: ::core::ffi::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getservbyname(
        name: *const ::core::ffi::c_char,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        port: ::core::ffi::c_int,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getaddrinfo(
        node: *const ::core::ffi::c_char,
        service: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freeaddrinfo(res: *mut addrinfo);
}
extern "C" {
    pub fn getnameinfo(
        addr: *const sockaddr,
        addrlen: socklen_t,
        host: *mut ::core::ffi::c_char,
        hostlen: socklen_t,
        serv: *mut ::core::ffi::c_char,
        servlen: socklen_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gai_strerror(ecode: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __rplwrap_gethostbyaddr(
        addr: *const ::core::ffi::c_void,
        len: usize,
        type_: ::core::ffi::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn __rplwrap_gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
}
extern "C" {
    pub fn __rplwrap_getaddrinfo(
        node: *const ::core::ffi::c_char,
        service: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_freeaddrinfo(res: *mut addrinfo);
}
extern "C" {
    pub fn __rplwrap_getnameinfo(
        addr: *const sockaddr,
        addrlen: socklen_t,
        host: *mut ::core::ffi::c_char,
        hostlen: socklen_t,
        serv: *mut ::core::ffi::c_char,
        servlen: socklen_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_clear_resolver_cache();
}
extern "C" {
    pub fn __rplwrap_set_resolver_allocator(
        alloc: ::core::option::Option<unsafe extern "C" fn(arg1: u32) -> *mut ::core::ffi::c_void>,
        free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_get_h_errno() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_gai_strerror(ecode: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
pub type NSSLError = i32;
pub type NSSLContextHandle = i32;
pub type NSSLConnectionHandle = i32;
pub const NSSL_ERROR_OK: NSSLErrors = 0;
pub const NSSL_ERROR_GENERIC: NSSLErrors = -1;
pub const NSSL_ERROR_INVALID_NSSL_CONTEXT: NSSLErrors = -2621441;
pub const NSSL_ERROR_INVALID_CERT_ID: NSSLErrors = -2621442;
pub const NSSL_ERROR_CERT_LIMIT: NSSLErrors = -2621443;
pub const NSSL_ERROR_INVALID_NSSL_CONNECTION: NSSLErrors = -2621444;
pub const NSSL_ERROR_INVALID_CERT: NSSLErrors = -2621445;
pub const NSSL_ERROR_ZERO_RETURN: NSSLErrors = -2621446;
pub const NSSL_ERROR_WANT_READ: NSSLErrors = -2621447;
pub const NSSL_ERROR_WANT_WRITE: NSSLErrors = -2621448;
pub const NSSL_ERROR_IO_ERROR: NSSLErrors = -2621449;
pub const NSSL_ERROR_NSSL_LIB_ERROR: NSSLErrors = -2621450;
pub const NSSL_ERROR_UNKNOWN: NSSLErrors = -2621451;
pub const NSSL_ERROR_OUT_OF_MEMORY: NSSLErrors = -2621452;
pub const NSSL_ERROR_INVALID_STATE: NSSLErrors = -2621453;
pub const NSSL_ERROR_HANDSHAKE_ERROR: NSSLErrors = -2621454;
pub const NSSL_ERROR_NO_CERT: NSSLErrors = -2621455;
pub const NSSL_ERROR_INVALID_FD: NSSLErrors = -2621456;
pub const NSSL_ERROR_LIB_NOT_READY: NSSLErrors = -2621457;
pub const NSSL_ERROR_IPC_ERROR: NSSLErrors = -2621458;
pub const NSSL_ERROR_RESOURCE_LIMIT: NSSLErrors = -2621459;
pub const NSSL_ERROR_INVALID_HANDLE: NSSLErrors = -2621460;
pub const NSSL_ERROR_INVALID_CERT_TYPE: NSSLErrors = -2621461;
pub const NSSL_ERROR_INVALID_KEY_TYPE: NSSLErrors = -2621462;
pub const NSSL_ERROR_INVALID_SIZE: NSSLErrors = -2621463;
pub const NSSL_ERROR_NO_PEER_CERT: NSSLErrors = -2621464;
pub const NSSL_ERROR_INSUFFICIENT_SIZE: NSSLErrors = -2621465;
pub const NSSL_ERROR_NO_CIPHER: NSSLErrors = -2621466;
pub const NSSL_ERROR_INVALID_ARG: NSSLErrors = -2621467;
pub const NSSL_ERROR_INVALID_NSSL_SESSION: NSSLErrors = -2621468;
pub const NSSL_ERROR_NO_SESSION: NSSLErrors = -2621469;
pub const NSSL_ERROR_SSL_SHUTDOWN_ERROR: NSSLErrors = -2621470;
pub const NSSL_ERROR_CERT_SIZE_LIMIT: NSSLErrors = -2621471;
pub const NSSL_ERROR_CERT_NO_ACCESS: NSSLErrors = -2621472;
pub const NSSL_ERROR_INVALID_CERT_ID2: NSSLErrors = -2621473;
pub const NSSL_ERROR_CERT_READ_ERROR: NSSLErrors = -2621474;
pub const NSSL_ERROR_CERT_STORE_INIT_FAILURE: NSSLErrors = -2621475;
pub const NSSL_ERROR_INVALID_CERT_ENCODING: NSSLErrors = -2621476;
pub const NSSL_ERROR_CERT_STORE_ERROR: NSSLErrors = -2621477;
pub const NSSL_ERROR_PRIVATE_KEY_READ_ERROR: NSSLErrors = -2621478;
pub const NSSL_ERROR_INVALID_PRIVATE_KEY: NSSLErrors = -2621479;
pub const NSSL_ERROR_NOT_READY: NSSLErrors = -2621480;
pub const NSSL_ERROR_ENCRYPTION_ERROR: NSSLErrors = -2621481;
pub const NSSL_ERROR_NO_CERT_STORE: NSSLErrors = -2621482;
pub const NSSL_ERROR_PRIVATE_KEY_SIZE_LIMIT: NSSLErrors = -2621483;
pub const NSSL_ERROR_PROCESS_MAX_EXT_CERTS: NSSLErrors = -2621484;
pub const NSSL_ERROR_PROCESS_MAX_CONTEXTS: NSSLErrors = -2621485;
pub const NSSL_ERROR_PROCESS_MAX_CONNECTIONS: NSSLErrors = -2621486;
pub const NSSL_ERROR_CERT_NOT_EXPORTABLE: NSSLErrors = -2621487;
pub const NSSL_ERROR_INVALID_CERT_SIZE: NSSLErrors = -2621488;
pub const NSSL_ERROR_INVALID_KEY_SIZE: NSSLErrors = -2621489;
pub type NSSLErrors = ::core::ffi::c_int;
pub const NSSL_SERVER_CERT_GROUP_NINTENDO_FIRST: NSSLServerCertId = 100;
pub const NSSL_SERVER_CERT_NINTENDO_CA: NSSLServerCertId = 100;
pub const NSSL_SERVER_CERT_NINTENDO_CA_G2: NSSLServerCertId = 101;
pub const NSSL_SERVER_CERT_NINTENDO_CA_G3: NSSLServerCertId = 102;
pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA: NSSLServerCertId = 103;
pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G2: NSSLServerCertId = 104;
pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G3: NSSLServerCertId = 105;
pub const NSSL_SERVER_CERT_GROUP_NINTENDO_LAST: NSSLServerCertId = 105;
pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_FIRST: NSSLServerCertId = 1001;
pub const NSSL_SERVER_CERT_BALTIMORE_CYBERTRUST_ROOT_CA: NSSLServerCertId = 1001;
pub const NSSL_SERVER_CERT_CYBERTRUST_GLOBAL_ROOT_CA: NSSLServerCertId = 1002;
pub const NSSL_SERVER_CERT_VERIZON_GLOBAL_ROOT_CA: NSSLServerCertId = 1003;
pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA: NSSLServerCertId = 1004;
pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R2: NSSLServerCertId = 1005;
pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R3: NSSLServerCertId = 1006;
pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G3: NSSLServerCertId = 1007;
pub const NSSL_SERVER_CERT_VERISIGN_UNIVERSAL_ROOT_CA: NSSLServerCertId = 1008;
pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G5: NSSLServerCertId = 1009;
pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA_G3: NSSLServerCertId = 1010;
pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA: NSSLServerCertId = 1011;
pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA: NSSLServerCertId = 1012;
pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA2: NSSLServerCertId = 1013;
pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA: NSSLServerCertId = 1014;
pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA_G3: NSSLServerCertId = 1015;
pub const NSSL_SERVER_CERT_ADDTRUST_EXT_CA_ROOT: NSSLServerCertId = 1016;
pub const NSSL_SERVER_CERT_COMODO_CA: NSSLServerCertId = 1017;
pub const NSSL_SERVER_CERT_UTN_DATACORP_SGC_CA: NSSLServerCertId = 1018;
pub const NSSL_SERVER_CERT_UTN_USERFIRST_HARDWARE_CA: NSSLServerCertId = 1019;
pub const NSSL_SERVER_CERT_DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA: NSSLServerCertId = 1020;
pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA: NSSLServerCertId = 1021;
pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA: NSSLServerCertId = 1022;
pub const NSSL_SERVER_CERT_GTE_CYBERTRUST_GLOBAL_ROOT: NSSLServerCertId = 1023;
pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA: NSSLServerCertId = 1024;
pub const NSSL_SERVER_CERT_THAWTE_PREMIUM_SERVER_CA: NSSLServerCertId = 1025;
pub const NSSL_SERVER_CERT_EQUIFAX_SECURE_CA: NSSLServerCertId = 1026;
pub const NSSL_SERVER_CERT_ENTRUST_SECURE_SERVER_CA: NSSLServerCertId = 1027;
pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G2: NSSLServerCertId = 1028;
pub const NSSL_SERVER_CERT_ENTRUST_CA_2048: NSSLServerCertId = 1029;
pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA: NSSLServerCertId = 1030;
pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA_G2: NSSLServerCertId = 1031;
pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA_G2: NSSLServerCertId = 1032;
pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA_G2: NSSLServerCertId = 1033;
pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_LAST: NSSLServerCertId = 1033;
pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_FIRST: NSSLServerCertId = 1900;
pub const NSSL_SERVER_CERT_COMODO_RSA_CA: NSSLServerCertId = 1900;
pub const NSSL_SERVER_CERT_USERTRUST_RSA_CA: NSSLServerCertId = 1901;
pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_LAST: NSSLServerCertId = 1901;
pub type NSSLServerCertId = ::core::ffi::c_uint;
extern "C" {
    pub fn NSSLInit() -> NSSLError;
}
extern "C" {
    pub fn NSSLFinish() -> NSSLError;
}
extern "C" {
    pub fn NSSLCreateContext(unk: i32) -> NSSLContextHandle;
}
extern "C" {
    pub fn NSSLDestroyContext(context: NSSLContextHandle) -> NSSLError;
}
extern "C" {
    pub fn NSSLAddServerPKIExternal(
        context: NSSLContextHandle,
        cert: *const ::core::ffi::c_void,
        length: i32,
        unk: i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn NSSLAddServerPKI(context: NSSLContextHandle, pki: NSSLServerCertId) -> NSSLError;
}
extern "C" {
    pub fn NSSLCreateConnection(
        context: NSSLContextHandle,
        host: *const ::core::ffi::c_char,
        hostLength: i32,
        options: i32,
        socket: i32,
        block: i32,
    ) -> NSSLConnectionHandle;
}
extern "C" {
    pub fn NSSLDestroyConnection(connection: NSSLConnectionHandle) -> NSSLError;
}
extern "C" {
    pub fn NSSLRead(
        connection: NSSLConnectionHandle,
        buffer: *const ::core::ffi::c_void,
        length: i32,
        outBytesRead: *mut i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn NSSLWrite(
        connection: NSSLConnectionHandle,
        buffer: *const ::core::ffi::c_void,
        length: i32,
        outBytesWritten: *mut i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn set_multicast_state(multicastEnable: BOOL) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn AVMCECInit() -> BOOL;
}
extern "C" {
    pub fn AVMEnableCEC();
}
extern "C" {
    pub fn AVMDisableCEC();
}
extern "C" {
    pub fn AVMCECSendCommand(
        destination: TVECECLogicalAddress,
        opCode: TVECECOpCode,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
}
extern "C" {
    pub fn AVMCECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress,
        outOpCode: *mut TVECECOpCode,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
}
pub const AVM_DRC_SCAN_MODE_UNKNOWN_0: AVMDrcScanMode = 0;
pub const AVM_DRC_SCAN_MODE_UNKNOWN_1: AVMDrcScanMode = 1;
pub const AVM_DRC_SCAN_MODE_UNKNOWN_3: AVMDrcScanMode = 3;
pub const AVM_DRC_SCAN_MODE_UNKNOWN_255: AVMDrcScanMode = 255;
pub type AVMDrcScanMode = ::core::ffi::c_uint;
pub const AVM_DRC_MODE_NONE: AVMDrcMode = 0;
pub const AVM_DRC_MODE_SINGLE: AVMDrcMode = 1;
pub const AVM_DRC_MODE_DOUBLE: AVMDrcMode = 2;
pub type AVMDrcMode = ::core::ffi::c_uint;
pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_0: AVMDrcSystemAudioMode = 0;
pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_1: AVMDrcSystemAudioMode = 1;
pub const AVM_DRC_SYSTEM_AUDIO_MODE_SURROUND: AVMDrcSystemAudioMode = 2;
pub type AVMDrcSystemAudioMode = ::core::ffi::c_uint;
extern "C" {
    pub fn AVMGetSystemDRCAudioMode(outAudioMode: *mut AVMDrcSystemAudioMode)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn AVMGetDRCSystemAudioMode(outAudioMode: *mut AVMDrcSystemAudioMode) -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCVertCount() -> u32;
}
extern "C" {
    pub fn AVMIsDRCFirstFlippDone() -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCScanMode(outScanMode: *mut AVMDrcScanMode) -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCMode(outMode: *mut AVMDrcMode) -> BOOL;
}
extern "C" {
    pub fn AVMProbeDRCNum() -> u32;
}
extern "C" {
    pub fn AVMSetDRCEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn AVMSetDRCGamma(gamma: *mut f32) -> BOOL;
}
pub const AVM_TV_ASPECT_RATIO_4_3: AVMTvAspectRatio = 0;
pub const AVM_TV_ASPECT_RATIO_16_9: AVMTvAspectRatio = 1;
pub type AVMTvAspectRatio = ::core::ffi::c_uint;
pub const AVM_TV_RESOLUTION_576I: AVMTvResolution = 1;
pub const AVM_TV_RESOLUTION_480I: AVMTvResolution = 2;
pub const AVM_TV_RESOLUTION_480P: AVMTvResolution = 3;
pub const AVM_TV_RESOLUTION_720P: AVMTvResolution = 4;
pub const AVM_TV_RESOLUTION_720P_3D: AVMTvResolution = 5;
pub const AVM_TV_RESOLUTION_1080I: AVMTvResolution = 6;
pub const AVM_TV_RESOLUTION_1080P: AVMTvResolution = 7;
pub const AVM_TV_RESOLUTION_480I_PAL60: AVMTvResolution = 10;
pub const AVM_TV_RESOLUTION_576P: AVMTvResolution = 11;
pub const AVM_TV_RESOLUTION_720P_50HZ: AVMTvResolution = 12;
pub const AVM_TV_RESOLUTION_1080I_50HZ: AVMTvResolution = 13;
pub const AVM_TV_RESOLUTION_1080P_50HZ: AVMTvResolution = 14;
pub type AVMTvResolution = ::core::ffi::c_uint;
pub const AVM_TV_VIDEO_REGION_NTSC: AVMTvVideoRegion = 1;
pub const AVM_TV_VIDEO_REGION_PAL: AVMTvVideoRegion = 2;
pub type AVMTvVideoRegion = ::core::ffi::c_uint;
extern "C" {
    pub fn AVMDebugIsNTSC() -> BOOL;
}
extern "C" {
    pub fn AVMGetCurrentPort(outPort: *mut TVEPort) -> BOOL;
}
extern "C" {
    pub fn AVMGetHDMIState(outState: *mut TVEHdmiState);
}
extern "C" {
    pub fn AVMGetTVAspectRatio(outAspectRatio: *mut AVMTvAspectRatio) -> BOOL;
}
extern "C" {
    pub fn AVMGetTVScanMode(outResolution: *mut AVMTvResolution) -> BOOL;
}
extern "C" {
    pub fn AVMGetTVUnderScan(outUnderScan: *mut u32) -> i32;
}
extern "C" {
    pub fn AVMIsAVOutReady() -> BOOL;
}
extern "C" {
    pub fn AVMSetTVAspectRatio(aspectRatio: AVMTvAspectRatio) -> BOOL;
}
extern "C" {
    pub fn AVMSetTVEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn AVMSetTVOutPort(port: TVEPort, resolution: AVMTvResolution) -> i32;
}
extern "C" {
    pub fn AVMSetTVScanMode(resolution: AVMTvResolution, unknown: u32, port: TVEPort) -> i32;
}
extern "C" {
    pub fn AVMSetTVScanResolution(resolution: AVMTvResolution) -> i32;
}
extern "C" {
    pub fn AVMSetTVUnderScan(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMSetTVUnderScanParam(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMSetTVVideoRegion(
        videoRegion: AVMTvVideoRegion,
        port: TVEPort,
        resolution: AVMTvResolution,
    ) -> i32;
}
extern "C" {
    pub fn AVMReadSystemAspectRatioConfig(outAspectRatio: *mut AVMTvAspectRatio) -> i32;
}
extern "C" {
    pub fn AVMReadSystemPortConfig(outPort: *mut TVEPort) -> i32;
}
extern "C" {
    pub fn AVMReadSystemTVUnderScanConfig(outUnderScan: *mut u32) -> i32;
}
extern "C" {
    pub fn AVMReadSystemVideoResConfig(outResolution: *mut AVMTvResolution) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemAspectRatioConfig(aspectRatio: AVMTvAspectRatio) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemTVUnderScanConfig(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemVideoOutConfig(port: TVEPort, resolution: AVMTvResolution) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemVideoResConfig(resolution: AVMTvResolution) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsDeviceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUsb: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubclass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsConfigDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub bMaxPower: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsInterfaceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsSetupPacket {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
}
pub const UHS_STATUS_OK: UHSStatus = 0;
pub const UHS_STATUS_HANDLE_INVALID_ARGS: UHSStatus = 4292804605;
pub const UHS_STATUS_HANDLE_INVALID_STATE: UHSStatus = 4292804604;
pub type UHSStatus = ::core::ffi::c_uint;
pub const UHS_HANDLE_STATE_INIT: UHSHandleState = 0;
pub const UHS_HANDLE_STATE_OPENING: UHSHandleState = 1;
pub const UHS_HANDLE_STATE_OPENED: UHSHandleState = 2;
pub const UHS_HANDLE_STATE_CLOSING: UHSHandleState = 3;
pub const UHS_HANDLE_STATE_CLOSED: UHSHandleState = 4;
pub const UHS_HANDLE_STATE_ERROR: UHSHandleState = 5;
pub type UHSHandleState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsConfig {
    pub controller_num: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub buffer_size: u32,
}
impl Default for UhsConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsHandle {
    pub state: UHSHandleState,
    pub ipc_buffer: *mut ::core::ffi::c_void,
    pub __unk99: [::core::ffi::c_char; 4usize],
    pub handle: u32,
    pub config: *mut UhsConfig,
    pub __unk100: [::core::ffi::c_char; 4usize],
}
impl Default for UhsHandle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsInterfaceFilter {
    pub match_params: u16,
    pub vid: u16,
    pub pid: u16,
    pub __unk101: [::core::ffi::c_char; 4usize],
    pub dev_class: u8,
    pub dev_subclass: u8,
    pub dev_protocol: u8,
    pub if_class: u8,
    pub if_subclass: u8,
    pub if_protocol: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsEndpointDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
    pub __unk102: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsInterfaceProfile {
    pub if_handle: u32,
    pub __unk103: [::core::ffi::c_char; 36usize],
    pub dev_desc: UhsDeviceDescriptor,
    pub cfg_desc: UhsConfigDescriptor,
    pub if_desc: UhsInterfaceDescriptor,
    pub in_endpoints: [UhsEndpointDescriptor; 16usize],
    pub out_endpoints: [UhsEndpointDescriptor; 16usize],
}
impl Default for UhsInterfaceProfile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UHS_ADMIN_DEV_RESET: UHSAdminDevType = 1;
pub const UHS_ADMIN_DEV_FREEZE: UHSAdminDevType = 2;
pub const UHS_ADMIN_DEV_SUSPEND: UHSAdminDevType = 3;
pub const UHS_ADMIN_DEV_RESUME: UHSAdminDevType = 4;
pub const UHS_ADMIN_DEV_DESTROY: UHSAdminDevType = 5;
pub type UHSAdminDevType = ::core::ffi::c_uint;
pub const UHS_ADMIN_EP_ENABLE: UHSAdminEpType = 1;
pub const UHS_ADMIN_EP_DISABLE: UHSAdminEpType = 2;
pub const UHS_ADMIN_EP_CANCEL: UHSAdminEpType = 3;
pub const UHS_ADMIN_EP_CANCEL_RESET: UHSAdminEpType = 4;
pub type UHSAdminEpType = ::core::ffi::c_uint;
extern "C" {
    pub fn UhsClientOpen(handle: *mut UhsHandle, config: *mut UhsConfig) -> UHSStatus;
}
extern "C" {
    pub fn UhsClientClose(handle: *mut UhsHandle) -> UHSStatus;
}
pub type UHSDrvRegCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, profile: *mut UhsInterfaceProfile),
>;
extern "C" {
    pub fn UhsClassDrvReg(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        context: *mut ::core::ffi::c_void,
        callback: UHSDrvRegCallback,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsClassDrvUnReg(handle: *mut UhsHandle, drv_handle: u32) -> UHSStatus;
}
extern "C" {
    pub fn UhsGetFullConfigDescriptor(
        handle: *mut UhsHandle,
        if_handle: u32,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsGetDescriptorString(
        handle: *mut UhsHandle,
        if_handle: u32,
        string_index: u8,
        as_unicode: BOOL,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsQueryInterfaces(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        profiles: *mut UhsInterfaceProfile,
        max_profiles: i32,
    ) -> UHSStatus;
}
pub type UhsAcquireInterfaceCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, arg1: i32, arg2: i32),
>;
extern "C" {
    pub fn UhsAcquireInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        context: *mut ::core::ffi::c_void,
        callback: UhsAcquireInterfaceCallback,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsReleaseInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        no_reacquire: bool,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsAdministerDevice(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminDevType,
        arg3: i32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsAdministerEndpoint(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminEpType,
        endpointMask: u32,
        max_pending_requests: u32,
        max_request_size: u32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsClearEndpointHalt(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u32,
        direction: i32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsSubmitControlRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        buffer: *mut ::core::ffi::c_void,
        bRequest: u8,
        bmRequestType: u8,
        wValue: u16,
        wIndex: u16,
        wLength: u16,
        timeout: i32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsSubmitBulkRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus;
}
extern "C" {
    pub fn UhsSubmitInterruptRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSemaphore {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk104: [::core::ffi::c_char; 4usize],
    pub count: i32,
    pub queue: OSThreadQueue,
}
impl Default for OSSemaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitSemaphore(semaphore: *mut OSSemaphore, count: i32);
}
extern "C" {
    pub fn OSInitSemaphoreEx(
        semaphore: *mut OSSemaphore,
        count: i32,
        name: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSGetSemaphoreCount(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSSignalSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSTryWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
pub type OSFiberEntryFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type OSFiberExEntryFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32, arg3: u32, arg4: u32)>;
extern "C" {
    pub fn OSSwitchFiber(entry: OSFiberEntryFn, stack: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    pub fn OSSwitchFiberEx(
        arg1: u32,
        arg2: u32,
        arg3: u32,
        arg4: u32,
        entry: OSFiberExEntryFn,
        stack: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type OSDynLoad_Module = *mut ::core::ffi::c_void;
pub const OS_DYNLOAD_OK: OSDynLoad_Error = 0;
pub const OS_DYNLOAD_OUT_OF_MEMORY: OSDynLoad_Error = 3134259202;
pub const OS_DYNLOAD_INVALID_NOTIFY_PTR: OSDynLoad_Error = 3134259214;
pub const OS_DYNLOAD_INVALID_MODULE_NAME_PTR: OSDynLoad_Error = 3134259215;
pub const OS_DYNLOAD_INVALID_MODULE_NAME: OSDynLoad_Error = 3134259216;
pub const OS_DYNLOAD_INVALID_ACQUIRE_PTR: OSDynLoad_Error = 3134259217;
pub const OS_DYNLOAD_EMPTY_MODULE_NAME: OSDynLoad_Error = 3134259218;
pub const OS_DYNLOAD_INVALID_ALLOCATOR_PTR: OSDynLoad_Error = 3134259223;
pub const OS_DYNLOAD_OUT_OF_SYSTEM_MEMORY: OSDynLoad_Error = 3134259247;
pub const OS_DYNLOAD_TLS_ALLOCATOR_LOCKED: OSDynLoad_Error = 3134259249;
pub const OS_DYNLOAD_MODULE_NOT_FOUND: OSDynLoad_Error = 4294967290;
pub type OSDynLoad_Error = ::core::ffi::c_uint;
pub type OSDynLoadAllocFn = ::core::option::Option<
    unsafe extern "C" fn(
        size: i32,
        align: i32,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error,
>;
pub type OSDynLoadFreeFn =
    ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void)>;
pub const OS_DYNLOAD_EXPORT_FUNC: OSDynLoad_ExportType = 0;
pub const OS_DYNLOAD_EXPORT_DATA: OSDynLoad_ExportType = 1;
pub type OSDynLoad_ExportType = ::core::ffi::c_uint;
pub const OS_DYNLOAD_LOADED: OSDynLoad_EntryReason = 1;
pub const OS_DYNLOAD_UNLOADED: OSDynLoad_EntryReason = 2;
pub type OSDynLoad_EntryReason = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_NotifyData {
    pub name: *mut ::core::ffi::c_char,
    pub textAddr: u32,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: u32,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub readAddr: u32,
    pub readOffset: u32,
    pub readSize: u32,
}
impl Default for OSDynLoad_NotifyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSDynLoad_LoaderHeapStatistics {
    pub codeHeapUsed: u32,
    pub unk_0x04: u32,
    pub codeHeapFree: u32,
    pub codeHeapLargestFree: u32,
    pub dataHeapUsed: u32,
    pub unk_0x14: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_LoaderUserFileInfo {
    pub size: u32,
    pub magic: u32,
    pub pathStringLength: u32,
    pub pathString: *mut ::core::ffi::c_char,
    pub fileInfoFlags: u32,
    pub tlsModuleIndex: i16,
    pub tlsAlignShift: i16,
    pub tlsAddressStart: *mut ::core::ffi::c_void,
    pub tlsSectionSize: u32,
    pub shstrndx: u32,
    pub titleLocation: u32,
    pub __unk105: [::core::ffi::c_char; 56usize],
}
impl Default for OSDynLoad_LoaderUserFileInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OSDynLoad_LoaderSectionInfo {
    pub type_: u32,
    pub flags: u32,
    pub address: *mut ::core::ffi::c_void,
    pub __bindgen_anon_1: OSDynLoad_LoaderSectionInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSDynLoad_LoaderSectionInfo__bindgen_ty_1 {
    pub size: u32,
    pub name: u32,
}
impl Default for OSDynLoad_LoaderSectionInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for OSDynLoad_LoaderSectionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_InternalData {
    pub handle: u32,
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub moduleName: *mut ::core::ffi::c_char,
    pub moduleNameLen: u32,
    pub sectionInfoCount: u32,
    pub sectionInfo: *mut OSDynLoad_LoaderSectionInfo,
    pub importModules: *mut *mut OSDynLoad_InternalData,
    pub importModuleCount: u32,
    pub userFileInfoSize: u32,
    pub userFileInfo: *mut OSDynLoad_LoaderUserFileInfo,
    pub notifyData: *mut OSDynLoad_NotifyData,
    pub entryPoint: *mut ::core::ffi::c_void,
    pub dataSectionSize: u32,
    pub dataSection: *mut ::core::ffi::c_void,
    pub loadSectionSize: u32,
    pub loadSection: *mut ::core::ffi::c_void,
    pub dynLoadFreeFn: OSDynLoadFreeFn,
    pub codeExports: *mut ::core::ffi::c_void,
    pub numCodeExports: u32,
    pub dataExports: *mut ::core::ffi::c_void,
    pub numDataExports: u32,
    pub next: *mut OSDynLoad_InternalData,
    pub __unk106: [::core::ffi::c_char; 60usize],
}
impl Default for OSDynLoad_InternalData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OS_DYNLOAD_NOTIFY_UNLOADED: OSDynLoad_NotifyReason = 0;
pub const OS_DYNLOAD_NOTIFY_LOADED: OSDynLoad_NotifyReason = 1;
pub type OSDynLoad_NotifyReason = ::core::ffi::c_uint;
pub type OSDynLoadNotifyFunc = ::core::option::Option<
    unsafe extern "C" fn(
        module: OSDynLoad_Module,
        userContext: *mut ::core::ffi::c_void,
        notifyReason: OSDynLoad_NotifyReason,
        infos: *mut OSDynLoad_NotifyData,
    ),
>;
extern "C" {
    pub fn OSDynLoad_Acquire(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_FindExport(
        module: OSDynLoad_Module,
        exportType: OSDynLoad_ExportType,
        name: *const ::core::ffi::c_char,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_Release(module: OSDynLoad_Module);
}
extern "C" {
    pub fn OSDynLoad_SetAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_GetAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_SetTLSAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_GetTLSAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_GetLoaderHeapStatistics(
        outLoaderHeapStatistics: *mut OSDynLoad_LoaderHeapStatistics,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_GetModuleName(
        module: OSDynLoad_Module,
        nameBuf: *mut ::core::ffi::c_char,
        nameBufSize: *mut i32,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_GetNumberOfRPLs() -> i32;
}
extern "C" {
    pub fn OSDynLoad_GetRPLInfo(
        first: u32,
        count: u32,
        outInfos: *mut OSDynLoad_NotifyData,
    ) -> BOOL;
}
extern "C" {
    pub fn OSDynLoad_IsModuleLoaded(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_AddNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn OSDynLoad_DelNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error;
}
extern "C" {
    pub fn rpl_entry(module: OSDynLoad_Module, reason: OSDynLoad_EntryReason)
        -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct OSStopwatch {
    pub lock: OSSpinLock,
    pub name: *const ::core::ffi::c_char,
    pub hitCount: u32,
    pub totalTime: OSTime,
    pub minTime: OSTime,
    pub maxTime: OSTime,
    pub startTime: OSTime,
    pub running: BOOL,
    pub __unk107: [::core::ffi::c_char; 4usize],
}
impl Default for OSStopwatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitStopwatch(stopwatch: *mut OSStopwatch, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSResetStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSStartStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSStopStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSCheckStopwatch(stopwatch: *mut OSStopwatch) -> OSTime;
}
extern "C" {
    pub fn OSDumpStopwatch(stopwatch: *mut OSStopwatch);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexLink {
    pub next: *mut OSMutex,
    pub prev: *mut OSMutex,
}
impl Default for OSMutexLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk108: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
    pub owner: *mut OSThread,
    pub count: i32,
    pub link: OSMutexLink,
}
impl Default for OSMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitMutex(mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSInitMutexEx(mutex: *mut OSMutex, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSLockMutex(mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSTryLockMutex(mutex: *mut OSMutex) -> BOOL;
}
extern "C" {
    pub fn OSUnlockMutex(mutex: *mut OSMutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPoolFIFO {
    pub pushIndex: i32,
    pub popIndex: i32,
    pub count: i32,
    pub maxCount: i32,
    pub messages: *mut *mut ::core::ffi::c_void,
}
impl Default for IPCBufPoolFIFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IPCBufPoolAttributes {
    pub messageSize: u32,
    pub poolSize: u32,
    pub numMessages: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPool {
    pub magic: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub size: u32,
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub messageSize0x14: u32,
    pub messageSize0x18: u32,
    pub messageCount: u32,
    pub messages: *mut ::core::ffi::c_void,
    pub messageIndexSize: *mut u32,
    pub fifo: IPCBufPoolFIFO,
    pub mutex: OSMutex,
    pub __unk109: [::core::ffi::c_char; 4usize],
}
impl Default for IPCBufPool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn IPCBufPoolCreate(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        messageSize: u32,
        outNumMessages: *mut u32,
        unk0x0c: u32,
    ) -> *mut IPCBufPool;
}
extern "C" {
    pub fn IPCBufPoolAllocate(pool: *mut IPCBufPool, size: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn IPCBufPoolFree(pool: *mut IPCBufPool, message: *mut ::core::ffi::c_void) -> IOSError;
}
extern "C" {
    pub fn IPCBufPoolGetAttributes(
        pool: *mut IPCBufPool,
        attribs: *mut IPCBufPoolAttributes,
    ) -> IOSError;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSRendezvous {
    pub core: [u32; 3usize],
    pub __unk110: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn OSInitRendezvous(rendezvous: *mut OSRendezvous);
}
extern "C" {
    pub fn OSWaitRendezvous(rendezvous: *mut OSRendezvous, coreMask: u32) -> BOOL;
}
extern "C" {
    pub fn OSWaitRendezvousWithTimeout(
        rendezvous: *mut OSRendezvous,
        coreMask: u32,
        timeout: OSTime,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk111: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
impl Default for OSFastCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSFastCond_Init(condition: *mut OSFastCondition, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSFastCond_Wait(condition: *mut OSFastCondition, mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastCond_Signal(condition: *mut OSFastCondition);
}
pub const OS_ICI_COMMAND_INVALID_IC_RANGE: OSICICommand = 1;
pub const OS_ICI_COMMAND_RESCHEDULE_CORE: OSICICommand = 2;
pub const OS_ICI_COMMAND_HALT_CORE: OSICICommand = 3;
pub const OS_ICI_COMMAND_PROC_EXIT: OSICICommand = 4;
pub const OS_ICI_COMMAND_SET_DABR: OSICICommand = 5;
pub const OS_ICI_COMMAND_PROC_SCHED: OSICICommand = 6;
pub const OS_ICI_COMMAND_FAST_BG_EXIT: OSICICommand = 7;
pub const OS_ICI_COMMAND_IOP_SHELL_CORE_TRACE: OSICICommand = 8;
pub const OS_ICI_COMMAND_SYSTEM_FATAL: OSICICommand = 9;
pub const OS_ICI_COMMAND_SET_IABR: OSICICommand = 10;
pub const OS_ICI_COMMAND_PANIC_0X15: OSICICommand = 11;
pub const OS_ICI_COMMAND_PROC_KILL: OSICICommand = 12;
pub const OS_ICI_COMMAND_PROC_CRASH: OSICICommand = 13;
pub const OS_ICI_COMMAND_UNKNOWN: OSICICommand = 14;
pub const OS_ICI_COMMAND_OVERLAY_ARENA: OSICICommand = 15;
pub type OSICICommand = ::core::ffi::c_uint;
pub type OSExceptionCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(
        exceptionType: OSExceptionType,
        interruptedContext: *mut OSContext,
        cbContext: *mut OSContext,
    ),
>;
pub type KernelTimerCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        exception: OSExceptionType,
        interruptedContext: *mut OSContext,
        currentContext: *mut OSContext,
    ),
>;
pub type KernelTimerHandle = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSExceptionChainInfo {
    pub callback: OSExceptionCallbackExFn,
    pub stack: *mut ::core::ffi::c_void,
    pub context: *mut OSContext,
}
impl Default for OSExceptionChainInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0 {
    pub upid: i32,
    pub rampid: i32,
    pub appFlags: u32,
    pub dataAreaStart: *mut ::core::ffi::c_void,
    pub dataAreaEnd: *mut ::core::ffi::c_void,
    pub physDataAreaStart: *mut ::core::ffi::c_void,
    pub physDataAreaEnd: *mut ::core::ffi::c_void,
    pub physAvailStart: *mut ::core::ffi::c_void,
    pub physAvailEnd: *mut ::core::ffi::c_void,
    pub physCodeGenStart: *mut ::core::ffi::c_void,
    pub physCodeGenEnd: *mut ::core::ffi::c_void,
    pub sdaBase: *mut ::core::ffi::c_void,
    pub sda2Base: *mut ::core::ffi::c_void,
    pub systemHeapSize: u32,
    pub stackEnd0: *mut ::core::ffi::c_void,
    pub stackEnd1: *mut ::core::ffi::c_void,
    pub stackEnd2: *mut ::core::ffi::c_void,
    pub stackBase0: *mut ::core::ffi::c_void,
    pub stackBase1: *mut ::core::ffi::c_void,
    pub stackBase2: *mut ::core::ffi::c_void,
    pub exceptionStackEnd0: *mut ::core::ffi::c_void,
    pub exceptionStackEnd1: *mut ::core::ffi::c_void,
    pub exceptionStackEnd2: *mut ::core::ffi::c_void,
    pub exceptionStackBase0: *mut ::core::ffi::c_void,
    pub exceptionStackBase1: *mut ::core::ffi::c_void,
    pub exceptionStackBase2: *mut ::core::ffi::c_void,
    pub lockedCacheBase0: *mut ::core::ffi::c_void,
    pub lockedCacheBase1: *mut ::core::ffi::c_void,
    pub lockedCacheBase2: *mut ::core::ffi::c_void,
    pub coreinit: KernelInfo0_CoreinitInfo,
    pub unk0x9C: u32,
    pub titleId: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0_CoreinitInfo {
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub textAddr: *mut ::core::ffi::c_void,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: *mut ::core::ffi::c_void,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub loadAddr: *mut ::core::ffi::c_void,
    pub loadOffset: u32,
    pub loadSize: u32,
}
impl Default for KernelInfo0_CoreinitInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for KernelInfo0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo6 {
    pub osTitleId: u64,
    pub unk0x08: u32,
    pub __unk112: [::core::ffi::c_char; 252usize],
}
impl Default for KernelInfo6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __KernelSetUserModeExHandler(
        exceptionType: OSExceptionType,
        chainInfo: *mut OSExceptionChainInfo,
        prevChainInfo: *mut OSExceptionChainInfo,
    );
}
extern "C" {
    pub fn __KernelAllocateTimer(
        arg1: KernelTimerCallbackFn,
        exceptionStack: *mut ::core::ffi::c_void,
        context: *mut OSContext,
    ) -> KernelTimerHandle;
}
extern "C" {
    pub fn __KernelPrimeTimer(
        handle: KernelTimerHandle,
        startTimeInTicks: u64,
        intervalInTicks: u64,
        unknown: u32,
    ) -> u32;
}
extern "C" {
    pub fn __KernelSendICI(
        cmd: OSICICommand,
        arg1: *mut ::core::ffi::c_void,
        unknown1: u32,
        unknown2: u32,
    );
}
extern "C" {
    pub fn __KernelGetInfo(
        type_: u32,
        outBuffer: *mut ::core::ffi::c_void,
        outBufferSize: u32,
        core: u32,
    );
}
pub type IMEventMask = u32;
pub const IM_PAD_TYPE_NONE: IMPadType = 0;
pub const IM_PAD_TYPE_WII_REMOTE: IMPadType = 1;
pub const IM_PAD_TYPE_WIIU_PRO_CONTROLLER: IMPadType = 2;
pub const IM_PAD_TYPE_WII_REMOTE_EXTENSION: IMPadType = 3;
pub const IM_PAD_TYPE_WIIU_GAMEPAD: IMPadType = 4;
pub type IMPadType = ::core::ffi::c_uint;
pub const IM_DEVICE_STATE_CLEAR: IMDeviceState = 0;
pub const IM_DEVICE_STATE_INACTIVE: IMDeviceState = 1;
pub const IM_DEVICE_STATE_ACTIVE: IMDeviceState = 2;
pub const IM_DEVICE_STATE_HOME: IMDeviceState = 3;
pub const IM_DEVICE_STATE_POWER: IMDeviceState = 4;
pub const IM_DEVICE_STATE_SYNC: IMDeviceState = 5;
pub type IMDeviceState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMRequest {
    pub args: [u8; 128usize],
    pub ioctlVecs: [IOSVec; 2usize],
    pub handle: IOSHandle,
    pub request: i32,
    pub asyncCallback: IOSAsyncCallbackFn,
    pub asyncCallbackContext: *mut ::core::ffi::c_void,
    pub copySrc: *mut ::core::ffi::c_void,
    pub copyDst: *mut ::core::ffi::c_void,
    pub copySize: u32,
}
impl Default for IMRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMHomeButtonParams {
    pub type_: IMPadType,
    pub index: i32,
}
impl Default for IMHomeButtonParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMParameters {
    pub resetEnabled: u32,
    pub dimEnabled: u32,
    pub dimPeriod: u32,
    pub apdEnabled: u32,
    pub apdPeriod: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMDeviceStateEx {
    pub state: IMDeviceState,
    pub params: IMHomeButtonParams,
}
impl Default for IMDeviceStateEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IM_PARAMETER_INACTIVE_SECONDS: IMParameter = 0;
pub const IM_PARAMETER_DIM_ENABLED: IMParameter = 1;
pub const IM_PARAMETER_DIM_PERIOD: IMParameter = 2;
pub const IM_PARAMETER_APD_ENABLED: IMParameter = 3;
pub const IM_PARAMETER_APD_PERIOD: IMParameter = 4;
pub const IM_PARAMETER_RESET_ENABLE: IMParameter = 5;
pub const IM_PARAMETER_RESET_SECONDS: IMParameter = 6;
pub const IM_PARAMETER_POWER_OFF_ENABLE: IMParameter = 7;
pub const IM_PARAMETER_APD_OCCURED: IMParameter = 8;
pub const IM_PARAMETER_DIM_ENABLE_TV: IMParameter = 9;
pub const IM_PARAMETER_DIM_ENABLE_DRC: IMParameter = 10;
pub const IM_PARAMETER_MAX: IMParameter = 11;
pub type IMParameter = ::core::ffi::c_uint;
pub const IM_TIMER_DIM: IMTimer = 0;
pub const IM_TIMER_APD: IMTimer = 1;
pub type IMTimer = ::core::ffi::c_uint;
pub const IM_EVENT_ACTIVE: IMEvent = 1;
pub const IM_EVENT_INACTIVE: IMEvent = 2;
pub const IM_EVENT_DIM: IMEvent = 4;
pub const IM_EVENT_UNDIM: IMEvent = 8;
pub const IM_EVENT_APD: IMEvent = 16;
pub const IM_EVENT_POWER: IMEvent = 32;
pub const IM_EVENT_HOME: IMEvent = 64;
pub const IM_EVENT_SYNC: IMEvent = 128;
pub const IM_EVENT_RESET: IMEvent = 256;
pub const IM_EVENT_CANCELLED: IMEvent = -2147483648;
pub type IMEvent = ::core::ffi::c_int;
extern "C" {
    pub fn IM_Open() -> IOSHandle;
}
extern "C" {
    pub fn IM_Close(handle: IOSHandle) -> IOSError;
}
extern "C" {
    pub fn IM_GetHomeButtonParams(
        handle: IOSHandle,
        request: *mut IMRequest,
        output: *mut IMHomeButtonParams,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_GetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_GetParameters(parameters: *mut IMParameters) -> IOSError;
}
extern "C" {
    pub fn IM_GetNvParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_GetNvParameterWithoutHandleAndItb(
        parameter: IMParameter,
        outValue: *mut u32,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_GetRuntimeParameter(parameter: IMParameter, outValue: *mut u32) -> IOSError;
}
extern "C" {
    pub fn IM_GetTimerRemaining(
        handle: IOSHandle,
        request: *mut IMRequest,
        timer: IMTimer,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_GetTimerRemainingSeconds(timer: IMTimer, outSeconds: *mut u32) -> IOSError;
}
extern "C" {
    pub fn IM_SetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter,
        value: u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_SetRuntimeParameter(parameter: IMParameter, value: u32) -> IOSError;
}
extern "C" {
    pub fn IM_GetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        event: *mut IMEventMask,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_CancelGetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_SetDeviceState(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: IMDeviceState,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn IM_SetDeviceStateEx(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: *mut IMDeviceStateEx,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError;
}
extern "C" {
    pub fn __rplwrap_exit(code: ::core::ffi::c_int);
}
extern "C" {
    pub fn _Exit(code: ::core::ffi::c_int) -> !;
}
pub type IMError = i32;
extern "C" {
    pub fn IMDisableAPD() -> IMError;
}
extern "C" {
    pub fn IMDisableDim() -> IMError;
}
extern "C" {
    pub fn IMEnableAPD() -> IMError;
}
extern "C" {
    pub fn IMEnableDim() -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabledBySysSettings(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsDimEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableDRC(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableTV(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimPeriod(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeAPD(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeDimming(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableDRC(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableTV(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMStartAPDVideoMode() -> IMError;
}
extern "C" {
    pub static mut __OSSchedulerLock: *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSEnableScheduler();
}
extern "C" {
    pub fn __OSDisableScheduler();
}
extern "C" {
    pub fn __OSLockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn __OSUnlockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSIsSchedulerLocked(lockId: *mut ::core::ffi::c_void) -> BOOL;
}
extern "C" {
    pub fn __OSTryLockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn __OSTouchSchedulerLock();
}
extern "C" {
    pub fn DCInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCFlushRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCStoreRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCFlushRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCStoreRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCZeroRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCTouchRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn ICInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn OSMemoryBarrier();
}
pub const OS_SAVED_FRAME_A: OSSavedFrameType = 0;
pub const OS_SAVED_FRAME_B: OSSavedFrameType = 1;
pub type OSSavedFrameType = ::core::ffi::c_uint;
pub const OS_SAVED_FRAME_SCREEN_TV: OSSavedFrameScreen = 2;
pub const OS_SAVED_FRAME_SCREEN_DRC: OSSavedFrameScreen = 4;
pub type OSSavedFrameScreen = ::core::ffi::c_uint;
extern "C" {
    pub fn __OSClearSavedFrame(type_: OSSavedFrameType, screen: OSSavedFrameScreen) -> u32;
}
extern "C" {
    pub fn __OSGetSavedFrame(
        screen: OSSavedFrameScreen,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameA(
        screen: OSSavedFrameScreen,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameB(
        screen: OSSavedFrameScreen,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameGammaA(screen: OSSavedFrameScreen, outGamma: *mut f32) -> BOOL;
}
extern "C" {
    pub fn __OSGetSavedFrameGammaB(screen: OSSavedFrameScreen, outGamma: *mut f32) -> BOOL;
}
extern "C" {
    pub fn __OSGetSavedFramePtr(
        type_: OSSavedFrameType,
        screen: OSSavedFrameScreen,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFramePtrForRead(screen: OSSavedFrameScreen) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFramePtrForWrite(screen: OSSavedFrameScreen) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFrames() -> u32;
}
extern "C" {
    pub fn __OSGetSavedFramesA() -> u32;
}
extern "C" {
    pub fn __OSGetSavedFramesB() -> u32;
}
extern "C" {
    pub fn __OSResetSavedFrame(screen: OSSavedFrameScreen);
}
extern "C" {
    pub fn __OSSetSavedFrame(
        screen: OSSavedFrameScreen,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSSetSavedFrameGamma(gamma: f32, screen: OSSavedFrameScreen);
}
pub const OS_INTERRUPT_TYPE_ERROR: OSInterruptType = 0;
pub const OS_INTERRUPT_TYPE_DSP: OSInterruptType = 1;
pub const OS_INTERRUPT_TYPE_GPU7: OSInterruptType = 2;
pub const OS_INTERRUPT_TYPE_GPIPPC: OSInterruptType = 3;
pub const OS_INTERRUPT_TYPE_PRIMARYI2C: OSInterruptType = 4;
pub const OS_INTERRUPT_TYPE_DSPAI: OSInterruptType = 5;
pub const OS_INTERRUPT_TYPE_DSPAI2: OSInterruptType = 6;
pub const OS_INTERRUPT_TYPE_DSPACC: OSInterruptType = 7;
pub const OS_INTERRUPT_TYPE_DSPDSP: OSInterruptType = 8;
pub const OS_INTERRUPT_TYPE_IPCPPC0: OSInterruptType = 9;
pub const OS_INTERRUPT_TYPE_IPCPPC1: OSInterruptType = 10;
pub const OS_INTERRUPT_TYPE_IPCPPC2: OSInterruptType = 11;
pub const OS_INTERRUPT_TYPE_AHB: OSInterruptType = 12;
pub type OSInterruptType = ::core::ffi::c_uint;
pub type OSUserInterruptHandler = ::core::option::Option<
    unsafe extern "C" fn(type_: OSInterruptType, interruptedContext: *mut OSContext),
>;
extern "C" {
    pub fn OSEnableInterrupts() -> BOOL;
}
extern "C" {
    pub fn OSDisableInterrupts() -> BOOL;
}
extern "C" {
    pub fn OSRestoreInterrupts(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSIsInterruptEnabled() -> BOOL;
}
extern "C" {
    pub fn __OSSetInterruptHandler(
        type_: OSInterruptType,
        handler: OSUserInterruptHandler,
    ) -> OSUserInterruptHandler;
}
extern "C" {
    pub fn __OSClearAndEnableInterrupt(type_: OSInterruptType);
}
extern "C" {
    pub fn __OSDisableInterrupt(type_: OSInterruptType);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk113: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
impl Default for OSCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn OSInitCond(condition: *mut OSCondition);
}
extern "C" {
    pub fn OSInitCondEx(condition: *mut OSCondition, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSWaitCond(condition: *mut OSCondition, mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSSignalCond(condition: *mut OSCondition);
}
pub const COS_REPORT_LEVEL_ERROR: COSReportLevel = 0;
pub const COS_REPORT_LEVEL_WARN: COSReportLevel = 1;
pub const COS_REPORT_LEVEL_INFO: COSReportLevel = 2;
pub const COS_REPORT_LEVEL_VERBOSE: COSReportLevel = 3;
pub type COSReportLevel = ::core::ffi::c_uint;
pub const COS_REPORT_MODULE_UNKNOWN_0: COSReportModule = 0;
pub const COS_REPORT_MODULE_UNKNOWN_1: COSReportModule = 1;
pub const COS_REPORT_MODULE_UNKNOWN_2: COSReportModule = 2;
pub const COS_REPORT_MODULE_UNKNOWN_5: COSReportModule = 5;
pub type COSReportModule = ::core::ffi::c_uint;
extern "C" {
    pub fn COSVReport(
        module: COSReportModule,
        level: COSReportLevel,
        fmt: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn COSError(module: COSReportModule, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSInfo(module: COSReportModule, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSVerbose(module: COSReportModule, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSWarn(module: COSReportModule, fmt: *const ::core::ffi::c_char, ...);
}
pub type UCError = i32;
pub type UCHandle = i32;
pub const UC_CMD_READ_SYS_CONFIG: UCCommand = 48;
pub const UC_CMD_WRITE_SYS_CONFIG: UCCommand = 49;
pub const UC_CMD_DELETE_SYS_CONFIG: UCCommand = 50;
pub const UC_CMD_QUERY_SYS_CONFIG: UCCommand = 51;
pub const UC_CMD_LIST_SYS_CONFIG: UCCommand = 52;
pub type UCCommand = ::core::ffi::c_uint;
pub const UC_DATATYPE_UNDEFINED: UCDataType = 0;
pub const UC_DATATYPE_UNSIGNED_BYTE: UCDataType = 1;
pub const UC_DATATYPE_UNSIGNED_SHORT: UCDataType = 2;
pub const UC_DATATYPE_UNSIGNED_INT: UCDataType = 3;
pub const UC_DATATYPE_SIGNED_INT: UCDataType = 4;
pub const UC_DATATYPE_FLOAT: UCDataType = 5;
pub const UC_DATATYPE_STRING: UCDataType = 6;
pub const UC_DATATYPE_HEXBINARY: UCDataType = 7;
pub const UC_DATATYPE_COMPLEX: UCDataType = 8;
pub const UC_DATATYPE_INVALID: UCDataType = 255;
pub type UCDataType = ::core::ffi::c_uint;
pub const UC_ERROR_OK: UCErrors = 0;
pub const UC_ERROR_ERROR: UCErrors = -1;
pub const UC_ERROR_OTHER: UCErrors = -2097153;
pub const UC_ERROR_SYSTEM: UCErrors = -2097154;
pub const UC_ERROR_ALLOC: UCErrors = -2097155;
pub const UC_ERROR_OPCODE: UCErrors = -2097156;
pub const UC_ERROR_INVALID_PARAM: UCErrors = -2097157;
pub const UC_ERROR_INVALID_TYPE: UCErrors = -2097158;
pub const UC_ERROR_UNSUPPORTED: UCErrors = -2097159;
pub const UC_ERROR_NON_LEAF_NODE: UCErrors = -2097160;
pub const UC_ERROR_KEY_NOT_FOUND: UCErrors = -2097161;
pub const UC_ERROR_MODIFY: UCErrors = -2097162;
pub const UC_ERROR_STRING_TOO_LONG: UCErrors = -2097163;
pub const UC_ERROR_ROOT_KEYS_DIFFER: UCErrors = -2097164;
pub const UC_ERROR_INVALID_LOCATION: UCErrors = -2097165;
pub const UC_ERROR_BAD_COMMENT: UCErrors = -2097166;
pub const UC_ERROR_READ_ACCESS: UCErrors = -2097167;
pub const UC_ERROR_WRITE_ACCESS: UCErrors = -2097168;
pub const UC_ERROR_CREATE_ACCESS: UCErrors = -2097169;
pub const UC_ERROR_FILE_SYS_NAME: UCErrors = -2097170;
pub const UC_ERROR_FILE_SYS_INIT: UCErrors = -2097171;
pub const UC_ERROR_FILE_SYS_MOUNT: UCErrors = -2097172;
pub const UC_ERROR_FILE_OPEN: UCErrors = -2097173;
pub const UC_ERROR_FILE_STAT: UCErrors = -2097174;
pub const UC_ERROR_FILE_READ: UCErrors = -2097175;
pub const UC_ERROR_FILE_WRITE: UCErrors = -2097176;
pub const UC_ERROR_FILE_TOO_BIG: UCErrors = -2097177;
pub const UC_ERROR_FILE_REMOVE: UCErrors = -2097178;
pub const UC_ERROR_FILE_RENAME: UCErrors = -2097179;
pub const UC_ERROR_FILE_CLOSE: UCErrors = -2097180;
pub const UC_ERROR_FILE_SEEK: UCErrors = -2097181;
pub const UC_ERROR_FILE_CONFIRM: UCErrors = -2097182;
pub const UC_ERROR_FILE_BACKUP: UCErrors = -2097183;
pub const UC_ERROR_MALFORMED_XML: UCErrors = -2097184;
pub const UC_ERROR_VERSION: UCErrors = -2097185;
pub const UC_ERROR_NO_IPC_BUFFERS: UCErrors = -2097186;
pub const UC_ERROR_FILE_LOCK_NEEDED: UCErrors = -2097188;
pub const UC_ERROR_SYS_PROT: UCErrors = -2097192;
pub type UCErrors = ::core::ffi::c_int;
pub const UC_FILE_SYS_INVALID: UCFileSys = 0;
pub const UC_FILE_SYS_SYS: UCFileSys = 1;
pub const UC_FILE_SYS_SLC: UCFileSys = 2;
pub const UC_FILE_SYS_RAM: UCFileSys = 3;
pub type UCFileSys = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCSysConfig {
    pub name: [::core::ffi::c_char; 64usize],
    pub access: u32,
    pub dataType: UCDataType,
    pub error: UCError,
    pub dataSize: u32,
    pub data: *mut ::core::ffi::c_void,
}
impl Default for UCSysConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type UCAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: UCError,
        command: UCCommand,
        count: u32,
        settings: *mut UCSysConfig,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCAsyncParams {
    pub callback: UCAsyncCallbackFn,
    pub context: *mut ::core::ffi::c_void,
    pub command: UCCommand,
    pub unk0x0C: u32,
    pub count: u32,
    pub settings: *mut UCSysConfig,
    pub vecs: *mut IOSVec,
}
impl Default for UCAsyncParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn UCOpen() -> UCHandle;
}
extern "C" {
    pub fn UCClose(handle: UCHandle) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn __OSClearCopyData();
}
extern "C" {
    pub fn __OSAppendCopyData(data: *const ::core::ffi::c_void, size: u32) -> BOOL;
}
extern "C" {
    pub fn __OSGetCopyDataPtr() -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetCopyDataSize() -> u32;
}
extern "C" {
    pub fn __OSResizeCopyData(size: u32) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic(ptr: *mut u32, compare: u32, value: u32) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx(ptr: *mut u32, compare: u32, value: u32, old: *mut u32)
        -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSAddAtomic(ptr: *mut i32, value: i32) -> i32;
}
extern "C" {
    pub fn OSAndAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSOrAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSXorAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSTestAndClearAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSGetCoreCount() -> u32;
}
extern "C" {
    pub fn OSGetCoreId() -> u32;
}
extern "C" {
    pub fn OSGetMainCoreId() -> u32;
}
extern "C" {
    pub fn OSIsMainCore() -> BOOL;
}
pub const SMD_LOCK_TYPE_MUTEX: SmdLockType = 0;
pub const SMD_LOCK_TYPE_DISABLE_INTERRUPTS: SmdLockType = 1;
pub const SMD_LOCK_TYPE_NONE: SmdLockType = 2;
pub type SmdLockType = ::core::ffi::c_uint;
pub const SMD_PPC_STATE_INVALID: SmdPpcState = 0;
pub const SMD_PPC_STATE_INITIALIZED: SmdPpcState = 1;
pub const SMD_PPC_STATE_CLOSED: SmdPpcState = 2;
pub const SMD_PPC_STATE_OPENED: SmdPpcState = 3;
pub type SmdPpcState = ::core::ffi::c_uint;
pub const SMD_INTERFACE_STATE_OPENED: SmdInterfaceState = 8738;
pub const SMD_INTERFACE_STATE_CLOSED: SmdInterfaceState = 13107;
pub type SmdInterfaceState = ::core::ffi::c_uint;
pub const SMD_ELEMENT_TYPE_MESSAGE: SmdElementType = 0;
pub const SMD_ELEMENT_TYPE_VECTOR_SPEC: SmdElementType = 1;
pub const SMD_ELEMENT_TYPE_VECTOR: SmdElementType = 2;
pub type SmdElementType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVectorSpec {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SmdVectorSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVector {
    pub command: u32,
    pub count: i32,
    pub vecs: [SmdVectorSpec; 4usize],
}
impl Default for SmdVector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdElement {
    pub type_: SmdElementType,
    pub size: u32,
    pub __bindgen_anon_1: SmdElement__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdElement__bindgen_ty_1 {
    pub data: [u8; 248usize],
    pub spec: SmdVector,
    pub vectorPaddr: u32,
}
impl Default for SmdElement__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SmdElement {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdReceiveData {
    pub type_: SmdElementType,
    pub size: u32,
    pub __bindgen_anon_1: SmdReceiveData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdReceiveData__bindgen_ty_1 {
    pub message: [u8; 128usize],
    pub spec: SmdVector,
    pub vector: *mut SmdVector,
}
impl Default for SmdReceiveData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SmdReceiveData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdInterface {
    pub state: SmdInterfaceState,
    pub __unk114: [::core::ffi::c_char; 124usize],
    pub elementCount: u32,
    pub __unk115: [::core::ffi::c_char; 124usize],
    pub readOffset: i32,
    pub __unk116: [::core::ffi::c_char; 124usize],
    pub writeOffset: i32,
    pub __unk117: [::core::ffi::c_char; 124usize],
    pub bufPaddr: u32,
    pub __unk118: [::core::ffi::c_char; 124usize],
}
impl Default for SmdInterface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdCtrlTable {
    pub name: [::core::ffi::c_char; 16usize],
    pub reusedCount: u32,
    pub __unk119: [::core::ffi::c_char; 108usize],
    pub iopInterface: SmdInterface,
    pub __unk120: [::core::ffi::c_char; 64usize],
    pub ppcInterface: SmdInterface,
    pub __unk121: [::core::ffi::c_char; 64usize],
}
impl Default for SmdCtrlTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpcCtrlTableVectors {
    pub ctrlTable: *mut SmdCtrlTable,
    pub ctrlTableSize: u32,
    pub writeBuf: *mut SmdElement,
    pub writeBufSize: u32,
    pub readBuf: *mut SmdElement,
    pub readBufSize: u32,
}
impl Default for SmdPpcCtrlTableVectors {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpc {
    pub self_: *mut SmdPpc,
    pub ctrlTable: *mut SmdCtrlTable,
    pub lockType: SmdLockType,
    pub mutex: OSMutex,
    pub messageCount: u32,
    pub writeBuf: *mut SmdElement,
    pub readBuf: *mut SmdElement,
    pub state: SmdPpcState,
    pub __unk122: [::core::ffi::c_char; 56usize],
}
impl Default for SmdPpc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdSimpleBufPool {
    pub self_: *mut SmdSimpleBufPool,
    pub mutex: OSMutex,
    pub poolData: *mut ::core::ffi::c_void,
    pub poolDataSize: u32,
    pub lockType: SmdLockType,
    pub allocSize: u32,
    pub realAllocSize: u32,
    pub maxAllocCount: u32,
    pub allocPoolStart: *mut ::core::ffi::c_void,
    pub allocPoolEnd: *mut ::core::ffi::c_void,
    pub elementsIn: u32,
    pub freeErrorCount: u32,
    pub __unk123: [::core::ffi::c_char; 40usize],
}
impl Default for SmdSimpleBufPool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn smdPpcInit(
        buf: *mut ::core::ffi::c_void,
        bufSize: u32,
        messageCount: u32,
        name: *const ::core::ffi::c_char,
        lockType: SmdLockType,
    ) -> *mut SmdPpc;
}
extern "C" {
    pub fn smdPpcGetCtrlTableVectors(
        smd: *mut SmdPpc,
        outVectors: *mut SmdPpcCtrlTableVectors,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcOpen(smd: *mut SmdPpc) -> i32;
}
extern "C" {
    pub fn smdPpcClose(smd: *mut SmdPpc) -> i32;
}
extern "C" {
    pub fn smdPpcGetInterfaceState(
        smd: *mut SmdPpc,
        outPpcState: *mut SmdInterfaceState,
        outIopState: *mut SmdInterfaceState,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcReceive(smd: *mut SmdPpc, data: *mut SmdReceiveData) -> i32;
}
extern "C" {
    pub fn smdPpcSendMessage(
        smd: *mut SmdPpc,
        message: *mut ::core::ffi::c_void,
        messageSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcSendVectorSpec(
        smd: *mut SmdPpc,
        command: u32,
        specs: *mut SmdVectorSpec,
        specsCount: i32,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcSendVector(smd: *mut SmdPpc, vector: *mut SmdVector) -> i32;
}
extern "C" {
    pub fn smdSimpleBufPoolCreate(
        poolData: *mut ::core::ffi::c_void,
        poolDataSize: u32,
        allocSize: u32,
        allocCount: u32,
        lockType: SmdLockType,
    ) -> *mut SmdSimpleBufPool;
}
extern "C" {
    pub fn smdSimpleBufAlloc(
        pool: *mut SmdSimpleBufPool,
        outAlloc: *mut *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn smdSimpleBufFree(pool: *mut SmdSimpleBufPool, alloc: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    pub fn smdSimpleBufGetStatistics(
        pool: *mut SmdSimpleBufPool,
        allocCount: *mut u32,
        freeErrorCount: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn __OSGetSavedAudioFlags() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSGetTransitionAudioBuffer(
        buffer: *mut *mut ::core::ffi::c_void,
        size: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSSetTransitionAudioSize(size: u32);
}
pub type DisassemblyPrintFn =
    ::core::option::Option<unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, ...)>;
pub type DisassemblyFindSymbolFn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32,
>;
pub const DISASSEMBLE_PPC_FLAGS_NONE: DisassemblePPCFlags = 0;
pub type DisassemblePPCFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
}
extern "C" {
    pub fn __OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
}
extern "C" {
    pub fn OSReport(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportVerbose(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportInfo(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportWarn(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSPanic(
        file: *const ::core::ffi::c_char,
        line: u32,
        fmt: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn OSFatal(msg: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSGetSymbolName(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32;
}
extern "C" {
    pub fn OSGetUPID() -> u32;
}
extern "C" {
    pub fn OSIsDebuggerInitialized() -> BOOL;
}
extern "C" {
    pub fn OSIsDebuggerPresent() -> BOOL;
}
extern "C" {
    pub fn OSIsECOBoot() -> BOOL;
}
extern "C" {
    pub fn OSIsECOMode() -> BOOL;
}
extern "C" {
    pub fn __OSSetCrashRecovery(crashRecovery: u32);
}
extern "C" {
    pub fn __OSGetCrashRecovery() -> u32;
}
extern "C" {
    pub fn DisassemblePPCOpcode(
        opcode: *mut u32,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags,
    ) -> BOOL;
}
extern "C" {
    pub fn DisassemblePPCRange(
        start: *mut ::core::ffi::c_void,
        end: *mut ::core::ffi::c_void,
        printFn: DisassemblyPrintFn,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags,
    );
}
pub type BSPError = i32;
pub type BSPHardwareVersion = u32;
pub type BSPConsoleTypeRaw = u32;
pub const BSP_ERROR_OK: BSPErrors = 0;
pub const BSP_ERROR_IOS_ERROR: BSPErrors = 64;
pub const BSP_ERROR_RESPONSE_TOO_LARGE: BSPErrors = 128;
pub type BSPErrors = ::core::ffi::c_uint;
pub const BSP_HARDWARE_VERSION_UNKNOWN: BSPHardwareVersions = 0;
pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_1: BSPHardwareVersions = 1;
pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_2: BSPHardwareVersions = 268435457;
pub const BSP_HARDWARE_VERSION_HOLLYWOOD_PROD_FOR_WII: BSPHardwareVersions = 269484033;
pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO: BSPHardwareVersions = 269484040;
pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO_ESPRESSO: BSPHardwareVersions = 269484044;
pub const BSP_HARDWARE_VERSION_BOLLYWOOD: BSPHardwareVersions = 536870913;
pub const BSP_HARDWARE_VERSION_BOLLYWOOD_PROD_FOR_WII: BSPHardwareVersions = 537919489;
pub const BSP_HARDWARE_VERSION_LATTE_A11_EV: BSPHardwareVersions = 554696720;
pub const BSP_HARDWARE_VERSION_LATTE_A11_CAT: BSPHardwareVersions = 554696736;
pub const BSP_HARDWARE_VERSION_LATTE_A12_EV: BSPHardwareVersions = 555745296;
pub const BSP_HARDWARE_VERSION_LATTE_A12_CAT: BSPHardwareVersions = 555745312;
pub const BSP_HARDWARE_VERSION_LATTE_A2X_EV: BSPHardwareVersions = 571473936;
pub const BSP_HARDWARE_VERSION_LATTE_A2X_CAT: BSPHardwareVersions = 571473952;
pub const BSP_HARDWARE_VERSION_LATTE_A3X_EV: BSPHardwareVersions = 588251152;
pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAT: BSPHardwareVersions = 588251168;
pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAFE: BSPHardwareVersions = 588251176;
pub const BSP_HARDWARE_VERSION_LATTE_A4X_EV: BSPHardwareVersions = 605028368;
pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAT: BSPHardwareVersions = 605028384;
pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAFE: BSPHardwareVersions = 605028392;
pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV: BSPHardwareVersions = 621805584;
pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV_Y: BSPHardwareVersions = 621805585;
pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAT: BSPHardwareVersions = 621805600;
pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAFE: BSPHardwareVersions = 621805608;
pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV: BSPHardwareVersions = 638582800;
pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV_Y: BSPHardwareVersions = 638582801;
pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAT: BSPHardwareVersions = 638582816;
pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAFE: BSPHardwareVersions = 638582824;
pub type BSPHardwareVersions = ::core::ffi::c_uint;
extern "C" {
    pub fn bspInitializeShimInterface() -> BSPError;
}
extern "C" {
    pub fn bspShutdownShimInterface() -> BSPError;
}
extern "C" {
    pub fn bspGetHardwareVersion(version: *mut BSPHardwareVersion) -> BSPError;
}
extern "C" {
    pub fn bspGetConsoleTypeRaw(consoleTypeRaw: *mut BSPConsoleTypeRaw) -> BSPError;
}
extern "C" {
    pub fn bspInitialize(
        entityName: *const ::core::ffi::c_char,
        instance: u32,
        attributeName: *const ::core::ffi::c_char,
        optionSize: u32,
        pOptions: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspShutdown(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
    ) -> BSPError;
}
extern "C" {
    pub fn bspGetEntityVersion(
        entityName: *const ::core::ffi::c_char,
        entityVersion: *mut u32,
    ) -> BSPError;
}
extern "C" {
    pub fn bspRead(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspWrite(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspQuery(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn OSEnableForegroundExit();
}
extern "C" {
    pub fn OSReleaseForeground();
}
extern "C" {
    pub fn OSSavesDone_ReadyToRelease();
}
extern "C" {
    pub fn OSGetAtomic64(ptr: *mut u64) -> u64;
}
extern "C" {
    pub fn OSSetAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic64(ptr: *mut u64, compare: u64, value: u64) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx64(
        ptr: *mut u64,
        compare: u64,
        value: u64,
        old: *mut u64,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSAddAtomic64(ptr: *mut i64, value: i64) -> i64;
}
extern "C" {
    pub fn OSAndAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSOrAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSXorAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSTestAndClearAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
extern "C" {
    pub fn __os_snprintf(
        buf: *mut ::core::ffi::c_char,
        n: usize,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
pub type MPTaskFunc = ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32) -> u32>;
pub const MP_TASK_STATE_INITIALISED: MPTaskState = 1;
pub const MP_TASK_STATE_READY: MPTaskState = 2;
pub const MP_TASK_STATE_RUNNING: MPTaskState = 4;
pub const MP_TASK_STATE_FINISHED: MPTaskState = 8;
pub type MPTaskState = ::core::ffi::c_uint;
pub const MP_TASK_QUEUE_STATE_INITIALISED: MPTaskQueueState = 1;
pub const MP_TASK_QUEUE_STATE_READY: MPTaskQueueState = 2;
pub const MP_TASK_QUEUE_STATE_STOPPING: MPTaskQueueState = 4;
pub const MP_TASK_QUEUE_STATE_STOPPED: MPTaskQueueState = 8;
pub const MP_TASK_QUEUE_STATE_FINISHED: MPTaskQueueState = 16;
pub type MPTaskQueueState = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskInfo {
    pub state: MPTaskState,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
}
impl Default for MPTaskInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTask {
    pub self_: *mut MPTask,
    pub queue: *mut MPTaskQueue,
    pub state: MPTaskState,
    pub func: MPTaskFunc,
    pub userArg1: u32,
    pub userArg2: u32,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
    pub userData: *mut ::core::ffi::c_void,
}
impl Default for MPTask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueueInfo {
    pub state: MPTaskQueueState,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub tasksFinished: u32,
}
impl Default for MPTaskQueueInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueue {
    pub self_: *mut MPTaskQueue,
    pub state: MPTaskQueueState,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub __unk124: [::core::ffi::c_char; 4usize],
    pub tasksFinished: u32,
    pub __unk125: [::core::ffi::c_char; 8usize],
    pub queueIndex: u32,
    pub __unk126: [::core::ffi::c_char; 8usize],
    pub queueSize: u32,
    pub __unk127: [::core::ffi::c_char; 4usize],
    pub queue: *mut *mut MPTask,
    pub queueMaxSize: u32,
    pub lock: OSSpinLock,
}
impl Default for MPTaskQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn MPInitTaskQ(queue: *mut MPTaskQueue, queueBuffer: *mut *mut MPTask, queueBufferLen: u32);
}
extern "C" {
    pub fn MPTermTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskQInfo(queue: *mut MPTaskQueue, info: *mut MPTaskQueueInfo) -> BOOL;
}
extern "C" {
    pub fn MPStartTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPStopTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPResetTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPEnqueTask(queue: *mut MPTaskQueue, task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPDequeTask(queue: *mut MPTaskQueue) -> *mut MPTask;
}
extern "C" {
    pub fn MPDequeTasks(
        queue: *mut MPTaskQueue,
        queueBuffer: *mut *mut MPTask,
        queueBufferLen: u32,
    ) -> u32;
}
extern "C" {
    pub fn MPWaitTaskQ(queue: *mut MPTaskQueue, mask: MPTaskQueueState) -> BOOL;
}
extern "C" {
    pub fn MPWaitTaskQWithTimeout(
        queue: *mut MPTaskQueue,
        wmask: MPTaskQueueState,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn MPPrintTaskQStats(queue: *mut MPTaskQueue, unk: u32) -> BOOL;
}
extern "C" {
    pub fn MPInitTask(task: *mut MPTask, func: MPTaskFunc, userArg1: u32, userArg2: u32);
}
extern "C" {
    pub fn MPTermTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskInfo(task: *mut MPTask, info: *mut MPTaskInfo) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskUserData(task: *mut MPTask) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MPSetTaskUserData(task: *mut MPTask, userData: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MPRunTasksFromTaskQ(queue: *mut MPTaskQueue, count: u32) -> BOOL;
}
extern "C" {
    pub fn MPRunTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn OSForceFullRelaunch();
}
extern "C" {
    pub fn OSRestartGame(argc: ::core::ffi::c_int, argv: *mut *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn OSShutdown() -> BOOL;
}
extern "C" {
    pub fn OSLaunchTitleByPathl(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        ...
    );
}
extern "C" {
    pub fn OSLaunchTitleByPathv(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSLaunchTitlel(titleId: u64, argc: ::core::ffi::c_int, ...);
}
extern "C" {
    pub fn OSLaunchTitlev(
        titleId: u64,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
}
pub const OS_MAP_MEMORY_INVALID: OSMemoryMapMode = 0;
pub const OS_MAP_MEMORY_READ_ONLY: OSMemoryMapMode = 1;
pub const OS_MAP_MEMORY_READ_WRITE: OSMemoryMapMode = 2;
pub const OS_MAP_MEMORY_FREE: OSMemoryMapMode = 3;
pub const OS_MAP_MEMORY_ALLOCATED: OSMemoryMapMode = 4;
pub type OSMemoryMapMode = ::core::ffi::c_uint;
extern "C" {
    pub fn OSEffectiveToPhysical(virtualAddress: u32) -> u32;
}
extern "C" {
    pub fn __OSPhysicalToEffectiveCached(physicalAddress: u32) -> u32;
}
extern "C" {
    pub fn __OSPhysicalToEffectiveUncached(physicalAddress: u32) -> u32;
}
extern "C" {
    pub fn OSIsAddressValid(virtualAddress: u32) -> BOOL;
}
extern "C" {
    pub fn __OSValidateAddressSpaceRange(
        arg1: ::core::ffi::c_int,
        virtualAddress: u32,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn OSAllocVirtAddr(virtualAddress: u32, size: u32, align: u32) -> u32;
}
extern "C" {
    pub fn OSFreeVirtAddr(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    pub fn OSQueryVirtAddr(virtualAddress: u32) -> OSMemoryMapMode;
}
extern "C" {
    pub fn OSMapMemory(
        virtualAddress: u32,
        physicalAddress: u32,
        size: u32,
        mode: OSMemoryMapMode,
    ) -> BOOL;
}
extern "C" {
    pub fn OSUnmapMemory(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    pub fn OSGetMapVirtAddrRange(outVirtualAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    pub fn OSGetAvailPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    pub fn OSGetDataPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
pub type FSACommand = u32;
pub type FSAIpcRequestType = u16;
pub type FSAClientHandle = IOSHandle;
pub type FSAFileHandle = u32;
pub type FSADirectoryHandle = u32;
pub type FSAEntryNum = u32;
pub type FSADirectoryEntry = FSDirectoryEntry;
pub type FSAStat = FSStat;
pub type FSAFilePosition = u32;
pub type FSAVolumeInfo = FSVolumeInfo;
pub type FSAAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSABlockInfo {
    pub __unk128: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSADeviceInfo {
    pub __unk129: [::core::ffi::c_char; 8usize],
    pub deviceSizeInSectors: u64,
    pub deviceSectorSize: u32,
    pub __unk130: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAFileSystemInfo {
    pub __unk131: [::core::ffi::c_char; 30usize],
}
pub const FSA_MOUNT_PRIORITY_BASE: FSAMountPriority = 1;
pub const FSA_MOUNT_PRIORITY_RAM_DISK_CACHE: FSAMountPriority = 4;
pub const FSA_MOUNT_PRIORITY_TITLE_UPDATE: FSAMountPriority = 9;
pub const FSA_MOUNT_PRIORITY_UNMOUNT_ALL: FSAMountPriority = 2147483648;
pub type FSAMountPriority = ::core::ffi::c_uint;
pub const FSA_QUERY_INFO_FREE_SPACE_SIZE: FSAQueryInfoType = 0;
pub const FSA_QUERY_INFO_DIR_SIZE: FSAQueryInfoType = 1;
pub const FSA_QUERY_INFO_ENTRY_NUM: FSAQueryInfoType = 2;
pub const FSA_QUERY_INFO_FILE_SYSTEM_INFO: FSAQueryInfoType = 3;
pub const FSA_QUERY_INFO_DEVICE_INFO: FSAQueryInfoType = 4;
pub const FSA_QUERY_INFO_STAT: FSAQueryInfoType = 5;
pub const FSA_QUERY_INFO_BAD_BLOCK_INFO: FSAQueryInfoType = 6;
pub const FSA_QUERY_INFO_JOURNAL_FREE_SPACE_SIZE: FSAQueryInfoType = 7;
pub const FSA_QUERY_INFO_FRAGMENT_BLOCK_INFO: FSAQueryInfoType = 8;
pub type FSAQueryInfoType = ::core::ffi::c_uint;
pub const FSA_READ_FLAG_NONE: FSAReadFlag = 0;
pub const FSA_READ_FLAG_READ_WITH_POS: FSAReadFlag = 1;
pub type FSAReadFlag = ::core::ffi::c_uint;
pub const FSA_WRITE_FLAG_NONE: FSAWriteFlag = 0;
pub const FSA_WRITE_FLAG_READ_WITH_POS: FSAWriteFlag = 1;
pub type FSAWriteFlag = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAProcessInfo {
    pub titleId: u64,
    pub processId: u32,
    pub groupId: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawOpen {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRawOpen {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawClose {
    pub handle: i32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawRead {
    pub __unk132: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawWrite {
    pub __unk133: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestAppendFile {
    pub size: u32,
    pub count: u32,
    pub handle: FSAFileHandle,
    pub unk0x0C: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeDir {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestChangeDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeMode {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode1: u32,
    pub mode2: u32,
}
impl Default for FSARequestChangeMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestCloseDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestCloseFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestFlushFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestFlushQuota {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestFlushQuota {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestGetInfoByQuery {
    pub path: [::core::ffi::c_char; 640usize],
    pub type_: FSAQueryInfoType,
}
impl Default for FSARequestGetInfoByQuery {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestGetPosFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestIsEof {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeDir {
    pub path: [::core::ffi::c_char; 640usize],
    pub permission: u32,
}
impl Default for FSARequestMakeDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeQuota {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: u32,
    pub size: u64,
}
impl Default for FSARequestMakeQuota {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMount {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub unk0x500: u32,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
impl Default for FSARequestMount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority,
    pub process: FSAProcessInfo,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
impl Default for FSARequestMountWithProcess {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenDir {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestOpenDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenFile {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: [::core::ffi::c_char; 16usize],
    pub unk0x290: u32,
    pub unk0x294: u32,
    pub unk0x298: u32,
}
impl Default for FSARequestOpenFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestReadDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestReadFile {
    pub buffer: *mut u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub readFlags: FSAReadFlag,
}
impl Default for FSARequestReadFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRemove {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRemove {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRename {
    pub oldPath: [::core::ffi::c_char; 640usize],
    pub newPath: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRename {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRewindDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestSetPosFile {
    pub handle: FSAFileHandle,
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestStatFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestTruncateFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmount {
    pub path: [::core::ffi::c_char; 640usize],
    pub unk0x280: u32,
}
impl Default for FSARequestUnmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority,
    pub process: FSAProcessInfo,
}
impl Default for FSARequestUnmountWithProcess {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestWriteFile {
    pub buffer: *const u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub writeFlags: FSAWriteFlag,
}
impl Default for FSARequestWriteFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeOwner {
    pub path: [::core::ffi::c_char; 640usize],
    pub __unk134: [::core::ffi::c_char; 4usize],
    pub owner: u32,
    pub __unk135: [::core::ffi::c_char; 4usize],
    pub group: u32,
}
impl Default for FSARequestChangeOwner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSARequest {
    pub emulatedError: FSError,
    pub __bindgen_anon_1: FSARequest__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSARequest__bindgen_ty_1 {
    pub rawOpen: FSARequestRawOpen,
    pub rawClose: FSARequestRawClose,
    pub rawRead: FSARequestRawRead,
    pub rawWrite: FSARequestRawWrite,
    pub appendFile: FSARequestAppendFile,
    pub changeDir: FSARequestChangeDir,
    pub changeMode: FSARequestChangeMode,
    pub closeDir: FSARequestCloseDir,
    pub closeFile: FSARequestCloseFile,
    pub flushFile: FSARequestFlushFile,
    pub flushQuota: FSARequestFlushQuota,
    pub getInfoByQuery: FSARequestGetInfoByQuery,
    pub getPosFile: FSARequestGetPosFile,
    pub isEof: FSARequestIsEof,
    pub makeDir: FSARequestMakeDir,
    pub makeQuota: FSARequestMakeQuota,
    pub mount: FSARequestMount,
    pub mountWithProcess: FSARequestMountWithProcess,
    pub openDir: FSARequestOpenDir,
    pub openFile: FSARequestOpenFile,
    pub readDir: FSARequestReadDir,
    pub readFile: FSARequestReadFile,
    pub remove: FSARequestRemove,
    pub rename: FSARequestRename,
    pub rewindDir: FSARequestRewindDir,
    pub setPosFile: FSARequestSetPosFile,
    pub statFile: FSARequestStatFile,
    pub truncateFile: FSARequestTruncateFile,
    pub unmount: FSARequestUnmount,
    pub unmountWithProcess: FSARequestUnmountWithProcess,
    pub writeFile: FSARequestWriteFile,
    pub changeOwner: FSARequestChangeOwner,
    pub __unk136: [::core::ffi::c_char; 1308usize],
}
impl Default for FSARequest__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSARequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseRawOpen {
    pub handle: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetCwd {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSAResponseGetCwd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseGetFileBlockAddress {
    pub address: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseGetPosFile {
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetVolumeInfo {
    pub volumeInfo: FSAVolumeInfo,
}
impl Default for FSAResponseGetVolumeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponseGetInfoByQuery {
    pub __bindgen_anon_1: FSAResponseGetInfoByQuery__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponseGetInfoByQuery__bindgen_ty_1 {
    pub badBlockInfo: FSABlockInfo,
    pub deviceInfo: FSADeviceInfo,
    pub dirSize: u64,
    pub entryNum: FSAEntryNum,
    pub fileSystemInfo: FSAFileSystemInfo,
    pub fragmentBlockInfo: FSABlockInfo,
    pub freeSpaceSize: u64,
    pub journalFreeSpaceSize: u64,
    pub stat: FSAStat,
}
impl Default for FSAResponseGetInfoByQuery__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSAResponseGetInfoByQuery {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseOpenFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseOpenDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseReadDir {
    pub entry: FSADirectoryEntry,
}
impl Default for FSAResponseReadDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseStatFile {
    pub stat: FSAStat,
}
impl Default for FSAResponseStatFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponse {
    pub word0: u32,
    pub __bindgen_anon_1: FSAResponse__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponse__bindgen_ty_1 {
    pub rawOpen: FSAResponseRawOpen,
    pub getCwd: FSAResponseGetCwd,
    pub getFileBlockAddress: FSAResponseGetFileBlockAddress,
    pub getPosFile: FSAResponseGetPosFile,
    pub getVolumeInfo: FSAResponseGetVolumeInfo,
    pub getInfoByQuery: FSAResponseGetInfoByQuery,
    pub openDir: FSAResponseOpenDir,
    pub openFile: FSAResponseOpenFile,
    pub readDir: FSAResponseReadDir,
    pub statFile: FSAResponseStatFile,
    pub __unk137: [::core::ffi::c_char; 655usize],
}
impl Default for FSAResponse__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSAResponse {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FSA_COMMAND_INVALID: FSACommandEnum = 0;
pub const FSA_COMMAND_MOUNT: FSACommandEnum = 1;
pub const FSA_COMMAND_UNMOUNT: FSACommandEnum = 2;
pub const FSA_COMMAND_GET_VOLUME_INFO: FSACommandEnum = 3;
pub const FSA_COMMAND_GET_ATTACH: FSACommandEnum = 4;
pub const FSA_COMMAND_CHANGE_DIR: FSACommandEnum = 5;
pub const FSA_COMMAND_GET_CWD: FSACommandEnum = 6;
pub const FSA_COMMAND_MAKE_DIR: FSACommandEnum = 7;
pub const FSA_COMMAND_REMOVE: FSACommandEnum = 8;
pub const FSA_COMMAND_RENAME: FSACommandEnum = 9;
pub const FSA_COMMAND_OPEN_DIR: FSACommandEnum = 10;
pub const FSA_COMMAND_READ_DIR: FSACommandEnum = 11;
pub const FSA_COMMAND_REWIND_DIR: FSACommandEnum = 12;
pub const FSA_COMMAND_CLOSE_DIR: FSACommandEnum = 13;
pub const FSA_COMMAND_OPEN_FILE: FSACommandEnum = 14;
pub const FSA_COMMAND_READ_FILE: FSACommandEnum = 15;
pub const FSA_COMMAND_WRITE_FILE: FSACommandEnum = 16;
pub const FSA_COMMAND_GET_POS_FILE: FSACommandEnum = 17;
pub const FSA_COMMAND_SET_POS_FILE: FSACommandEnum = 18;
pub const FSA_COMMAND_IS_EOF: FSACommandEnum = 19;
pub const FSA_COMMAND_STAT_FILE: FSACommandEnum = 20;
pub const FSA_COMMAND_CLOSE_FILE: FSACommandEnum = 21;
pub const FSA_COMMAND_GET_ERROR: FSACommandEnum = 22;
pub const FSA_COMMAND_FLUSH_FILE: FSACommandEnum = 23;
pub const FSA_COMMAND_GET_INFO_BY_QUERY: FSACommandEnum = 24;
pub const FSA_COMMAND_APPEND_FILE: FSACommandEnum = 25;
pub const FSA_COMMAND_TRUNCATE_FILE: FSACommandEnum = 26;
pub const FSA_COMMAND_FLUSH_VOLUME: FSACommandEnum = 27;
pub const FSA_COMMAND_ROLLBACK_VOLUME: FSACommandEnum = 28;
pub const FSA_COMMAND_MAKE_QUOTA: FSACommandEnum = 29;
pub const FSA_COMMAND_FLUSH_QUOTA: FSACommandEnum = 30;
pub const FSA_COMMAND_ROLLBACK_QUOTA: FSACommandEnum = 31;
pub const FSA_COMMAND_CHANGE_MODE: FSACommandEnum = 32;
pub const FSA_COMMAND_OPEN_FILE_BY_STAT: FSACommandEnum = 33;
pub const FSA_COMMAND_REGISTER_FLUSH_QUOTA: FSACommandEnum = 34;
pub const FSA_COMMAND_FLUSH_MULTI_QUOTA: FSACommandEnum = 35;
pub const FSA_COMMAND_GET_FILE_BLOCK_ADDRESS: FSACommandEnum = 37;
pub const FSA_COMMAND_ADD_USER_PROCESS: FSACommandEnum = 101;
pub const FSA_COMMAND_DEL_USER_PROCESS: FSACommandEnum = 102;
pub const FSA_COMMAND_MOUNT_WITH_PROCESS: FSACommandEnum = 103;
pub const FSA_COMMAND_UNMOUNT_WITH_PROCESS: FSACommandEnum = 104;
pub const FSA_COMMAND_FORMAT: FSACommandEnum = 105;
pub const FSA_COMMAND_RAW_OPEN: FSACommandEnum = 106;
pub const FSA_COMMAND_RAW_READ: FSACommandEnum = 107;
pub const FSA_COMMAND_RAW_WRITE: FSACommandEnum = 108;
pub const FSA_COMMAND_RAW_CLOSE: FSACommandEnum = 109;
pub const FSA_COMMAND_GET_LAST_FAILED_VOLUME: FSACommandEnum = 110;
pub const FSA_COMMAND_GET_VOLUME_EXISTENCE: FSACommandEnum = 111;
pub const FSA_COMMAND_CHANGE_OWNER: FSACommandEnum = 112;
pub const FSA_COMMAND_CANCEL_GET_ATTACH: FSACommandEnum = 113;
pub const FSA_COMMAND_REMOVE_QUOTA: FSACommandEnum = 114;
pub const FSA_COMMAND_SET_CLIENT_PRIORITY: FSACommandEnum = 115;
pub const FSA_COMMAND_APPLY_MEMORY_CACHE: FSACommandEnum = 116;
pub const FSA_COMMAND_MAKE_LINK: FSACommandEnum = 117;
pub const FSA_COMMAND_XFER_PARAMS: FSACommandEnum = 118;
pub const FSA_COMMAND_EXEC_DEBUG_PROC: FSACommandEnum = 120;
pub const FSA_COMMAND_DEBUG_SET_TITLE_ID: FSACommandEnum = 121;
pub const FSA_COMMAND_DEBUG_SET_CAPABILITY: FSACommandEnum = 122;
pub const FSA_COMMAND_SET_PROCESS_CONFIG: FSACommandEnum = 130;
pub const FSA_COMMAND_CONFIG_SET_MEMORY_CACHE: FSACommandEnum = 131;
pub const FSA_COMMAND_CONFIG_UNSET_MEMORY_CACHE: FSACommandEnum = 132;
pub const FSA_COMMAND_CONFIG_SET_PRF2_CHAR_CODE: FSACommandEnum = 133;
pub const FSA_COMMAND_GET_PROC_RESOURCE_USAGE: FSACommandEnum = 140;
pub const FSA_COMMAND_GET_ALL_RESOURCE_USAGE: FSACommandEnum = 141;
pub const FSA_COMMAND_SEND_PROFILE_CMD: FSACommandEnum = 142;
pub type FSACommandEnum = ::core::ffi::c_uint;
pub const FSA_IPC_REQUEST_IOCTL: FSAIpcRequestTypeEnum = 0;
pub const FSA_IPC_REQUEST_IOCTLV: FSAIpcRequestTypeEnum = 1;
pub type FSAIpcRequestTypeEnum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAAsyncResult {
    pub ioMsgQueue: *mut OSMessageQueue,
    pub msg: FSMessage,
    pub userCallback: FSAAsyncCallbackFn,
    pub error: FSError,
    pub command: FSACommand,
    pub request: *mut FSARequest,
    pub response: *mut FSAResponse,
    pub userContext: *mut ::core::ffi::c_void,
}
impl Default for FSAAsyncResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAShimBuffer {
    pub request: FSARequest,
    pub __unk138: [::core::ffi::c_char; 96usize],
    pub response: FSAResponse,
    pub __unk139: [::core::ffi::c_char; 109usize],
    pub ioctlvVec: [IOSVec; 3usize],
    pub __unk140: [::core::ffi::c_char; 92usize],
    pub command: FSACommand,
    pub clientHandle: u32,
    pub ipcReqType: FSAIpcRequestType,
    pub ioctlvVecIn: u8,
    pub ioctlvVecOut: u8,
    pub fsaAsyncResult: FSAAsyncResult,
}
impl Default for FSAShimBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FSAClientAttachAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAClientAttachAsyncData {
    pub userCallback: FSAClientAttachAsyncCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSAClientAttachAsyncData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FSA_MOUNT_FLAG_LOCAL_MOUNT: FSAMountFlags = 0;
pub const FSA_MOUNT_FLAG_BIND_MOUNT: FSAMountFlags = 1;
pub const FSA_MOUNT_FLAG_GLOBAL_MOUNT: FSAMountFlags = 2;
pub type FSAMountFlags = ::core::ffi::c_uint;
pub const FSA_UNMOUNT_FLAG_NONE: FSAUnmountFlags = 0;
pub const FSA_UNMOUNT_FLAG_FORCE: FSAUnmountFlags = 2;
pub const FSA_UNMOUNT_FLAG_BIND_MOUNT: FSAUnmountFlags = 2147483648;
pub type FSAUnmountFlags = ::core::ffi::c_uint;
extern "C" {
    pub fn FSAInit() -> FSError;
}
extern "C" {
    pub fn FSAShutdown();
}
extern "C" {
    pub fn FSAGetClientNum() -> u32;
}
extern "C" {
    pub fn FSAAddClient(attachAsyncData: *mut FSAClientAttachAsyncData) -> FSAClientHandle;
}
extern "C" {
    pub fn FSADelClient(client: FSAClientHandle) -> FSError;
}
extern "C" {
    pub fn FSAGetStatusStr(error: FSError) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __FSAShimDecodeIosErrorToFsaStatus(handle: IOSHandle, err: IOSError) -> FSError;
}
extern "C" {
    pub fn FSAFlushMultiQuota(client: FSAClientHandle, path: *const ::core::ffi::c_char)
        -> FSError;
}
extern "C" {
    pub fn FSAFlushQuota(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSAFlushVolume(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSAFreeAsyncResult(asyncResult: *mut FSAAsyncResult);
}
extern "C" {
    pub fn FSAGetAsyncResult(asyncResult: *mut OSMessage) -> FSAAsyncResult;
}
extern "C" {
    pub fn FSAMount(
        client: FSAClientHandle,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        flags: FSAMountFlags,
        arg_buf: *mut ::core::ffi::c_void,
        arg_len: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAUnmount(
        client: FSAClientHandle,
        mountedTarget: *const ::core::ffi::c_char,
        flags: FSAUnmountFlags,
    ) -> FSError;
}
extern "C" {
    pub fn FSAChangeDir(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSAChangeMode(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        permission: FSMode,
    ) -> FSError;
}
extern "C" {
    pub fn FSAOpenFileEx(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode,
        openFlag: FSOpenFileFlags,
        preallocSize: u32,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError;
}
extern "C" {
    pub fn FSAOpenFileByStat(
        client: FSAClientHandle,
        stat: *mut FSAStat,
        mode: *const ::core::ffi::c_char,
        path: *const ::core::ffi::c_char,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetStatFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        stat: *mut FSAStat,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetStat(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        stat: *mut FSAStat,
    ) -> FSError;
}
extern "C" {
    pub fn FSACloseFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError;
}
extern "C" {
    pub fn FSAAppendFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAAppendFileEx(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
        flags: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetPosFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        outPos: *mut u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAFlushFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError;
}
extern "C" {
    pub fn FSASetPosFile(client: FSAClientHandle, fileHandle: FSAFileHandle, pos: u32) -> FSError;
}
extern "C" {
    pub fn FSATruncateFile(client: FSAClientHandle, handle: FSAFileHandle) -> FSError;
}
extern "C" {
    pub fn FSAWriteFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAWriteFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAIsEof(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError;
}
extern "C" {
    pub fn FSAReadFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAReadFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSARemove(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSARename(
        client: FSAClientHandle,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
    ) -> FSError;
}
extern "C" {
    pub fn FSAOpenDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        dirHandle: *mut FSADirectoryHandle,
    ) -> FSError;
}
extern "C" {
    pub fn FSAReadDir(
        client: FSAClientHandle,
        dirHandle: FSADirectoryHandle,
        directoryEntry: *mut FSADirectoryEntry,
    ) -> FSError;
}
extern "C" {
    pub fn FSARewindDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError;
}
extern "C" {
    pub fn FSACloseDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError;
}
extern "C" {
    pub fn FSAMakeDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: FSMode,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetCwd(
        client: FSAClientHandle,
        outPath: *mut ::core::ffi::c_char,
        outPathLen: u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetTransactionBlockPoolAttributes(
        messageSize: *mut u32,
        poolSize: *mut u32,
        numMessages: *mut u32,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetVolumeInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        outVolumeInfo: *mut FSAVolumeInfo,
    ) -> FSError;
}
extern "C" {
    pub fn FSAMakeQuota(
        client: FSAClientHandle,
        name: *const ::core::ffi::c_char,
        mode: u32,
        quota: u64,
    ) -> FSError;
}
extern "C" {
    pub fn FSARegisterFlushQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError;
}
extern "C" {
    pub fn FSARollbackQuota(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSARollbackQuotaForce(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError;
}
extern "C" {
    pub fn FSARollbackVolume(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError;
}
extern "C" {
    pub fn FSAGetFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeSpaceSize: *mut u64,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetJournalFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        journalFreeSpaceSize: *mut u64,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetDirSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeDirSize: *mut u64,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetEntryNum(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        entryNum: *mut FSAEntryNum,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetFileSystemInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSAFileSystemInfo,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetDeviceInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSADeviceInfo,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetBadBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError;
}
extern "C" {
    pub fn FSAGetFragmentBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSStopWatchAtomic {
    pub startTime: OSTime,
    pub totalTime: OSTime,
}
extern "C" {
    pub fn OSStopWatchStart(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchStop(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchLap(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchReset(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
pub const OS_PM_ARG_MMCR0: OSPerfMonArg = 1;
pub const OS_PM_ARG_MMCR1: OSPerfMonArg = 2;
pub const OS_PM_ARG_PMC1: OSPerfMonArg = 4;
pub const OS_PM_ARG_PMC2: OSPerfMonArg = 8;
pub const OS_PM_ARG_PMC3: OSPerfMonArg = 16;
pub const OS_PM_ARG_PMC4: OSPerfMonArg = 32;
pub type OSPerfMonArg = ::core::ffi::c_uint;
pub const OS_PM_MMCR0_PMC1_CURRENT: OSPerfMonMMCR0Flags = 0;
pub const OS_PM_MMCR0_PMC1_CPU_CYCLES: OSPerfMonMMCR0Flags = 64;
pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR0Flags = 128;
pub const OS_PM_MMCR0_PMC1_TBL_RISING_TRANSITIONS: OSPerfMonMMCR0Flags = 192;
pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_DISPATCHED: OSPerfMonMMCR0Flags = 256;
pub const OS_PM_MMCR0_PMC1_EIEIO_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR0Flags = 320;
pub const OS_PM_MMCR0_PMC1_ITLB_SEARCH_CYCLES: OSPerfMonMMCR0Flags = 384;
pub const OS_PM_MMCR0_PMC1_L2_HITS: OSPerfMonMMCR0Flags = 448;
pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_EA_DELIVERED: OSPerfMonMMCR0Flags = 512;
pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED_MATCHES_IABR: OSPerfMonMMCR0Flags = 576;
pub const OS_PM_MMCR0_PMC1_SLOW_L1_MISSES: OSPerfMonMMCR0Flags = 640;
pub const OS_PM_MMCR0_PMC1_UNRESOLVED_BRANCHES: OSPerfMonMMCR0Flags = 704;
pub const OS_PM_MMCR0_PMC1_UNRESOLVED_STALL_CYCLES: OSPerfMonMMCR0Flags = 768;
pub const OS_PM_MMCR0_PMC1_L1_SHARED_STORES: OSPerfMonMMCR0Flags = 896;
pub const OS_PM_MMCR0_PMC1_L2_SHARED_INTERVENTIONS: OSPerfMonMMCR0Flags = 960;
pub const OS_PM_MMCR0_PMC1_CACHE_PARADOXES: OSPerfMonMMCR0Flags = 1024;
pub const OS_PM_MMCR0_PMC1_CIU_LOAD_REQUESTS: OSPerfMonMMCR0Flags = 1280;
pub const OS_PM_MMCR0_PMC1_BIU_ADDRESS_ONLY_REQUESTS: OSPerfMonMMCR0Flags = 1344;
pub const OS_PM_MMCR0_PMC1_CIU_PARADOXES: OSPerfMonMMCR0Flags = 1408;
pub const OS_PM_MMCR0_PMC1_60XE_BUS_DATA_BEATS: OSPerfMonMMCR0Flags = 1472;
pub const OS_PM_MMCR0_PMC2_CURRENT: OSPerfMonMMCR0Flags = 0;
pub const OS_PM_MMCR0_PMC2_CPU_CYCLES: OSPerfMonMMCR0Flags = 1;
pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR0Flags = 2;
pub const OS_PM_MMCR0_PMC2_TBL_RISING_TRANSITIONS: OSPerfMonMMCR0Flags = 3;
pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_DISPATCHED: OSPerfMonMMCR0Flags = 4;
pub const OS_PM_MMCR0_PMC2_L1_ICACHE_MISSES: OSPerfMonMMCR0Flags = 5;
pub const OS_PM_MMCR0_PMC2_ITLB_MISSES: OSPerfMonMMCR0Flags = 6;
pub const OS_PM_MMCR0_PMC2_L2_INSTRUCTION_MISSES: OSPerfMonMMCR0Flags = 7;
pub const OS_PM_MMCR0_PMC2_PRED_BRANCHES_NOT_TAKEN: OSPerfMonMMCR0Flags = 8;
pub const OS_PM_MMCR0_PMC2_RESERVED_LOADS: OSPerfMonMMCR0Flags = 10;
pub const OS_PM_MMCR0_PMC2_LOADS_AND_STORES: OSPerfMonMMCR0Flags = 11;
pub const OS_PM_MMCR0_PMC2_CACHE_SNOOPS: OSPerfMonMMCR0Flags = 12;
pub const OS_PM_MMCR0_PMC2_L1_TO_L2_CASTOUTS: OSPerfMonMMCR0Flags = 13;
pub const OS_PM_MMCR0_PMC2_SYSTEM_UNIT_INSTRUCTIONS: OSPerfMonMMCR0Flags = 14;
pub const OS_PM_MMCR0_PMC2_L1_INSTRUCTION_MISS_CYCLES: OSPerfMonMMCR0Flags = 15;
pub const OS_PM_MMCR0_PMC2_FIRST_SPECULATIVE_BRANCH_RESOLVES: OSPerfMonMMCR0Flags = 16;
pub const OS_PM_MMCR0_PMC2_L2_SHARED_STORES: OSPerfMonMMCR0Flags = 17;
pub const OS_PM_MMCR0_PMC2_L1_SHARED_INTERVENTIONS: OSPerfMonMMCR0Flags = 18;
pub const OS_PM_MMCR0_PMC2_CIU_STORE_REQUESTS: OSPerfMonMMCR0Flags = 20;
pub const OS_PM_MMCR0_PMC2_SLOW_OUTSTANDING_BIU_TRANSACTIONS: OSPerfMonMMCR0Flags = 21;
pub const OS_PM_MMCR0_PMC2_CIU_MODIFIED_INTERVENTIONS: OSPerfMonMMCR0Flags = 22;
pub type OSPerfMonMMCR0Flags = ::core::ffi::c_uint;
pub const OS_PM_MMCR1_PMC3_CURRENT: OSPerfMonMMCR1Flags = 0;
pub const OS_PM_MMCR1_PMC3_CPU_CYCLES: OSPerfMonMMCR1Flags = 134217728;
pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR1Flags = 268435456;
pub const OS_PM_MMCR1_PMC3_TBL_RISING_TRANSITIONS: OSPerfMonMMCR1Flags = 402653184;
pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_DISPATCHED: OSPerfMonMMCR1Flags = 536870912;
pub const OS_PM_MMCR1_PMC3_L1_DCACHE_MISSES: OSPerfMonMMCR1Flags = 671088640;
pub const OS_PM_MMCR1_PMC3_DTLB_MISSES: OSPerfMonMMCR1Flags = 805306368;
pub const OS_PM_MMCR1_PMC3_L2_DATA_MISSES: OSPerfMonMMCR1Flags = 939524096;
pub const OS_PM_MMCR1_PMC3_PRED_BRANCHES_TAKEN: OSPerfMonMMCR1Flags = 1073741824;
pub const OS_PM_MMCR1_PMC3_COND_STORES_COMPLETED: OSPerfMonMMCR1Flags = 1342177280;
pub const OS_PM_MMCR1_PMC3_FPU_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR1Flags = 1476395008;
pub const OS_PM_MMCR1_PMC3_L2_CASTOUTS_BY_SNOOPS: OSPerfMonMMCR1Flags = 1610612736;
pub const OS_PM_MMCR1_PMC3_L2_CACHE_OPERATIONS: OSPerfMonMMCR1Flags = 1744830464;
pub const OS_PM_MMCR1_PMC3_L1_LOAD_MISS_CYCLES: OSPerfMonMMCR1Flags = 2013265920;
pub const OS_PM_MMCR1_PMC3_SECOND_SPECULATIVE_BRANCH_RESOLVES: OSPerfMonMMCR1Flags = 2147483648;
pub const OS_PM_MMCR1_PMC3_BPU_STALL_LR_CR_CYCLES: OSPerfMonMMCR1Flags = 2281701376;
pub const OS_PM_MMCR1_PMC3_L1_MODIFIED_INTERVENTIONS: OSPerfMonMMCR1Flags = 2415919104;
pub const OS_PM_MMCR1_PMC3_ICBI_SNOOPS: OSPerfMonMMCR1Flags = 2550136832;
pub const OS_PM_MMCR1_PMC3_CIU_ADDRESS_ONLY_REQUESTS: OSPerfMonMMCR1Flags = 2684354560;
pub const OS_PM_MMCR1_PMC3_BIU_LOAD_REQUESTS: OSPerfMonMMCR1Flags = 2818572288;
pub const OS_PM_MMCR1_PMC3_CIU_SHARED_INTERVENTIONS: OSPerfMonMMCR1Flags = 2952790016;
pub const OS_PM_MMCR1_PMC4_CURRENT: OSPerfMonMMCR1Flags = 0;
pub const OS_PM_MMCR1_PMC4_CPU_CYCLES: OSPerfMonMMCR1Flags = 4194304;
pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR1Flags = 8388608;
pub const OS_PM_MMCR1_PMC4_TBL_RISING_TRANSITIONS: OSPerfMonMMCR1Flags = 12582912;
pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_DISPATCHED: OSPerfMonMMCR1Flags = 16777216;
pub const OS_PM_MMCR1_PMC4_L2_CASTOUTS: OSPerfMonMMCR1Flags = 20971520;
pub const OS_PM_MMCR1_PMC4_DTLB_SEARCH_CYCLES: OSPerfMonMMCR1Flags = 25165824;
pub const OS_PM_MMCR1_PMC4_BRANCHES_MISPREDICTED: OSPerfMonMMCR1Flags = 33554432;
pub const OS_PM_MMCR1_PMC4_INTACT_COND_STORES_COMPLETED: OSPerfMonMMCR1Flags = 41943040;
pub const OS_PM_MMCR1_PMC4_SYNC_INSTRUCTIONS_COMPLETED: OSPerfMonMMCR1Flags = 46137344;
pub const OS_PM_MMCR1_PMC4_SNOOP_RETRIES: OSPerfMonMMCR1Flags = 50331648;
pub const OS_PM_MMCR1_PMC4_INTEGER_OPERATIONS: OSPerfMonMMCR1Flags = 54525952;
pub const OS_PM_MMCR1_PMC4_BPU_STALL_TWO_BRANCHES_CYCLES: OSPerfMonMMCR1Flags = 58720256;
pub const OS_PM_MMCR1_PMC4_L2_MODIFIED_INTERVENTIONS: OSPerfMonMMCR1Flags = 67108864;
pub const OS_PM_MMCR1_PMC4_TLBIE_SNOOPS: OSPerfMonMMCR1Flags = 71303168;
pub const OS_PM_MMCR1_PMC4_L2_BANK_REFRESH_OVERFLOWS: OSPerfMonMMCR1Flags = 75497472;
pub const OS_PM_MMCR1_PMC4_CIU_ARTRY_COUNT: OSPerfMonMMCR1Flags = 83886080;
pub const OS_PM_MMCR1_PMC4_BIU_STORE_REQUESTS: OSPerfMonMMCR1Flags = 88080384;
pub const OS_PM_MMCR1_PMC4_CIU_TWO_CORE_SHARED_INTERVENTIONS: OSPerfMonMMCR1Flags = 92274688;
pub type OSPerfMonMMCR1Flags = ::core::ffi::c_uint;
extern "C" {
    pub fn OSSetPerformanceMonitor(
        arg_mask: u32,
        mmcr0: u32,
        mmcr1: u32,
        pmc1: u32,
        pmc2: u32,
        pmc3: u32,
        pmc4: u32,
    );
}
pub const CODEGEN_RW_: OSCodegenSecMode = 0;
pub const CODEGEN_R_X: OSCodegenSecMode = 1;
pub type OSCodegenSecMode = ::core::ffi::c_uint;
extern "C" {
    pub fn OSGetCodegenVirtAddrRange(
        outVirtualAddress: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
}
extern "C" {
    pub fn OSGetCodegenCore() -> u32;
}
extern "C" {
    pub fn OSGetCodegenMode() -> u32;
}
extern "C" {
    pub fn OSSwitchSecCodeGenMode(mode: OSCodegenSecMode) -> BOOL;
}
extern "C" {
    pub fn OSGetSecCodeGenMode() -> u32;
}
extern "C" {
    pub fn OSCodegenCopy(
        dst: *mut ::core::ffi::c_void,
        src: *mut ::core::ffi::c_void,
        size: usize,
    ) -> BOOL;
}
pub const OS_MEM1: OSMemoryType = 1;
pub const OS_MEM2: OSMemoryType = 2;
pub type OSMemoryType = ::core::ffi::c_uint;
pub const OS_SHAREDDATATYPE_FONT_CHINESE: OSSharedDataType = 0;
pub const OS_SHAREDDATATYPE_FONT_KOREAN: OSSharedDataType = 1;
pub const OS_SHAREDDATATYPE_FONT_STANDARD: OSSharedDataType = 2;
pub const OS_SHAREDDATATYPE_FONT_TAIWANESE: OSSharedDataType = 3;
pub const OS_SHAREDDATATYPE_FONT_MAX: OSSharedDataType = 4;
pub type OSSharedDataType = ::core::ffi::c_uint;
extern "C" {
    pub fn OSGetSharedData(
        type_: OSSharedDataType,
        unk_r4: u32,
        outPtr: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    pub fn __OSRootLoadShared();
}
extern "C" {
    pub fn OSBlockMove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        size: u32,
        flush: BOOL,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSBlockSet(
        dst: *mut ::core::ffi::c_void,
        val: u8,
        size: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSAllocFromSystem(size: u32, align: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSFreeToSystem(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSGetForegroundBucket(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    pub fn OSGetForegroundBucketFreeArea(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    pub fn OSGetMemBound(
        type_: OSMemoryType,
        outAddr: *mut u32,
        outSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSZeroProcessMemory(proccesID: u32);
}
extern "C" {
    pub fn OSGetTitleID() -> u64;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSCoroutine {
    pub nia: u32,
    pub cr: u32,
    pub ugqr1: u32,
    pub stack: u32,
    pub sda2Base: u32,
    pub sdaBase: u32,
    pub gpr: [u32; 18usize],
    pub fpr: [f64; 18usize],
    pub psr: [f64; 18usize],
}
extern "C" {
    pub fn OSInitCoroutine(
        coroutine: *mut OSCoroutine,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn OSLoadCoroutine(coroutine: *mut OSCoroutine, result: u32) -> u32;
}
extern "C" {
    pub fn OSSaveCoroutine(coroutine: *mut OSCoroutine) -> u32;
}
extern "C" {
    pub fn OSSwitchCoroutine(from: *mut OSCoroutine, to: *mut OSCoroutine);
}
pub const SCREEN_TV: OSScreenID = 0;
pub const SCREEN_DRC: OSScreenID = 1;
pub type OSScreenID = ::core::ffi::c_uint;
extern "C" {
    pub fn OSScreenInit();
}
extern "C" {
    pub fn OSScreenShutdown();
}
extern "C" {
    pub fn OSScreenGetBufferSizeEx(screen: OSScreenID) -> u32;
}
extern "C" {
    pub fn OSScreenSetBufferEx(screen: OSScreenID, addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSScreenClearBufferEx(screen: OSScreenID, colour: u32);
}
extern "C" {
    pub fn OSScreenFlipBuffersEx(screen: OSScreenID);
}
extern "C" {
    pub fn OSScreenPutFontEx(
        screen: OSScreenID,
        column: u32,
        row: u32,
        buffer: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSScreenPutPixelEx(screen: OSScreenID, x: u32, y: u32, colour: u32);
}
extern "C" {
    pub fn OSScreenEnableEx(screen: OSScreenID, enable: BOOL);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::core::ffi::c_ulong,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memalign(
        arg1: ::core::ffi::c_ulong,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _memalign_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn _mallinfo_r(arg1: *mut _reent) -> mallinfo;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn _malloc_stats_r(arg1: *mut _reent);
}
extern "C" {
    pub fn mallopt(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mallopt_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn malloc_usable_size(arg1: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn _malloc_usable_size_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _valloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pvalloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _pvalloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn malloc_trim(arg1: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _malloc_trim_r(arg1: *mut _reent, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __malloc_lock(arg1: *mut _reent);
}
extern "C" {
    pub fn __malloc_unlock(arg1: *mut _reent);
}
extern "C" {
    pub fn mstats(arg1: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
pub type __builtin_va_list = [[u32; 3usize]; 1usize];
