/* automatically generated by rust-bindgen 0.70.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 18;
pub const __clang_minor__: u32 = 1;
pub const __clang_patchlevel__: u32 = 3;
#[allow(unsafe_code)]
pub const __clang_version__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"18.1.3 (1ubuntu1)\0") };
pub const __GNUC__: u32 = 4;
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __MEMORY_SCOPE_SYSTEM: u32 = 0;
pub const __MEMORY_SCOPE_DEVICE: u32 = 1;
pub const __MEMORY_SCOPE_WRKGRP: u32 = 2;
pub const __MEMORY_SCOPE_WVFRNT: u32 = 3;
pub const __MEMORY_SCOPE_SINGLE: u32 = 4;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __FPCLASS_SNAN: u32 = 1;
pub const __FPCLASS_QNAN: u32 = 2;
pub const __FPCLASS_NEGINF: u32 = 4;
pub const __FPCLASS_NEGNORMAL: u32 = 8;
pub const __FPCLASS_NEGSUBNORMAL: u32 = 16;
pub const __FPCLASS_NEGZERO: u32 = 32;
pub const __FPCLASS_POSZERO: u32 = 64;
pub const __FPCLASS_POSSUBNORMAL: u32 = 128;
pub const __FPCLASS_POSNORMAL: u32 = 256;
pub const __FPCLASS_POSINF: u32 = 512;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
#[allow(unsafe_code)]
pub const __VERSION__: &::core::ffi::CStr = unsafe {
    ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Ubuntu Clang 18.1.3 (1ubuntu1)\0")
};
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
#[allow(unsafe_code)]
pub const __clang_literal_encoding__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"UTF-8\0") };
#[allow(unsafe_code)]
pub const __clang_wide_literal_encoding__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"UTF-32\0") };
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 4321;
pub const __BIG_ENDIAN__: u32 = 1;
pub const _ILP32: u32 = 1;
pub const __ILP32__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __BOOL_WIDTH__: u32 = 8;
pub const __SHRT_WIDTH__: u32 = 16;
pub const __INT_WIDTH__: u32 = 32;
pub const __LONG_WIDTH__: u32 = 32;
pub const __LLONG_WIDTH__: u32 = 64;
pub const __BITINT_MAXWIDTH__: u32 = 128;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u32 = 2147483647;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_MAX__: u32 = 2147483647;
pub const __WINT_WIDTH__: u32 = 32;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __SIZE_MAX__: u32 = 4294967295;
pub const __SIZE_WIDTH__: u32 = 32;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_MAX__: u32 = 2147483647;
pub const __PTRDIFF_WIDTH__: u32 = 32;
pub const __INTPTR_MAX__: u32 = 2147483647;
pub const __INTPTR_WIDTH__: u32 = 32;
pub const __UINTPTR_MAX__: u32 = 4294967295;
pub const __UINTPTR_WIDTH__: u32 = 32;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 4;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 4;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 4;
pub const __SIZEOF_SIZE_T__: u32 = 4;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
#[allow(unsafe_code)]
pub const __INTMAX_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INTMAX_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINTMAX_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
#[allow(unsafe_code)]
pub const __PTRDIFF_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const __PTRDIFF_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const __INTPTR_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const __INTPTR_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const __SIZE_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __UINTPTR_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const __UINTPTR_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 31;
pub const __LDBL_DECIMAL_DIG__: u32 = 33;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 106;
pub const __LDBL_MAX_10_EXP__: u32 = 308;
pub const __LDBL_MAX_EXP__: u32 = 1024;
pub const __LDBL_MIN_10_EXP__: i32 = -291;
pub const __LDBL_MIN_EXP__: i32 = -968;
pub const __POINTER_WIDTH__: u32 = 32;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __CHAR_UNSIGNED__: u32 = 1;
#[allow(unsafe_code)]
pub const __INT8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
#[allow(unsafe_code)]
pub const __INT16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
#[allow(unsafe_code)]
pub const __INT32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
#[allow(unsafe_code)]
pub const __INT64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
#[allow(unsafe_code)]
pub const __UINT16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
#[allow(unsafe_code)]
pub const __UINT32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
#[allow(unsafe_code)]
pub const __UINT64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_WIDTH__: u32 = 8;
#[allow(unsafe_code)]
pub const __INT_LEAST8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
pub const __UINT_LEAST8_MAX__: u32 = 255;
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_WIDTH__: u32 = 16;
#[allow(unsafe_code)]
pub const __INT_LEAST16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
pub const __UINT_LEAST16_MAX__: u32 = 65535;
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __INT_LEAST32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_WIDTH__: u32 = 64;
#[allow(unsafe_code)]
pub const __INT_LEAST64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT_LEAST64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
pub const __UINT_LEAST64_MAX__: i32 = -1;
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT_LEAST64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_WIDTH__: u32 = 8;
#[allow(unsafe_code)]
pub const __INT_FAST8_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhd\0") };
#[allow(unsafe_code)]
pub const __INT_FAST8_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhi\0") };
pub const __UINT_FAST8_MAX__: u32 = 255;
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hho\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST8_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hhX\0") };
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_WIDTH__: u32 = 16;
#[allow(unsafe_code)]
pub const __INT_FAST16_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hd\0") };
#[allow(unsafe_code)]
pub const __INT_FAST16_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
pub const __UINT_FAST16_MAX__: u32 = 65535;
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ho\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST16_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hX\0") };
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_WIDTH__: u32 = 32;
#[allow(unsafe_code)]
pub const __INT_FAST32_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"d\0") };
#[allow(unsafe_code)]
pub const __INT_FAST32_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"o\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"x\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST32_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"X\0") };
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_WIDTH__: u32 = 64;
#[allow(unsafe_code)]
pub const __INT_FAST64_FMTd__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lld\0") };
#[allow(unsafe_code)]
pub const __INT_FAST64_FMTi__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lli\0") };
pub const __UINT_FAST64_MAX__: i32 = -1;
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTo__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llo\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTu__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llu\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTx__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llx\0") };
#[allow(unsafe_code)]
pub const __UINT_FAST64_FMTX__: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"llX\0") };
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 33;
pub const __ELF__: u32 = 1;
pub const __ppc__: u32 = 1;
pub const __PPC__: u32 = 1;
pub const _ARCH_PPC: u32 = 1;
pub const __powerpc__: u32 = 1;
pub const __POWERPC__: u32 = 1;
pub const _BIG_ENDIAN: u32 = 1;
pub const __NATURAL_ALIGNMENT__: u32 = 1;
pub const __LONG_DOUBLE_128__: u32 = 1;
pub const __LONGDOUBLE128: u32 = 1;
pub const __LONG_DOUBLE_IBM128__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __HAVE_BSWAP__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201710;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
#[allow(unsafe_code)]
pub const _NEWLIB_VERSION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"4.4.0\0") };
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 4;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
#[allow(unsafe_code)]
pub const __INT8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __INT16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __INT64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
#[allow(unsafe_code)]
pub const __FAST8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __FAST16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __FAST64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
#[allow(unsafe_code)]
pub const __LEAST8: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hh\0") };
#[allow(unsafe_code)]
pub const __LEAST16: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const __LEAST64: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ll\0") };
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST8_MAX: u32 = 127;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST16_MAX: u32 = 32767;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const UINTMAX_MAX: i32 = -1;
pub const SIZE_MAX: u32 = 4294967295;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const OS_MESSAGE_QUEUE_TAG: u32 = 1834182481;
pub const OS_FAST_MUTEX_TAG: u32 = 1716352088;
pub const OS_CONTEXT_TAG: u64 = 5715986497936849012;
pub const OS_ALARM_QUEUE_TAG: u32 = 1632398673;
pub const OS_ALARM_TAG: u32 = 1632399949;
pub const FS_MAX_PATH: u32 = 639;
pub const FS_MODE_LENGTH: u32 = 16;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const GX2_FALSE: u32 = 0;
pub const GX2_TRUE: u32 = 1;
pub const GX2_DISABLE: u32 = 0;
pub const GX2_ENABLE: u32 = 1;
pub const GX2_COMMAND_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_CONTEXT_STATE_ALIGNMENT: u32 = 256;
pub const GX2_SCAN_BUFFER_ALIGNMENT: u32 = 4096;
pub const GX2_SHADER_PROGRAM_ALIGNMENT: u32 = 256;
pub const GX2_VERTEX_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_INDEX_BUFFER_ALIGNMENT: u32 = 32;
pub const GX2_UNIFORM_BLOCK_ALIGNMENT: u32 = 256;
pub const GX2_COMMAND_BUFFER_SIZE: u32 = 4194304;
pub const GFD_HEADER_MAGIC: u32 = 1197897778;
pub const GFD_BLOCK_HEADER_MAGIC: u32 = 1112296315;
pub const GFD_RELOCATION_HEADER_MAGIC: u32 = 2101496907;
pub const GFD_FILE_VERSION_MAJOR: u32 = 7;
pub const GFD_FILE_VERSION_MINOR: u32 = 1;
pub const GFD_BLOCK_VERSION_MAJOR: u32 = 1;
pub const GFD_PATCH_MASK: u32 = 4293918720;
pub const GFD_PATCH_DATA: u32 = 3495952384;
pub const GFD_PATCH_TEXT: u32 = 3396337664;
pub const FD_SETSIZE: u32 = 32;
pub const IOCPARM_SHIFT: u32 = 13;
pub const IOCPARM_MASK: u32 = 8191;
pub const IOCPARM_MAX: u32 = 8192;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOC_DIRMASK: u32 = 3758096384;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 4321;
pub const _QUAD_HIGHWORD: u32 = 0;
pub const _QUAD_LOWWORD: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 4321;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG2STR_MAX: u32 = 17;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: i32 = -1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_DONTWAIT: u32 = 32;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_TCPSACK: u32 = 512;
pub const SO_WINSCALE: u32 = 1024;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_HOPCNT: u32 = 4105;
pub const SO_MAXMSG: u32 = 4112;
pub const SO_RXDATA: u32 = 4113;
pub const SO_TXDATA: u32 = 4114;
pub const SO_MYADDR: u32 = 4115;
pub const SO_NBIO: u32 = 4116;
pub const SO_BIO: u32 = 4117;
pub const SO_NONBLOCK: u32 = 4118;
pub const SO_UNKNOWN1019: u32 = 4121;
pub const SO_UNKNOWN101A: u32 = 4122;
pub const SO_UNKNOWN101B: u32 = 4123;
pub const SO_NOSLOWSTART: u32 = 16384;
pub const SO_RUSRBUF: u32 = 65536;
pub const OS_THREAD_TAG: u32 = 1950904900;
pub const CAMERA_WIDTH: u32 = 640;
pub const CAMERA_PITCH: u32 = 768;
pub const CAMERA_HEIGHT: u32 = 480;
pub const CAMERA_Y_BUFFER_SIZE: u32 = 368640;
pub const CAMERA_UV_BUFFER_SIZE: u32 = 184320;
pub const CAMERA_YUV_BUFFER_SIZE: u32 = 552960;
pub const CAMERA_YUV_BUFFER_ALIGNMENT: u32 = 256;
pub const CCR_CDC_IRDA_DATA_TRANSFER_SIZE: u32 = 520;
pub const SOL_TCP: u32 = 6;
pub const TCP_ACKDELAYTIME: u32 = 8193;
pub const TCP_NOACKDELAY: u32 = 8194;
pub const TCP_MAXSEG: u32 = 8195;
pub const TCP_NODELAY: u32 = 8196;
pub const TCP_UNKNOWN: u32 = 8197;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_UNKNOWN: u32 = 14;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const OS_EVENT_TAG: u32 = 1700163156;
pub const HPAD_STICK_AXIS_MIN: i32 = -56;
pub const HPAD_STICK_AXIS_MAX: u32 = 56;
pub const HPAD_SUBSTICK_AXIS_MIN: i32 = -44;
pub const HPAD_SUBSTICK_AXIS_MAX: u32 = 44;
pub const HPAD_TRIGGER_MIN: u32 = 0;
pub const HPAD_TRIGGER_MAX: u32 = 150;
pub const WHB_SERVER_BUFFER_SIZE: u32 = 1024;
pub const NSYSNET_FD_SETSIZE: u32 = 32;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_NUMERICSCOPE: u32 = 32;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const USBCLASS_DEVICE: u32 = 0;
pub const USBCLASS_AUDIO: u32 = 1;
pub const USBCLASS_HID: u32 = 3;
pub const USBCLASS_STORAGE: u32 = 8;
pub const MATCH_ANY: u32 = 0;
pub const MATCH_DEV_VID: u32 = 1;
pub const MATCH_DEV_PID: u32 = 2;
pub const MATCH_DEV_CLASS: u32 = 16;
pub const MATCH_DEV_SUBCLASS: u32 = 32;
pub const MATCH_DEV_PROTOCOL: u32 = 64;
pub const MATCH_IF_CLASS: u32 = 128;
pub const MATCH_IF_SUBCLASS: u32 = 256;
pub const MATCH_IF_PROTOCOL: u32 = 512;
pub const UHS_CONFIG_BUFFER_SIZE: u32 = 4991;
pub const ENDPOINT_TRANSFER_OUT: u32 = 1;
pub const ENDPOINT_TRANSFER_IN: u32 = 2;
pub const TIMEOUT_NONE: i32 = -1;
pub const OS_SEMAPHORE_TAG: u32 = 1934649426;
pub const OS_MUTEX_TAG: u32 = 1834316888;
pub const IPC_BUF_POOL_MAGIC: u32 = 195948557;
pub const OS_FAST_CONDITION_TAG: u32 = 1716413526;
pub const OS_CONDITION_TAG: u32 = 1666081878;
pub const OS_TITLE_ID_COLDBOOT: i32 = -3;
pub const OS_TITLE_ID_REBOOT: i32 = -2;
pub const OS_PAGE_SIZE: u32 = 131072;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_long;
pub type __uintptr_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type BOOL = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadLink {
    pub next: *mut OSThread,
    pub prev: *mut OSThread,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk0: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadSimpleQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
}
extern "C" {
    pub fn OSInitThreadQueue(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSInitThreadQueueEx(queue: *mut OSThreadQueue, parent: *mut ::core::ffi::c_void);
}
pub mod OSMessageFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MESSAGE_FLAGS_NONE: Type = 0;
    pub const OS_MESSAGE_FLAGS_BLOCKING: Type = 1;
    pub const OS_MESSAGE_FLAGS_HIGH_PRIORITY: Type = 2;
}
pub mod OSFunctionType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_FUNCTION_TYPE_HIO_OPEN: Type = 1;
    pub const OS_FUNCTION_TYPE_HIO_READ_ASYNC: Type = 2;
    pub const OS_FUNCTION_TYPE_HIO_WRITE_ASYNC: Type = 3;
    pub const OS_FUNCTION_TYPE_FSA_CMD_ASYNC: Type = 4;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC: Type = 5;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC_NO_ALLOC: Type = 6;
    pub const OS_FUNCTION_TYPE_FSA_ATTACH_EVENT: Type = 7;
    pub const OS_FUNCTION_TYPE_FS_CMD_ASYNC: Type = 8;
    pub const OS_FUNCTION_TYPE_FS_CMD_HANDLER: Type = 9;
    pub const OS_FUNCTION_TYPE_FS_ATTACH_EVENT: Type = 10;
    pub const OS_FUNCTION_TYPE_FS_STATE_CHANGE_EVENT: Type = 11;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessage {
    pub message: *mut ::core::ffi::c_void,
    pub args: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessageQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk1: [::core::ffi::c_char; 4usize],
    pub sendQueue: OSThreadQueue,
    pub recvQueue: OSThreadQueue,
    pub messages: *mut OSMessage,
    pub size: u32,
    pub first: u32,
    pub used: u32,
}
extern "C" {
    pub fn OSInitMessageQueue(queue: *mut OSMessageQueue, messages: *mut OSMessage, size: i32);
}
extern "C" {
    pub fn OSInitMessageQueueEx(
        queue: *mut OSMessageQueue,
        messages: *mut OSMessage,
        size: i32,
        name: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSSendMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn OSReceiveMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn OSPeekMessage(queue: *mut OSMessageQueue, message: *mut OSMessage) -> BOOL;
}
extern "C" {
    pub fn OSGetSystemMessageQueue() -> *mut OSMessageQueue;
}
extern "C" {
    pub fn OSGetDefaultAppIOQueue() -> *mut OSMessageQueue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSystemInfo {
    pub busClockSpeed: u32,
    pub coreClockSpeed: u32,
    pub baseTime: i64,
    pub __unk2: [::core::ffi::c_char; 16usize],
}
extern "C" {
    pub fn OSGetSystemInfo() -> *mut OSSystemInfo;
}
extern "C" {
    pub fn OSEnableHomeButtonMenu(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSIsHomeButtonMenuEnabled() -> BOOL;
}
extern "C" {
    pub fn OSGetOSID() -> u64;
}
extern "C" {
    pub fn __OSGetProcessSDKVersion() -> u32;
}
pub type OSTick = i32;
pub type OSTime = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCalendarTime {
    pub tm_sec: i32,
    pub tm_min: i32,
    pub tm_hour: i32,
    pub tm_mday: i32,
    pub tm_mon: i32,
    pub tm_year: i32,
    pub tm_wday: i32,
    pub tm_yday: i32,
    pub tm_msec: i32,
    pub tm_usec: i32,
}
extern "C" {
    pub fn OSGetTime() -> OSTime;
}
extern "C" {
    pub fn OSGetSystemTime() -> OSTime;
}
extern "C" {
    pub fn OSGetTick() -> OSTick;
}
extern "C" {
    pub fn OSGetSystemTick() -> OSTick;
}
extern "C" {
    pub fn OSCalendarTimeToTicks(calendarTime: *mut OSCalendarTime) -> OSTime;
}
extern "C" {
    pub fn OSTicksToCalendarTime(time: OSTime, calendarTime: *mut OSCalendarTime);
}
extern "C" {
    pub fn __OSSetAbsoluteSystemTime(time: OSTime) -> BOOL;
}
pub type IOSHandle = i32;
pub mod IOSOpenMode {
    pub type Type = ::core::ffi::c_uint;
    pub const IOS_OPEN_READ: Type = 1;
    pub const IOS_OPEN_WRITE: Type = 2;
    pub const IOS_OPEN_READWRITE: Type = 3;
}
pub mod IOSError {
    pub type Type = ::core::ffi::c_int;
    pub const IOS_ERROR_OK: Type = 0;
    pub const IOS_ERROR_ACCESS: Type = -1;
    pub const IOS_ERROR_EXISTS: Type = -2;
    pub const IOS_ERROR_INTR: Type = -3;
    pub const IOS_ERROR_INVALID: Type = -4;
    pub const IOS_ERROR_MAX: Type = -5;
    pub const IOS_ERROR_NOEXISTS: Type = -6;
    pub const IOS_ERROR_QEMPTY: Type = -7;
    pub const IOS_ERROR_QFULL: Type = -8;
    pub const IOS_ERROR_UNKNOWN: Type = -9;
    pub const IOS_ERROR_NOTREADY: Type = -10;
    pub const IOS_ERROR_ECC: Type = -11;
    pub const IOS_ERROR_ECCCRIT: Type = -12;
    pub const IOS_ERROR_BADBLOCK: Type = -13;
    pub const IOS_ERROR_INVALIDOBJTYPE: Type = -14;
    pub const IOS_ERROR_INVALIDRNG: Type = -15;
    pub const IOS_ERROR_INVALIDFLAG: Type = -16;
    pub const IOS_ERROR_INVALIDFORMAT: Type = -17;
    pub const IOS_ERROR_INVALIDVERSION: Type = -18;
    pub const IOS_ERROR_INVALIDSIGNER: Type = -19;
    pub const IOS_ERROR_FAILCHECKVALUE: Type = -20;
    pub const IOS_ERROR_FAILINTERNAL: Type = -21;
    pub const IOS_ERROR_FAILALLOC: Type = -22;
    pub const IOS_ERROR_INVALIDSIZE: Type = -23;
    pub const IOS_ERROR_NOLINK: Type = -24;
    pub const IOS_ERROR_ANFAILED: Type = -25;
    pub const IOS_ERROR_MAXSEMCOUNT: Type = -26;
    pub const IOS_ERROR_SEMUNAVAILABLE: Type = -27;
    pub const IOS_ERROR_INVALIDHANDLE: Type = -28;
    pub const IOS_ERROR_INVALIDARG: Type = -29;
    pub const IOS_ERROR_NORESOURCE: Type = -30;
    pub const IOS_ERROR_BUSY: Type = -31;
    pub const IOS_ERROR_TIMEOUT: Type = -32;
    pub const IOS_ERROR_ALIGNMENT: Type = -33;
    pub const IOS_ERROR_BSP: Type = -34;
    pub const IOS_ERROR_DATAPENDING: Type = -35;
    pub const IOS_ERROR_EXPIRED: Type = -36;
    pub const IOS_ERROR_NOREADACCESS: Type = -37;
    pub const IOS_ERROR_NOWRITEACCESS: Type = -38;
    pub const IOS_ERROR_NOREADWRITEACCESS: Type = -39;
    pub const IOS_ERROR_CLIENTTXNLIMIT: Type = -40;
    pub const IOS_ERROR_STALEHANDLE: Type = -41;
    pub const IOS_ERROR_UNKNOWNVALUE: Type = -42;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOSVec {
    pub vaddr: *mut ::core::ffi::c_void,
    pub len: u32,
    pub paddr: *mut ::core::ffi::c_void,
}
pub type IOSAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: IOSError::Type, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    pub fn IOS_Open(device: *const ::core::ffi::c_char, mode: IOSOpenMode::Type) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_OpenAsync(
        device: *const ::core::ffi::c_char,
        mode: IOSOpenMode::Type,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Close(handle: IOSHandle) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_CloseAsync(
        handle: IOSHandle,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Ioctl(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_IoctlAsync(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_Ioctlv(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IOS_IoctlvAsync(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexLink {
    pub next: *mut OSFastMutex,
    pub prev: *mut OSFastMutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk3: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadSimpleQueue,
    pub link: OSFastMutexLink,
    pub __unk4: [::core::ffi::c_char; 16usize],
}
extern "C" {
    pub fn OSFastMutex_Init(mutex: *mut OSFastMutex, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSFastMutex_Lock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_Unlock(mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastMutex_TryLock(mutex: *mut OSFastMutex) -> BOOL;
}
pub type OSContextState = u16;
pub mod OS_CONTEXT_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_CONTEXT_STATE_OSCALLBACK: Type = 8;
    pub const OS_CONTEXT_STATE_USERMODE_SAVED: Type = 16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSContext {
    pub tag: u64,
    pub gpr: [u32; 32usize],
    pub cr: u32,
    pub lr: u32,
    pub ctr: u32,
    pub xer: u32,
    pub srr0: u32,
    pub srr1: u32,
    pub dsisr: u32,
    pub dar: u32,
    pub __unk5: [::core::ffi::c_char; 12usize],
    pub fpscr: u32,
    pub fpr: [f64; 32usize],
    pub spinLockCount: u16,
    pub state: OSContextState,
    pub gqr: [u32; 8usize],
    pub upir: u32,
    pub psf: [f64; 32usize],
    pub coretime: [u64; 3usize],
    pub starttime: u64,
    pub error: u32,
    pub __unk6: [::core::ffi::c_char; 4usize],
    pub pmc1: u32,
    pub pmc2: u32,
    pub pmc3: u32,
    pub pmc4: u32,
    pub mmcr0: u32,
    pub mmcr1: u32,
}
extern "C" {
    pub fn OSInitContext(
        context: *mut OSContext,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn OSDumpContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSLoadContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveContext(context: *mut OSContext) -> u32;
}
extern "C" {
    pub fn OSLoadFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSaveFPUContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSGetCurrentContext() -> *mut OSContext;
}
extern "C" {
    pub fn OSSetCurrentContext(context: *mut OSContext);
}
extern "C" {
    pub fn OSSwitchStack(stack: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSSetCurrentUserContext(context: *mut OSContext);
}
extern "C" {
    pub fn __OSSetAndLoadContext(context: *mut OSContext);
}
pub type OSAlarmCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut OSAlarm, arg2: *mut OSContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk7: [::core::ffi::c_char; 4usize],
    pub threadQueue: OSThreadQueue,
    pub head: *mut OSAlarm,
    pub tail: *mut OSAlarm,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmLink {
    pub prev: *mut OSAlarm,
    pub next: *mut OSAlarm,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarm {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk8: [::core::ffi::c_char; 4usize],
    pub callback: OSAlarmCallback,
    pub group: u32,
    pub __unk9: [::core::ffi::c_char; 4usize],
    pub nextFire: OSTime,
    pub link: OSAlarmLink,
    pub period: OSTime,
    pub start: OSTime,
    pub userData: *mut ::core::ffi::c_void,
    pub state: u32,
    pub threadQueue: OSThreadQueue,
    pub alarmQueue: *mut OSAlarmQueue,
    pub context: *mut OSContext,
}
extern "C" {
    pub fn OSCancelAlarm(alarm: *mut OSAlarm) -> BOOL;
}
extern "C" {
    pub fn OSCancelAlarms(group: u32);
}
extern "C" {
    pub fn OSCreateAlarm(alarm: *mut OSAlarm);
}
extern "C" {
    pub fn OSCreateAlarmEx(alarm: *mut OSAlarm, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSGetAlarmUserData(alarm: *mut OSAlarm) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSInitAlarmQueue(queue: *mut OSAlarmQueue);
}
extern "C" {
    pub fn OSInitAlarmQueueEx(queue: *mut OSAlarmQueue, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSSetAlarm(alarm: *mut OSAlarm, time: OSTime, callback: OSAlarmCallback) -> BOOL;
}
extern "C" {
    pub fn OSSetPeriodicAlarm(
        alarm: *mut OSAlarm,
        start: OSTime,
        interval: OSTime,
        callback: OSAlarmCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSetAlarmTag(alarm: *mut OSAlarm, group: u32);
}
extern "C" {
    pub fn OSSetAlarmUserData(alarm: *mut OSAlarm, data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSWaitAlarm(alarm: *mut OSAlarm) -> BOOL;
}
pub type FSDirectoryHandle = u32;
pub type FSFileHandle = u32;
pub type FSPriority = u32;
pub type FSTime = u64;
pub type FSStateChangeInfo = FSStateChangeParams;
pub mod FSErrorFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_ERROR_FLAG_NONE: Type = 0;
    pub const FS_ERROR_FLAG_MAX: Type = 1;
    pub const FS_ERROR_FLAG_ALREADY_OPEN: Type = 2;
    pub const FS_ERROR_FLAG_EXISTS: Type = 4;
    pub const FS_ERROR_FLAG_NOT_FOUND: Type = 8;
    pub const FS_ERROR_FLAG_NOT_FILE: Type = 16;
    pub const FS_ERROR_FLAG_NOT_DIR: Type = 32;
    pub const FS_ERROR_FLAG_ACCESS_ERROR: Type = 64;
    pub const FS_ERROR_FLAG_PERMISSION_ERROR: Type = 128;
    pub const FS_ERROR_FLAG_FILE_TOO_BIG: Type = 256;
    pub const FS_ERROR_FLAG_STORAGE_FULL: Type = 512;
    pub const FS_ERROR_FLAG_UNSUPPORTED_CMD: Type = 1024;
    pub const FS_ERROR_FLAG_JOURNAL_FULL: Type = 2048;
    pub const FS_ERROR_FLAG_ALL: Type = 4294967295;
}
pub mod FSStatus {
    pub type Type = ::core::ffi::c_int;
    pub const FS_STATUS_OK: Type = 0;
    pub const FS_STATUS_CANCELLED: Type = -1;
    pub const FS_STATUS_END: Type = -2;
    pub const FS_STATUS_MAX: Type = -3;
    pub const FS_STATUS_ALREADY_OPEN: Type = -4;
    pub const FS_STATUS_EXISTS: Type = -5;
    pub const FS_STATUS_NOT_FOUND: Type = -6;
    pub const FS_STATUS_NOT_FILE: Type = -7;
    pub const FS_STATUS_NOT_DIR: Type = -8;
    pub const FS_STATUS_ACCESS_ERROR: Type = -9;
    pub const FS_STATUS_PERMISSION_ERROR: Type = -10;
    pub const FS_STATUS_FILE_TOO_BIG: Type = -11;
    pub const FS_STATUS_STORAGE_FULL: Type = -12;
    pub const FS_STATUS_JOURNAL_FULL: Type = -13;
    pub const FS_STATUS_UNSUPPORTED_CMD: Type = -14;
    pub const FS_STATUS_MEDIA_NOT_READY: Type = -15;
    pub const FS_STATUS_MEDIA_ERROR: Type = -17;
    pub const FS_STATUS_CORRUPTED: Type = -18;
    pub const FS_STATUS_FATAL_ERROR: Type = -1024;
}
pub mod FSError {
    pub type Type = ::core::ffi::c_int;
    pub const FS_ERROR_OK: Type = 0;
    pub const FS_ERROR_NOT_INIT: Type = -196609;
    pub const FS_ERROR_BUSY: Type = -196610;
    pub const FS_ERROR_CANCELLED: Type = -196611;
    pub const FS_ERROR_END_OF_DIR: Type = -196612;
    pub const FS_ERROR_END_OF_FILE: Type = -196613;
    pub const FS_ERROR_MAX_MOUNT_POINTS: Type = -196624;
    pub const FS_ERROR_MAX_VOLUMES: Type = -196625;
    pub const FS_ERROR_MAX_CLIENTS: Type = -196626;
    pub const FS_ERROR_MAX_FILES: Type = -196627;
    pub const FS_ERROR_MAX_DIRS: Type = -196628;
    pub const FS_ERROR_ALREADY_OPEN: Type = -196629;
    pub const FS_ERROR_ALREADY_EXISTS: Type = -196630;
    pub const FS_ERROR_NOT_FOUND: Type = -196631;
    pub const FS_ERROR_NOT_EMPTY: Type = -196632;
    pub const FS_ERROR_ACCESS_ERROR: Type = -196633;
    pub const FS_ERROR_PERMISSION_ERROR: Type = -196634;
    pub const FS_ERROR_DATA_CORRUPTED: Type = -196635;
    pub const FS_ERROR_STORAGE_FULL: Type = -196636;
    pub const FS_ERROR_JOURNAL_FULL: Type = -196637;
    pub const FS_ERROR_UNAVAILABLE_COMMAND: Type = -196639;
    pub const FS_ERROR_UNSUPPORTED_COMMAND: Type = -196640;
    pub const FS_ERROR_INVALID_PARAM: Type = -196641;
    pub const FS_ERROR_INVALID_PATH: Type = -196642;
    pub const FS_ERROR_INVALID_BUFFER: Type = -196643;
    pub const FS_ERROR_INVALID_ALIGNMENT: Type = -196644;
    pub const FS_ERROR_INVALID_CLIENTHANDLE: Type = -196645;
    pub const FS_ERROR_INVALID_FILEHANDLE: Type = -196646;
    pub const FS_ERROR_INVALID_DIRHANDLE: Type = -196647;
    pub const FS_ERROR_NOT_FILE: Type = -196648;
    pub const FS_ERROR_NOT_DIR: Type = -196649;
    pub const FS_ERROR_FILE_TOO_BIG: Type = -196650;
    pub const FS_ERROR_OUT_OF_RANGE: Type = -196651;
    pub const FS_ERROR_OUT_OF_RESOURCES: Type = -196652;
    pub const FS_ERROR_MEDIA_NOT_READY: Type = -196672;
    pub const FS_ERROR_MEDIA_ERROR: Type = -196673;
    pub const FS_ERROR_WRITE_PROTECTED: Type = -196674;
    pub const FS_ERROR_INVALID_MEDIA: Type = -196675;
}
pub mod FSMode {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MODE_READ_OWNER: Type = 1024;
    pub const FS_MODE_WRITE_OWNER: Type = 512;
    pub const FS_MODE_EXEC_OWNER: Type = 256;
    pub const FS_MODE_READ_GROUP: Type = 64;
    pub const FS_MODE_WRITE_GROUP: Type = 32;
    pub const FS_MODE_EXEC_GROUP: Type = 16;
    pub const FS_MODE_READ_OTHER: Type = 4;
    pub const FS_MODE_WRITE_OTHER: Type = 2;
    pub const FS_MODE_EXEC_OTHER: Type = 1;
}
pub mod FSStatFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_STAT_DIRECTORY: Type = 2147483648;
    pub const FS_STAT_QUOTA: Type = 1610612736;
    pub const FS_STAT_FILE: Type = 16777216;
    pub const FS_STAT_ENCRYPTED_FILE: Type = 8388608;
    pub const FS_STAT_LINK: Type = 65536;
}
pub mod FSVolumeState {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_VOLUME_STATE_INITIAL: Type = 0;
    pub const FS_VOLUME_STATE_READY: Type = 1;
    pub const FS_VOLUME_STATE_NO_MEDIA: Type = 2;
    pub const FS_VOLUME_STATE_INVALID_MEDIA: Type = 3;
    pub const FS_VOLUME_STATE_DIRTY_MEDIA: Type = 4;
    pub const FS_VOLUME_STATE_WRONG_MEDIA: Type = 5;
    pub const FS_VOLUME_STATE_MEDIA_ERROR: Type = 6;
    pub const FS_VOLUME_STATE_DATA_CORRUPTED: Type = 7;
    pub const FS_VOLUME_STATE_WRITE_PROTECTED: Type = 8;
    pub const FS_VOLUME_STATE_JOURNAL_FULL: Type = 9;
    pub const FS_VOLUME_STATE_FATAL: Type = 10;
    pub const FS_VOLUME_STATE_INVALID: Type = 11;
}
pub mod FSMediaState {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MEDIA_STATE_READY: Type = 0;
    pub const FS_MEDIA_STATE_NO_MEDIA: Type = 1;
    pub const FS_MEDIA_STATE_INVALID_MEDIA: Type = 2;
    pub const FS_MEDIA_STATE_DIRTY_MEDIA: Type = 3;
    pub const FS_MEDIA_STATE_MEDIA_ERROR: Type = 4;
}
pub mod FSMountSourceType {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MOUNT_SOURCE_SD: Type = 0;
    pub const FS_MOUNT_SOURCE_UNK: Type = 1;
}
pub mod FSOpenFileFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_OPEN_FLAG_NONE: Type = 0;
    pub const FS_OPEN_FLAG_UNENCRYPTED: Type = 1;
    pub const FS_OPEN_FLAG_PREALLOC_SIZE: Type = 2;
}
pub type FSAsyncCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSClient,
        arg2: *mut FSCmdBlock,
        arg3: FSStatus::Type,
        arg4: u32,
    ),
>;
pub type FSStateChangeCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSClient,
        arg2: FSVolumeState::Type,
        arg3: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSFsm {
    pub __unk10: [::core::ffi::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdQueue {
    pub __unk11: [::core::ffi::c_char; 68usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMessage {
    pub data: *mut ::core::ffi::c_void,
    pub __unk12: [::core::ffi::c_char; 8usize],
    pub type_: OSFunctionType::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBodyLink {
    pub next: *mut FSClientBody,
    pub prev: *mut FSClientBody,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBody {
    pub __unk13: [::core::ffi::c_char; 5188usize],
    pub clientHandle: IOSHandle,
    pub fsm: FSFsm,
    pub cmdQueue: FSCmdQueue,
    pub lastDequeuedCommand: *mut FSCmdBlockBody,
    pub emulatedError: FSError::Type,
    pub __unk14: [::core::ffi::c_char; 148usize],
    pub mutex: OSFastMutex,
    pub __unk15: [::core::ffi::c_char; 4usize],
    pub fsmAlarm: OSAlarm,
    pub lastError: FSError::Type,
    pub isLastErrorWithoutVolume: bool,
    pub fsCmdHandlerMsg: FSMessage,
    pub lastMountSourceDevice: [::core::ffi::c_char; 16usize],
    pub findMountSourceType: FSMountSourceType::Type,
    pub link: FSClientBodyLink,
    pub client: *mut FSClient,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClient {
    pub __unk16: [::core::ffi::c_char; 5888usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlock {
    pub __unk17: [::core::ffi::c_char; 2688usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSStat {
    pub flags: FSStatFlags::Type,
    pub mode: FSMode::Type,
    pub owner: u32,
    pub group: u32,
    pub size: u32,
    pub allocSize: u32,
    pub quotaSize: u64,
    pub entryId: u32,
    pub created: FSTime,
    pub modified: FSTime,
    pub __unk18: [::core::ffi::c_char; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSStateChangeParams {
    pub callback: FSStateChangeCallback,
    pub param: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncData {
    pub callback: FSAsyncCallback,
    pub param: u32,
    pub ioMsgQueue: *mut OSMessageQueue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncResult {
    pub asyncData: FSAsyncData,
    pub ioMsg: FSMessage,
    pub client: *mut FSClient,
    pub block: *mut FSCmdBlock,
    pub status: FSStatus::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlockBody {
    pub __unk19: [::core::ffi::c_char; 2412usize],
    pub asyncResult: FSAsyncResult,
    pub __unk20: [::core::ffi::c_char; 104usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSDirectoryEntry {
    pub info: FSStat,
    pub name: [::core::ffi::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMountSource {
    pub __unk21: [::core::ffi::c_char; 768usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSVolumeInfo {
    pub flags: u32,
    pub mediaState: FSMediaState::Type,
    pub __unk22: [::core::ffi::c_char; 4usize],
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub unk0x14: i32,
    pub unk0x18: i32,
    pub __unk23: [::core::ffi::c_char; 16usize],
    pub volumeLabel: [::core::ffi::c_char; 128usize],
    pub volumeId: [::core::ffi::c_char; 128usize],
    pub devicePath: [::core::ffi::c_char; 16usize],
    pub mountPath: [::core::ffi::c_char; 128usize],
}
extern "C" {
    pub fn FSInit();
}
extern "C" {
    pub fn FSShutdown();
}
extern "C" {
    pub fn FSAddClient(client: *mut FSClient, errorMask: FSErrorFlag::Type) -> FSStatus::Type;
}
extern "C" {
    pub fn FSDelClient(client: *mut FSClient, errorMask: FSErrorFlag::Type) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetClientNum() -> u32;
}
extern "C" {
    pub fn FSInitCmdBlock(block: *mut FSCmdBlock);
}
extern "C" {
    pub fn FSSetCmdPriority(block: *mut FSCmdBlock, priority: FSPriority) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetStateChangeNotification(client: *mut FSClient, info: *mut FSStateChangeParams);
}
extern "C" {
    pub fn FSGetCwd(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetAsyncResult(message: *mut FSMessage) -> *mut FSAsyncResult;
}
extern "C" {
    pub fn FSGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFileEx(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenFileExAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRewindDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetVolumeInfo(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetVolumeInfoAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSCloseDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        modeMask: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSChangeModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        modeMask: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetStatFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSReadFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSWriteFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSSetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSFlushFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSFlushFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSTruncateFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSTruncateFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSGetVolumeState(client: *mut FSClient) -> FSVolumeState::Type;
}
extern "C" {
    pub fn FSGetLastError(client: *mut FSClient) -> FSError::Type;
}
extern "C" {
    pub fn FSGetLastErrorCodeForViewer(client: *mut FSClient) -> FSError::Type;
}
extern "C" {
    pub fn FSGetMountSource(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        type_: FSMountSourceType::Type,
        out: *mut FSMountSource,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *mut FSMountSource,
        target: *const ::core::ffi::c_char,
        bytes: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSBindMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSBindUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn FSTimeToCalendarTime(time: FSTime, outCalendarTime: *mut OSCalendarTime);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NNResult {
    pub value: i32,
}
pub mod WPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_CHAN_0: Type = 0;
    pub const WPAD_CHAN_1: Type = 1;
    pub const WPAD_CHAN_2: Type = 2;
    pub const WPAD_CHAN_3: Type = 3;
    pub const WPAD_CHAN_4: Type = 4;
    pub const WPAD_CHAN_5: Type = 5;
    pub const WPAD_CHAN_6: Type = 6;
}
pub mod WPADDataFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_FMT_CORE: Type = 0;
    pub const WPAD_FMT_CORE_ACC: Type = 1;
    pub const WPAD_FMT_CORE_ACC_DPD: Type = 2;
    pub const WPAD_FMT_NUNCHUK: Type = 3;
    pub const WPAD_FMT_NUNCHUK_ACC: Type = 4;
    pub const WPAD_FMT_NUNCHUK_ACC_DPD: Type = 5;
    pub const WPAD_FMT_CLASSIC: Type = 6;
    pub const WPAD_FMT_CLASSIC_ACC: Type = 7;
    pub const WPAD_FMT_CLASSIC_ACC_DPD: Type = 8;
    pub const WPAD_FMT_CORE_ACC_DPD_FULL: Type = 9;
    pub const WPAD_FMT_TRAIN: Type = 10;
    pub const WPAD_FMT_GUITAR: Type = 11;
    pub const WPAD_FMT_BALANCE_BOARD: Type = 12;
    pub const WPAD_FMT_DRUM: Type = 15;
    pub const WPAD_FMT_MPLUS: Type = 16;
    pub const WPAD_FMT_TAIKO: Type = 17;
    pub const WPAD_FMT_PRO_CONTROLLER: Type = 22;
}
pub mod WPADExtensionType {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_EXT_CORE: Type = 0;
    pub const WPAD_EXT_NUNCHUK: Type = 1;
    pub const WPAD_EXT_CLASSIC: Type = 2;
    pub const WPAD_EXT_MPLUS: Type = 5;
    pub const WPAD_EXT_MPLUS_NUNCHUK: Type = 6;
    pub const WPAD_EXT_MPLUS_CLASSIC: Type = 7;
    pub const WPAD_EXT_PRO_CONTROLLER: Type = 31;
    pub const WPAD_EXT_DEV_NOT_FOUND: Type = 253;
    pub const WPAD_EXT_UNKNOWN: Type = 255;
}
pub mod WPADButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_BUTTON_LEFT: Type = 1;
    pub const WPAD_BUTTON_RIGHT: Type = 2;
    pub const WPAD_BUTTON_DOWN: Type = 4;
    pub const WPAD_BUTTON_UP: Type = 8;
    pub const WPAD_BUTTON_PLUS: Type = 16;
    pub const WPAD_BUTTON_2: Type = 256;
    pub const WPAD_BUTTON_1: Type = 512;
    pub const WPAD_BUTTON_B: Type = 1024;
    pub const WPAD_BUTTON_A: Type = 2048;
    pub const WPAD_BUTTON_MINUS: Type = 4096;
    pub const WPAD_BUTTON_Z: Type = 8192;
    pub const WPAD_BUTTON_C: Type = 16384;
    pub const WPAD_BUTTON_HOME: Type = 32768;
}
pub mod WPADNunchukButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_NUNCHUK_STICK_EMULATION_LEFT: Type = 1;
    pub const WPAD_NUNCHUK_STICK_EMULATION_RIGHT: Type = 2;
    pub const WPAD_NUNCHUK_STICK_EMULATION_DOWN: Type = 4;
    pub const WPAD_NUNCHUK_STICK_EMULATION_UP: Type = 8;
    pub const WPAD_NUNCHUK_BUTTON_Z: Type = 8192;
    pub const WPAD_NUNCHUK_BUTTON_C: Type = 16384;
}
pub mod WPADClassicButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_CLASSIC_BUTTON_UP: Type = 1;
    pub const WPAD_CLASSIC_BUTTON_LEFT: Type = 2;
    pub const WPAD_CLASSIC_BUTTON_ZR: Type = 4;
    pub const WPAD_CLASSIC_BUTTON_X: Type = 8;
    pub const WPAD_CLASSIC_BUTTON_A: Type = 16;
    pub const WPAD_CLASSIC_BUTTON_Y: Type = 32;
    pub const WPAD_CLASSIC_BUTTON_B: Type = 64;
    pub const WPAD_CLASSIC_BUTTON_ZL: Type = 128;
    pub const WPAD_CLASSIC_BUTTON_R: Type = 512;
    pub const WPAD_CLASSIC_BUTTON_PLUS: Type = 1024;
    pub const WPAD_CLASSIC_BUTTON_HOME: Type = 2048;
    pub const WPAD_CLASSIC_BUTTON_MINUS: Type = 4096;
    pub const WPAD_CLASSIC_BUTTON_L: Type = 8192;
    pub const WPAD_CLASSIC_BUTTON_DOWN: Type = 16384;
    pub const WPAD_CLASSIC_BUTTON_RIGHT: Type = 32768;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_LEFT: Type = 65536;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_RIGHT: Type = 131072;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_DOWN: Type = 262144;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_UP: Type = 524288;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_LEFT: Type = 1048576;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_RIGHT: Type = 2097152;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_DOWN: Type = 4194304;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_UP: Type = 8388608;
}
pub mod WPADProButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_PRO_BUTTON_UP: Type = 1;
    pub const WPAD_PRO_BUTTON_LEFT: Type = 2;
    pub const WPAD_PRO_TRIGGER_ZR: Type = 4;
    pub const WPAD_PRO_BUTTON_X: Type = 8;
    pub const WPAD_PRO_BUTTON_A: Type = 16;
    pub const WPAD_PRO_BUTTON_Y: Type = 32;
    pub const WPAD_PRO_BUTTON_B: Type = 64;
    pub const WPAD_PRO_TRIGGER_ZL: Type = 128;
    pub const WPAD_PRO_RESERVED: Type = 256;
    pub const WPAD_PRO_TRIGGER_R: Type = 512;
    pub const WPAD_PRO_BUTTON_PLUS: Type = 1024;
    pub const WPAD_PRO_BUTTON_HOME: Type = 2048;
    pub const WPAD_PRO_BUTTON_MINUS: Type = 4096;
    pub const WPAD_PRO_TRIGGER_L: Type = 8192;
    pub const WPAD_PRO_BUTTON_DOWN: Type = 16384;
    pub const WPAD_PRO_BUTTON_RIGHT: Type = 32768;
    pub const WPAD_PRO_BUTTON_STICK_R: Type = 65536;
    pub const WPAD_PRO_BUTTON_STICK_L: Type = 131072;
    pub const WPAD_PRO_STICK_L_EMULATION_UP: Type = 2097152;
    pub const WPAD_PRO_STICK_L_EMULATION_DOWN: Type = 1048576;
    pub const WPAD_PRO_STICK_L_EMULATION_LEFT: Type = 262144;
    pub const WPAD_PRO_STICK_L_EMULATION_RIGHT: Type = 524288;
    pub const WPAD_PRO_STICK_R_EMULATION_UP: Type = 33554432;
    pub const WPAD_PRO_STICK_R_EMULATION_DOWN: Type = 16777216;
    pub const WPAD_PRO_STICK_R_EMULATION_LEFT: Type = 4194304;
    pub const WPAD_PRO_STICK_R_EMULATION_RIGHT: Type = 8388608;
}
pub mod WPADLed {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_LED_ONE: Type = 1;
    pub const WPAD_LED_TWO: Type = 2;
    pub const WPAD_LED_THREE: Type = 4;
    pub const WPAD_LED_FOUR: Type = 8;
}
pub mod WPADDpdFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_DPD_FMT_NONE: Type = 0;
    pub const WPAD_DPD_FMT_BASIC: Type = 1;
    pub const WPAD_DPD_FMT_EXTENDED: Type = 3;
    pub const WPAD_DPD_FMT_FULL: Type = 5;
}
pub mod WPADSpeakerCmd {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_SPEAKER_CMD_OFF: Type = 0;
    pub const WPAD_SPEAKER_CMD_ON: Type = 1;
    pub const WPAD_SPEAKER_CMD_MUTE: Type = 2;
    pub const WPAD_SPEAKER_CMD_UNMUTE: Type = 3;
    pub const WPAD_SPEAKER_CMD_PLAY: Type = 4;
    pub const WPAD_SPEAKER_CMD_ON_ALT: Type = 5;
}
pub mod WPADMplsMode {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_MPLS_MODE_DISABLE: Type = 0;
    pub const WPAD_MPLS_MODE_MPLS_ONLY: Type = 4;
    pub const WPAD_MPLS_MODE_MPLS_NUNCHUK: Type = 5;
    pub const WPAD_MPLS_MODE_MPLS_CLASSIC: Type = 7;
}
pub mod WPADPeripheralSpace {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_PERIPHERAL_SPACE_SPEAKER: Type = 162;
    pub const WPAD_PERIPHERAL_SPACE_EXTENSION: Type = 164;
    pub const WPAD_PERIPHERAL_SPACE_MOTIONPLUS: Type = 166;
    pub const WPAD_PERIPHERAL_SPACE_DPD: Type = 176;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADVec2D {
    pub x: i16,
    pub y: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADStatusProController {
    pub __unk24: [::core::ffi::c_char; 40usize],
    pub extensionType: u8,
    pub err: u8,
    pub __unk25: [::core::ffi::c_char; 2usize],
    pub buttons: u32,
    pub leftStick: WPADVec2D,
    pub rightStick: WPADVec2D,
    pub __unk26: [::core::ffi::c_char; 8usize],
    pub dataFormat: WPADDataFormat::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADInfo {
    pub irEnabled: u32,
    pub speakerEnabled: u32,
    pub extensionAttached: u32,
    pub batteryLow: u32,
    pub batteryNearEmpty: u32,
    pub batteryLevel: u8,
    pub led: u8,
    pub protocol: u8,
    pub firmware: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueueElement {
    pub data: [u8; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueue {
    pub frontIndex: u8,
    pub backIndex: u8,
    pub __unk27: [::core::ffi::c_char; 2usize],
    pub elements: *mut WPADiQueueElement,
    pub capacity: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADAddress {
    pub btDeviceAddress: [u8; 6usize],
}
pub type WPADIsMplsAttachedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlLedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlDpdCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlSpeakerCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADGetInfoCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADReadMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADWriteMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type)>;
pub type WPADExtensionCallback = ::core::option::Option<
    unsafe extern "C" fn(chan: WPADChan::Type, ext: WPADExtensionType::Type),
>;
pub type WPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADiSendCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADiWriteGameDataCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
extern "C" {
    pub fn WPADInit();
}
extern "C" {
    pub fn WPADShutdown();
}
extern "C" {
    pub fn WPADDisconnect(chan: WPADChan::Type);
}
extern "C" {
    pub fn WPADProbe(chan: WPADChan::Type, outExtensionType: *mut WPADExtensionType::Type) -> i32;
}
extern "C" {
    pub fn WPADSetDataFormat(chan: WPADChan::Type, format: WPADDataFormat::Type) -> i32;
}
extern "C" {
    pub fn WPADGetDataFormat(chan: WPADChan::Type) -> WPADDataFormat::Type;
}
extern "C" {
    pub fn WPADRead(chan: WPADChan::Type, data: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn WPADControlLed(
        channel: WPADChan::Type,
        led: WPADLed::Type,
        callback: WPADControlLedCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADControlDpd(
        channel: WPADChan::Type,
        mode: WPADDpdFormat::Type,
        callback: WPADControlDpdCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADGetDpdFormat(chan: WPADChan::Type) -> WPADDpdFormat::Type;
}
extern "C" {
    pub fn WPADControlMotor(chan: WPADChan::Type, motorEnabled: BOOL);
}
extern "C" {
    pub fn WPADControlSpeaker(
        chan: WPADChan::Type,
        mode: WPADSpeakerCmd::Type,
        arg1: WPADControlSpeakerCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADIsSpeakerEnabled(chan: WPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn WPADCanSendStreamData(chan: WPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn WPADSendStreamData(
        chan: WPADChan::Type,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn WPADGetSpeakerVolume() -> u8;
}
extern "C" {
    pub fn WPADSetSpeakerVolume(volume: u8);
}
extern "C" {
    pub fn WPADIsMplsAttached(
        channel: WPADChan::Type,
        enabled: *mut BOOL,
        callback: WPADIsMplsAttachedCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADIsMplsIntegrated(channel: WPADChan::Type) -> i32;
}
extern "C" {
    pub fn WPADGetInfo(channel: WPADChan::Type, outInfo: *mut WPADInfo) -> i32;
}
extern "C" {
    pub fn WPADGetInfoAsync(
        channel: WPADChan::Type,
        outInfo: *mut WPADInfo,
        arg1: WPADGetInfoCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADReadMemoryAsync(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADWriteMemoryAsync(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADReadExtReg(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        peripheral: WPADPeripheralSpace::Type,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADWriteExtReg(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u32,
        peripheral: WPADPeripheralSpace::Type,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADGetBLCalibration(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        address: u32,
        size: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADSetPowerSaveMode(chan: WPADChan::Type, powerSave: BOOL);
}
extern "C" {
    pub fn WPADGetPowerSaveMode(chan: WPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn WPADGetAddress(chan: WPADChan::Type, outAddress: *mut WPADAddress);
}
extern "C" {
    pub fn WPADEnableMotor(enable: BOOL);
}
extern "C" {
    pub fn WPADIsMotorEnabled() -> BOOL;
}
extern "C" {
    pub fn WPADEnableURCC(enable: BOOL);
}
extern "C" {
    pub fn WPADIsEnabledURC() -> BOOL;
}
extern "C" {
    pub fn WPADEnableWBC(enable: BOOL);
}
extern "C" {
    pub fn WPADIsEnableWBC() -> BOOL;
}
extern "C" {
    pub fn WPADEnableWiiRemote(enable: BOOL);
}
extern "C" {
    pub fn WPADSetAutoSleepTime(time: u8);
}
extern "C" {
    pub fn WPADStartSyncDevice() -> BOOL;
}
extern "C" {
    pub fn WPADStartSyncDeviceEx(
        deviceAddress: *mut WPADAddress,
        deviceName: *const ::core::ffi::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADSetConnectCallback(
        chan: WPADChan::Type,
        callback: WPADConnectCallback,
    ) -> WPADConnectCallback;
}
extern "C" {
    pub fn WPADSetExtensionCallback(
        chan: WPADChan::Type,
        callback: WPADExtensionCallback,
    ) -> WPADExtensionCallback;
}
extern "C" {
    pub fn WPADSetSamplingCallback(
        chan: WPADChan::Type,
        callback: WPADSamplingCallback,
    ) -> WPADSamplingCallback;
}
extern "C" {
    pub fn WPADiShutdown();
}
extern "C" {
    pub fn WPADiClearQueue(queue: *mut WPADiQueue);
}
extern "C" {
    pub fn WPADiIsAvailableCmdQueue(queue: *mut WPADiQueue, count: u32) -> bool;
}
extern "C" {
    pub fn WPADiHIDParser(channel: WPADChan::Type, hidData: *mut u8) -> i32;
}
extern "C" {
    pub fn WPADiSendSetVibrator(cmdQueue: *mut WPADiQueue) -> BOOL;
}
extern "C" {
    pub fn WPADiSendSetPort(
        cmdQueue: *mut WPADiQueue,
        led: WPADLed::Type,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendSetReportType(
        cmdQueue: *mut WPADiQueue,
        dataFormat: WPADDataFormat::Type,
        powerSave: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendGetContStat(
        cmdQueue: *mut WPADiQueue,
        outInfo: *mut WPADInfo,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableDPD(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableDPDCSB(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendEnableSpeaker(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendMuteSpeaker(
        cmdQueue: *mut WPADiQueue,
        mute: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendStreamData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendWriteDataCmd(
        cmdQueue: *mut WPADiQueue,
        byte: u8,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendWriteData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiSendReadData(
        cmdQueue: *mut WPADiQueue,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
}
extern "C" {
    pub fn WPADiGetGameCode() -> *mut u32;
}
extern "C" {
    pub fn WPADiGetGameType() -> u8;
}
extern "C" {
    pub fn WPADSetGameTitleUtf16(title: *mut u16);
}
extern "C" {
    pub fn WPADGetGameTitleUtf16(chan: WPADChan::Type, outTitle: *mut *mut u16) -> i32;
}
extern "C" {
    pub fn WPADGetGameDataTimestamp(chan: WPADChan::Type, timestamp: *mut OSTime) -> i32;
}
extern "C" {
    pub fn WPADiWriteGameData(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADiReadGameData(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
}
extern "C" {
    pub fn WPADiGetMplsStatus() -> WPADMplsMode::Type;
}
pub use self::WPADChan::Type as KPADChan;
pub use self::WPADDataFormat::Type as KPADDataFormat;
pub use self::WPADExtensionType::Type as KPADExtensionType;
pub use self::WPADMplsMode::Type as KPADMplsMode;
pub mod KPADError {
    pub type Type = ::core::ffi::c_int;
    pub const KPAD_ERROR_OK: Type = 0;
    pub const KPAD_ERROR_NO_SAMPLES: Type = -1;
    pub const KPAD_ERROR_INVALID_CONTROLLER: Type = -2;
    pub const KPAD_ERROR_WPAD_UNINIT: Type = -3;
    pub const KPAD_ERROR_BUSY: Type = -4;
    pub const KPAD_ERROR_UNINITIALIZED: Type = -5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub pos: KPADVec2D,
    pub __unk28: [::core::ffi::c_char; 12usize],
    pub angle: KPADVec2D,
    pub __unk29: [::core::ffi::c_char; 32usize],
    pub extensionType: u8,
    pub error: i8,
    pub posValid: i8,
    pub format: u8,
    pub __bindgen_anon_1: KPADStatus__bindgen_ty_1,
    pub __unk31: [::core::ffi::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union KPADStatus__bindgen_ty_1 {
    pub nunchuk: KPADStatus__bindgen_ty_1__bindgen_ty_1,
    pub classic: KPADStatus__bindgen_ty_1__bindgen_ty_2,
    pub pro: KPADStatus__bindgen_ty_1__bindgen_ty_3,
    pub __unk30: [::core::ffi::c_char; 80usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_1 {
    pub stick: KPADVec2D,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_2 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub leftTrigger: f32,
    pub rightTrigger: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_3 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub charging: i32,
    pub wired: i32,
}
pub type KPADConnectCallback = WPADConnectCallback;
extern "C" {
    pub fn KPADInit();
}
extern "C" {
    pub fn KPADShutdown();
}
extern "C" {
    pub fn KPADRead(chan: KPADChan, data: *mut KPADStatus, size: u32) -> i32;
}
extern "C" {
    pub fn KPADReadEx(
        chan: KPADChan,
        data: *mut KPADStatus,
        size: u32,
        error: *mut KPADError::Type,
    ) -> i32;
}
extern "C" {
    pub fn KPADSetMaxControllers(maxControllers: u32) -> i32;
}
extern "C" {
    pub fn KPADGetMaxControllers() -> u32;
}
extern "C" {
    pub fn KPADGetGameMaxControllers() -> u32;
}
extern "C" {
    pub fn KPADSetConnectCallback(
        chan: KPADChan,
        callback: KPADConnectCallback,
    ) -> KPADConnectCallback;
}
extern "C" {
    pub fn KPADEnableMpls(channel: KPADChan, mode: KPADMplsMode);
}
extern "C" {
    pub fn KPADDisableMpls(channel: KPADChan);
}
extern "C" {
    pub fn KPADGetMplsStatus(chan: KPADChan) -> KPADMplsMode;
}
extern "C" {
    pub fn KPADEnableDPD(chan: KPADChan);
}
extern "C" {
    pub fn KPADDisableDPD(chan: KPADChan);
}
pub mod VPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_CHAN_0: Type = 0;
    pub const VPAD_CHAN_1: Type = 1;
}
pub mod VPADIRCStatusFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_IRC_STATUS_FLAG_HAS_DATA: Type = 1;
    pub const VPAD_IRC_STATUS_FLAG_CONNECTED: Type = 2;
}
extern "C" {
    pub fn VPADBASEInit();
}
extern "C" {
    pub fn VPADBASEShutdown();
}
extern "C" {
    pub fn VPADBASEIsInit() -> BOOL;
}
extern "C" {
    pub fn VPADBASEGetMotorOnRemainingCount(chan: VPADChan::Type) -> i32;
}
extern "C" {
    pub fn VPADBASESetMotorOnRemainingCount(chan: VPADChan::Type, counter: i32) -> i32;
}
extern "C" {
    pub fn VPADBASESetSensorBarSetting(chan: VPADChan::Type, setting: i8);
}
extern "C" {
    pub fn VPADBASEGetSensorBarSetting(chan: VPADChan::Type, outSetting: *mut i8);
}
extern "C" {
    pub fn VPADBASEGetHeadphoneStatus(chan: VPADChan::Type) -> i32;
}
extern "C" {
    pub fn VPADBASEGetGameControllerMode(chan: VPADChan::Type, mode: *mut i32);
}
extern "C" {
    pub fn VPADBASESetGameControllerMode(chan: VPADChan::Type, mode: i32);
}
extern "C" {
    pub fn VPADBASEGetPowerButtonPressStatus(
        chan: VPADChan::Type,
        tick: *mut u32,
        status: *mut u32,
    );
}
extern "C" {
    pub fn VPADBASESetPowerButtonPressStatus(chan: VPADChan::Type, tick: u32, status: u32);
}
extern "C" {
    pub fn VPADBASESetPowerButtonDisableMode(chan: VPADChan::Type, mode: u32);
}
extern "C" {
    pub fn VPADBASEClearIRCEvent(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADBASEGetIRCStatus(chan: VPADChan::Type) -> VPADIRCStatusFlags::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADGyroStatus {
    _unused: [u8; 0],
}
pub mod VPADButtons {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_BUTTON_A: Type = 32768;
    pub const VPAD_BUTTON_B: Type = 16384;
    pub const VPAD_BUTTON_X: Type = 8192;
    pub const VPAD_BUTTON_Y: Type = 4096;
    pub const VPAD_BUTTON_LEFT: Type = 2048;
    pub const VPAD_BUTTON_RIGHT: Type = 1024;
    pub const VPAD_BUTTON_UP: Type = 512;
    pub const VPAD_BUTTON_DOWN: Type = 256;
    pub const VPAD_BUTTON_ZL: Type = 128;
    pub const VPAD_BUTTON_ZR: Type = 64;
    pub const VPAD_BUTTON_L: Type = 32;
    pub const VPAD_BUTTON_R: Type = 16;
    pub const VPAD_BUTTON_PLUS: Type = 8;
    pub const VPAD_BUTTON_MINUS: Type = 4;
    pub const VPAD_BUTTON_HOME: Type = 2;
    pub const VPAD_BUTTON_SYNC: Type = 1;
    pub const VPAD_BUTTON_STICK_R: Type = 131072;
    pub const VPAD_BUTTON_STICK_L: Type = 262144;
    pub const VPAD_BUTTON_TV: Type = 65536;
    pub const VPAD_STICK_R_EMULATION_LEFT: Type = 67108864;
    pub const VPAD_STICK_R_EMULATION_RIGHT: Type = 33554432;
    pub const VPAD_STICK_R_EMULATION_UP: Type = 16777216;
    pub const VPAD_STICK_R_EMULATION_DOWN: Type = 8388608;
    pub const VPAD_STICK_L_EMULATION_LEFT: Type = 1073741824;
    pub const VPAD_STICK_L_EMULATION_RIGHT: Type = 536870912;
    pub const VPAD_STICK_L_EMULATION_UP: Type = 268435456;
    pub const VPAD_STICK_L_EMULATION_DOWN: Type = 134217728;
}
pub mod VPADTouchPadValidity {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_VALID: Type = 0;
    pub const VPAD_INVALID_X: Type = 1;
    pub const VPAD_INVALID_Y: Type = 2;
}
pub mod VPADTouchPadResolution {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_TP_1920X1080: Type = 0;
    pub const VPAD_TP_1280X720: Type = 1;
    pub const VPAD_TP_854X480: Type = 2;
}
pub mod VPADReadError {
    pub type Type = ::core::ffi::c_int;
    pub const VPAD_READ_SUCCESS: Type = 0;
    pub const VPAD_READ_NO_SAMPLES: Type = -1;
    pub const VPAD_READ_INVALID_CONTROLLER: Type = -2;
    pub const VPAD_READ_BUSY: Type = -4;
    pub const VPAD_READ_UNINITIALIZED: Type = -5;
}
pub mod VPADLcdMode {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_LCD_STANDBY: Type = 0;
    pub const VPAD_LCD_OFF: Type = 1;
    pub const VPAD_LCD_ON: Type = 255;
}
pub mod VPADGyroZeroDriftMode {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_GYRO_ZERODRIFT_LOOSE: Type = 0;
    pub const VPAD_GYRO_ZERODRIFT_STANDARD: Type = 1;
    pub const VPAD_GYRO_ZERODRIFT_TIGHT: Type = 2;
    pub const VPAD_GYRO_ZERODRIFT_NONE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADDirection {
    pub x: VPADVec3D,
    pub y: VPADVec3D,
    pub z: VPADVec3D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADTouchCalibrationParam {
    pub adjustX: u16,
    pub adjustY: u16,
    pub scaleX: f32,
    pub scaleY: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADTouchData {
    pub x: u16,
    pub y: u16,
    pub touched: u16,
    pub validity: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADAccStatus {
    pub acc: VPADVec3D,
    pub magnitude: f32,
    pub variation: f32,
    pub vertical: VPADVec2D,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: VPADVec2D,
    pub rightStick: VPADVec2D,
    pub accelorometer: VPADAccStatus,
    pub gyro: VPADVec3D,
    pub angle: VPADVec3D,
    pub error: u8,
    pub __unk32: [::core::ffi::c_char; 1usize],
    pub tpNormal: VPADTouchData,
    pub tpFiltered1: VPADTouchData,
    pub tpFiltered2: VPADTouchData,
    pub __unk33: [::core::ffi::c_char; 2usize],
    pub direction: VPADDirection,
    pub usingHeadphones: BOOL,
    pub mag: VPADVec3D,
    pub slideVolume: u8,
    pub battery: u8,
    pub micStatus: u8,
    pub slideVolumeEx: u8,
    pub __unk34: [::core::ffi::c_char; 8usize],
}
pub type VPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: VPADChan::Type)>;
extern "C" {
    pub fn VPADInit();
}
extern "C" {
    pub fn VPADShutdown();
}
extern "C" {
    pub fn VPADRead(
        chan: VPADChan::Type,
        buffers: *mut VPADStatus,
        count: u32,
        outError: *mut VPADReadError::Type,
    ) -> i32;
}
extern "C" {
    pub fn VPADGetTPCalibrationParam(
        chan: VPADChan::Type,
        outParam: *mut VPADTouchCalibrationParam,
    );
}
extern "C" {
    pub fn VPADSetTPCalibrationParam(chan: VPADChan::Type, param: *const VPADTouchCalibrationParam);
}
extern "C" {
    pub fn VPADGetTPCalibratedPoint(
        chan: VPADChan::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    pub fn VPADGetTPCalibratedPointEx(
        chan: VPADChan::Type,
        tpResolution: VPADTouchPadResolution::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
}
extern "C" {
    pub fn VPADSetAccParam(chan: VPADChan::Type, playRadius: f32, sensitivity: f32);
}
extern "C" {
    pub fn VPADGetAccParam(chan: VPADChan::Type, outPlayRadius: *mut f32, outSensitivity: *mut f32);
}
extern "C" {
    pub fn VPADSetBtnRepeat(chan: VPADChan::Type, delaySec: f32, pulseSec: f32);
}
extern "C" {
    pub fn VPADEnableStickCrossClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableStickCrossClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADSetLStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
}
extern "C" {
    pub fn VPADSetRStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
}
extern "C" {
    pub fn VPADGetGyroDirReviseParam(chan: VPADChan::Type, param: *mut f32);
}
extern "C" {
    pub fn VPADGetGyroZeroDriftMode(chan: VPADChan::Type, mode: *mut VPADGyroZeroDriftMode::Type);
}
extern "C" {
    pub fn VPADGetLStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADGetRStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
}
extern "C" {
    pub fn VPADSetStickOrigin(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableLStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableRStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableLStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableRStickZeroClamp(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADSetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADGetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
}
extern "C" {
    pub fn VPADSetGyroAngle(chan: VPADChan::Type, ax: f32, ay: f32, az: f32);
}
extern "C" {
    pub fn VPADSetGyroDirReviseBase(chan: VPADChan::Type, base: *mut VPADDirection);
}
extern "C" {
    pub fn VPADSetGyroDirReviseParam(chan: VPADChan::Type, param: f32);
}
extern "C" {
    pub fn VPADSetGyroDirection(chan: VPADChan::Type, dir: *mut VPADDirection);
}
extern "C" {
    pub fn VPADSetGyroDirectionMag(chan: VPADChan::Type, mag: f32);
}
extern "C" {
    pub fn VPADSetGyroMagnification(chan: VPADChan::Type, pitch: f32, yaw: f32, roll: f32);
}
extern "C" {
    pub fn VPADSetGyroZeroDriftMode(chan: VPADChan::Type, mode: VPADGyroZeroDriftMode::Type);
}
extern "C" {
    pub fn VPADEnableGyroZeroPlay(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableGyroDirRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnableGyroAccRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroZeroPlay(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroDirRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADDisableGyroAccRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADIsEnableGyroZeroPlay(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroZeroDrift(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroDirRevise(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADIsEnableGyroAccRevise(chan: VPADChan::Type) -> f32;
}
extern "C" {
    pub fn VPADSetGyroZeroPlayParam(chan: VPADChan::Type, radius: f32);
}
extern "C" {
    pub fn VPADInitGyroZeroPlayParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroDirReviseParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroAccReviseParam(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADStartGyroMagRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADStopGyroMagRevise(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADInitGyroZeroDriftMode(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADGetTVMenuStatus(chan: VPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn VPADSetTVMenuInvalid(chan: VPADChan::Type, invalid: BOOL);
}
extern "C" {
    pub fn VPADDisablePowerButton(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADEnablePowerButton(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADControlMotor(chan: VPADChan::Type, pattern: *mut u8, length: u8) -> i32;
}
extern "C" {
    pub fn VPADStopMotor(chan: VPADChan::Type);
}
extern "C" {
    pub fn VPADSetLcdMode(chan: VPADChan::Type, lcdMode: VPADLcdMode::Type) -> i32;
}
extern "C" {
    pub fn VPADGetLcdMode(chan: VPADChan::Type, outLcdMode: *mut VPADLcdMode::Type) -> i32;
}
extern "C" {
    pub fn VPADSetSensorBar(chan: VPADChan::Type, on: BOOL) -> i32;
}
extern "C" {
    pub fn VPADSetSamplingCallback(
        chan: VPADChan::Type,
        callback: VPADSamplingCallback,
    ) -> VPADSamplingCallback;
}
extern "C" {
    pub fn VPADGetButtonProcMode(chan: VPADChan::Type) -> BOOL;
}
pub type wint_t = ::core::ffi::c_int;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::core::ffi::c_int;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_ulong;
pub type _ssize_t = ::core::ffi::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::core::ffi::c_ulong;
pub type _LOCK_T = ::core::ffi::c_int;
pub type _LOCK_RECURSIVE_T = ::core::ffi::c_int;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::core::ffi::c_int;
}
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub deviceData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::core::ffi::c_void,
        arg2: *mut ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
pub type MICHandle = ::core::ffi::c_int;
pub mod MICError {
    pub type Type = ::core::ffi::c_int;
    pub const MIC_ERROR_OK: Type = 0;
    pub const MIC_ERROR_NOT_OPENED: Type = -1;
    pub const MIC_ERROR_INVALID_HANDLE: Type = -2;
    pub const MIC_ERROR_INIT: Type = -5;
    pub const MIC_ERROR_ALREADY_CLOSED: Type = -7;
    pub const MIC_ERROR_INVALID_INSTANCE: Type = -8;
}
pub mod MICInstance {
    pub type Type = ::core::ffi::c_uint;
    pub const MIC_INSTANCE_0: Type = 0;
    pub const MIC_INSTANCE_1: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MICWorkMemory {
    pub sampleMaxCount: usize,
    pub sampleBuffer: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MICStatus {
    pub state: ::core::ffi::c_int,
    pub availableData: ::core::ffi::c_int,
    pub bufferPos: ::core::ffi::c_int,
}
extern "C" {
    pub fn MICInit(
        instance: MICInstance::Type,
        unused: ::core::ffi::c_int,
        workMemory: *mut MICWorkMemory,
        outError: *mut MICError::Type,
    ) -> MICHandle;
}
extern "C" {
    pub fn MICOpen(handle: MICHandle) -> MICError::Type;
}
extern "C" {
    pub fn MICGetState(
        handle: MICHandle,
        state: ::core::ffi::c_int,
        outStateVal: *mut u32,
    ) -> MICError::Type;
}
extern "C" {
    pub fn MICSetState(
        handle: MICHandle,
        state: ::core::ffi::c_int,
        stateVal: u32,
    ) -> MICError::Type;
}
extern "C" {
    pub fn MICGetStatus(handle: MICHandle, outStatus: *mut MICStatus) -> MICError::Type;
}
extern "C" {
    pub fn MICSetDataConsumed(
        handle: MICHandle,
        dataAmountConsumed: ::core::ffi::c_int,
    ) -> MICError::Type;
}
extern "C" {
    pub fn MICClose(handle: MICHandle) -> MICError::Type;
}
extern "C" {
    pub fn MICUninit(handle: MICHandle) -> MICError::Type;
}
pub type NFCError = i32;
pub type NFCProtocol = u8;
pub type NFCTechnology = u8;
pub type NFCTechnologyMask = u8;
pub type NFCNDEFFlags = u8;
pub mod NFCMode {
    pub type Type = ::core::ffi::c_int;
    pub const NFC_MODE_INVALID: Type = -1;
    pub const NFC_MODE_IDLE: Type = 0;
    pub const NFC_MODE_ACTIVE: Type = 1;
}
pub mod NFCProtocolEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_PROTOCOL_UNKNOWN: Type = 0;
    pub const NFC_PROTOCOL_T1T: Type = 1;
    pub const NFC_PROTOCOL_T2T: Type = 2;
    pub const NFC_PROTOCOL_T3T: Type = 3;
    pub const NFC_PROTOCOL_ISO_DEP: Type = 4;
    pub const NFC_PROTOCOL_15693: Type = 131;
}
pub mod NFCTechnologyEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_TECHNOLOGY_A: Type = 0;
    pub const NFC_TECHNOLOGY_B: Type = 1;
    pub const NFC_TECHNOLOGY_F: Type = 2;
    pub const NFC_TECHNOLOGY_ISO15693: Type = 6;
}
pub mod NFCTechnologyMaskEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_TECHNOLOGY_MASK_ALL: Type = 0;
    pub const NFC_TECHNOLOGY_MASK_A: Type = 1;
    pub const NFC_TECHNOLOGY_MASK_B: Type = 2;
    pub const NFC_TECHNOLOGY_MASK_F: Type = 4;
    pub const NFC_TECHNOLOGY_MASK_ISO15693: Type = 8;
}
pub mod NFCNDEFFlagsEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_NDEF_FLAG_READ_ONLY: Type = 1;
    pub const NFC_NDEF_FLAG_FORMATED: Type = 2;
    pub const NFC_NDEF_FLAG_SUPPORTED: Type = 4;
    pub const NFC_NDEF_FLAG_UNKNOWN: Type = 8;
    pub const NFC_NDEF_FLAG_FORMATABLE: Type = 16;
    pub const NFC_NDEF_FLAG_SOFT_LOCKABLE: Type = 32;
    pub const NFC_NDEF_FLAG_HARD_LOCKABLE: Type = 64;
    pub const NFC_NDEF_FLAG_OTP: Type = 128;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCUid {
    pub uid: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCTagInfo {
    pub uidSize: u8,
    pub uid: [u8; 10usize],
    pub technology: NFCTechnology,
    pub protocol: NFCProtocol,
    pub __unk35: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCNTAGVersion {
    pub header: u8,
    pub vendorId: u8,
    pub productType: u8,
    pub productSubtype: u8,
    pub majorProductVersion: u8,
    pub minorProductversion: u8,
    pub storageSize: u8,
    pub protocolType: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCReadT2TResult {
    pub numReads: u8,
    pub read0Start: u8,
    pub read0End: u8,
    pub read1Start: u8,
    pub read1End: u8,
    pub read2Start: u8,
    pub read2End: u8,
    pub read3Start: u8,
    pub read3End: u8,
    pub data: [u8; 928usize],
}
pub type NFCCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCTagDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(chan: VPADChan::Type, hasTag: BOOL, userContext: *mut ::core::ffi::c_void),
>;
pub type NFCDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        hasLockedData: BOOL,
        flags: NFCNDEFFlags,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        responseSize: u32,
        responseData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataTwiceCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        numCompleted: u8,
        response0Size: u32,
        response0Data: *mut ::core::ffi::c_void,
        response1Size: u32,
        response1Data: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        dataSize: u32,
        data: *mut ::core::ffi::c_void,
        lockedDataSize: u32,
        lockedData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        rfDiscId: u8,
        protocol: NFCProtocol,
        technology: NFCTechnology,
        uidSize: u8,
        uid: *mut u8,
        version: *mut NFCNTAGVersion,
        result: *mut NFCReadT2TResult,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        tagInfo: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoMultiCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        numTagInfos: u8,
        tagInfo0: *mut NFCTagInfo,
        tagInfo1: *mut NFCTagInfo,
        tagInfo2: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn NFCInit(chan: VPADChan::Type) -> NFCError;
}
extern "C" {
    pub fn NFCInitEx(chan: VPADChan::Type, powerMode: u32) -> NFCError;
}
extern "C" {
    pub fn NFCShutdown(chan: VPADChan::Type) -> NFCError;
}
extern "C" {
    pub fn NFCIsInit(chan: VPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn NFCProc(chan: VPADChan::Type);
}
extern "C" {
    pub fn NFCSetTagDetectCallback(
        chan: VPADChan::Type,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn NFCGetMode(chan: VPADChan::Type) -> NFCMode::Type;
}
extern "C" {
    pub fn NFCSetMode(chan: VPADChan::Type, mode: NFCMode::Type) -> NFCError;
}
extern "C" {
    pub fn NFCAbort(
        chan: VPADChan::Type,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCAntennaCheck(
        chan: VPADChan::Type,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCDetect(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSetLockBitsForT1T(
        chan: VPADChan::Type,
        numBlocks: u8,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCRead(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCWrite(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        size: u32,
        data: *mut ::core::ffi::c_void,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawData(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataEx(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataEx2(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        techMask: NFCTechnologyMask,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataWithPrePolling(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataWithPrePollingEx(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSendRawDataTwice(
        chan: VPADChan::Type,
        command0Timeout: u32,
        command0Size: u32,
        response0Size: u32,
        command0Data: *mut ::core::ffi::c_void,
        command1Timeout: u32,
        command1Size: u32,
        response1Size: u32,
        command1Data: *mut ::core::ffi::c_void,
        callback: NFCRawDataTwiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCFormat(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetTagInfo(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetTagInfoMulti(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoMultiCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCIsTagPresent(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCSetReadOnly(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCReadT2T(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numReads: u8,
        read0Start: u8,
        read0End: u8,
        read1Start: u8,
        read1End: u8,
        read2Start: u8,
        read2End: u8,
        read3Start: u8,
        read3End: u8,
        authenticate: u8,
        callback: NFCReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCWriteT2T(
        chan: VPADChan::Type,
        discoveryTimeout: u16,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numWrites: u8,
        write0Start: u8,
        write0Size: u8,
        write0Data: *mut ::core::ffi::c_void,
        write1Start: u8,
        write1Size: u8,
        write1Data: *mut ::core::ffi::c_void,
        write2Start: u8,
        write2Size: u8,
        write2Data: *mut ::core::ffi::c_void,
        write3Start: u8,
        write3Size: u8,
        write3Data: *mut ::core::ffi::c_void,
        activationStart: u8,
        deactivationData: *mut u32,
        activationData: *mut u32,
        authenticate: u8,
        activate: u8,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
}
extern "C" {
    pub fn NFCGetUIDFromActivationEventData(
        data: *mut ::core::ffi::c_void,
        outProtocol: *mut NFCProtocol,
        outTechnology: *mut NFCTechnology,
        outUidSize: *mut u8,
        outUid: *mut u8,
    );
}
extern "C" {
    pub fn __NFCSystemAbort(chan: VPADChan::Type) -> NFCError;
}
pub mod GX2AAMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_AA_MODE1X: Type = 0;
    pub const GX2_AA_MODE2X: Type = 1;
    pub const GX2_AA_MODE4X: Type = 2;
    pub const GX2_AA_MODE8X: Type = 3;
}
pub mod GX2AlphaToMaskMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ALPHA_TO_MASK_MODE_NON_DITHERED: Type = 0;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_0: Type = 1;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_90: Type = 2;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_180: Type = 3;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_270: Type = 4;
}
pub mod GX2AspectRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ASPECT_RATIO_4_3: Type = 0;
    pub const GX2_ASPECT_RATIO_16_9: Type = 1;
}
pub mod GX2AttribFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ATTRIB_TYPE_8: Type = 0;
    pub const GX2_ATTRIB_TYPE_4_4: Type = 1;
    pub const GX2_ATTRIB_TYPE_16: Type = 2;
    pub const GX2_ATTRIB_TYPE_16_FLOAT: Type = 3;
    pub const GX2_ATTRIB_TYPE_8_8: Type = 4;
    pub const GX2_ATTRIB_TYPE_32: Type = 5;
    pub const GX2_ATTRIB_TYPE_32_FLOAT: Type = 6;
    pub const GX2_ATTRIB_TYPE_16_16: Type = 7;
    pub const GX2_ATTRIB_TYPE_16_16_FLOAT: Type = 8;
    pub const GX2_ATTRIB_TYPE_10_11_11_FLOAT: Type = 9;
    pub const GX2_ATTRIB_TYPE_8_8_8_8: Type = 10;
    pub const GX2_ATTRIB_TYPE_10_10_10_2: Type = 11;
    pub const GX2_ATTRIB_TYPE_32_32: Type = 12;
    pub const GX2_ATTRIB_TYPE_32_32_FLOAT: Type = 13;
    pub const GX2_ATTRIB_TYPE_16_16_16_16: Type = 14;
    pub const GX2_ATTRIB_TYPE_16_16_16_16_FLOAT: Type = 15;
    pub const GX2_ATTRIB_TYPE_32_32_32: Type = 16;
    pub const GX2_ATTRIB_TYPE_32_32_32_FLOAT: Type = 17;
    pub const GX2_ATTRIB_TYPE_32_32_32_32: Type = 18;
    pub const GX2_ATTRIB_TYPE_32_32_32_32_FLOAT: Type = 19;
    pub const GX2_ATTRIB_FLAG_INTEGER: Type = 256;
    pub const GX2_ATTRIB_FLAG_SIGNED: Type = 512;
    pub const GX2_ATTRIB_FLAG_DEGAMMA: Type = 1024;
    pub const GX2_ATTRIB_FLAG_SCALED: Type = 2048;
    pub const GX2_ATTRIB_FORMAT_UNORM_8: Type = 0;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8: Type = 4;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8_8_8: Type = 10;
    pub const GX2_ATTRIB_FORMAT_UINT_8: Type = 256;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8: Type = 260;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8_8_8: Type = 266;
    pub const GX2_ATTRIB_FORMAT_SNORM_8: Type = 512;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8: Type = 516;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8_8_8: Type = 522;
    pub const GX2_ATTRIB_FORMAT_SINT_8: Type = 768;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8: Type = 772;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8_8_8: Type = 778;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32: Type = 2054;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32: Type = 2061;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32: Type = 2065;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32: Type = 2067;
}
pub mod GX2AttribIndexType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ATTRIB_INDEX_PER_VERTEX: Type = 0;
    pub const GX2_ATTRIB_INDEX_PER_INSTANCE: Type = 1;
}
pub mod GX2BlendMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BLEND_MODE_ZERO: Type = 0;
    pub const GX2_BLEND_MODE_ONE: Type = 1;
    pub const GX2_BLEND_MODE_SRC_COLOR: Type = 2;
    pub const GX2_BLEND_MODE_INV_SRC_COLOR: Type = 3;
    pub const GX2_BLEND_MODE_SRC_ALPHA: Type = 4;
    pub const GX2_BLEND_MODE_INV_SRC_ALPHA: Type = 5;
    pub const GX2_BLEND_MODE_DST_ALPHA: Type = 6;
    pub const GX2_BLEND_MODE_INV_DST_ALPHA: Type = 7;
    pub const GX2_BLEND_MODE_DST_COLOR: Type = 8;
    pub const GX2_BLEND_MODE_INV_DST_COLOR: Type = 9;
    pub const GX2_BLEND_MODE_SRC_ALPHA_SAT: Type = 10;
    pub const GX2_BLEND_MODE_BOTH_SRC_ALPHA: Type = 11;
    pub const GX2_BLEND_MODE_BOTH_INV_SRC_ALPHA: Type = 12;
    pub const GX2_BLEND_MODE_BLEND_FACTOR: Type = 13;
    pub const GX2_BLEND_MODE_INV_BLEND_FACTOR: Type = 14;
    pub const GX2_BLEND_MODE_SRC1_COLOR: Type = 15;
    pub const GX2_BLEND_MODE_INV_SRC1_COLOR: Type = 16;
    pub const GX2_BLEND_MODE_SRC1_ALPHA: Type = 17;
    pub const GX2_BLEND_MODE_INV_SRC1_ALPHA: Type = 18;
    pub const GX2_BLEND_MODE_CONSTANT_ALPHA: Type = 19;
    pub const GX2_BLEND_MODE_INV_CONSTANT_ALPHA: Type = 20;
}
pub mod GX2BlendCombineMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BLEND_COMBINE_MODE_ADD: Type = 0;
    pub const GX2_BLEND_COMBINE_MODE_SUB: Type = 1;
    pub const GX2_BLEND_COMBINE_MODE_MIN: Type = 2;
    pub const GX2_BLEND_COMBINE_MODE_MAX: Type = 3;
    pub const GX2_BLEND_COMBINE_MODE_REV_SUB: Type = 4;
}
pub mod GX2BufferingMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BUFFERING_MODE_SINGLE: Type = 1;
    pub const GX2_BUFFERING_MODE_DOUBLE: Type = 2;
    pub const GX2_BUFFERING_MODE_TRIPLE: Type = 3;
}
pub mod GX2ChannelMask {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_CHANNEL_MASK_R: Type = 1;
    pub const GX2_CHANNEL_MASK_G: Type = 2;
    pub const GX2_CHANNEL_MASK_RG: Type = 3;
    pub const GX2_CHANNEL_MASK_B: Type = 4;
    pub const GX2_CHANNEL_MASK_RB: Type = 5;
    pub const GX2_CHANNEL_MASK_GB: Type = 6;
    pub const GX2_CHANNEL_MASK_RGB: Type = 7;
    pub const GX2_CHANNEL_MASK_A: Type = 8;
    pub const GX2_CHANNEL_MASK_RA: Type = 9;
    pub const GX2_CHANNEL_MASK_GA: Type = 10;
    pub const GX2_CHANNEL_MASK_RGA: Type = 11;
    pub const GX2_CHANNEL_MASK_BA: Type = 12;
    pub const GX2_CHANNEL_MASK_RBA: Type = 13;
    pub const GX2_CHANNEL_MASK_GBA: Type = 14;
    pub const GX2_CHANNEL_MASK_RGBA: Type = 15;
}
pub mod GX2ClearFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_CLEAR_FLAGS_DEPTH: Type = 1;
    pub const GX2_CLEAR_FLAGS_STENCIL: Type = 2;
    pub const GX2_CLEAR_FLAGS_BOTH: Type = 3;
}
pub mod GX2CompareFunction {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_COMPARE_FUNC_NEVER: Type = 0;
    pub const GX2_COMPARE_FUNC_LESS: Type = 1;
    pub const GX2_COMPARE_FUNC_EQUAL: Type = 2;
    pub const GX2_COMPARE_FUNC_LEQUAL: Type = 3;
    pub const GX2_COMPARE_FUNC_GREATER: Type = 4;
    pub const GX2_COMPARE_FUNC_NOT_EQUAL: Type = 5;
    pub const GX2_COMPARE_FUNC_GEQUAL: Type = 6;
    pub const GX2_COMPARE_FUNC_ALWAYS: Type = 7;
}
pub mod GX2DrcRenderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DRC_RENDER_MODE_DISABLED: Type = 0;
    pub const GX2_DRC_RENDER_MODE_SINGLE: Type = 1;
    pub const GX2_DRC_RENDER_MODE_DOUBLE: Type = 2;
}
pub mod GX2EventType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_EVENT_TYPE_START_OF_PIPE_INTERRUPT: Type = 0;
    pub const GX2_EVENT_TYPE_END_OF_PIPE_INTERRUPT: Type = 1;
    pub const GX2_EVENT_TYPE_VSYNC: Type = 2;
    pub const GX2_EVENT_TYPE_FLIP: Type = 3;
    pub const GX2_EVENT_TYPE_DISPLAY_LIST_OVERRUN: Type = 4;
}
pub mod GX2EndianSwapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ENDIAN_SWAP_NONE: Type = 0;
    pub const GX2_ENDIAN_SWAP_8_IN_16: Type = 1;
    pub const GX2_ENDIAN_SWAP_8_IN_32: Type = 2;
    pub const GX2_ENDIAN_SWAP_DEFAULT: Type = 3;
}
pub mod GX2FetchShaderType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_FETCH_SHADER_TESSELLATION_NONE: Type = 0;
    pub const GX2_FETCH_SHADER_TESSELLATION_LINE: Type = 1;
    pub const GX2_FETCH_SHADER_TESSELLATION_TRIANGLE: Type = 2;
    pub const GX2_FETCH_SHADER_TESSELLATION_QUAD: Type = 3;
}
pub mod GX2FrontFace {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_FRONT_FACE_CCW: Type = 0;
    pub const GX2_FRONT_FACE_CW: Type = 1;
}
pub mod GX2IndexType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INDEX_TYPE_U16_LE: Type = 0;
    pub const GX2_INDEX_TYPE_U32_LE: Type = 1;
    pub const GX2_INDEX_TYPE_U16: Type = 4;
    pub const GX2_INDEX_TYPE_U32: Type = 9;
}
pub mod GX2InvalidateMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INVALIDATE_MODE_NONE: Type = 0;
    pub const GX2_INVALIDATE_MODE_ATTRIBUTE_BUFFER: Type = 1;
    pub const GX2_INVALIDATE_MODE_TEXTURE: Type = 2;
    pub const GX2_INVALIDATE_MODE_UNIFORM_BLOCK: Type = 4;
    pub const GX2_INVALIDATE_MODE_SHADER: Type = 8;
    pub const GX2_INVALIDATE_MODE_COLOR_BUFFER: Type = 16;
    pub const GX2_INVALIDATE_MODE_DEPTH_BUFFER: Type = 32;
    pub const GX2_INVALIDATE_MODE_CPU: Type = 64;
    pub const GX2_INVALIDATE_MODE_STREAM_OUT_BUFFER: Type = 128;
    pub const GX2_INVALIDATE_MODE_EXPORT_BUFFER: Type = 256;
    pub const GX2_INVALIDATE_MODE_CPU_ATTRIBUTE_BUFFER: Type = 65;
    pub const GX2_INVALIDATE_MODE_CPU_TEXTURE: Type = 66;
    pub const GX2_INVALIDATE_MODE_CPU_SHADER: Type = 72;
}
pub mod GX2InitAttributes {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INIT_END: Type = 0;
    pub const GX2_INIT_CMD_BUF_BASE: Type = 1;
    pub const GX2_INIT_CMD_BUF_POOL_SIZE: Type = 2;
    pub const GX2_INIT_ARGC: Type = 7;
    pub const GX2_INIT_ARGV: Type = 8;
    pub const GX2_INIT_PROFILE_MODE: Type = 9;
    pub const GX2_INIT_TOSS_STAGE: Type = 10;
    pub const GX2_INIT_APP_IO_THREAD_STACK_SIZE: Type = 11;
}
pub mod GX2LogicOp {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_LOGIC_OP_CLEAR: Type = 0;
    pub const GX2_LOGIC_OP_NOR: Type = 17;
    pub const GX2_LOGIC_OP_INV_AND: Type = 34;
    pub const GX2_LOGIC_OP_INV_COPY: Type = 51;
    pub const GX2_LOGIC_OP_REV_AND: Type = 68;
    pub const GX2_LOGIC_OP_INV: Type = 85;
    pub const GX2_LOGIC_OP_XOR: Type = 102;
    pub const GX2_LOGIC_OP_NOT_AND: Type = 119;
    pub const GX2_LOGIC_OP_AND: Type = 136;
    pub const GX2_LOGIC_OP_EQUIV: Type = 153;
    pub const GX2_LOGIC_OP_NOP: Type = 170;
    pub const GX2_LOGIC_OP_INV_OR: Type = 187;
    pub const GX2_LOGIC_OP_COPY: Type = 204;
    pub const GX2_LOGIC_OP_REV_OR: Type = 221;
    pub const GX2_LOGIC_OP_OR: Type = 238;
    pub const GX2_LOGIC_OP_SET: Type = 255;
}
pub mod GX2PrimitiveMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_PRIMITIVE_MODE_POINTS: Type = 1;
    pub const GX2_PRIMITIVE_MODE_LINES: Type = 2;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP: Type = 3;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES: Type = 4;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_FAN: Type = 5;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP: Type = 6;
    pub const GX2_PRIMITIVE_MODE_LINES_ADJACENCY: Type = 10;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP_ADJACENCY: Type = 11;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES_ADJACENCY: Type = 12;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP_ADJACENCY: Type = 13;
    pub const GX2_PRIMITIVE_MODE_RECTS: Type = 17;
    pub const GX2_PRIMITIVE_MODE_LINE_LOOP: Type = 18;
    pub const GX2_PRIMITIVE_MODE_QUADS: Type = 19;
    pub const GX2_PRIMITIVE_MODE_QUAD_STRIP: Type = 20;
}
pub mod GX2PolygonMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_POLYGON_MODE_POINT: Type = 0;
    pub const GX2_POLYGON_MODE_LINE: Type = 1;
    pub const GX2_POLYGON_MODE_TRIANGLE: Type = 2;
}
pub mod GX2RenderTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_RENDER_TARGET_0: Type = 0;
    pub const GX2_RENDER_TARGET_1: Type = 1;
    pub const GX2_RENDER_TARGET_2: Type = 2;
    pub const GX2_RENDER_TARGET_3: Type = 3;
    pub const GX2_RENDER_TARGET_4: Type = 4;
    pub const GX2_RENDER_TARGET_5: Type = 5;
    pub const GX2_RENDER_TARGET_6: Type = 6;
    pub const GX2_RENDER_TARGET_7: Type = 7;
}
pub mod GX2RoundingMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ROUNDING_MODE_ROUND_TO_EVEN: Type = 0;
    pub const GX2_ROUNDING_MODE_TRUNCATE: Type = 1;
}
pub mod GX2SamplerVarType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_1D: Type = 0;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_2D: Type = 1;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_3D: Type = 3;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_CUBE: Type = 4;
}
pub mod GX2ScanTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SCAN_TARGET_TV0: Type = 1;
    pub const GX2_SCAN_TARGET_TV1: Type = 2;
    pub const GX2_SCAN_TARGET_DRC0: Type = 4;
    pub const GX2_SCAN_TARGET_DRC1: Type = 8;
    pub const GX2_SCAN_TARGET_TV: Type = 1;
    pub const GX2_SCAN_TARGET_DRC: Type = 4;
}
pub mod GX2ShaderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SHADER_MODE_UNIFORM_REGISTER: Type = 0;
    pub const GX2_SHADER_MODE_UNIFORM_BLOCK: Type = 1;
    pub const GX2_SHADER_MODE_GEOMETRY_SHADER: Type = 2;
    pub const GX2_SHADER_MODE_COMPUTE_SHADER: Type = 3;
}
pub mod GX2ShaderVarType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SHADER_VAR_TYPE_VOID: Type = 0;
    pub const GX2_SHADER_VAR_TYPE_BOOL: Type = 1;
    pub const GX2_SHADER_VAR_TYPE_INT: Type = 2;
    pub const GX2_SHADER_VAR_TYPE_UINT: Type = 3;
    pub const GX2_SHADER_VAR_TYPE_FLOAT: Type = 4;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE: Type = 5;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2: Type = 6;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3: Type = 7;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4: Type = 8;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2: Type = 9;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3: Type = 10;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4: Type = 11;
    pub const GX2_SHADER_VAR_TYPE_BOOL2: Type = 12;
    pub const GX2_SHADER_VAR_TYPE_BOOL3: Type = 13;
    pub const GX2_SHADER_VAR_TYPE_BOOL4: Type = 14;
    pub const GX2_SHADER_VAR_TYPE_INT2: Type = 15;
    pub const GX2_SHADER_VAR_TYPE_INT3: Type = 16;
    pub const GX2_SHADER_VAR_TYPE_INT4: Type = 17;
    pub const GX2_SHADER_VAR_TYPE_UINT2: Type = 18;
    pub const GX2_SHADER_VAR_TYPE_UINT3: Type = 19;
    pub const GX2_SHADER_VAR_TYPE_UINT4: Type = 20;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X2: Type = 21;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X3: Type = 22;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X4: Type = 23;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X2: Type = 24;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X3: Type = 25;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X4: Type = 26;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X2: Type = 27;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X3: Type = 28;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X4: Type = 29;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X2: Type = 30;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X3: Type = 31;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X4: Type = 32;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X2: Type = 33;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X3: Type = 34;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X4: Type = 35;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X2: Type = 36;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X3: Type = 37;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X4: Type = 38;
}
pub mod GX2StencilFunction {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_STENCIL_FUNCTION_KEEP: Type = 0;
    pub const GX2_STENCIL_FUNCTION_ZERO: Type = 1;
    pub const GX2_STENCIL_FUNCTION_REPLACE: Type = 2;
    pub const GX2_STENCIL_FUNCTION_INCR_CLAMP: Type = 3;
    pub const GX2_STENCIL_FUNCTION_DECR_CLAMP: Type = 4;
    pub const GX2_STENCIL_FUNCTION_INV: Type = 5;
    pub const GX2_STENCIL_FUNCTION_INCR_WRAP: Type = 6;
    pub const GX2_STENCIL_FUNCTION_DECR_WRAP: Type = 7;
}
pub mod GX2SurfaceDim {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SURFACE_DIM_TEXTURE_1D: Type = 0;
    pub const GX2_SURFACE_DIM_TEXTURE_2D: Type = 1;
    pub const GX2_SURFACE_DIM_TEXTURE_3D: Type = 2;
    pub const GX2_SURFACE_DIM_TEXTURE_CUBE: Type = 3;
    pub const GX2_SURFACE_DIM_TEXTURE_1D_ARRAY: Type = 4;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_ARRAY: Type = 5;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA: Type = 6;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA_ARRAY: Type = 7;
}
pub mod GX2SurfaceFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SURFACE_FORMAT_INVALID: Type = 0;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4: Type = 2;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4: Type = 11;
    pub const GX2_SURFACE_FORMAT_UNORM_R8: Type = 1;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8: Type = 7;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8: Type = 26;
    pub const GX2_SURFACE_FORMAT_UNORM_R16: Type = 5;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16: Type = 15;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16_B16_A16: Type = 31;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G6_B5: Type = 8;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1: Type = 10;
    pub const GX2_SURFACE_FORMAT_UNORM_A1_B5_G5_R5: Type = 12;
    pub const GX2_SURFACE_FORMAT_UNORM_R24_X8: Type = 17;
    pub const GX2_SURFACE_FORMAT_UNORM_A2_B10_G10_R10: Type = 27;
    pub const GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2: Type = 25;
    pub const GX2_SURFACE_FORMAT_UNORM_BC1: Type = 49;
    pub const GX2_SURFACE_FORMAT_UNORM_BC2: Type = 50;
    pub const GX2_SURFACE_FORMAT_UNORM_BC3: Type = 51;
    pub const GX2_SURFACE_FORMAT_UNORM_BC4: Type = 52;
    pub const GX2_SURFACE_FORMAT_UNORM_BC5: Type = 53;
    pub const GX2_SURFACE_FORMAT_UNORM_NV12: Type = 129;
    pub const GX2_SURFACE_FORMAT_UINT_R8: Type = 257;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8: Type = 263;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8_B8_A8: Type = 282;
    pub const GX2_SURFACE_FORMAT_UINT_R16: Type = 261;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16: Type = 271;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16_B16_A16: Type = 287;
    pub const GX2_SURFACE_FORMAT_UINT_R32: Type = 269;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32: Type = 285;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32_B32_A32: Type = 290;
    pub const GX2_SURFACE_FORMAT_UINT_A2_B10_G10_R10: Type = 283;
    pub const GX2_SURFACE_FORMAT_UINT_R10_G10_B10_A2: Type = 281;
    pub const GX2_SURFACE_FORMAT_UINT_X24_G8: Type = 273;
    pub const GX2_SURFACE_FORMAT_UINT_G8_X24: Type = 284;
    pub const GX2_SURFACE_FORMAT_SNORM_R8: Type = 513;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8: Type = 519;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8_B8_A8: Type = 538;
    pub const GX2_SURFACE_FORMAT_SNORM_R16: Type = 517;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16: Type = 527;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16_B16_A16: Type = 543;
    pub const GX2_SURFACE_FORMAT_SNORM_R10_G10_B10_A2: Type = 537;
    pub const GX2_SURFACE_FORMAT_SNORM_BC4: Type = 564;
    pub const GX2_SURFACE_FORMAT_SNORM_BC5: Type = 565;
    pub const GX2_SURFACE_FORMAT_SINT_R8: Type = 769;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8: Type = 775;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8_B8_A8: Type = 794;
    pub const GX2_SURFACE_FORMAT_SINT_R16: Type = 773;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16: Type = 783;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16_B16_A16: Type = 799;
    pub const GX2_SURFACE_FORMAT_SINT_R32: Type = 781;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32: Type = 797;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32_B32_A32: Type = 802;
    pub const GX2_SURFACE_FORMAT_SINT_R10_G10_B10_A2: Type = 793;
    pub const GX2_SURFACE_FORMAT_SRGB_R8_G8_B8_A8: Type = 1050;
    pub const GX2_SURFACE_FORMAT_SRGB_BC1: Type = 1073;
    pub const GX2_SURFACE_FORMAT_SRGB_BC2: Type = 1074;
    pub const GX2_SURFACE_FORMAT_SRGB_BC3: Type = 1075;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32: Type = 2062;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32: Type = 2078;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32_B32_A32: Type = 2083;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16: Type = 2054;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16: Type = 2064;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16_B16_A16: Type = 2080;
    pub const GX2_SURFACE_FORMAT_FLOAT_R11_G11_B10: Type = 2070;
    pub const GX2_SURFACE_FORMAT_FLOAT_D24_S8: Type = 2065;
    pub const GX2_SURFACE_FORMAT_FLOAT_X8_X24: Type = 2076;
}
pub mod GX2SurfaceUse {
    pub type Type = ::core::ffi::c_int;
    pub const GX2_SURFACE_USE_NONE: Type = 0;
    pub const GX2_SURFACE_USE_TEXTURE: Type = 1;
    pub const GX2_SURFACE_USE_COLOR_BUFFER: Type = 2;
    pub const GX2_SURFACE_USE_DEPTH_BUFFER: Type = 4;
    pub const GX2_SURFACE_USE_SCAN_BUFFER: Type = 8;
    pub const GX2_SURFACE_USE_TV: Type = -2147483648;
    pub const GX2_SURFACE_USE_TEXTURE_COLOR_BUFFER_TV: Type = -2147483645;
}
pub mod GX2TessellationMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TESSELLATION_MODE_DISCRETE: Type = 0;
    pub const GX2_TESSELLATION_MODE_CONTINUOUS: Type = 1;
    pub const GX2_TESSELLATION_MODE_ADAPTIVE: Type = 2;
}
pub mod GX2TexBorderType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_BORDER_TYPE_TRANSPARENT_BLACK: Type = 0;
    pub const GX2_TEX_BORDER_TYPE_BLACK: Type = 1;
    pub const GX2_TEX_BORDER_TYPE_WHITE: Type = 2;
    pub const GX2_TEX_BORDER_TYPE_VARIABLE: Type = 3;
}
pub mod GX2TexClampMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_CLAMP_MODE_WRAP: Type = 0;
    pub const GX2_TEX_CLAMP_MODE_MIRROR: Type = 1;
    pub const GX2_TEX_CLAMP_MODE_CLAMP: Type = 2;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE: Type = 3;
    pub const GX2_TEX_CLAMP_MODE_CLAMP_HALF_BORDER: Type = 4;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_HALF_BORDER: Type = 5;
    pub const GX2_TEX_CLAMP_MODE_CLAMP_BORDER: Type = 6;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_BORDER: Type = 7;
}
pub mod GX2TexMipFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_MIP_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_MIP_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_MIP_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexMipPerfMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_MIP_PERF_MODE_DISABLE: Type = 0;
}
pub mod GX2TexXYFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_XY_FILTER_MODE_POINT: Type = 0;
    pub const GX2_TEX_XY_FILTER_MODE_LINEAR: Type = 1;
    pub const GX2_TEX_XY_FILTER_MODE_BICUBIC: Type = 2;
}
pub mod GX2TexAnisoRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_ANISO_RATIO_NONE: Type = 0;
    pub const GX2_TEX_ANISO_RATIO_2_TO_1: Type = 1;
    pub const GX2_TEX_ANISO_RATIO_4_TO_1: Type = 2;
    pub const GX2_TEX_ANISO_RATIO_8_TO_1: Type = 3;
    pub const GX2_TEX_ANISO_RATIO_16_TO_1: Type = 4;
}
pub mod GX2TexZFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_Z_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_Z_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_Z_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexZPerfMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_Z_PERF_MODE_DISABLED: Type = 0;
}
pub mod GX2TileMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TILE_MODE_DEFAULT: Type = 0;
    pub const GX2_TILE_MODE_LINEAR_ALIGNED: Type = 1;
    pub const GX2_TILE_MODE_TILED_1D_THIN1: Type = 2;
    pub const GX2_TILE_MODE_TILED_1D_THICK: Type = 3;
    pub const GX2_TILE_MODE_TILED_2D_THIN1: Type = 4;
    pub const GX2_TILE_MODE_TILED_2D_THIN2: Type = 5;
    pub const GX2_TILE_MODE_TILED_2D_THIN4: Type = 6;
    pub const GX2_TILE_MODE_TILED_2D_THICK: Type = 7;
    pub const GX2_TILE_MODE_TILED_2B_THIN1: Type = 8;
    pub const GX2_TILE_MODE_TILED_2B_THIN2: Type = 9;
    pub const GX2_TILE_MODE_TILED_2B_THIN4: Type = 10;
    pub const GX2_TILE_MODE_TILED_2B_THICK: Type = 11;
    pub const GX2_TILE_MODE_TILED_3D_THIN1: Type = 12;
    pub const GX2_TILE_MODE_TILED_3D_THICK: Type = 13;
    pub const GX2_TILE_MODE_TILED_3B_THIN1: Type = 14;
    pub const GX2_TILE_MODE_TILED_3B_THICK: Type = 15;
    pub const GX2_TILE_MODE_LINEAR_SPECIAL: Type = 16;
}
pub mod GX2TVRenderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TV_RENDER_MODE_DISABLED: Type = 0;
    pub const GX2_TV_RENDER_MODE_STANDARD_480P: Type = 1;
    pub const GX2_TV_RENDER_MODE_WIDE_480P: Type = 2;
    pub const GX2_TV_RENDER_MODE_WIDE_720P: Type = 3;
    pub const GX2_TV_RENDER_MODE_WIDE_1080P: Type = 5;
}
pub mod GX2TVScanMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TV_SCAN_MODE_NONE: Type = 0;
    pub const GX2_TV_SCAN_MODE_576I: Type = 1;
    pub const GX2_TV_SCAN_MODE_480I: Type = 2;
    pub const GX2_TV_SCAN_MODE_480P: Type = 3;
    pub const GX2_TV_SCAN_MODE_720P: Type = 4;
    pub const GX2_TV_SCAN_MODE_1080I: Type = 6;
    pub const GX2_TV_SCAN_MODE_1080P: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2Sampler {
    pub regs: [u32; 3usize],
}
extern "C" {
    pub fn GX2InitSampler(
        sampler: *mut GX2Sampler,
        clampMode: GX2TexClampMode::Type,
        minMagFilterMode: GX2TexXYFilterMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerBorderType(sampler: *mut GX2Sampler, borderType: GX2TexBorderType::Type);
}
extern "C" {
    pub fn GX2InitSamplerClamping(
        sampler: *mut GX2Sampler,
        clampX: GX2TexClampMode::Type,
        clampY: GX2TexClampMode::Type,
        clampZ: GX2TexClampMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerDepthCompare(
        sampler: *mut GX2Sampler,
        depthCompare: GX2CompareFunction::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerFilterAdjust(
        sampler: *mut GX2Sampler,
        highPrecision: BOOL,
        perfMip: GX2TexMipPerfMode::Type,
        perfZ: GX2TexZPerfMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerLOD(sampler: *mut GX2Sampler, lodMin: f32, lodMax: f32, lodBias: f32);
}
extern "C" {
    pub fn GX2InitSamplerLODAdjust(sampler: *mut GX2Sampler, unk1: f32, unk2: BOOL);
}
extern "C" {
    pub fn GX2InitSamplerRoundingMode(
        sampler: *mut GX2Sampler,
        roundingMode: GX2RoundingMode::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerXYFilter(
        sampler: *mut GX2Sampler,
        filterMag: GX2TexXYFilterMode::Type,
        filterMin: GX2TexXYFilterMode::Type,
        maxAniso: GX2TexAnisoRatio::Type,
    );
}
extern "C" {
    pub fn GX2InitSamplerZMFilter(
        sampler: *mut GX2Sampler,
        filterZ: GX2TexZFilterMode::Type,
        filterMip: GX2TexMipFilterMode::Type,
    );
}
pub mod GX2RResourceFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2R_RESOURCE_BIND_NONE: Type = 0;
    pub const GX2R_RESOURCE_BIND_TEXTURE: Type = 1;
    pub const GX2R_RESOURCE_BIND_COLOR_BUFFER: Type = 2;
    pub const GX2R_RESOURCE_BIND_DEPTH_BUFFER: Type = 4;
    pub const GX2R_RESOURCE_BIND_SCAN_BUFFER: Type = 8;
    pub const GX2R_RESOURCE_BIND_VERTEX_BUFFER: Type = 16;
    pub const GX2R_RESOURCE_BIND_INDEX_BUFFER: Type = 32;
    pub const GX2R_RESOURCE_BIND_UNIFORM_BLOCK: Type = 64;
    pub const GX2R_RESOURCE_BIND_SHADER_PROGRAM: Type = 128;
    pub const GX2R_RESOURCE_BIND_STREAM_OUTPUT: Type = 256;
    pub const GX2R_RESOURCE_BIND_DISPLAY_LIST: Type = 512;
    pub const GX2R_RESOURCE_BIND_GS_RING_BUFFER: Type = 1024;
    pub const GX2R_RESOURCE_USAGE_CPU_READ: Type = 2048;
    pub const GX2R_RESOURCE_USAGE_CPU_WRITE: Type = 4096;
    pub const GX2R_RESOURCE_USAGE_GPU_READ: Type = 8192;
    pub const GX2R_RESOURCE_USAGE_GPU_WRITE: Type = 16384;
    pub const GX2R_RESOURCE_USAGE_DMA_READ: Type = 32768;
    pub const GX2R_RESOURCE_USAGE_DMA_WRITE: Type = 65536;
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM1: Type = 131072;
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM2: Type = 262144;
    pub const GX2R_RESOURCE_DISABLE_CPU_INVALIDATE: Type = 1048576;
    pub const GX2R_RESOURCE_DISABLE_GPU_INVALIDATE: Type = 2097152;
    pub const GX2R_RESOURCE_LOCKED_READ_ONLY: Type = 4194304;
    pub const GX2R_RESOURCE_GX2R_ALLOCATED: Type = 536870912;
    pub const GX2R_RESOURCE_LOCKED: Type = 1073741824;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2RBuffer {
    pub flags: GX2RResourceFlags::Type,
    pub elemSize: u32,
    pub elemCount: u32,
    pub buffer: *mut ::core::ffi::c_void,
}
extern "C" {
    pub fn GX2RBufferExists(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBuffer(buffer: *mut GX2RBuffer) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateBufferUserMemory(
        buffer: *mut GX2RBuffer,
        memory: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroyBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RGetBufferAlignment(flags: GX2RResourceFlags::Type) -> u32;
}
extern "C" {
    pub fn GX2RGetBufferAllocationSize(buffer: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RInvalidateBuffer(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RLockBufferEx(
        buffer: *mut GX2RBuffer,
        flags: GX2RResourceFlags::Type,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn GX2RUnlockBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
}
extern "C" {
    pub fn GX2RSetVertexUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetPixelUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
extern "C" {
    pub fn GX2RSetGeometryUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader {
    pub type_: GX2FetchShaderType::Type,
    pub regs: GX2FetchShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub attribCount: u32,
    pub numDivisors: u32,
    pub divisors: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader__bindgen_ty_1 {
    pub sq_pgm_resources_fs: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformBlock {
    pub name: *const ::core::ffi::c_char,
    pub offset: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub offset: u32,
    pub block: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformInitialValue {
    pub value: [f32; 4usize],
    pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2LoopVar {
    pub offset: u32,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2SamplerVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2SamplerVarType::Type,
    pub location: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub location: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader {
    pub regs: GX2VertexShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub attribVarCount: u32,
    pub attribVars: *mut GX2AttribVar,
    pub ringItemsize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader__bindgen_ty_1 {
    pub sq_pgm_resources_vs: u32,
    pub vgt_primitiveid_en: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub pa_cl_vs_out_cntl: u32,
    pub sq_vtx_semantic_clear: u32,
    pub num_sq_vtx_semantic: u32,
    pub sq_vtx_semantic: [u32; 32usize],
    pub vgt_strmout_buffer_en: u32,
    pub vgt_vertex_reuse_block_cntl: u32,
    pub vgt_hos_reuse_depth: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader {
    pub regs: GX2PixelShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader__bindgen_ty_1 {
    pub sq_pgm_resources_ps: u32,
    pub sq_pgm_exports_ps: u32,
    pub spi_ps_in_control_0: u32,
    pub spi_ps_in_control_1: u32,
    pub num_spi_ps_input_cntl: u32,
    pub spi_ps_input_cntls: [u32; 32usize],
    pub cb_shader_mask: u32,
    pub cb_shader_control: u32,
    pub db_shader_control: u32,
    pub spi_input_z: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader {
    pub regs: GX2GeometryShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub vertexProgramSize: u32,
    pub vertexProgram: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub ringItemSize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader__bindgen_ty_1 {
    pub sq_pgm_resources_gs: u32,
    pub vgt_gs_out_prim_type: u32,
    pub vgt_gs_mode: u32,
    pub pa_cl_vs_out_cntl: u32,
    pub sq_pgm_resources_vs: u32,
    pub sq_gs_vert_itemsize: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub vgt_strmout_buffer_en: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribStream {
    pub location: u32,
    pub buffer: u32,
    pub offset: u32,
    pub format: GX2AttribFormat::Type,
    pub type_: GX2AttribIndexType::Type,
    pub aluDivisor: u32,
    pub mask: u32,
    pub endianSwap: GX2EndianSwapMode::Type,
}
extern "C" {
    pub fn GX2CalcGeometryShaderInputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcGeometryShaderOutputRingBufferSize(ringItemSize: u32) -> u32;
}
extern "C" {
    pub fn GX2CalcFetchShaderSizeEx(
        attribs: u32,
        fetchShaderType: GX2FetchShaderType::Type,
        tesellationMode: GX2TessellationMode::Type,
    ) -> u32;
}
extern "C" {
    pub fn GX2InitFetchShaderEx(
        fetchShader: *mut GX2FetchShader,
        buffer: *mut u8,
        attribCount: u32,
        attribs: *const GX2AttribStream,
        type_: GX2FetchShaderType::Type,
        tessMode: GX2TessellationMode::Type,
    );
}
extern "C" {
    pub fn GX2SetFetchShader(shader: *const GX2FetchShader);
}
extern "C" {
    pub fn GX2SetVertexShader(shader: *const GX2VertexShader);
}
extern "C" {
    pub fn GX2SetPixelShader(shader: *const GX2PixelShader);
}
extern "C" {
    pub fn GX2SetGeometryShader(shader: *const GX2GeometryShader);
}
extern "C" {
    pub fn GX2SetVertexSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetPixelSampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetGeometrySampler(sampler: *const GX2Sampler, id: u32);
}
extern "C" {
    pub fn GX2SetVertexUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetVertexUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetPixelUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetGeometryUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
}
extern "C" {
    pub fn GX2SetShaderModeEx(
        mode: GX2ShaderMode::Type,
        numVsGpr: u32,
        numVsStackEntries: u32,
        numGsGpr: u32,
        numGsStackEntries: u32,
        numPsGpr: u32,
        numPsStackEntries: u32,
    );
}
extern "C" {
    pub fn GX2SetStreamOutEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetGeometryShaderInputRingBuffer(buffer: *const ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn GX2SetGeometryShaderOutputRingBuffer(buffer: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn GX2GetPixelShaderGPRs(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetPixelShaderStackEntries(shader: *const GX2PixelShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderGPRs(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetVertexShaderStackEntries(shader: *const GX2VertexShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderGPRs(shader: *const GX2GeometryShader) -> u32;
}
extern "C" {
    pub fn GX2GetGeometryShaderStackEntries(shader: *const GX2GeometryShader) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Surface {
    pub dim: GX2SurfaceDim::Type,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mipLevels: u32,
    pub format: GX2SurfaceFormat::Type,
    pub aa: GX2AAMode::Type,
    pub __bindgen_anon_1: GX2Surface__bindgen_ty_1,
    pub imageSize: u32,
    pub image: *mut ::core::ffi::c_void,
    pub mipmapSize: u32,
    pub mipmaps: *mut ::core::ffi::c_void,
    pub tileMode: GX2TileMode::Type,
    pub swizzle: u32,
    pub alignment: u32,
    pub pitch: u32,
    pub mipLevelOffset: [u32; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GX2Surface__bindgen_ty_1 {
    pub use_: GX2SurfaceUse::Type,
    pub resourceFlags: GX2RResourceFlags::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2DepthBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub hiZPtr: *mut ::core::ffi::c_void,
    pub hiZSize: u32,
    pub depthClear: f32,
    pub stencilClear: u32,
    pub regs: [u32; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ColorBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub aaBuffer: *mut ::core::ffi::c_void,
    pub aaSize: u32,
    pub regs: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2Rect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2Point {
    pub x: i32,
    pub y: i32,
}
extern "C" {
    pub fn GX2CalcSurfaceSizeAndAlignment(surface: *mut GX2Surface);
}
extern "C" {
    pub fn GX2CalcDepthBufferHiZInfo(
        depthBuffer: *mut GX2DepthBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcColorBufferAuxInfo(
        surface: *mut GX2ColorBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetColorBuffer(colorBuffer: *const GX2ColorBuffer, target: GX2RenderTarget::Type);
}
extern "C" {
    pub fn GX2SetDepthBuffer(depthBuffer: *const GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitColorBufferRegs(colorBuffer: *mut GX2ColorBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferRegs(depthBuffer: *mut GX2DepthBuffer);
}
extern "C" {
    pub fn GX2InitDepthBufferHiZEnable(depthBuffer: *mut GX2DepthBuffer, enable: BOOL);
}
extern "C" {
    pub fn GX2GetSurfaceSwizzle(surface: *const GX2Surface) -> u32;
}
extern "C" {
    pub fn GX2SetSurfaceSwizzle(surface: *mut GX2Surface, swizzle: u32);
}
extern "C" {
    pub fn GX2CopySurface(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
    );
}
extern "C" {
    pub fn GX2CopySurfaceEx(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
        numRects: u32,
        srcRects: *mut GX2Rect,
        dstPoints: *mut GX2Point,
    );
}
extern "C" {
    pub fn GX2ResolveAAColorBuffer(
        srcColorBuffer: *const GX2ColorBuffer,
        dstSurface: *mut GX2Surface,
        dstMip: u32,
        dstSlice: u32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Texture {
    pub surface: GX2Surface,
    pub viewFirstMip: u32,
    pub viewNumMips: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub compMap: u32,
    pub regs: [u32; 5usize],
}
extern "C" {
    pub fn GX2InitTextureRegs(texture: *mut GX2Texture);
}
extern "C" {
    pub fn GX2SetPixelTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetVertexTexture(texture: *const GX2Texture, unit: u32);
}
extern "C" {
    pub fn GX2SetGeometryTexture(texture: *const GX2Texture, unit: u32);
}
pub mod GFDBlockType {
    pub type Type = ::core::ffi::c_uint;
    pub const GFD_BLOCK_END_OF_FILE: Type = 1;
    pub const GFD_BLOCK_PADDING: Type = 2;
    pub const GFD_BLOCK_VERTEX_SHADER_HEADER: Type = 3;
    pub const GFD_BLOCK_VERTEX_SHADER_PROGRAM: Type = 5;
    pub const GFD_BLOCK_PIXEL_SHADER_HEADER: Type = 6;
    pub const GFD_BLOCK_PIXEL_SHADER_PROGRAM: Type = 7;
    pub const GFD_BLOCK_GEOMETRY_SHADER_HEADER: Type = 8;
    pub const GFD_BLOCK_GEOMETRY_SHADER_PROGRAM: Type = 9;
    pub const GFD_BLOCK_GEOMETRY_SHADER_COPY_PROGRAM: Type = 10;
    pub const GFD_BLOCK_TEXTURE_HEADER: Type = 11;
    pub const GFD_BLOCK_TEXTURE_IMAGE: Type = 12;
    pub const GFD_BLOCK_TEXTURE_MIPMAP: Type = 13;
    pub const GFD_BLOCK_COMPUTE_SHADER_HEADER: Type = 14;
    pub const GFD_BLOCK_COMPUTE_SHADER_PROGRAM: Type = 15;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFDHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub gpuVersion: u32,
    pub align: u32,
    pub unk1: u32,
    pub unk2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFDBlockHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub type_: GFDBlockType::Type,
    pub dataSize: u32,
    pub id: u32,
    pub index: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFDRelocationHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub unk1: u32,
    pub dataSize: u32,
    pub dataOffset: u32,
    pub textSize: u32,
    pub textOffset: u32,
    pub patchBase: u32,
    pub patchCount: u32,
    pub patchOffset: u32,
}
extern "C" {
    pub fn GFDGetLastErrorString() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn GFDGetGeometryShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShaderCopyProgramSize(index: u32, file: *const ::core::ffi::c_void)
        -> u32;
}
extern "C" {
    pub fn GFDGetGeometryShader(
        shader: *mut GX2GeometryShader,
        program: *mut ::core::ffi::c_void,
        copyProgram: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetPixelShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetPixelShader(
        shader: *mut GX2PixelShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetVertexShaderCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetVertexShader(
        shader: *mut GX2VertexShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetTextureCount(file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureMipImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTextureAlignmentSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GFDGetTexture(
        texture: *mut GX2Texture,
        image: *mut ::core::ffi::c_void,
        mipmap: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetGX2RTexture(
        texture: *mut GX2Texture,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn GFDGetTexturePointer(index: u32, file: *const ::core::ffi::c_void) -> *const GX2Texture;
}
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
extern "C" {
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ioctl(fd: ::core::ffi::c_int, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiodgname_arg {
    pub len: ::core::ffi::c_int,
    pub buf: *mut ::core::ffi::c_void,
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ulong = ::core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::core::ffi::c_int,
    pub contentionscope: ::core::ffi::c_int,
    pub inheritsched: ::core::ffi::c_int,
    pub schedpolicy: ::core::ffi::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::core::ffi::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub recursive: ::core::ffi::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::core::ffi::c_int,
    pub init_executed: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::core::ffi::c_long;
}
extern "C" {
    pub static mut _daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::core::ffi::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_value: sigval,
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_flags: ::core::ffi::c_int,
    pub ss_size: usize,
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::core::ffi::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::core::ffi::c_int, arg3: sigval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn str2sig(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type sig_atomic_t = ::core::ffi::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: _sig_func_ptr,
    ) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn signal(arg1: ::core::ffi::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::core::ffi::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::core::ffi::c_int, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::core::ffi::c_int, __value: *mut itimerval) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::core::ffi::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub ss_padding: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::core::ffi::c_int,
    pub l_linger: ::core::ffi::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bind(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::core::ffi::c_int, backlog: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn send(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::core::ffi::c_int, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn GX2SetTessellation(
        tessellationMode: GX2TessellationMode::Type,
        primitiveMode: GX2PrimitiveMode::Type,
        indexType: GX2IndexType::Type,
    );
}
extern "C" {
    pub fn GX2SetMinTessellationLevel(min: f32);
}
extern "C" {
    pub fn GX2SetMaxTessellationLevel(max: f32);
}
extern "C" {
    pub fn GX2ClearColor(
        colorBuffer: *mut GX2ColorBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2ClearDepthStencilEx(
        depthBuffer: *mut GX2DepthBuffer,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
}
extern "C" {
    pub fn GX2ClearBuffersEx(
        colorBuffer: *mut GX2ColorBuffer,
        depthBuffer: *mut GX2DepthBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
}
extern "C" {
    pub fn GX2SetClearDepth(depthBuffer: *mut GX2DepthBuffer, depth: f32);
}
extern "C" {
    pub fn GX2SetClearStencil(depthBuffer: *mut GX2DepthBuffer, stencil: u8);
}
extern "C" {
    pub fn GX2SetClearDepthStencil(depthBuffer: *mut GX2DepthBuffer, depth: f32, stencil: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ShadowState {
    pub config: [u32; 2816usize],
    pub context: [u32; 1024usize],
    pub alu: [u32; 2048usize],
    pub loop_: [u32; 96usize],
    pub __unk36: [::core::ffi::c_char; 128usize],
    pub resource: [u32; 3486usize],
    pub __unk37: [::core::ffi::c_char; 136usize],
    pub sampler: [u32; 162usize],
    pub __unk38: [::core::ffi::c_char; 120usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ContextState {
    pub shadowState: GX2ShadowState,
    pub __unk39: [::core::ffi::c_char; 4usize],
    pub shadowDisplayListSize: u32,
    pub __unk40: [::core::ffi::c_char; 1528usize],
    pub shadowDisplayList: [u32; 192usize],
}
extern "C" {
    pub fn GX2SetupContextStateEx(state: *mut GX2ContextState, unk1: BOOL);
}
extern "C" {
    pub fn GX2GetContextStateDisplayList(
        state: *const GX2ContextState,
        outDisplayList: *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetContextState(state: *mut GX2ContextState);
}
extern "C" {
    pub fn GX2SetDefaultState();
}
extern "C" {
    pub fn GX2CopyColorBufferToScanBuffer(
        buffer: *const GX2ColorBuffer,
        scanTarget: GX2ScanTarget::Type,
    );
}
extern "C" {
    pub fn GX2SwapScanBuffers();
}
extern "C" {
    pub fn GX2GetLastFrame(scanTarget: GX2ScanTarget::Type, texture: *mut GX2Texture) -> BOOL;
}
extern "C" {
    pub fn GX2GetLastFrameGamma(scanTarget: GX2ScanTarget::Type, gammaOut: *mut f32) -> BOOL;
}
extern "C" {
    pub fn GX2GetSwapInterval() -> u32;
}
extern "C" {
    pub fn GX2SetSwapInterval(interval: u32);
}
pub type GX2DRCConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(drcSlot: u32, attached: BOOL)>;
extern "C" {
    pub fn GX2SetTVEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2SetDRCEnable(enable: BOOL);
}
extern "C" {
    pub fn GX2CalcTVSize(
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2CalcDRCSize(
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetTVBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
}
extern "C" {
    pub fn GX2SetDRCBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
}
extern "C" {
    pub fn GX2SetTVScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2SetDRCScale(x: u32, y: u32);
}
extern "C" {
    pub fn GX2GetSystemTVAspectRatio() -> GX2AspectRatio::Type;
}
extern "C" {
    pub fn GX2GetSystemTVScanMode() -> GX2TVScanMode::Type;
}
extern "C" {
    pub fn GX2GetSystemDRCScanMode() -> GX2DrcRenderMode::Type;
}
extern "C" {
    pub fn GX2GetSystemDRCMode() -> GX2DrcRenderMode::Type;
}
extern "C" {
    pub fn GX2SetDRCConnectCallback(
        drcSlot: u32,
        callback: GX2DRCConnectCallback,
    ) -> GX2DRCConnectCallback;
}
extern "C" {
    pub fn GX2Init(attributes: *mut u32);
}
extern "C" {
    pub fn GX2Shutdown();
}
extern "C" {
    pub fn GX2Flush();
}
extern "C" {
    pub fn GX2ResetGPU(unknown: u32);
}
extern "C" {
    pub fn GX2GetMainCoreId() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn GX2TempGetGPUVersion() -> u32;
}
pub mod GX2DebugCaptureInterfaceVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_INTERFACE_VERSION: Type = 1;
}
pub mod GX2DebugCaptureStartFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_NONE: Type = 0;
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_DISABLE_GX2DRAWDONE: Type = 1;
}
pub mod GX2DebugCaptureEndFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_NONE: Type = 0;
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_DISABLE_GX2FLUSH: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DebugCaptureInterface {
    pub version: u32,
    pub onShutdown: ::core::option::Option<unsafe extern "C" fn()>,
    pub setAllocator: ::core::option::Option<unsafe extern "C" fn()>,
    pub onCaptureStart:
        ::core::option::Option<unsafe extern "C" fn(filename: *const ::core::ffi::c_char)>,
    pub onCaptureEnd: ::core::option::Option<unsafe extern "C" fn()>,
    pub isCaptureEnabled: ::core::option::Option<unsafe extern "C" fn() -> BOOL>,
    pub onAlloc: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32, align: u32),
    >,
    pub onFree: ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>,
    pub onUnknownMemory:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32)>,
    pub setOutputSurface: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub onSwapScanBuffers: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub submitToRing: ::core::option::Option<
        unsafe extern "C" fn(
            unk1: *mut ::core::ffi::c_void,
            unk2: u32,
            unk3: *mut u32,
            outSubmitTimestamp: *mut u64,
        ),
    >,
}
extern "C" {
    pub fn _GX2DebugSetCaptureInterface(interface: *mut GX2DebugCaptureInterface) -> BOOL;
}
extern "C" {
    pub fn GX2DebugCaptureStart(
        filename: *const ::core::ffi::c_char,
        flags: GX2DebugCaptureStartFlags::Type,
    );
}
extern "C" {
    pub fn GX2DebugCaptureEnd(flags: GX2DebugCaptureEndFlags::Type);
}
extern "C" {
    pub fn GX2DebugCaptureFrame(filename: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn GX2DebugCaptureFrames(filename: *const ::core::ffi::c_char, count: u32);
}
extern "C" {
    pub fn GX2SetAttribBuffer(
        index: u32,
        size: u32,
        stride: u32,
        buffer: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2DrawEx(mode: GX2PrimitiveMode::Type, count: u32, offset: u32, numInstances: u32);
}
extern "C" {
    pub fn GX2DrawEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
}
extern "C" {
    pub fn GX2DrawIndexedImmediateEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2SetPrimitiveRestartIndex(index: u32);
}
extern "C" {
    pub fn GX2BeginDisplayListEx(displayList: *mut ::core::ffi::c_void, bytes: u32, unk1: BOOL);
}
extern "C" {
    pub fn GX2EndDisplayList(displayList: *mut ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn GX2DirectCallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2CallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
extern "C" {
    pub fn GX2GetDisplayListWriteStatus() -> BOOL;
}
extern "C" {
    pub fn GX2GetCurrentDisplayList(
        outDisplayList: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2CopyDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
}
pub mod GX2_SQ_SEL {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SQ_SEL_X: Type = 0;
    pub const GX2_SQ_SEL_Y: Type = 1;
    pub const GX2_SQ_SEL_Z: Type = 2;
    pub const GX2_SQ_SEL_W: Type = 3;
    pub const GX2_SQ_SEL_R: Type = 0;
    pub const GX2_SQ_SEL_G: Type = 1;
    pub const GX2_SQ_SEL_B: Type = 2;
    pub const GX2_SQ_SEL_A: Type = 3;
    pub const GX2_SQ_SEL_0: Type = 4;
    pub const GX2_SQ_SEL_1: Type = 5;
    pub const GX2_SQ_SEL_MASK: Type = 7;
}
pub type GX2EventCallbackFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2EventType::Type, arg2: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DisplayListOverrunData {
    pub oldList: *mut ::core::ffi::c_void,
    pub oldSize: u32,
    pub newList: *mut ::core::ffi::c_void,
    pub newSize: u32,
    pub __unk41: [::core::ffi::c_char; 8usize],
}
extern "C" {
    pub fn GX2DrawDone() -> BOOL;
}
extern "C" {
    pub fn GX2WaitForVsync();
}
extern "C" {
    pub fn GX2WaitForFlip();
}
extern "C" {
    pub fn GX2SetEventCallback(
        type_: GX2EventType::Type,
        func: GX2EventCallbackFunction,
        userData: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2GetEventCallback(
        type_: GX2EventType::Type,
        funcOut: *mut GX2EventCallbackFunction,
        userDataOut: *mut *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2GetRetiredTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetLastSubmittedTimeStamp() -> OSTime;
}
extern "C" {
    pub fn GX2GetSwapStatus(
        swapCount: *mut u32,
        flipCount: *mut u32,
        lastFlip: *mut OSTime,
        lastVsync: *mut OSTime,
    );
}
extern "C" {
    pub fn GX2WaitTimeStamp(time: OSTime) -> BOOL;
}
extern "C" {
    pub fn GX2Invalidate(
        mode: GX2InvalidateMode::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
    );
}
pub type GX2ApertureHandle = u32;
extern "C" {
    pub fn GX2AllocateTilingApertureEx(
        surface: *mut GX2Surface,
        level: u32,
        depth: u32,
        endian: GX2EndianSwapMode::Type,
        outHandle: *mut GX2ApertureHandle,
        outAddress: *mut *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn GX2FreeTilingAperture(handle: GX2ApertureHandle);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AAMaskReg {
    pub pa_sc_aa_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AlphaTestReg {
    pub sx_alpha_test_control: u32,
    pub sx_alpha_ref: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AlphaToMaskReg {
    pub db_alpha_to_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendControlReg {
    pub target: GX2RenderTarget::Type,
    pub cb_blend_control: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendConstantColorReg {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ColorControlReg {
    pub cb_color_control: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DepthStencilControlReg {
    pub db_depth_control: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2StencilMaskReg {
    pub db_stencilrefmask: u32,
    pub db_stencilrefmask_bf: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2LineWidthReg {
    pub pa_su_line_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PointSizeReg {
    pub pa_su_point_size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PointLimitsReg {
    pub pa_su_point_minmax: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PolygonControlReg {
    pub pa_su_sc_mode_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PolygonOffsetReg {
    pub pa_su_poly_offset_front_scale: u32,
    pub pa_su_poly_offset_front_offset: u32,
    pub pa_su_poly_offset_back_scale: u32,
    pub pa_su_poly_offset_back_offset: u32,
    pub pa_su_poly_offset_clamp: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ScissorReg {
    pub pa_sc_generic_scissor_tl: u32,
    pub pa_sc_generic_scissor_br: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2TargetChannelMaskReg {
    pub cb_target_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ViewportReg {
    pub pa_cl_vport_xscale: u32,
    pub pa_cl_vport_xoffset: u32,
    pub pa_cl_vport_yscale: u32,
    pub pa_cl_vport_yoffset: u32,
    pub pa_cl_vport_zscale: u32,
    pub pa_cl_vport_zoffset: u32,
    pub pa_cl_gb_vert_clip_adj: u32,
    pub pa_cl_gb_vert_disc_adj: u32,
    pub pa_cl_gb_horz_clip_adj: u32,
    pub pa_cl_gb_horz_disc_adj: u32,
    pub pa_sc_vport_zmin: u32,
    pub pa_sc_vport_zmax: u32,
}
extern "C" {
    pub fn GX2SetAAMask(upperLeft: u8, upperRight: u8, lowerLeft: u8, lowerRight: u8);
}
extern "C" {
    pub fn GX2InitAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: u8,
        upperRight: u8,
        lowerLeft: u8,
        lowerRight: u8,
    );
}
extern "C" {
    pub fn GX2GetAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: *mut u8,
        upperRight: *mut u8,
        lowerLeft: *mut u8,
        lowerRight: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetAAMaskReg(reg: *const GX2AAMaskReg);
}
extern "C" {
    pub fn GX2SetAlphaTest(alphaTest: BOOL, func: GX2CompareFunction::Type, ref_: f32);
}
extern "C" {
    pub fn GX2InitAlphaTestReg(
        reg: *mut GX2AlphaTestReg,
        alphaTest: BOOL,
        func: GX2CompareFunction::Type,
        ref_: f32,
    );
}
extern "C" {
    pub fn GX2GetAlphaTestReg(
        reg: *const GX2AlphaTestReg,
        alphaTest: *mut BOOL,
        func: *mut GX2CompareFunction::Type,
        ref_: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetAlphaTestReg(reg: *const GX2AlphaTestReg);
}
extern "C" {
    pub fn GX2SetAlphaToMask(alphaToMask: BOOL, mode: GX2AlphaToMaskMode::Type);
}
extern "C" {
    pub fn GX2InitAlphaToMaskReg(
        reg: *mut GX2AlphaToMaskReg,
        alphaToMask: BOOL,
        mode: GX2AlphaToMaskMode::Type,
    );
}
extern "C" {
    pub fn GX2GetAlphaToMaskReg(
        reg: *const GX2AlphaToMaskReg,
        alphaToMask: *mut BOOL,
        mode: *mut GX2AlphaToMaskMode::Type,
    );
}
extern "C" {
    pub fn GX2SetAlphaToMaskReg(reg: *const GX2AlphaToMaskReg);
}
extern "C" {
    pub fn GX2SetBlendConstantColor(red: f32, green: f32, blue: f32, alpha: f32);
}
extern "C" {
    pub fn GX2InitBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
}
extern "C" {
    pub fn GX2GetBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: *mut f32,
        green: *mut f32,
        blue: *mut f32,
        alpha: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetBlendConstantColorReg(reg: *const GX2BlendConstantColorReg);
}
extern "C" {
    pub fn GX2SetBlendControl(
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2InitBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2GetBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: *mut GX2RenderTarget::Type,
        colorSrcBlend: *mut GX2BlendMode::Type,
        colorDstBlend: *mut GX2BlendMode::Type,
        colorCombine: *mut GX2BlendCombineMode::Type,
        useAlphaBlend: *mut BOOL,
        alphaSrcBlend: *mut GX2BlendMode::Type,
        alphaDstBlend: *mut GX2BlendMode::Type,
        alphaCombine: *mut GX2BlendCombineMode::Type,
    );
}
extern "C" {
    pub fn GX2SetBlendControlReg(reg: *const GX2BlendControlReg);
}
extern "C" {
    pub fn GX2SetColorControl(
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: *mut GX2LogicOp::Type,
        targetBlendEnable: *mut u8,
        multiWriteEnable: *mut BOOL,
        colorWriteEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetColorControlReg(reg: *const GX2ColorControlReg);
}
extern "C" {
    pub fn GX2SetDepthOnlyControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2InitDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2GetDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: *mut BOOL,
        depthWrite: *mut BOOL,
        depthCompare: *mut GX2CompareFunction::Type,
        stencilTest: *mut BOOL,
        backfaceStencil: *mut BOOL,
        frontStencilFunc: *mut GX2CompareFunction::Type,
        frontStencilZPass: *mut GX2StencilFunction::Type,
        frontStencilZFail: *mut GX2StencilFunction::Type,
        frontStencilFail: *mut GX2StencilFunction::Type,
        backStencilFunc: *mut GX2CompareFunction::Type,
        backStencilZPass: *mut GX2StencilFunction::Type,
        backStencilZFail: *mut GX2StencilFunction::Type,
        backStencilFail: *mut GX2StencilFunction::Type,
    );
}
extern "C" {
    pub fn GX2SetDepthStencilControlReg(reg: *const GX2DepthStencilControlReg);
}
extern "C" {
    pub fn GX2SetStencilMask(
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2InitStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
}
extern "C" {
    pub fn GX2GetStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: *mut u8,
        frontWriteMask: *mut u8,
        frontRef: *mut u8,
        backMask: *mut u8,
        backWriteMask: *mut u8,
        backRef: *mut u8,
    );
}
extern "C" {
    pub fn GX2SetStencilMaskReg(reg: *const GX2StencilMaskReg);
}
extern "C" {
    pub fn GX2SetLineWidth(width: f32);
}
extern "C" {
    pub fn GX2InitLineWidthReg(reg: *mut GX2LineWidthReg, width: f32);
}
extern "C" {
    pub fn GX2GetLineWidthReg(reg: *mut GX2LineWidthReg, width: *mut f32);
}
extern "C" {
    pub fn GX2SetLineWidthReg(reg: *const GX2LineWidthReg);
}
extern "C" {
    pub fn GX2SetPointSize(width: f32, height: f32);
}
extern "C" {
    pub fn GX2InitPointSizeReg(reg: *mut GX2PointSizeReg, width: f32, height: f32);
}
extern "C" {
    pub fn GX2GetPointSizeReg(reg: *mut GX2PointSizeReg, width: *mut f32, height: *mut f32);
}
extern "C" {
    pub fn GX2SetPointSizeReg(reg: *const GX2PointSizeReg);
}
extern "C" {
    pub fn GX2SetPointLimits(min: f32, max: f32);
}
extern "C" {
    pub fn GX2InitPointLimitsReg(reg: *mut GX2PointLimitsReg, min: f32, max: f32);
}
extern "C" {
    pub fn GX2GetPointLimitsReg(reg: *mut GX2PointLimitsReg, min: *mut f32, max: *mut f32);
}
extern "C" {
    pub fn GX2SetPointLimitsReg(reg: *const GX2PointLimitsReg);
}
extern "C" {
    pub fn GX2SetCullOnlyControl(frontFace: GX2FrontFace::Type, cullFront: BOOL, cullBack: BOOL);
}
extern "C" {
    pub fn GX2SetPolygonControl(
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2InitPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
}
extern "C" {
    pub fn GX2GetPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: *mut GX2FrontFace::Type,
        cullFront: *mut BOOL,
        cullBack: *mut BOOL,
        polyMode: *mut BOOL,
        polyModeFront: *mut GX2PolygonMode::Type,
        polyModeBack: *mut GX2PolygonMode::Type,
        polyOffsetFrontEnable: *mut BOOL,
        polyOffsetBackEnable: *mut BOOL,
        polyOffsetParaEnable: *mut BOOL,
    );
}
extern "C" {
    pub fn GX2SetPolygonControlReg(reg: *const GX2PolygonControlReg);
}
extern "C" {
    pub fn GX2SetPolygonOffset(
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2InitPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
}
extern "C" {
    pub fn GX2GetPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: *mut f32,
        frontScale: *mut f32,
        backOffset: *mut f32,
        backScale: *mut f32,
        clamp: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetPolygonOffsetReg(reg: *const GX2PolygonOffsetReg);
}
extern "C" {
    pub fn GX2SetScissor(x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2InitScissorReg(reg: *mut GX2ScissorReg, x: u32, y: u32, width: u32, height: u32);
}
extern "C" {
    pub fn GX2GetScissorReg(
        reg: *mut GX2ScissorReg,
        x: *mut u32,
        y: *mut u32,
        width: *mut u32,
        height: *mut u32,
    );
}
extern "C" {
    pub fn GX2SetScissorReg(reg: *const GX2ScissorReg);
}
extern "C" {
    pub fn GX2SetTargetChannelMasks(
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2InitTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2GetTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: *mut GX2ChannelMask::Type,
        mask1: *mut GX2ChannelMask::Type,
        mask2: *mut GX2ChannelMask::Type,
        mask3: *mut GX2ChannelMask::Type,
        mask4: *mut GX2ChannelMask::Type,
        mask5: *mut GX2ChannelMask::Type,
        mask6: *mut GX2ChannelMask::Type,
        mask7: *mut GX2ChannelMask::Type,
    );
}
extern "C" {
    pub fn GX2SetTargetChannelMasksReg(reg: *const GX2TargetChannelMaskReg);
}
extern "C" {
    pub fn GX2SetViewport(x: f32, y: f32, width: f32, height: f32, nearZ: f32, farZ: f32);
}
extern "C" {
    pub fn GX2InitViewportReg(
        reg: *mut GX2ViewportReg,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        nearZ: f32,
        farZ: f32,
    );
}
extern "C" {
    pub fn GX2GetViewportReg(
        reg: *mut GX2ViewportReg,
        x: *mut f32,
        y: *mut f32,
        width: *mut f32,
        height: *mut f32,
        nearZ: *mut f32,
        farZ: *mut f32,
    );
}
extern "C" {
    pub fn GX2SetViewportReg(reg: *const GX2ViewportReg);
}
extern "C" {
    pub fn GX2SetRasterizerClipControl(rasterizer: BOOL, zclipEnable: BOOL);
}
extern "C" {
    pub fn GX2SetRasterizerClipControlEx(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
}
extern "C" {
    pub fn GX2SetRasterizerClipControlHalfZ(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
}
pub type H264DECFptrOutputFn =
    ::core::option::Option<unsafe extern "C" fn(output: *mut H264DecodeOutput)>;
pub mod H264Error {
    pub type Type = ::core::ffi::c_uint;
    pub const H264_ERROR_OK: Type = 0;
    pub const H264_ERROR_INVALID_PPS: Type = 24;
    pub const H264_ERROR_INVALID_SPS: Type = 26;
    pub const H264_ERROR_INVALID_SLICEHEADER: Type = 61;
    pub const H264_ERROR_GENERIC: Type = 16777216;
    pub const H264_ERROR_INVALID_PARAMETER: Type = 16842752;
    pub const H264_ERROR_OUT_OF_MEMORY: Type = 16908288;
    pub const H264_ERROR_INVALID_PROFILE: Type = 17301504;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodedVuiParameters {
    pub aspect_ratio_info_present_flag: u8,
    pub aspect_ratio_idc: u8,
    pub sar_width: i16,
    pub sar_height: i16,
    pub overscan_info_present_flag: u8,
    pub overscan_appropriate_flag: u8,
    pub video_signal_type_present_flag: u8,
    pub video_format: u8,
    pub video_full_range_flag: u8,
    pub colour_description_present_flag: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub chroma_loc_info_present_flag: u8,
    pub chroma_sample_loc_type_top_field: u8,
    pub chroma_sample_loc_type_bottom_field: u8,
    pub timing_info_present_flag: u8,
    pub __unk42: [::core::ffi::c_char; 1usize],
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub fixed_frame_rate_flag: u8,
    pub nal_hrd_parameters_present_flag: u8,
    pub vcl_hrd_parameters_present_flag: u8,
    pub low_delay_hrd_flag: u8,
    pub pic_struct_present_flag: u8,
    pub bitstream_restriction_flag: u8,
    pub motion_vectors_over_pic_boundaries_flag: u8,
    pub __unk43: [::core::ffi::c_char; 1usize],
    pub max_bytes_per_pic_denom: i16,
    pub max_bits_per_mb_denom: i16,
    pub log2_max_mv_length_horizontal: i16,
    pub log2_max_mv_length_vertical: i16,
    pub num_reorder_frames: i16,
    pub max_dec_frame_buffering: i16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeResult {
    pub status: i32,
    pub __unk44: [::core::ffi::c_char; 4usize],
    pub timestamp: f64,
    pub width: i32,
    pub height: i32,
    pub nextLine: i32,
    pub cropEnableFlag: u8,
    pub __unk45: [::core::ffi::c_char; 3usize],
    pub cropTop: i32,
    pub cropBottom: i32,
    pub cropLeft: i32,
    pub cropRight: i32,
    pub panScanEnableFlag: u8,
    pub __unk46: [::core::ffi::c_char; 3usize],
    pub panScanTop: i32,
    pub panScanBottom: i32,
    pub panScanLeft: i32,
    pub panScanRight: i32,
    pub framebuffer: *mut ::core::ffi::c_void,
    pub vui_parameters_present_flag: u8,
    pub __unk47: [::core::ffi::c_char; 3usize],
    pub vui_parameters: *mut H264DecodedVuiParameters,
    pub __unk48: [::core::ffi::c_char; 40usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeOutput {
    pub frameCount: i32,
    pub decodeResults: *mut *mut H264DecodeResult,
    pub userMemory: *mut ::core::ffi::c_void,
}
extern "C" {
    pub fn H264DECCheckDecunitLength(
        memory: *mut ::core::ffi::c_void,
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outLength: *mut i32,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECCheckSkipableFrame(
        buffer: *const u8,
        bufferLength: i32,
        outSkippable: *mut BOOL,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECFindDecstartpoint(
        buffer: *const u8,
        bufferLength: i32,
        outOffset: *mut i32,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECFindIdrpoint(buffer: *const u8, bufferLength: i32, outOffset: *mut i32) -> i32;
}
extern "C" {
    pub fn H264DECGetImageSize(
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outWidth: *mut i32,
        outHeight: *mut i32,
    ) -> H264Error::Type;
}
pub mod H264Parameter {
    pub type Type = ::core::ffi::c_uint;
    pub const H264_PARAMETER_FRAME_POINTER_OUTPUT: Type = 1;
    pub const H264_PARAMETER_OUTPUT_PER_FRAME: Type = 536870914;
    pub const H264_PARAMETER_UNKNOWN_20000010: Type = 536870928;
    pub const H264_PARAMETER_UNKNOWN_20000030: Type = 536870960;
    pub const H264_PARAMETER_UNKNOWN_20000040: Type = 536870976;
    pub const H264_PARAMETER_USER_MEMORY: Type = 1879048193;
}
extern "C" {
    pub fn H264DECMemoryRequirement(
        profile: i32,
        level: i32,
        maxWidth: i32,
        maxHeight: i32,
        outMemoryRequirement: *mut u32,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECInitParam(memorySize: i32, memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECSetParam(
        memory: *mut ::core::ffi::c_void,
        parameter: H264Parameter::Type,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECSetParam_FPTR_OUTPUT(
        memory: *mut ::core::ffi::c_void,
        value: H264DECFptrOutputFn,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECSetParam_OUTPUT_PER_FRAME(
        memory: *mut ::core::ffi::c_void,
        value: u32,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECSetParam_USER_MEMORY(
        memory: *mut ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECCheckMemSegmentation(
        memory: *mut ::core::ffi::c_void,
        size: u32,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECOpen(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECBegin(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECSetBitstream(
        memory: *mut ::core::ffi::c_void,
        buffer: *mut u8,
        bufferLength: u32,
        timestamp: f64,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECExecute(
        memory: *mut ::core::ffi::c_void,
        frameBuffer: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECFlush(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECEnd(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
extern "C" {
    pub fn H264DECClose(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
}
pub mod HIDAttachEvent {
    pub type Type = ::core::ffi::c_uint;
    pub const HID_DEVICE_DETACH: Type = 0;
    pub const HID_DEVICE_ATTACH: Type = 1;
}
pub type HIDAttachCallback = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut HIDClient,
        device: *mut HIDDevice,
        attach: HIDAttachEvent::Type,
    ) -> i32,
>;
pub type HIDCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: u32,
        error: i32,
        buffer: *mut u8,
        bytesTransferred: u32,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDDevice {
    pub handle: u32,
    pub physicalDeviceInst: u32,
    pub vid: u16,
    pub pid: u16,
    pub interfaceIndex: u8,
    pub subClass: u8,
    pub protocol: u8,
    pub __unk49: [::core::ffi::c_char; 1usize],
    pub maxPacketSizeRx: u16,
    pub maxPacketSizeTx: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDClient {
    pub next: *mut HIDClient,
    pub attachCallback: HIDAttachCallback,
}
extern "C" {
    pub fn HIDSetup() -> i32;
}
extern "C" {
    pub fn HIDTeardown() -> i32;
}
extern "C" {
    pub fn HIDAddClient(client: *mut HIDClient, attachCallback: HIDAttachCallback) -> i32;
}
extern "C" {
    pub fn HIDDelClient(client: *mut HIDClient) -> i32;
}
extern "C" {
    pub fn HIDGetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDSetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDGetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDRead(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn HIDWrite(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        hc: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type OSExceptionCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut OSContext) -> BOOL>;
pub mod OSExceptionMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EXCEPTION_MODE_SYSTEM: Type = 0;
    pub const OS_EXCEPTION_MODE_THREAD: Type = 1;
    pub const OS_EXCEPTION_MODE_GLOBAL: Type = 2;
    pub const OS_EXCEPTION_MODE_THREAD_ALL_CORES: Type = 3;
    pub const OS_EXCEPTION_MODE_GLOBAL_ALL_CORES: Type = 4;
}
pub mod OSExceptionType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EXCEPTION_TYPE_SYSTEM_RESET: Type = 0;
    pub const OS_EXCEPTION_TYPE_MACHINE_CHECK: Type = 1;
    pub const OS_EXCEPTION_TYPE_DSI: Type = 2;
    pub const OS_EXCEPTION_TYPE_ISI: Type = 3;
    pub const OS_EXCEPTION_TYPE_EXTERNAL_INTERRUPT: Type = 4;
    pub const OS_EXCEPTION_TYPE_ALIGNMENT: Type = 5;
    pub const OS_EXCEPTION_TYPE_PROGRAM: Type = 6;
    pub const OS_EXCEPTION_TYPE_FLOATING_POINT: Type = 7;
    pub const OS_EXCEPTION_TYPE_DECREMENTER: Type = 8;
    pub const OS_EXCEPTION_TYPE_SYSTEM_CALL: Type = 9;
    pub const OS_EXCEPTION_TYPE_TRACE: Type = 10;
    pub const OS_EXCEPTION_TYPE_PERFORMANCE_MONITOR: Type = 11;
    pub const OS_EXCEPTION_TYPE_BREAKPOINT: Type = 12;
    pub const OS_EXCEPTION_TYPE_SYSTEM_INTERRUPT: Type = 13;
    pub const OS_EXCEPTION_TYPE_ICI: Type = 14;
}
extern "C" {
    pub fn OSSetExceptionCallback(
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
extern "C" {
    pub fn OSSetExceptionCallbackEx(
        mode: OSExceptionMode::Type,
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
}
pub type OSThreadState = u8;
pub type OSThreadRequest = u32;
pub type OSThreadAttributes = u8;
pub type OSThreadType = u32;
pub type OSThreadEntryPointFn = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
pub type OSThreadCleanupCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub type OSThreadDeallocatorFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub mod OSThreadSpecificID {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_SPECIFIC_0: Type = 0;
    pub const OS_THREAD_SPECIFIC_1: Type = 1;
    pub const OS_THREAD_SPECIFIC_2: Type = 2;
    pub const OS_THREAD_SPECIFIC_3: Type = 3;
    pub const OS_THREAD_SPECIFIC_4: Type = 4;
    pub const OS_THREAD_SPECIFIC_5: Type = 5;
    pub const OS_THREAD_SPECIFIC_6: Type = 6;
    pub const OS_THREAD_SPECIFIC_7: Type = 7;
    pub const OS_THREAD_SPECIFIC_8: Type = 8;
    pub const OS_THREAD_SPECIFIC_9: Type = 9;
    pub const OS_THREAD_SPECIFIC_10: Type = 10;
    pub const OS_THREAD_SPECIFIC_11: Type = 11;
    pub const OS_THREAD_SPECIFIC_12: Type = 12;
    pub const OS_THREAD_SPECIFIC_13: Type = 13;
    pub const OS_THREAD_SPECIFIC_WUT_RESERVED_0: Type = 14;
    pub const OS_THREAD_SPECIFIC_WUT_RESERVED_1: Type = 15;
}
pub mod OS_THREAD_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_STATE_NONE: Type = 0;
    pub const OS_THREAD_STATE_READY: Type = 1;
    pub const OS_THREAD_STATE_RUNNING: Type = 2;
    pub const OS_THREAD_STATE_WAITING: Type = 4;
    pub const OS_THREAD_STATE_MORIBUND: Type = 8;
}
pub mod OS_THREAD_REQUEST {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_REQUEST_NONE: Type = 0;
    pub const OS_THREAD_REQUEST_SUSPEND: Type = 1;
    pub const OS_THREAD_REQUEST_CANCEL: Type = 2;
}
pub mod OS_THREAD_ATTRIB {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU0: Type = 1;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU1: Type = 2;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU2: Type = 4;
    pub const OS_THREAD_ATTRIB_AFFINITY_ANY: Type = 7;
    pub const OS_THREAD_ATTRIB_DETACHED: Type = 8;
    pub const OS_THREAD_ATTRIB_STACK_USAGE: Type = 32;
    pub const OS_THREAD_ATTRIB_UNKNOWN: Type = 128;
}
pub mod OS_THREAD_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_TYPE_DRIVER: Type = 0;
    pub const OS_THREAD_TYPE_IO: Type = 1;
    pub const OS_THREAD_TYPE_APP: Type = 2;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadGHSExceptionHandling {
    pub __unk50: [::core::ffi::c_char; 104usize],
    pub eh_globals: *mut ::core::ffi::c_void,
    pub eh_mem_manage: [*mut ::core::ffi::c_void; 9usize],
    pub eh_store_globals: [*mut ::core::ffi::c_void; 6usize],
    pub eh_store_globals_tdeh: [*mut ::core::ffi::c_void; 76usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexQueue {
    pub head: *mut OSMutex,
    pub tail: *mut OSMutex,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk51: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexQueue {
    pub head: *mut OSFastMutex,
    pub tail: *mut OSFastMutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSTLSSection {
    pub data: *mut ::core::ffi::c_void,
    pub __unk52: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThread {
    pub context: OSContext,
    pub tag: u32,
    pub state: OSThreadState,
    pub attr: OSThreadAttributes,
    pub id: u16,
    pub suspendCounter: i32,
    pub priority: i32,
    pub basePriority: i32,
    pub exitValue: i32,
    pub coreRunQueue: [*mut OSThreadQueue; 3usize],
    pub coreRunQueueLink: [OSThreadLink; 3usize],
    pub queue: *mut OSThreadQueue,
    pub link: OSThreadLink,
    pub joinQueue: OSThreadQueue,
    pub mutex: *mut OSMutex,
    pub mutexQueue: OSMutexQueue,
    pub activeLink: OSThreadLink,
    pub stackStart: *mut ::core::ffi::c_void,
    pub stackEnd: *mut ::core::ffi::c_void,
    pub entryPoint: OSThreadEntryPointFn,
    pub ghsExceptionHandling: OSThreadGHSExceptionHandling,
    pub alarmCancelled: BOOL,
    pub specific: [*mut ::core::ffi::c_void; 16usize],
    pub type_: OSThreadType,
    pub name: *const ::core::ffi::c_char,
    pub waitEventTimeoutAlarm: *mut OSAlarm,
    pub userStackPointer: *mut ::core::ffi::c_void,
    pub cleanupCallback: OSThreadCleanupCallbackFn,
    pub deallocator: OSThreadDeallocatorFn,
    pub cancelState: BOOL,
    pub requestFlag: OSThreadRequest,
    pub needSuspend: i32,
    pub suspendResult: i32,
    pub suspendQueue: OSThreadQueue,
    pub __unk53: [::core::ffi::c_char; 4usize],
    pub runQuantumTicks: i64,
    pub coreTimeConsumedNs: u64,
    pub wakeCount: u64,
    pub unk0x610: OSTime,
    pub unk0x618: OSTime,
    pub unk0x620: OSTime,
    pub unk0x628: OSTime,
    pub dsiCallback: [OSExceptionCallbackFn; 3usize],
    pub isiCallback: [OSExceptionCallbackFn; 3usize],
    pub programCallback: [OSExceptionCallbackFn; 3usize],
    pub perfMonCallback: [OSExceptionCallbackFn; 3usize],
    pub stackSyncObjAllowed: BOOL,
    pub tlsSectionCount: u16,
    pub __unk54: [::core::ffi::c_char; 2usize],
    pub tlsSections: *mut OSTLSSection,
    pub fastMutex: *mut OSFastMutex,
    pub contendedFastMutexes: OSFastMutexQueue,
    pub fastMutexQueue: OSFastMutexQueue,
    pub alignCallback: [OSExceptionCallbackFn; 3usize],
    pub reserved: [u32; 5usize],
}
extern "C" {
    pub fn OSCancelThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSCheckActiveThreads() -> i32;
}
extern "C" {
    pub fn OSCheckThreadStackUsage(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSClearThreadStackUsage(thread: *mut OSThread);
}
extern "C" {
    pub fn OSContinueThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSCreateThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: i32,
        argv: *mut ::core::ffi::c_char,
        stack: *mut ::core::ffi::c_void,
        stackSize: u32,
        priority: i32,
        attributes: OSThreadAttributes,
    ) -> BOOL;
}
extern "C" {
    pub fn OSDetachThread(thread: *mut OSThread);
}
extern "C" {
    pub fn OSExitThread(result: i32);
}
extern "C" {
    pub fn OSGetActiveThreadLink(thread: *mut OSThread, link: *mut OSThreadLink);
}
extern "C" {
    pub fn OSGetCurrentThread() -> *mut OSThread;
}
extern "C" {
    pub fn OSGetDefaultThread(coreID: u32) -> *mut OSThread;
}
extern "C" {
    pub fn OSGetStackPointer() -> u32;
}
extern "C" {
    pub fn OSGetThreadAffinity(thread: *mut OSThread) -> u32;
}
extern "C" {
    pub fn OSGetThreadName(thread: *mut OSThread) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn OSGetThreadPriority(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSGetThreadSpecific(id: OSThreadSpecificID::Type) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSIsThreadSuspended(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSIsThreadTerminated(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSJoinThread(thread: *mut OSThread, threadResult: *mut ::core::ffi::c_int) -> BOOL;
}
extern "C" {
    pub fn OSResumeThread(thread: *mut OSThread) -> i32;
}
extern "C" {
    pub fn OSRunThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadAffinity(thread: *mut OSThread, affinity: u32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadCancelState(state: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadCleanupCallback(
        thread: *mut OSThread,
        callback: OSThreadCleanupCallbackFn,
    ) -> OSThreadCleanupCallbackFn;
}
extern "C" {
    pub fn OSSetThreadDeallocator(
        thread: *mut OSThread,
        deallocator: OSThreadDeallocatorFn,
    ) -> OSThreadDeallocatorFn;
}
extern "C" {
    pub fn OSSetThreadName(thread: *mut OSThread, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSSetThreadPriority(thread: *mut OSThread, priority: i32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadRunQuantum(thread: *mut OSThread, quantum: u32) -> BOOL;
}
extern "C" {
    pub fn OSSetThreadSpecific(id: OSThreadSpecificID::Type, value: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSSetThreadStackUsage(thread: *mut OSThread) -> BOOL;
}
extern "C" {
    pub fn OSSleepThread(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSSleepTicks(ticks: OSTime);
}
extern "C" {
    pub fn OSSuspendThread(thread: *mut OSThread) -> u32;
}
extern "C" {
    pub fn __OSSuspendThreadNolock(thread: *mut OSThread);
}
extern "C" {
    pub fn OSTestThreadCancel();
}
extern "C" {
    pub fn OSWakeupThread(queue: *mut OSThreadQueue);
}
extern "C" {
    pub fn OSYieldThread();
}
pub type CAMHandle = ::core::ffi::c_int;
pub type CAMError = ::core::ffi::c_int;
pub mod CamError {
    pub type Type = ::core::ffi::c_int;
    pub const CAMERA_ERROR_OK: Type = 0;
    pub const CAMERA_ERROR_INVALID_ARG: Type = -1;
    pub const CAMERA_ERROR_INVALID_HANDLE: Type = -2;
    pub const CAMERA_ERROR_TOO_MANY_SURFACES: Type = -4;
    pub const CAMERA_ERROR_INSUFFICIENT_MEMORY: Type = -5;
    pub const CAMERA_ERROR_NOT_READY: Type = -6;
    pub const CAMERA_ERROR_UNINITIALIZED: Type = -8;
    pub const CAMERA_ERROR_UVC: Type = -9;
    pub const CAMERA_ERROR_UVD_CONTEXT: Type = -10;
    pub const CAMERA_ERROR_DEVICE_IN_USE: Type = -12;
    pub const CAMERA_ERROR_UVD_SESSION: Type = -13;
    pub const CAMERA_ERROR_SEGMENT_VIOLATION: Type = -15;
}
pub mod CamFps {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_FPS_15: Type = 0;
    pub const CAMERA_FPS_30: Type = 1;
}
pub mod CamStreamType {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_STREAM_TYPE_1: Type = 0;
}
pub mod CamEventType {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_DECODE_DONE: Type = 0;
    pub const CAMERA_DRC_DETACH: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CAMEventData {
    pub eventType: CamEventType::Type,
    pub __bindgen_anon_1: CAMEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CAMEventData__bindgen_ty_1 {
    pub decode: CAMEventData__bindgen_ty_1__bindgen_ty_1,
    pub detach: CAMEventData__bindgen_ty_1__bindgen_ty_2,
    pub args: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_1 {
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub handle: CAMHandle,
    pub failed: BOOL,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_2 {
    pub connected: BOOL,
    pub handle: CAMHandle,
}
pub type CAMEventHandler =
    ::core::option::Option<unsafe extern "C" fn(camEventData: *mut CAMEventData)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMMode {
    pub forceDrc: BOOL,
    pub fps: CamFps::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMWorkMem {
    pub size: u32,
    pub pMem: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMStreamInfo {
    pub type_: CamStreamType::Type,
    pub height: u32,
    pub width: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSetupInfo {
    pub streamInfo: CAMStreamInfo,
    pub workMem: CAMWorkMem,
    pub eventHandler: CAMEventHandler,
    pub mode: CAMMode,
    pub threadAffinity: u32,
    pub __unk55: [::core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSurface {
    pub surfaceSize: i32,
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub height: i32,
    pub width: i32,
    pub pitch: i32,
    pub alignment: i32,
    pub tileMode: i32,
    pub pixelFormat: i32,
}
extern "C" {
    pub fn CAMInit(
        instance: ::core::ffi::c_int,
        setupInfo: *mut CAMSetupInfo,
        err: *mut CAMError,
    ) -> CAMHandle;
}
extern "C" {
    pub fn CAMExit(handle: CAMHandle);
}
extern "C" {
    pub fn CAMOpen(handle: CAMHandle) -> CAMError;
}
extern "C" {
    pub fn CAMClose(handle: CAMHandle) -> CAMError;
}
extern "C" {
    pub fn CAMGetMemReq(streamInfo: *mut CAMStreamInfo) -> i32;
}
extern "C" {
    pub fn CAMSubmitTargetSurface(handle: CAMHandle, surface: *mut CAMSurface) -> CAMError;
}
extern "C" {
    pub fn CAMCheckMemSegmentation(pMem: *mut ::core::ffi::c_void, size: u32) -> CAMError;
}
pub type ProcUISaveCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type ProcUISaveCallbackEx =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub type ProcUICallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub mod ProcUICallbackType {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCUI_CALLBACK_ACQUIRE: Type = 0;
    pub const PROCUI_CALLBACK_RELEASE: Type = 1;
    pub const PROCUI_CALLBACK_EXIT: Type = 2;
    pub const PROCUI_CALLBACK_NET_IO_START: Type = 3;
    pub const PROCUI_CALLBACK_NET_IO_STOP: Type = 4;
    pub const PROCUI_CALLBACK_HOME_BUTTON_DENIED: Type = 5;
}
pub mod ProcUIStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCUI_STATUS_IN_FOREGROUND: Type = 0;
    pub const PROCUI_STATUS_IN_BACKGROUND: Type = 1;
    pub const PROCUI_STATUS_RELEASE_FOREGROUND: Type = 2;
    pub const PROCUI_STATUS_EXITING: Type = 3;
}
extern "C" {
    pub fn ProcUIClearCallbacks();
}
extern "C" {
    pub fn ProcUIDrawDoneRelease();
}
extern "C" {
    pub fn ProcUIInForeground() -> BOOL;
}
extern "C" {
    pub fn ProcUIInShutdown() -> BOOL;
}
extern "C" {
    pub fn ProcUIInit(saveCallback: ProcUISaveCallback);
}
extern "C" {
    pub fn ProcUIInitEx(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn ProcUIIsRunning() -> BOOL;
}
extern "C" {
    pub fn ProcUIProcessMessages(block: BOOL) -> ProcUIStatus::Type;
}
extern "C" {
    pub fn ProcUIRegisterCallback(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
    );
}
extern "C" {
    pub fn ProcUIRegisterCallbackCore(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
        core: u32,
    );
}
extern "C" {
    pub fn ProcUIRegisterBackgroundCallback(
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        interval: OSTime,
    );
}
extern "C" {
    pub fn ProcUISetSaveCallback(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn ProcUIShutdown();
}
extern "C" {
    pub fn ProcUISubProcessMessages(block: BOOL) -> ProcUIStatus::Type;
}
extern "C" {
    pub fn ProcUICalcMemorySize(numCallbacks: u32) -> u32;
}
extern "C" {
    pub fn ProcUISetMemoryPool(pool: *mut ::core::ffi::c_void, size: u32) -> i32;
}
extern "C" {
    pub fn ProcUISetCallbackStackSize(size: u32);
}
extern "C" {
    pub fn ProcUISetBucketStorage(buf: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn ProcUISetMEM1Storage(buf: *mut ::core::ffi::c_void, size: u32);
}
pub type CCRCDCDestination = u8;
pub type CCRCDCWpsStatusType = u32;
pub type CCRCDCWakeState = u8;
pub type CCRCDCUicConfigId = u8;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCRegisterCallbackData {
    pub attached: i32,
    pub chan: u32,
    pub __unk56: [::core::ffi::c_char; 6usize],
}
pub type CCRCDCRegisterCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut CCRCDCRegisterCallbackData, arg2: *mut ::core::ffi::c_void),
>;
pub mod CCRCDCDestinationEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_DESTINATION_DRH: Type = 1;
    pub const CCR_CDC_DESTINATION_DRC0: Type = 2;
    pub const CCR_CDC_DESTINATION_DRC1: Type = 3;
}
pub mod CCRCDCWpsStatusEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_WPS_STATUS_PAIRED: Type = 0;
    pub const CCR_CDC_WPS_STATUS_SEARCHING: Type = 1;
    pub const CCR_CDC_WPS_STATUS_PAIRING: Type = 2;
}
pub mod CCRCDCDrcStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_DRC_STATE_ACTIVE: Type = 0;
    pub const CCR_CDC_DRC_STATE_PAIRING: Type = 1;
    pub const CCR_CDC_DRC_STATE_FWUPDATE: Type = 2;
    pub const CCR_CDC_DRC_STATE_STANDALONE: Type = 3;
    pub const CCR_CDC_DRC_STATE_BACKGROUND: Type = 4;
    pub const CCR_CDC_DRC_STATE_SLEEP: Type = 5;
    pub const CCR_CDC_DRC_STATE_STANDBY: Type = 6;
    pub const CCR_CDC_DRC_STATE_WOWLSETTING: Type = 7;
    pub const CCR_CDC_DRC_STATE_DKSETTING: Type = 8;
    pub const CCR_CDC_DRC_STATE_UNKNOWN9: Type = 9;
    pub const CCR_CDC_DRC_STATE_WIIACTIVE: Type = 10;
    pub const CCR_CDC_DRC_STATE_LOW_BATTERY: Type = 11;
    pub const CCR_CDC_DRC_STATE_SUBACTIVE: Type = 12;
}
pub mod CCRCDCWakeStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_WAKE_STATE_ACTIVE: Type = 1;
    pub const CCR_CDC_WAKE_STATE_BACKGROUND: Type = 2;
}
pub mod CCRCDCBoardVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_BOARD_VERSION_DK1: Type = 0;
    pub const CCR_CDC_BOARD_VERSION_DK1_EP_DK2: Type = 1;
    pub const CCR_CDC_BOARD_VERSION_DP1: Type = 2;
    pub const CCR_CDC_BOARD_VERSION_DP2: Type = 3;
    pub const CCR_CDC_BOARD_VERSION_DK3: Type = 4;
    pub const CCR_CDC_BOARD_VERSION_DK4: Type = 5;
    pub const CCR_CDC_BOARD_VERSION_PREDP3_DP3: Type = 6;
    pub const CCR_CDC_BOARD_VERSION_DK5: Type = 7;
    pub const CCR_CDC_BOARD_VERSION_DP4: Type = 8;
    pub const CCR_CDC_BOARD_VERSION_DKMP: Type = 9;
    pub const CCR_CDC_BOARD_VERSION_DP5: Type = 10;
    pub const CCR_CDC_BOARD_VERSION_MASS: Type = 11;
    pub const CCR_CDC_BOARD_VERSION_DKMP2: Type = 12;
    pub const CCR_CDC_BOARD_VERSION_DRC_I: Type = 13;
    pub const CCR_CDC_BOARD_VERSION_DKTVMP: Type = 14;
}
pub mod CCRCDCChipVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_CHIP_VERSION_TS: Type = 16;
    pub const CCR_CDC_CHIP_VERSION_ES1: Type = 32;
    pub const CCR_CDC_CHIP_VERSION_ES2: Type = 48;
    pub const CCR_CDC_CHIP_VERSION_ES3: Type = 64;
    pub const CCR_CDC_CHIP_VERSION_MS01: Type = 65;
}
pub mod CCRCDCUicConfigIdEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_BANK: Type = 0;
    pub const CCR_CDC_UIC_CONFIG_ID_MIC_CONFIG: Type = 2;
    pub const CCR_CDC_UIC_CONFIG_ID_ACC_CALIBRATION_VALUE: Type = 3;
    pub const CCR_CDC_UIC_CONFIG_ID_TP_CALIBRATION_VALUE: Type = 5;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK7: Type = 7;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK8: Type = 8;
    pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_EXT_ID: Type = 9;
    pub const CCR_CDC_UIC_CONFIG_ID_TV_CONTROL_ID: Type = 10;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_2: Type = 11;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_3: Type = 12;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_4: Type = 13;
    pub const CCR_CDC_UIC_CONFIG_ID_INIT_BOOT_FLAG: Type = 14;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK15: Type = 15;
    pub const CCR_CDC_UIC_CONFIG_ID_LCD_MODE: Type = 16;
    pub const CCR_CDC_UIC_CONFIG_ID_RC_DATABASE_EXT_ID: Type = 17;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK18: Type = 18;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_ENABLE_FLAG: Type = 19;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_INITIAL_BOOT_FLAG: Type = 20;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_CAFFEINE_SLOT: Type = 21;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_SOUND_MODE: Type = 22;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_INFO: Type = 23;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_READ_COUNT: Type = 24;
}
pub mod CCRCDCExt {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_EXT_LANGUAGE: Type = 0;
    pub const CCR_CDC_EXT_RC_DATABASE: Type = 1;
    pub const CCR_CDC_EXT_UNK2: Type = 2;
    pub const CCR_CDC_EXT_UNK3: Type = 3;
    pub const CCR_CDC_EXT_UNK4: Type = 4;
}
pub mod CCRCDCDrhStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_SYS_DRH_STATE_NORADIO: Type = 0;
    pub const CCR_CDC_SYS_DRH_STATE_WII: Type = 1;
    pub const CCR_CDC_SYS_DRH_STATE_UNK2: Type = 2;
    pub const CCR_CDC_SYS_DRH_STATE_NODRC: Type = 3;
    pub const CCR_CDC_SYS_DRH_STATE_ECO: Type = 4;
    pub const CCR_CDC_SYS_DRH_STATE_UNK7F: Type = 127;
    pub const CCR_CDC_SYS_DRH_STATE_CAFE: Type = 255;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCMacAddress {
    pub device: CCRCDCDestination,
    pub address: [u8; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCWpsArgs {
    pub hasArgs: u8,
    pub pin: [::core::ffi::c_char; 8usize],
    pub timeout: u16,
    pub pairDestination: CCRCDCDestination,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCSysMessage {
    pub message: u16,
    pub timeout: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCSysInfo {
    pub boardVersion: CCRCDCBoardVersion::Type,
    pub chipVersion: CCRCDCChipVersion::Type,
    pub lvcVersion: u32,
    pub umiVersion: u32,
    pub unknown: u32,
    pub sdCis: u32,
    pub splId: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCEepromData {
    pub version: u32,
    pub data: [u8; 768usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCWowlWakeDrcArg {
    pub __unk57: [::core::ffi::c_char; 6usize],
    pub state: CCRCDCWakeState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCUicConfig {
    pub configId: CCRCDCUicConfigId,
    pub size: u8,
    pub data: [u8; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCFWInfo {
    pub imageSize: u32,
    pub blockSize: u32,
    pub imageVersion: u32,
    pub sequencePerSession: u32,
    pub updateProgress: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCSoftwareVersion {
    pub runningVersion: u32,
    pub activeVersion: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCDrcState {
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCDrhState {
    pub state: u8,
}
extern "C" {
    pub fn CCRCDCCommand(
        unk: u8,
        fragment: u8,
        dest: CCRCDCDestination,
        flags0: u8,
        flags1: u8,
        service: u8,
        method: u8,
        payload: *mut ::core::ffi::c_void,
        payloadSize: u32,
        reply: *mut ::core::ffi::c_void,
        replySize: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCDevicePing(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSetStationId(id: *mut CCRCDCMacAddress) -> i32;
}
extern "C" {
    pub fn CCRCDCGetMacAddress(dest: CCRCDCDestination, mac: *mut CCRCDCMacAddress) -> i32;
}
extern "C" {
    pub fn CCRCDCGetMultiDrc(numDrcs: *mut u8) -> i32;
}
extern "C" {
    pub fn CCRCDCSetMultiDrc(numDrcs: u8) -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysSetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetDrhState(state: *mut CCRCDCDrhState) -> i32;
}
extern "C" {
    pub fn CCRCDCSysSetDrhState(state: *mut CCRCDCDrhState) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStart() -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStartEx(args: *mut CCRCDCWpsArgs) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStatus(status: *mut CCRCDCWpsStatusType) -> i32;
}
extern "C" {
    pub fn CCRCDCWpsStop() -> i32;
}
extern "C" {
    pub fn CCRCDCSysGetInfo(dest: CCRCDCDestination, info: *mut CCRCDCSysInfo) -> i32;
}
extern "C" {
    pub fn CCRCDCSysDrcDisplayMessage(
        dest: CCRCDCDestination,
        message: *mut CCRCDCSysMessage,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCPerGetUicEeprom(dest: CCRCDCDestination, eeprom: *mut CCRCDCEepromData) -> i32;
}
extern "C" {
    pub fn CCRCDCPerGetUicEepromEx(
        dest: CCRCDCDestination,
        eeprom: *mut CCRCDCEepromData,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSysConsoleShutdownInd(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCWowlWakeDrc(arg: *mut CCRCDCWowlWakeDrcArg) -> i32;
}
extern "C" {
    pub fn CCRCDCPerClearUicConfig(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCPerSetUicConfig(dest: CCRCDCDestination, config: *mut CCRCDCUicConfig) -> i32;
}
extern "C" {
    pub fn CCRCDCCalcCRC16(data: *mut ::core::ffi::c_void, dataSize: u32) -> u16;
}
extern "C" {
    pub fn CCRCDCGetFWInfo(dest: CCRCDCDestination, outInfo: *mut CCRCDCFWInfo) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareGetVersion(
        dest: CCRCDCDestination,
        outVersion: *mut CCRCDCSoftwareVersion,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareAbort(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareActivate(dest: CCRCDCDestination) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareLangUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        outVersion: *mut u32,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareLangActivate(
        dest: CCRCDCDestination,
        version: u32,
        outActivationResult: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareGetExtId(
        dest: CCRCDCDestination,
        ext: CCRCDCExt::Type,
        outId: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCSoftwareExtUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        imageSize: u32,
        extId: u32,
        ext: CCRCDCExt::Type,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterAOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterCFGAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterHIDAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterSYSAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterUACAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterUVCAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRCDCRegisterVOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type CCRCDCIrdaCommand = u8;
pub type CCRCDCIrdaBitrate = u8;
pub type CCRCDCIrdaConnectionType = u8;
pub mod CCRCDCIrdaCommandEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_COMMAND_CONNECT: Type = 0;
    pub const CCR_IRDA_COMMAND_SEND: Type = 1;
    pub const CCR_IRDA_COMMAND_RECEIVE: Type = 2;
    pub const CCR_IRDA_COMMAND_DISCONNECT: Type = 3;
}
pub mod CCRCDCIrdaBitrateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_BITRATE_115200: Type = 0;
    pub const CCR_IRDA_BITRATE_96000: Type = 1;
    pub const CCR_IRDA_BITRATE_72000: Type = 2;
    pub const CCR_IRDA_BITRATE_57600: Type = 3;
    pub const CCR_IRDA_BITRATE_48000: Type = 4;
    pub const CCR_IRDA_BITRATE_38400: Type = 5;
    pub const CCR_IRDA_BITRATE_36000: Type = 6;
    pub const CCR_IRDA_BITRATE_24000: Type = 7;
    pub const CCR_IRDA_BITRATE_19200: Type = 8;
    pub const CCR_IRDA_BITRATE_18000: Type = 9;
    pub const CCR_IRDA_BITRATE_12000: Type = 10;
    pub const CCR_IRDA_BITRATE_9600: Type = 11;
    pub const CCR_IRDA_BITRATE_7200: Type = 13;
    pub const CCR_IRDA_BITRATE_6000: Type = 13;
    pub const CCR_IRDA_BITRATE_4800: Type = 14;
    pub const CCR_IRDA_BITRATE_3000: Type = 15;
}
pub mod CCRCDCIrdaConnectionTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_CONNECTION_WAIT: Type = 0;
    pub const CCR_IRDA_CONNECTION_REQUIRE: Type = 1;
    pub const CCR_IRDA_CONNECTION_ANY: Type = 2;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaConnectRequest {
    pub command: CCRCDCIrdaCommand,
    pub timeout: u16,
    pub bitrate: CCRCDCIrdaBitrate,
    pub receiveSize: u16,
    pub targetId: u8,
    pub type_: CCRCDCIrdaConnectionType,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaConnectReply {
    pub result: u8,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaSendRequest {
    pub command: CCRCDCIrdaCommand,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaSendReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaReceiveRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaReceiveReply {
    pub result: u8,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaSmallPacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaSmallPacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let dataSize: u8 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCIrdaLargePacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaLargePacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let dataSize: u16 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn CCRCDCPerIrdaControl(
        dest: CCRCDCDestination,
        request: *mut ::core::ffi::c_void,
        requestSize: u32,
        response: *mut ::core::ffi::c_void,
        responseSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCConnect(
        drcIndex: i32,
        result: *mut u8,
        timeout: u16,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        targetId: u8,
        type_: CCRCDCIrdaConnectionType,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCSend(
        drcIndex: i32,
        result: *mut u8,
        size: u32,
        receiveSize: u32,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCReceive(
        drcIndex: i32,
        result: *mut u8,
        receivedSize: *mut u16,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn __CCRCDCIRCDisconnect(drcIndex: i32, result: *mut u8) -> i32;
}
pub mod IRCResult {
    pub type Type = ::core::ffi::c_uint;
    pub const IRC_RESULT_SUCCESS: Type = 0;
    pub const IRC_RESULT_INVALID_RECEIVE_SIZE: Type = 3;
    pub const IRC_RESULT_INVALID_PACKET: Type = 5;
    pub const IRC_RESULT_NO_DATA: Type = 6;
    pub const IRC_RESULT_ALREADY_CONNECTED: Type = 11;
    pub const IRC_IR_UNAVAILABLE: Type = 12;
    pub const IRC_RESULT_UNINITIALIZED: Type = 13;
    pub const IRC_RESULT_NOT_CONNECTED: Type = 13;
    pub const IRC_RESULT_CONNECT_FAILED: Type = 15;
    pub const IRC_RESULT_RECEIVE_FAILED: Type = 16;
    pub const IRC_RESULT_SEND_FAILED: Type = 17;
    pub const IRC_RESULT_DISCONNECT_FAILED: Type = 18;
}
pub type IRCConnectCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type IRCReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void, size: u16, result: IRCResult::Type),
>;
extern "C" {
    pub fn IRCInit(channel: VPADChan::Type, targetId: u8) -> BOOL;
}
extern "C" {
    pub fn IRCConnect(
        channel: VPADChan::Type,
        timeout: u16,
        type_: CCRCDCIrdaConnectionType,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        callback: IRCConnectCallback,
    ) -> IRCResult::Type;
}
extern "C" {
    pub fn IRCProc(channel: VPADChan::Type) -> IRCResult::Type;
}
extern "C" {
    pub fn IRCSend(
        channel: VPADChan::Type,
        data: *mut ::core::ffi::c_void,
        dataSize: u32,
        receiveSize: u32,
    ) -> IRCResult::Type;
}
extern "C" {
    pub fn IRCIsConnect(channel: VPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn IRCDisconnect(channel: VPADChan::Type) -> IRCResult::Type;
}
extern "C" {
    pub fn IRCSetReceiveCallback(
        channel: VPADChan::Type,
        receiveCallback: IRCReceiveCallback,
    ) -> IRCReceiveCallback;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct KBDAttachEvent {
    pub channel: u8,
    pub __unk58: [::core::ffi::c_char; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct KBDKeyEvent {
    pub channel: u8,
    pub hidCode: u8,
    pub __unk59: [::core::ffi::c_char; 2usize],
    pub isPressedDown: BOOL,
    pub __unk60: [::core::ffi::c_char; 4usize],
    pub asUTF16Character: u16,
    pub __unk61: [::core::ffi::c_char; 2usize],
}
pub type KDBAttachCallback =
    ::core::option::Option<unsafe extern "C" fn(channel: *mut KBDAttachEvent)>;
pub type KDBKeyCallback = ::core::option::Option<unsafe extern "C" fn(event: *mut KBDKeyEvent)>;
pub mod KDBCountry {
    pub type Type = ::core::ffi::c_uint;
    pub const KDB_COUNTRY_UNKNOWN_0: Type = 0;
    pub const KDB_COUNTRY_UNKNOWN_1: Type = 1;
    pub const KDB_COUNTRY_UNKNOWN_2: Type = 2;
    pub const KDB_COUNTRY_UNKNOWN_3: Type = 3;
    pub const KDB_COUNTRY_UNKNOWN_4: Type = 4;
    pub const KDB_COUNTRY_UNKNOWN_5: Type = 5;
    pub const KDB_COUNTRY_UNKNOWN_6: Type = 6;
    pub const KDB_COUNTRY_UNKNOWN_7: Type = 7;
    pub const KDB_COUNTRY_UNKNOWN_8: Type = 8;
    pub const KDB_COUNTRY_UNKNOWN_9: Type = 9;
    pub const KDB_COUNTRY_UNKNOWN_10: Type = 10;
    pub const KDB_COUNTRY_UNKNOWN_11: Type = 11;
    pub const KDB_COUNTRY_UNKNOWN_12: Type = 12;
    pub const KDB_COUNTRY_UNKNOWN_13: Type = 13;
    pub const KDB_COUNTRY_UNKNOWN_14: Type = 14;
    pub const KDB_COUNTRY_UNKNOWN_15: Type = 15;
    pub const KDB_COUNTRY_UNKNOWN_16: Type = 16;
    pub const KDB_COUNTRY_UNKNOWN_17: Type = 17;
    pub const KDB_COUNTRY_UNKNOWN_18: Type = 18;
}
pub mod KDBError {
    pub type Type = ::core::ffi::c_uint;
    pub const KDB_ERROR_NONE: Type = 0;
    pub const KDB_ERROR_NOT_INITIALIZED: Type = 2;
    pub const KDB_ERROR_ALREADY_INITIALIZED: Type = 3;
    pub const KDB_ERROR_INVALID_COUNTRY: Type = 4;
}
extern "C" {
    pub fn KBDInit(
        unused: u32,
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError::Type;
}
extern "C" {
    pub fn KBDSetup(
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError::Type;
}
extern "C" {
    pub fn KBDTeardown() -> KDBError::Type;
}
extern "C" {
    pub fn KBDSetCountry(channel: u8, country: KDBCountry::Type) -> KDBError::Type;
}
pub type nfds_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::core::ffi::c_int,
    pub events: ::core::ffi::c_int,
    pub revents: ::core::ffi::c_int,
}
extern "C" {
    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type DMAETimeStamp = u64;
extern "C" {
    pub fn DMAEWaitDone(timestamp: DMAETimeStamp) -> BOOL;
}
pub mod DMAESwapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const DMAE_SWAP_NONE: Type = 0;
    pub const DMAE_SWAP_16: Type = 1;
    pub const DMAE_SWAP_32: Type = 2;
    pub const DMAE_SWAP_64: Type = 3;
}
extern "C" {
    pub fn DMAECopyMem(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        wordCount: u32,
        swap: DMAESwapMode::Type,
    ) -> DMAETimeStamp;
}
extern "C" {
    pub fn DMAEFillMem(dst: *mut ::core::ffi::c_void, val: u32, wordCount: u32) -> DMAETimeStamp;
}
extern "C" {
    pub fn DMAEFillMemPhys(
        dst: *mut ::core::ffi::c_void,
        val: u32,
        wordCount: u32,
    ) -> DMAETimeStamp;
}
extern "C" {
    pub fn htonl(hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(hostshort: u16) -> u16;
}
extern "C" {
    pub fn ntohl(netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(netshort: u16) -> u16;
}
extern "C" {
    pub fn inet_addr(cp: *const ::core::ffi::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_aton(cp: *const ::core::ffi::c_char, inp: *mut in_addr) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn inet_ntoa(in_: in_addr) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_ntoa_r(in_: in_addr, buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
pub mod SOMemOptRequest {
    pub type Type = ::core::ffi::c_uint;
    pub const SOMEMOPT_REQUEST_INIT: Type = 1;
    pub const SOMEMOPT_REQUEST_GET_BYTES_USED: Type = 2;
    pub const SOMEMOPT_REQUEST_WAIT_FOR_INIT: Type = 3;
    pub const SOMEMOPT_REQUEST_CANCEL_WAIT: Type = 4;
}
pub mod SOMemOptFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const SOMEMOPT_FLAGS_NONE: Type = 0;
    pub const SOMEMOPT_FLAGS_BIG_BUFFERS: Type = 1;
}
extern "C" {
    pub fn somemopt(
        request: SOMemOptRequest::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags::Type,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_somemopt(
        request: SOMemOptRequest::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags::Type,
    ) -> ::core::ffi::c_int;
}
pub mod FFLCreateIDFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FFL_CREATE_ID_FLAG_WII_U: Type = 5;
    pub const FFL_CREATE_ID_FLAG_TEMPORARY: Type = 2;
    pub const FFL_CREATE_ID_FLAG_NORMAL: Type = 8;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLCreateID {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub deviceHash: [u8; 6usize],
}
impl FFLCreateID {
    #[inline]
    pub fn flags(&self) -> FFLCreateIDFlags::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: FFLCreateIDFlags::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: FFLCreateIDFlags::Type,
        timestamp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataCore {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mii_version: u8,
    pub author_id: u64,
    pub mii_id: FFLCreateID,
    pub unk_0x16: u16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub mii_name: [u16; 10usize],
    pub size: u8,
    pub fatness: u8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hair_type: u8,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 20usize]>,
}
impl FFLiMiiDataCore {
    #[inline]
    pub fn birth_platform(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_birth_platform(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x00_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x00_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn font_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_font_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn region_move(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_move(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x02_b6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x02_b6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copyable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_copyable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        birth_platform: u8,
        unk_0x00_b4: u8,
        unk_0x01_b0: u8,
        unk_0x01_b4: u8,
        font_region: u8,
        region_move: u8,
        unk_0x02_b6: u8,
        copyable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let birth_platform: u8 = unsafe { ::core::mem::transmute(birth_platform) };
            birth_platform as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unk_0x00_b4: u8 = unsafe { ::core::mem::transmute(unk_0x00_b4) };
            unk_0x00_b4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let unk_0x01_b0: u8 = unsafe { ::core::mem::transmute(unk_0x01_b0) };
            unk_0x01_b0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let unk_0x01_b4: u8 = unsafe { ::core::mem::transmute(unk_0x01_b4) };
            unk_0x01_b4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let font_region: u8 = unsafe { ::core::mem::transmute(font_region) };
            font_region as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let region_move: u8 = unsafe { ::core::mem::transmute(region_move) };
            region_move as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unk_0x02_b6: u8 = unsafe { ::core::mem::transmute(unk_0x02_b6) };
            unk_0x02_b6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let copyable: u8 = unsafe { ::core::mem::transmute(copyable) };
            copyable as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn unk_0x18_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x18_b1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_day(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_birth_day(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_month(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_birth_month(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn gender(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gender(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        unk_0x18_b0: u16,
        unk_0x18_b1: u16,
        color: u16,
        birth_day: u16,
        birth_month: u16,
        gender: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk_0x18_b0: u16 = unsafe { ::core::mem::transmute(unk_0x18_b0) };
            unk_0x18_b0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unk_0x18_b1: u16 = unsafe { ::core::mem::transmute(unk_0x18_b1) };
            unk_0x18_b1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let birth_day: u16 = unsafe { ::core::mem::transmute(birth_day) };
            birth_day as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let birth_month: u16 = unsafe { ::core::mem::transmute(birth_month) };
            birth_month as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let gender: u16 = unsafe { ::core::mem::transmute(gender) };
            gender as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn blush_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blush_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_style(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_style(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_face_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn face_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn local_only(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_local_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hair_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hair_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        blush_type: u8,
        face_style: u8,
        face_color: u8,
        face_type: u8,
        local_only: u8,
        hair_mirrored: u8,
        hair_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let blush_type: u8 = unsafe { ::core::mem::transmute(blush_type) };
            blush_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let face_style: u8 = unsafe { ::core::mem::transmute(face_style) };
            face_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let face_color: u8 = unsafe { ::core::mem::transmute(face_color) };
            face_color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let face_type: u8 = unsafe { ::core::mem::transmute(face_type) };
            face_type as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let local_only: u8 = unsafe { ::core::mem::transmute(local_only) };
            local_only as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let hair_mirrored: u8 = unsafe { ::core::mem::transmute(hair_mirrored) };
            hair_mirrored as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let hair_color: u8 = unsafe { ::core::mem::transmute(hair_color) };
            hair_color as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eye_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_eye_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eye_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eye_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(43usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(43usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(48usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(48usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(55usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(55usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(59usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_nose_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(71usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_nose_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(71usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(75usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_nose_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(75usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(80usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(80usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(83usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(83usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(87usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(87usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(90usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(90usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x40(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unk_0x40(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(104usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(104usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(107usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(107usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(112usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(112usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(118usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(118usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(122usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(122usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(125usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_height(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(128usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_glass_height(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(128usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(133usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(133usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(137usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_glass_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(137usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_type(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(140usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(140usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x46_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(144usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x46_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_ypos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(145usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_ypos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(145usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_xpos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(150usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_xpos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(150usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(155usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_mole_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(155usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_enabled(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(159usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mole_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        eye_thickness: u32,
        eye_scale: u32,
        eye_color: u32,
        eye_type: u32,
        eye_height: u32,
        eye_distance: u32,
        eye_rotation: u32,
        eyebrow_thickness: u32,
        eyebrow_scale: u32,
        eyebrow_color: u32,
        eyebrow_type: u32,
        eyebrow_height: u32,
        eyebrow_distance: u32,
        eyebrow_rotation: u32,
        nose_height: u32,
        nose_scale: u32,
        nose_type: u32,
        mouth_thickness: u32,
        mouth_scale: u32,
        mouth_color: u32,
        mouth_type: u32,
        unk_0x40: u32,
        mustache_type: u32,
        mouth_height: u32,
        mustache_height: u32,
        mustache_scale: u32,
        beard_color: u32,
        beard_type: u32,
        glass_height: u16,
        glass_scale: u16,
        glass_color: u16,
        glass_type: u16,
        unk_0x46_b0: u16,
        mole_ypos: u16,
        mole_xpos: u16,
        mole_scale: u16,
        mole_enabled: u16,
    ) -> __BindgenBitfieldUnit<[u8; 20usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 20usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let eye_thickness: u32 = unsafe { ::core::mem::transmute(eye_thickness) };
            eye_thickness as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let eye_scale: u32 = unsafe { ::core::mem::transmute(eye_scale) };
            eye_scale as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let eye_color: u32 = unsafe { ::core::mem::transmute(eye_color) };
            eye_color as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let eye_type: u32 = unsafe { ::core::mem::transmute(eye_type) };
            eye_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let eye_height: u32 = unsafe { ::core::mem::transmute(eye_height) };
            eye_height as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let eye_distance: u32 = unsafe { ::core::mem::transmute(eye_distance) };
            eye_distance as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let eye_rotation: u32 = unsafe { ::core::mem::transmute(eye_rotation) };
            eye_rotation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let eyebrow_thickness: u32 = unsafe { ::core::mem::transmute(eyebrow_thickness) };
            eyebrow_thickness as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let eyebrow_scale: u32 = unsafe { ::core::mem::transmute(eyebrow_scale) };
            eyebrow_scale as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let eyebrow_color: u32 = unsafe { ::core::mem::transmute(eyebrow_color) };
            eyebrow_color as u64
        });
        __bindgen_bitfield_unit.set(43usize, 5u8, {
            let eyebrow_type: u32 = unsafe { ::core::mem::transmute(eyebrow_type) };
            eyebrow_type as u64
        });
        __bindgen_bitfield_unit.set(48usize, 7u8, {
            let eyebrow_height: u32 = unsafe { ::core::mem::transmute(eyebrow_height) };
            eyebrow_height as u64
        });
        __bindgen_bitfield_unit.set(55usize, 4u8, {
            let eyebrow_distance: u32 = unsafe { ::core::mem::transmute(eyebrow_distance) };
            eyebrow_distance as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let eyebrow_rotation: u32 = unsafe { ::core::mem::transmute(eyebrow_rotation) };
            eyebrow_rotation as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let nose_height: u32 = unsafe { ::core::mem::transmute(nose_height) };
            nose_height as u64
        });
        __bindgen_bitfield_unit.set(71usize, 4u8, {
            let nose_scale: u32 = unsafe { ::core::mem::transmute(nose_scale) };
            nose_scale as u64
        });
        __bindgen_bitfield_unit.set(75usize, 5u8, {
            let nose_type: u32 = unsafe { ::core::mem::transmute(nose_type) };
            nose_type as u64
        });
        __bindgen_bitfield_unit.set(80usize, 3u8, {
            let mouth_thickness: u32 = unsafe { ::core::mem::transmute(mouth_thickness) };
            mouth_thickness as u64
        });
        __bindgen_bitfield_unit.set(83usize, 4u8, {
            let mouth_scale: u32 = unsafe { ::core::mem::transmute(mouth_scale) };
            mouth_scale as u64
        });
        __bindgen_bitfield_unit.set(87usize, 3u8, {
            let mouth_color: u32 = unsafe { ::core::mem::transmute(mouth_color) };
            mouth_color as u64
        });
        __bindgen_bitfield_unit.set(90usize, 6u8, {
            let mouth_type: u32 = unsafe { ::core::mem::transmute(mouth_type) };
            mouth_type as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let unk_0x40: u32 = unsafe { ::core::mem::transmute(unk_0x40) };
            unk_0x40 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 3u8, {
            let mustache_type: u32 = unsafe { ::core::mem::transmute(mustache_type) };
            mustache_type as u64
        });
        __bindgen_bitfield_unit.set(107usize, 5u8, {
            let mouth_height: u32 = unsafe { ::core::mem::transmute(mouth_height) };
            mouth_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 6u8, {
            let mustache_height: u32 = unsafe { ::core::mem::transmute(mustache_height) };
            mustache_height as u64
        });
        __bindgen_bitfield_unit.set(118usize, 4u8, {
            let mustache_scale: u32 = unsafe { ::core::mem::transmute(mustache_scale) };
            mustache_scale as u64
        });
        __bindgen_bitfield_unit.set(122usize, 3u8, {
            let beard_color: u32 = unsafe { ::core::mem::transmute(beard_color) };
            beard_color as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let beard_type: u32 = unsafe { ::core::mem::transmute(beard_type) };
            beard_type as u64
        });
        __bindgen_bitfield_unit.set(128usize, 5u8, {
            let glass_height: u16 = unsafe { ::core::mem::transmute(glass_height) };
            glass_height as u64
        });
        __bindgen_bitfield_unit.set(133usize, 4u8, {
            let glass_scale: u16 = unsafe { ::core::mem::transmute(glass_scale) };
            glass_scale as u64
        });
        __bindgen_bitfield_unit.set(137usize, 3u8, {
            let glass_color: u16 = unsafe { ::core::mem::transmute(glass_color) };
            glass_color as u64
        });
        __bindgen_bitfield_unit.set(140usize, 4u8, {
            let glass_type: u16 = unsafe { ::core::mem::transmute(glass_type) };
            glass_type as u64
        });
        __bindgen_bitfield_unit.set(144usize, 1u8, {
            let unk_0x46_b0: u16 = unsafe { ::core::mem::transmute(unk_0x46_b0) };
            unk_0x46_b0 as u64
        });
        __bindgen_bitfield_unit.set(145usize, 5u8, {
            let mole_ypos: u16 = unsafe { ::core::mem::transmute(mole_ypos) };
            mole_ypos as u64
        });
        __bindgen_bitfield_unit.set(150usize, 5u8, {
            let mole_xpos: u16 = unsafe { ::core::mem::transmute(mole_xpos) };
            mole_xpos as u64
        });
        __bindgen_bitfield_unit.set(155usize, 4u8, {
            let mole_scale: u16 = unsafe { ::core::mem::transmute(mole_scale) };
            mole_scale as u64
        });
        __bindgen_bitfield_unit.set(159usize, 1u8, {
            let mole_enabled: u16 = unsafe { ::core::mem::transmute(mole_enabled) };
            mole_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataOfficial {
    pub core: FFLiMiiDataCore,
    pub creator_name: [u16; 10usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLStoreData {
    pub data: FFLiMiiDataOfficial,
    pub unk_0x5C: u16,
    pub checksum: u16,
}
pub mod OSEventMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EVENT_MODE_MANUAL: Type = 0;
    pub const OS_EVENT_MODE_AUTO: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSEvent {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk62: [::core::ffi::c_char; 4usize],
    pub value: BOOL,
    pub queue: OSThreadQueue,
    pub mode: OSEventMode::Type,
}
extern "C" {
    pub fn OSInitEvent(event: *mut OSEvent, value: BOOL, mode: OSEventMode::Type);
}
extern "C" {
    pub fn OSInitEventEx(
        event: *mut OSEvent,
        value: BOOL,
        mode: OSEventMode::Type,
        name: *mut ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSSignalEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSSignalEventAll(event: *mut OSEvent);
}
extern "C" {
    pub fn OSWaitEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSResetEvent(event: *mut OSEvent);
}
extern "C" {
    pub fn OSWaitEventWithTimeout(event: *mut OSEvent, timeout: OSTime) -> BOOL;
}
pub type SYSArgID = u32;
pub type SYSArgType = u32;
pub type SYSDeserializeCallback = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut SYSDeserializeArg, userArg: *mut ::core::ffi::c_void),
>;
pub mod SYSArgIDEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_ARG_ID_END: Type = 0;
    pub const SYS_ARG_ID_ANCHOR: Type = 100;
    pub const SYS_ARG_ID_RESULT: Type = 101;
    pub const SYS_ARG_ID_URL: Type = 200;
    pub const SYS_ARG_ID_MIV_DATA: Type = 300;
    pub const SYS_ARG_ID_JOIN_PID: Type = 400;
}
pub mod SYSArgTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_ARG_TYPE_UINT32: Type = 1;
    pub const SYS_ARG_TYPE_UINT64: Type = 2;
    pub const SYS_ARG_TYPE_DATA: Type = 3;
    pub const SYS_ARG_TYPE_STRING: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SYSArgDataBlock {
    pub id: SYSArgID,
    pub type_: SYSArgType,
    pub __bindgen_anon_1: SYSArgDataBlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSArgDataBlock__bindgen_ty_1 {
    pub uint32: u32,
    pub uint64: u64,
    pub data: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1,
    pub string: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2 {
    pub ptr: *const ::core::ffi::c_char,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCallerInfo {
    pub upid: u32,
    pub __unk63: [::core::ffi::c_char; 4usize],
    pub titleID: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSDeserializeArg {
    pub argName: *const ::core::ffi::c_char,
    pub size: u32,
    pub data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsOut {
    pub data: *const ::core::ffi::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsIn {
    pub argString: *const ::core::ffi::c_char,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgs {
    pub anchorData: *mut ::core::ffi::c_void,
    pub anchorSize: u32,
    pub resultData: *mut ::core::ffi::c_void,
    pub resultSize: u32,
}
extern "C" {
    pub fn SYSGetArguments(args: *mut SYSArgDataBlock, callerInfo: *mut SYSCallerInfo) -> i32;
}
extern "C" {
    pub fn SYSGetStandardArgs(stdArgs: *mut SYSStandardArgs) -> i32;
}
extern "C" {
    pub fn SYSClearSysArgs();
}
extern "C" {
    pub fn SYSPackArgs() -> i32;
}
extern "C" {
    pub fn SYSSerializeSysArgs(
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn SYSSerializeSysArgsToBuffer(
        buffer: *mut ::core::ffi::c_char,
        bytesWritten: *mut u32,
        bufferSize: u32,
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        dataSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn SYSDeserializeSysArgs(
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn SYSDeserializeSysArgsFromBlock(
        block: *mut ::core::ffi::c_void,
        blockSize: u32,
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn _SYSDirectlyReturnToCaller(arg: *mut SYSStandardArgsOut) -> i32;
}
extern "C" {
    pub fn _SYSSerializeStandardArgsIn(arg: *mut SYSStandardArgsIn) -> i32;
}
extern "C" {
    pub fn _SYSDeserializeStandardArg(
        deserializeArg: *mut SYSDeserializeArg,
        standardArg: *mut SYSStandardArgs,
    ) -> BOOL;
}
pub mod ACPResult {
    pub type Type = ::core::ffi::c_int;
    pub const ACP_RESULT_SUCCESS: Type = 0;
    pub const ACP_RESULT_INVALID: Type = -200;
    pub const ACP_RESULT_INVALID_PARAMETER: Type = -201;
    pub const ACP_RESULT_INVALID_FILE: Type = -202;
    pub const ACP_RESULT_INVALID_XML_FILE: Type = -203;
    pub const ACP_RESULT_FILE_ACCESS_MODE: Type = -204;
    pub const ACP_RESULT_INVALID_NETWORK_TIME: Type = -205;
    pub const ACP_RESULT_NOT_FOUND: Type = -500;
    pub const ACP_RESULT_FILE_NOT_FOUND: Type = -501;
    pub const ACP_RESULT_DIR_NOT_FOUND: Type = -502;
    pub const ACP_RESULT_DEVICE_NOT_FOUND: Type = -503;
    pub const ACP_RESULT_TITLE_NOT_FOUND: Type = -504;
    pub const ACP_RESULT_APPLICATION_NOT_FOUND: Type = -505;
    pub const ACP_RESULT_SYSTEM_CONFIG_NOT_FOUND: Type = -506;
    pub const ACP_RESULT_XML_ITEM_NOT_FOUND: Type = -507;
    pub const ACP_RESULT_ALREADY_EXISTS: Type = -600;
    pub const ACP_RESULT_FILE_ALREADY_EXISTS: Type = -601;
    pub const ACP_RESULT_DIR_ALREADY_EXISTS: Type = -602;
    pub const ACP_RESULT_ALREADY_DONE: Type = -700;
    pub const ACP_RESULT_AUTHENTICATION: Type = -1000;
    pub const ACP_RESULT_INVALID_REGION: Type = -1001;
    pub const ACP_RESULT_RESTRICTED_RATING: Type = -1002;
    pub const ACP_RESULT_NOT_PRESENT_RATING: Type = -1003;
    pub const ACP_RESULT_PENDING_RATING: Type = -1004;
    pub const ACP_RESULT_NET_SETTING_REQUIRED: Type = -1005;
    pub const ACP_RESULT_NET_ACCOUNT_REQUIRED: Type = -1006;
    pub const ACP_RESULT_NET_ACCOUNT_ERROR: Type = -1007;
    pub const ACP_RESULT_BROWSER_REQUIRED: Type = -1008;
    pub const ACP_RESULT_OLV_REQUIRED: Type = -1009;
    pub const ACP_RESULT_PINCODE_REQUIRED: Type = -1010;
    pub const ACP_RESULT_INCORRECT_PINCODE: Type = -1011;
    pub const ACP_RESULT_INVALID_LOGO: Type = -1012;
    pub const ACP_RESULT_DEMO_EXPIRED_NUMBER: Type = -1013;
    pub const ACP_RESULT_DRC_REQUIRED: Type = -1014;
    pub const ACP_RESULT_NO_PERMISSION: Type = -1100;
    pub const ACP_RESULT_NO_FILE_PERMISSION: Type = -1101;
    pub const ACP_RESULT_NO_DIR_PERMISSION: Type = -1102;
    pub const ACP_RESULT_BUSY: Type = -1300;
    pub const ACP_RESULT_USB_STORAGE_NOT_READY: Type = -1301;
    pub const ACP_RESULT_CANCELLED: Type = -1400;
    pub const ACP_RESULT_RESOURCE: Type = -1500;
    pub const ACP_RESULT_DEVICE_FULL: Type = -1501;
    pub const ACP_RESULT_JOURNAL_FULL: Type = -1502;
    pub const ACP_RESULT_SYSTEM_MEMORY: Type = -1503;
    pub const ACP_RESULT_FS_RESOURCE: Type = -1504;
    pub const ACP_RESULT_IPC_RESOURCE: Type = -1505;
    pub const ACP_RESULT_NOT_INITIALISED: Type = -1600;
    pub const ACP_RESULT_ACCOUNT_ERROR: Type = -1700;
    pub const ACP_RESULT_UNSUPPORTED: Type = -1800;
    pub const ACP_RESULT_DATA_CORRUPTED: Type = -2000;
    pub const ACP_RESULT_DEVICE: Type = -2001;
    pub const ACP_RESULT_SLC_DATA_CORRUPTED: Type = -2002;
    pub const ACP_RESULT_MLC_DATA_CORRUPTED: Type = -2003;
    pub const ACP_RESULT_USB_DATA_CORRUPTED: Type = -2004;
    pub const ACP_RESULT_MEDIA: Type = -2100;
    pub const ACP_RESULT_MEDIA_NOT_READY: Type = -2101;
    pub const ACP_RESULT_MEDIA_BROKEN: Type = -2102;
    pub const ACP_RESULT_ODD_MEDIA_NOT_READY: Type = -2103;
    pub const ACP_RESULT_ODD_MEDIA_BROKEN: Type = -2104;
    pub const ACP_RESULT_USB_MEDIA_NOT_READY: Type = -2105;
    pub const ACP_RESULT_USB_MEDIA_BROKEN: Type = -2106;
    pub const ACP_RESULT_MEDIA_WRITE_PROTECTED: Type = -2107;
    pub const ACP_RESULT_USB_WRITE_PROTECTED: Type = -2108;
    pub const ACP_RESULT_MII: Type = -2200;
    pub const ACP_RESULT_ENCRYPTION_ERROR: Type = -2201;
    pub const ACP_RESULT_GENERIC_ERROR: Type = -4096;
}
pub mod ACPDeviceType {
    pub type Type = ::core::ffi::c_uint;
    pub const ACP_DEVICE_TYPE_AUTO: Type = 1;
    pub const ACP_DEVICE_TYPE_ODD: Type = 2;
    pub const ACP_DEVICE_TYPE_HFIODISC: Type = 2;
    pub const ACP_DEVICE_TYPE_MLC: Type = 3;
    pub const ACP_DEVICE_TYPE_HFIOMLC: Type = 3;
    pub const ACP_DEVICE_TYPE_USB: Type = 4;
}
extern "C" {
    pub fn ACPCheckApplicationDeviceEmulation(emulation: *mut BOOL) -> ACPResult::Type;
}
pub type MCPError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDeviceList {
    _unused: [u8; 0],
}
pub mod MCPAppType {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_APP_TYPE_GAME_UPDATE: Type = 134217755;
    pub const MCP_APP_TYPE_GAME_DLC: Type = 134217742;
    pub const MCP_APP_TYPE_BOOT1: Type = 268435465;
    pub const MCP_APP_TYPE_SYSTEM_LIBRARIES: Type = 268435466;
    pub const MCP_APP_TYPE_BLUETOOTH_FIRMWARE: Type = 268435474;
    pub const MCP_APP_TYPE_DRC_FIRMWARE: Type = 268435475;
    pub const MCP_APP_TYPE_DRH_FIRMWARE: Type = 268435476;
    pub const MCP_APP_TYPE_SYSTEM_VERSION: Type = 268435477;
    pub const MCP_APP_TYPE_DRC_LANGUAGE: Type = 268435482;
    pub const MCP_APP_TYPE_EXCEPTIONS_DATA: Type = 402653200;
    pub const MCP_APP_TYPE_SHARED_DATA: Type = 402653212;
    pub const MCP_APP_TYPE_CERT_STORE: Type = 402653214;
    pub const MCP_APP_TYPE_PATCH_MAP_DATA: Type = 402653219;
    pub const MCP_APP_TYPE_WAGONU_MIGRATION_LIST: Type = 402653225;
    pub const MCP_APP_TYPE_CAFFEINE_TITLE_LIST: Type = 402653232;
    pub const MCP_APP_TYPE_MCP_TITLE_LIST: Type = 402653233;
    pub const MCP_APP_TYPE_GAME: Type = 2147483648;
    pub const MCP_APP_TYPE_GAME_WII: Type = 2147483694;
    pub const MCP_APP_TYPE_SYSTEM_MENU: Type = 2415919105;
    pub const MCP_APP_TYPE_SYSTEM_UPDATER: Type = 2415919115;
    pub const MCP_APP_TYPE_SYSTEM_APPS: Type = 2415919136;
    pub const MCP_APP_TYPE_ACCOUNT_APPS: Type = 2415919137;
    pub const MCP_APP_TYPE_SYSTEM_SETTINGS: Type = 2415919138;
    pub const MCP_APP_TYPE_ECO_PROCESS: Type = 2415919151;
    pub const MCP_APP_TYPE_EMANUAL: Type = 3489660931;
    pub const MCP_APP_TYPE_HOME_MENU: Type = 3489660932;
    pub const MCP_APP_TYPE_ERROR_DISPLAY: Type = 3489660933;
    pub const MCP_APP_TYPE_BROWSER: Type = 3489660934;
    pub const MCP_APP_TYPE_MIIVERSE_POST: Type = 3489660941;
    pub const MCP_APP_TYPE_MIIVERSE: Type = 3489660950;
    pub const MCP_APP_TYPE_ESHOP: Type = 3489660951;
    pub const MCP_APP_TYPE_FRIEND_LIST: Type = 3489660952;
    pub const MCP_APP_TYPE_DOWNLOAD_MANAGEMENT: Type = 3489660953;
    pub const MCP_APP_TYPE_AOC_OVERLAY: Type = 3489660972;
    pub const MCP_APP_TYPE_AMIIBO_SETTINGS: Type = 3489660979;
}
pub mod MCPDeviceType {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_DEVICE_TYPE_AUTO: Type = 1;
    pub const MCP_DEVICE_TYPE_ODD: Type = 2;
    pub const MCP_DEVICE_TYPE_MLC: Type = 3;
    pub const MCP_DEVICE_TYPE_USB: Type = 4;
}
pub mod MCPDeviceFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_DEVICE_FLAG_UNK_1: Type = 1;
    pub const MCP_DEVICE_FLAG_UNK_2: Type = 2;
    pub const MCP_DEVICE_FLAG_UNK_4: Type = 4;
    pub const MCP_DEVICE_FLAG_UNK_8: Type = 8;
}
pub mod MCPInstallTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_INSTALL_TARGET_MLC: Type = 0;
    pub const MCP_INSTALL_TARGET_USB: Type = 1;
}
pub mod MCPRegion {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_REGION_JAPAN: Type = 1;
    pub const MCP_REGION_USA: Type = 2;
    pub const MCP_REGION_EUROPE: Type = 4;
    pub const MCP_REGION_CHINA: Type = 16;
    pub const MCP_REGION_KOREA: Type = 32;
    pub const MCP_REGION_TAIWAN: Type = 64;
}
pub mod MCPCompatAVFile {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_COMPAT_AV_FILE_DMCU: Type = 0;
    pub const MCP_COMPAT_AV_FILE_DEINT: Type = 1;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDevice {
    pub type_: [::core::ffi::c_char; 8usize],
    pub unk0x08: [::core::ffi::c_char; 128usize],
    pub filesystem: [::core::ffi::c_char; 8usize],
    pub path: [::core::ffi::c_char; 639usize],
    pub flags: MCPDeviceFlags::Type,
    pub uid: u32,
    pub index: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallInfo {
    pub __unk64: [::core::ffi::c_char; 639usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallProgress {
    pub inProgress: u32,
    pub tid: u64,
    pub sizeTotal: u64,
    pub sizeProgress: u64,
    pub contentsTotal: u32,
    pub contentsProgress: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallTitleInfo {
    pub __unk65: [::core::ffi::c_char; 639usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPSysProdSettings {
    pub product_area: MCPRegion::Type,
    pub eeprom_version: u16,
    pub __unk66: [::core::ffi::c_char; 2usize],
    pub game_region: MCPRegion::Type,
    pub __unk67: [::core::ffi::c_char; 4usize],
    pub ntsc_pal: [::core::ffi::c_char; 5usize],
    pub wifi_5ghz_country_code: [::core::ffi::c_char; 4usize],
    pub wifi_5ghz_country_code_revision: u8,
    pub code_id: [::core::ffi::c_char; 8usize],
    pub serial_id: [::core::ffi::c_char; 12usize],
    pub __unk68: [::core::ffi::c_char; 4usize],
    pub model_number: [::core::ffi::c_char; 16usize],
    pub version: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPSystemVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub region: ::core::ffi::c_char,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPTitleListType {
    pub titleId: u64,
    pub groupId: u32,
    pub path: [::core::ffi::c_char; 56usize],
    pub appType: MCPAppType::Type,
    pub titleVersion: u16,
    pub osVersion: u64,
    pub sdkVersion: u32,
    pub indexedDevice: [::core::ffi::c_char; 10usize],
    pub unk0x60: u8,
}
extern "C" {
    pub fn MCP_Open() -> MCPError;
}
extern "C" {
    pub fn MCP_Close(handle: ::core::ffi::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_DeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_FullDeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_GetOwnTitleInfo(handle: i32, titleInfo: *mut MCPTitleListType) -> MCPError;
}
extern "C" {
    pub fn MCP_GetSysProdSettings(handle: i32, settings: *mut MCPSysProdSettings) -> MCPError;
}
extern "C" {
    pub fn MCP_GetSystemVersion(handle: i32, systemVersion: *mut MCPSystemVersion) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleId(handle: i32, outTitleId: *mut u64) -> MCPError;
}
extern "C" {
    pub fn MCP_GetTitleInfo(
        handle: i32,
        titleId: u64,
        titleInfo: *mut MCPTitleListType,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetDevice(
        handle: ::core::ffi::c_int,
        device: MCPInstallTarget::Type,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetTargetDevice(
        handle: ::core::ffi::c_int,
        deviceOut: *mut MCPInstallTarget::Type,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallSetTargetUsb(handle: ::core::ffi::c_int, usb: ::core::ffi::c_int)
        -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetInfo(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAsync(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallGetProgress(
        handle: ::core::ffi::c_int,
        installProgressOut: *mut MCPInstallProgress,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_InstallTitleAbort(handle: ::core::ffi::c_int) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleCount(handle: i32) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleList(
        handle: i32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppType(
        handle: i32,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueId(
        handle: i32,
        uniqueId: u32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByDevice(
        handle: i32,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByDeviceType(
        handle: i32,
        deviceType: MCPDeviceType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppAndDevice(
        handle: i32,
        appType: MCPAppType::Type,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByAppAndDeviceType(
        handle: i32,
        appType: MCPAppType::Type,
        deviceType: MCPDeviceType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TitleListByUniqueIdAndIndexedDeviceAndAppType(
        handle: i32,
        uniqueId: u32,
        indexedDevice: *const ::core::ffi::c_char,
        unk0x60: u8,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_UninstallTitleAsync(
        handle: i32,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_CompatLoadAVFile(
        handle: i32,
        ptr: *mut ::core::ffi::c_void,
        size: *mut u32,
        file: MCPCompatAVFile::Type,
    ) -> MCPError;
}
extern "C" {
    pub fn MCP_TriggerCrashLogCollection(handle: i32) -> MCPError;
}
extern "C" {
    pub fn MCP_ChangeEcoSettings(
        handle: i32,
        enable: u32,
        maxOnTime: u32,
        defaultOffTime: u16,
    ) -> MCPError;
}
pub type ACPTitleId = u64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPMetaXml {
    pub title_id: u64,
    pub boss_id: u64,
    pub os_version: u64,
    pub app_size: u64,
    pub common_save_size: u64,
    pub account_save_size: u64,
    pub common_boss_size: u64,
    pub account_boss_size: u64,
    pub join_game_mode_mask: u64,
    pub version: u32,
    pub product_code: [::core::ffi::c_char; 32usize],
    pub content_platform: [::core::ffi::c_char; 32usize],
    pub company_code: [::core::ffi::c_char; 8usize],
    pub mastering_date: [::core::ffi::c_char; 32usize],
    pub logo_type: u32,
    pub app_launch_type: u32,
    pub invisible_flag: u32,
    pub no_managed_flag: u32,
    pub no_event_log: u32,
    pub no_icon_database: u32,
    pub launching_flag: u32,
    pub install_flag: u32,
    pub closing_msg: u32,
    pub title_version: u32,
    pub group_id: u32,
    pub save_no_rollback: u32,
    pub bg_daemon_enable: u32,
    pub join_game_id: u32,
    pub olv_accesskey: u32,
    pub wood_tin: u32,
    pub e_manual: u32,
    pub e_manual_version: u32,
    pub region: u32,
    pub pc_cero: u32,
    pub pc_esrb: u32,
    pub pc_bbfc: u32,
    pub pc_usk: u32,
    pub pc_pegi_gen: u32,
    pub pc_pegi_fin: u32,
    pub pc_pegi_prt: u32,
    pub pc_pegi_bbfc: u32,
    pub pc_cob: u32,
    pub pc_grb: u32,
    pub pc_cgsrr: u32,
    pub pc_oflc: u32,
    pub pc_reserved0: u32,
    pub pc_reserved1: u32,
    pub pc_reserved2: u32,
    pub pc_reserved3: u32,
    pub ext_dev_nunchaku: u32,
    pub ext_dev_classic: u32,
    pub ext_dev_urcc: u32,
    pub ext_dev_board: u32,
    pub ext_dev_usb_keyboard: u32,
    pub ext_dev_etc: u32,
    pub ext_dev_etc_name: [::core::ffi::c_char; 512usize],
    pub eula_version: u32,
    pub drc_use: u32,
    pub network_use: u32,
    pub online_account_use: u32,
    pub direct_boot: u32,
    pub reserved_flag0: u32,
    pub reserved_flag1: u32,
    pub reserved_flag2: u32,
    pub reserved_flag3: u32,
    pub reserved_flag4: u32,
    pub reserved_flag5: u32,
    pub reserved_flag6: u32,
    pub reserved_flag7: u32,
    pub longname_ja: [::core::ffi::c_char; 512usize],
    pub longname_en: [::core::ffi::c_char; 512usize],
    pub longname_fr: [::core::ffi::c_char; 512usize],
    pub longname_de: [::core::ffi::c_char; 512usize],
    pub longname_it: [::core::ffi::c_char; 512usize],
    pub longname_es: [::core::ffi::c_char; 512usize],
    pub longname_zhs: [::core::ffi::c_char; 512usize],
    pub longname_ko: [::core::ffi::c_char; 512usize],
    pub longname_nl: [::core::ffi::c_char; 512usize],
    pub longname_pt: [::core::ffi::c_char; 512usize],
    pub longname_ru: [::core::ffi::c_char; 512usize],
    pub longname_zht: [::core::ffi::c_char; 512usize],
    pub shortname_ja: [::core::ffi::c_char; 256usize],
    pub shortname_en: [::core::ffi::c_char; 256usize],
    pub shortname_fr: [::core::ffi::c_char; 256usize],
    pub shortname_de: [::core::ffi::c_char; 256usize],
    pub shortname_it: [::core::ffi::c_char; 256usize],
    pub shortname_es: [::core::ffi::c_char; 256usize],
    pub shortname_zhs: [::core::ffi::c_char; 256usize],
    pub shortname_ko: [::core::ffi::c_char; 256usize],
    pub shortname_nl: [::core::ffi::c_char; 256usize],
    pub shortname_pt: [::core::ffi::c_char; 256usize],
    pub shortname_ru: [::core::ffi::c_char; 256usize],
    pub shortname_zht: [::core::ffi::c_char; 256usize],
    pub publisher_ja: [::core::ffi::c_char; 256usize],
    pub publisher_en: [::core::ffi::c_char; 256usize],
    pub publisher_fr: [::core::ffi::c_char; 256usize],
    pub publisher_de: [::core::ffi::c_char; 256usize],
    pub publisher_it: [::core::ffi::c_char; 256usize],
    pub publisher_es: [::core::ffi::c_char; 256usize],
    pub publisher_zhs: [::core::ffi::c_char; 256usize],
    pub publisher_ko: [::core::ffi::c_char; 256usize],
    pub publisher_nl: [::core::ffi::c_char; 256usize],
    pub publisher_pt: [::core::ffi::c_char; 256usize],
    pub publisher_ru: [::core::ffi::c_char; 256usize],
    pub publisher_zht: [::core::ffi::c_char; 256usize],
    pub add_on_unique_id: [u32; 32usize],
    pub __unk69: [::core::ffi::c_char; 52usize],
}
extern "C" {
    pub fn ACPAssignTitlePatch(titleInfo: *mut MCPTitleListType) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleIdOfMainApplication(titleId: *mut ACPTitleId) -> ACPResult::Type;
}
extern "C" {
    pub fn __rplwrap_ACPGetTitleMetaXml(
        titleId: ACPTitleId,
        metaXml: *mut ACPMetaXml,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn __rplwrap_ACPGetTitleSaveMetaXml(
        titleId: u64,
        metaXml: *mut ACPMetaXml,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleMetaDir(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleMetaDirByDevice(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleMetaDirByTitleListType(
        titleListType: MCPTitleListType,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult::Type;
}
pub type ACPDrcLedStatus = u8;
pub type ACPDrcLedPattern = u32;
extern "C" {
    pub fn ACPDrcLedStartTest();
}
extern "C" {
    pub fn ACPDrcLedStopTest();
}
extern "C" {
    pub fn ACPGetDrcLedStat(ledStatus: *mut ACPDrcLedStatus);
}
extern "C" {
    pub fn ACPGetDrcLedStatusOfPattern(ledStatus: *mut ACPDrcLedStatus, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPSetDrcLedDummyPowerStat(unk1: u8);
}
extern "C" {
    pub fn ACPSetDrcLedTimerLength(unk1: u64, unk2: u64);
}
extern "C" {
    pub fn ACPSetDrcLedTimerSpeed(speed: u32);
}
extern "C" {
    pub fn ACPTurnOffDrcLed();
}
extern "C" {
    pub fn ACPTurnOffDrcLedTest(unk1: u8);
}
extern "C" {
    pub fn ACPTurnOnDrcLed(unk1: u32, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPTurnOnDrcLedTest(unk1: u8, unk2: u32, pattern: ACPDrcLedPattern);
}
extern "C" {
    pub fn ACPInitialize();
}
extern "C" {
    pub fn ACPFinalize();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPSaveDirInfo {
    pub __unk70: [::core::ffi::c_char; 8usize],
    pub persistentId: u32,
    pub __unk71: [::core::ffi::c_char; 20usize],
    pub path: [::core::ffi::c_char; 64usize],
    pub __unk72: [::core::ffi::c_char; 32usize],
}
extern "C" {
    pub fn ACPCreateSaveDir(persistentId: u32, deviceType: ACPDeviceType::Type) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPIsExternalStorageRequired(required: *mut BOOL) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPMountExternalStorage() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPMountSaveDir() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPRemoveSaveDir(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPRemoveSaveDirWithoutFlush(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPRemoveSaveDirWithoutMetaCheck(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPRepairSaveMetaDir() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPUnmountExternalStorage() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPUnmountSaveDir() -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetSaveDataTitleIdList(
        deviceType: ACPDeviceType::Type,
        titlesOut: *mut u64,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleSaveDirEx(
        titleId: u64,
        deviceType: ACPDeviceType::Type,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
}
extern "C" {
    pub fn ACPGetTitleSaveDirExWithoutMetaCheck(
        titleId: u64,
        deviceType: ACPDeviceType::Type,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
}
pub mod HPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_CHAN_0: Type = 0;
    pub const HPAD_CHAN_1: Type = 1;
    pub const HPAD_CHAN_2: Type = 2;
    pub const HPAD_CHAN_3: Type = 3;
    pub const HPAD_CHAN_4: Type = 4;
    pub const HPAD_CHAN_5: Type = 5;
    pub const HPAD_CHAN_6: Type = 6;
    pub const HPAD_CHAN_7: Type = 7;
}
pub mod HPADGGGGChan {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_GGGG_CHAN_0: Type = 0;
    pub const HPAD_GGGG_CHAN_1: Type = 1;
}
pub mod HPADButtons {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_BUTTON_A: Type = 1;
    pub const HPAD_BUTTON_B: Type = 2;
    pub const HPAD_BUTTON_X: Type = 4;
    pub const HPAD_BUTTON_Y: Type = 8;
    pub const HPAD_BUTTON_LEFT: Type = 16;
    pub const HPAD_BUTTON_RIGHT: Type = 32;
    pub const HPAD_BUTTON_DOWN: Type = 64;
    pub const HPAD_BUTTON_UP: Type = 128;
    pub const HPAD_BUTTON_START: Type = 256;
    pub const HPAD_TRIGGER_Z: Type = 512;
    pub const HPAD_TRIGGER_R: Type = 1024;
    pub const HPAD_TRIGGER_L: Type = 2048;
    pub const HPAD_STICK_EMULATION_LEFT: Type = 4096;
    pub const HPAD_STICK_EMULATION_RIGHT: Type = 8192;
    pub const HPAD_STICK_EMULATION_DOWN: Type = 16384;
    pub const HPAD_STICK_EMULATION_UP: Type = 32768;
    pub const HPAD_SUBSTICK_EMULATION_LEFT: Type = 65536;
    pub const HPAD_SUBSTICK_EMULATION_RIGHT: Type = 131072;
    pub const HPAD_SUBSTICK_EMULATION_DOWN: Type = 262144;
    pub const HPAD_SUBSTICK_EMULATION_UP: Type = 524288;
}
pub mod HPADMotorCommand {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_MOTOR_COMMAND_STOP: Type = 0;
    pub const HPAD_MOTOR_COMMAND_RUMBLE: Type = 1;
    pub const HPAD_MOTOR_COMMAND_STOP_HARD: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPADStatus {
    pub hold: i32,
    pub trigger: i32,
    pub release: i32,
    pub stickX: i8,
    pub stickY: i8,
    pub substickX: i8,
    pub substickY: i8,
    pub triggerL: u8,
    pub triggerR: u8,
    pub status: u8,
    pub __unk73: [::core::ffi::c_char; 1usize],
    pub error: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPADGGGGStatus {
    pub connected: BOOL,
    pub powerSupplyConnected: BOOL,
    pub active: BOOL,
}
pub type HPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADChan::Type, status: i32)>;
pub type HPADGGGGConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, connected: BOOL)>;
pub type HPADPowerSupplyCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, connected: BOOL)>;
pub type HPADSamplingCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type)>;
pub type HPADResetCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, status: i32)>;
extern "C" {
    pub fn HPADInit() -> i32;
}
extern "C" {
    pub fn HPADShutdown() -> i32;
}
extern "C" {
    pub fn __rplwrap_HPADRead(chan: HPADChan::Type, buffers: *mut HPADStatus, count: i32) -> i32;
}
extern "C" {
    pub fn HPADControlMotor(chan: HPADChan::Type, command: HPADMotorCommand::Type) -> i32;
}
extern "C" {
    pub fn HPADRecalibrate(chan: HPADChan::Type) -> i32;
}
extern "C" {
    pub fn HPADSetConnectCallback(
        chan: HPADChan::Type,
        callback: HPADConnectCallback,
    ) -> HPADConnectCallback;
}
extern "C" {
    pub fn HPADGetGGGGStatus(chan: HPADGGGGChan::Type, status: *mut HPADGGGGStatus) -> i32;
}
extern "C" {
    pub fn HPADSetGgggConnectCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADGGGGConnectCallback,
    ) -> HPADGGGGConnectCallback;
}
extern "C" {
    pub fn HPADSetPowerSupplyCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADPowerSupplyCallback,
    ) -> HPADPowerSupplyCallback;
}
extern "C" {
    pub fn HPADSetSamplingCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADSamplingCallback,
    ) -> HPADSamplingCallback;
}
extern "C" {
    pub fn HPADResetDevice(chan: HPADGGGGChan::Type, callback: HPADResetCallback) -> i32;
}
extern "C" {
    pub fn BETA_DEBUG_DUMP();
}
extern "C" {
    pub fn BETA_DEBUG_GET_QUEUE_SIZE(chan: HPADGGGGChan::Type) -> i32;
}
extern "C" {
    pub fn BETA_DEBUG_SEND_REPT_ID(chan: HPADGGGGChan::Type, reptId: u32);
}
extern "C" {
    pub fn BETA_DEBUG_GET_RAW_DATA();
}
extern "C" {
    pub fn BETA_DEBUG_SET_DUMP_MODE();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct OSSpinLock {
    pub owner: u32,
    pub __unk74: [::core::ffi::c_char; 4usize],
    pub recursion: u32,
    pub __unk75: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn OSInitSpinLock(spinlock: *mut OSSpinLock);
}
extern "C" {
    pub fn OSAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSTryAcquireSpinLockWithTimeout(spinlock: *mut OSSpinLock, timeout: OSTime) -> BOOL;
}
extern "C" {
    pub fn OSReleaseSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Acquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquire(spinlock: *mut OSSpinLock) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_TryAcquireWithTimeout(
        spinlock: *mut OSSpinLock,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn OSUninterruptibleSpinLock_Release(spinlock: *mut OSSpinLock) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryLink {
    pub prev: *mut ::core::ffi::c_void,
    pub next: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryList {
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
    pub count: u16,
    pub offsetToMemoryLink: u16,
}
extern "C" {
    pub fn MEMInitList(list: *mut MEMMemoryList, offsetToMemoryLink: u16);
}
extern "C" {
    pub fn MEMAppendListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMPrependListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMInsertListObject(
        list: *mut MEMMemoryList,
        before: *mut ::core::ffi::c_void,
        object: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn MEMRemoveListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MEMGetNextListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MEMGetPrevListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MEMGetNthListObject(list: *mut MEMMemoryList, n: u16) -> *mut ::core::ffi::c_void;
}
pub type MEMHeapHandle = *mut MEMHeapHeader;
pub mod MEMBaseHeapType {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_BASE_HEAP_MEM1: Type = 0;
    pub const MEM_BASE_HEAP_MEM2: Type = 1;
    pub const MEM_BASE_HEAP_FG: Type = 8;
}
pub mod MEMHeapFillType {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_HEAP_FILL_TYPE_UNUSED: Type = 0;
    pub const MEM_HEAP_FILL_TYPE_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FILL_TYPE_FREED: Type = 2;
}
pub mod MEMHeapTag {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_BLOCK_HEAP_TAG: Type = 1112296264;
    pub const MEM_EXPANDED_HEAP_TAG: Type = 1163415624;
    pub const MEM_FRAME_HEAP_TAG: Type = 1179798856;
    pub const MEM_UNIT_HEAP_TAG: Type = 1431196744;
    pub const MEM_USER_HEAP_TAG: Type = 1431523912;
}
pub mod MEMHeapFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_HEAP_FLAG_ZERO_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FLAG_DEBUG_MODE: Type = 2;
    pub const MEM_HEAP_FLAG_USE_LOCK: Type = 4;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MEMHeapHeader {
    pub tag: MEMHeapTag::Type,
    pub link: MEMMemoryLink,
    pub list: MEMMemoryList,
    pub dataStart: *mut ::core::ffi::c_void,
    pub dataEnd: *mut ::core::ffi::c_void,
    pub lock: OSSpinLock,
    pub flags: u32,
    pub __unk76: [::core::ffi::c_char; 12usize],
}
extern "C" {
    pub fn MEMGetArena(handle: MEMHeapHandle) -> MEMBaseHeapType::Type;
}
extern "C" {
    pub fn MEMGetBaseHeapHandle(type_: MEMBaseHeapType::Type) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMSetBaseHeapHandle(
        type_: MEMBaseHeapType::Type,
        handle: MEMHeapHandle,
    ) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMCreateUserHeapHandle(heap: *mut ::core::ffi::c_void, size: u32) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMDumpHeap(heap: MEMHeapHandle);
}
extern "C" {
    pub fn MEMFindContainHeap(block: *mut ::core::ffi::c_void) -> *mut MEMHeapHeader;
}
extern "C" {
    pub fn MEMFindParentHeap(handle: MEMHeapHandle) -> MEMHeapHandle;
}
extern "C" {
    pub fn MEMGetFillValForHeap(type_: MEMHeapFillType::Type) -> u32;
}
extern "C" {
    pub fn MEMSetFillValForHeap(type_: MEMHeapFillType::Type, value: u32);
}
extern "C" {
    pub fn MEMCheckHeap(handle: MEMHeapHandle) -> BOOL;
}
pub type MEMAllocFromDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut ::core::ffi::c_void>;
pub type MEMAllocFromDefaultHeapExFn = ::core::option::Option<
    unsafe extern "C" fn(size: u32, alignment: i32) -> *mut ::core::ffi::c_void,
>;
pub type MEMFreeToDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>;
extern "C" {
    pub static mut MEMAllocFromDefaultHeap: MEMAllocFromDefaultHeapFn;
}
extern "C" {
    pub static mut MEMAllocFromDefaultHeapEx: MEMAllocFromDefaultHeapExFn;
}
extern "C" {
    pub static mut MEMFreeToDefaultHeap: MEMFreeToDefaultHeapFn;
}
extern "C" {
    pub fn CoreInitDefaultHeap(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
extern "C" {
    pub fn __preinit_user(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
}
pub type ACConfigId = u32;
extern "C" {
    pub fn ACInitialize() -> NNResult;
}
extern "C" {
    pub fn ACFinalize();
}
extern "C" {
    pub fn ACConnect() -> NNResult;
}
extern "C" {
    pub fn ACConnectAsync() -> NNResult;
}
extern "C" {
    pub fn ACClose() -> NNResult;
}
extern "C" {
    pub fn ACGetCloseStatus() -> NNResult;
}
extern "C" {
    pub fn ACIsApplicationConnected(connected: *mut BOOL) -> NNResult;
}
extern "C" {
    pub fn ACGetStartupId(configId: *mut ACConfigId) -> NNResult;
}
extern "C" {
    pub fn ACConnectWithConfigId(configId: ACConfigId) -> NNResult;
}
extern "C" {
    pub fn ACGetAssignedAddress(ip: *mut u32) -> NNResult;
}
pub mod CCRSysPairingState {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_PAIRING_FINISHED: Type = 0;
    pub const CCR_SYS_PAIRING_IN_PROGRESS: Type = 1;
    pub const CCR_SYS_PAIRING_TIMED_OUT: Type = 2;
}
pub mod CCRSysInitBootFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_BOOT_FLAG_NONE: Type = 0;
    pub const CCR_SYS_BOOT_FLAG_FIRST_BOOT: Type = 1;
}
pub mod CCRSysLCDMode {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_1: Type = 1;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_2: Type = 2;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_3: Type = 3;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_4: Type = 4;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_5: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRSysUpdateState {
    pub state: u32,
    pub progress: u32,
}
extern "C" {
    pub fn CCRSysInit();
}
extern "C" {
    pub fn CCRSysExit();
}
extern "C" {
    pub fn CCRSysDRCShutdown() -> i32;
}
extern "C" {
    pub fn CCRSysInvalidatePairing() -> i32;
}
extern "C" {
    pub fn __CCRSysDRCIsAttached(drcSlot: u32) -> BOOL;
}
extern "C" {
    pub fn CCRSysStartPairing(drcSlot: u32, timeout: u32) -> i32;
}
extern "C" {
    pub fn CCRSysStopPairing() -> i32;
}
extern "C" {
    pub fn CCRSysGetPairingState() -> CCRSysPairingState::Type;
}
extern "C" {
    pub fn CCRSysGetPincode(pin: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetSystemTime(time: OSTime) -> i32;
}
extern "C" {
    pub fn CCRSysNeedsDRCFWUpdate(drcSlot: u32, outNeedsUpdate: *mut BOOL) -> i32;
}
extern "C" {
    pub fn __CCRSysNeedsDRCFWUpdate(
        drcSlot: u32,
        outNeedsUpdate: *mut BOOL,
        allowDowngrade: BOOL,
    ) -> i32;
}
extern "C" {
    pub fn CCRSysDRCFWUpdate(drcSlot: u32) -> i32;
}
extern "C" {
    pub fn __CCRSysDRCFWUpdate(drcSlot: u32, allowDowngrade: BOOL) -> i32;
}
extern "C" {
    pub fn CCRSysDRCFWUpdateForward();
}
extern "C" {
    pub fn CCRSysGetUpdateState(outUpdateState: *mut CCRSysUpdateState);
}
extern "C" {
    pub fn __CCRSysInitReattach(drcSlot: u32);
}
extern "C" {
    pub fn __CCRSysWaitReattach(drcSlot: u32, unknown: BOOL) -> i32;
}
extern "C" {
    pub fn CCRSysGetVersionCheckFlag(outFlag: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetVersionCheckFlag(flag: u32) -> i32;
}
extern "C" {
    pub fn CCRSysCaffeineSetCaffeineSlot(slot: u32) -> i32;
}
extern "C" {
    pub fn CCRSysSetInitBootFlag(flag: CCRSysInitBootFlag::Type) -> i32;
}
extern "C" {
    pub fn CCRSysInitializeSettings() -> i32;
}
extern "C" {
    pub fn CCRSysSetCurrentLCDMode(mode: CCRSysLCDMode::Type) -> i32;
}
extern "C" {
    pub fn CCRSysGetCurrentLCDMode(mode: *mut CCRSysLCDMode::Type) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRAppLaunchParam {
    pub launchInfoDatabaseEntryId: u64,
    pub uuid: [::core::ffi::c_char; 16usize],
    pub __unk77: [::core::ffi::c_char; 231usize],
}
extern "C" {
    pub fn CCRSysCaffeineGetAppLaunchParam(data: *mut CCRAppLaunchParam);
}
extern "C" {
    pub fn CCRSysCaffeineBootCheck() -> u32;
}
extern "C" {
    pub fn CCRSysCaffeineBootCheckAbort();
}
extern "C" {
    pub fn CCRSysCaffeineSetDRCEnableFlag(enabled: i32) -> i32;
}
extern "C" {
    pub fn CCRSysCaffeineSetEnableFlag(enabled: i32) -> i32;
}
pub mod TEMPTargetPreference {
    pub type Type = ::core::ffi::c_uint;
    pub const TEMP_PREF_DEFAULT: Type = 0;
    pub const TEMP_PREF_USB: Type = 1;
}
pub type TEMPDirId = u64;
extern "C" {
    pub fn TEMPInit() -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPShutdown();
}
extern "C" {
    pub fn TEMPCreateAndInitTempDir(
        maxSize: u32,
        pref: TEMPTargetPreference::Type,
        outDir: *mut TEMPDirId,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPShutdownTempDir(tempId: TEMPDirId) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetDirGlobalPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetDirPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPChangeOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPChangeOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPMountTempDir(dirId: TEMPDirId) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPUnmountTempDir(dirId: TEMPDirId) -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenNewFile() -> FSStatus::Type;
}
extern "C" {
    pub fn TEMPOpenNewFileAsync() -> FSStatus::Type;
}
extern "C" {
    pub fn PDMInitialize() -> u32;
}
extern "C" {
    pub fn PDMFinalize();
}
extern "C" {
    pub fn PDMCloseAllFiles();
}
extern "C" {
    pub fn PDMNotifySetTimeBeginEvent();
}
extern "C" {
    pub fn PDMNotifySetTimeEndEvent();
}
pub mod SAVEStatus {
    pub type Type = ::core::ffi::c_int;
    pub const SAVE_STATUS_OK: Type = 0;
    pub const SAVE_STATUS_NOT_FOUND: Type = -6;
    pub const SAVE_STATUS_STORAGE_FULL: Type = -12;
}
extern "C" {
    pub fn SAVEInit() -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEShutdown();
}
extern "C" {
    pub fn SAVEInitSaveDir(slotNo: u8) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEInitCommonSaveDir() -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEInitAccountSaveDir(slotNo: u8) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEInitNoDeleteGroupSaveDir();
}
extern "C" {
    pub fn SAVEUpdateSaveDir() -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEChangeGroupAndOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEChangeGroupAndOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEChangeGroupMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEChangeGroupModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVECheckSaveDirRequiredUpdate(
        unk1: *mut ::core::ffi::c_int,
        unk2: *mut u64,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEFlushQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEFlushQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut i64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetFreeSpaceSizeOfDevice(deviceType: ACPDeviceType::Type) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEGetNoDeleteGroupSaveDirPath(
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEGetNoDeleteSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEGetSharedDataTitlePath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEGetSharedSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEGetStatOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEInitSaveDirByAppMeta(
        slotNo: u8,
        metaXmlPath: *const ::core::ffi::c_char,
        metaXmlBuffer: *mut u8,
        metaXmlBufferSize: u32,
        iconPath: *const ::core::ffi::c_char,
        iconBuffer: *mut u8,
        iconBufferSize: u32,
    ) -> SAVEStatus::Type;
}
extern "C" {
    pub fn SAVEMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenDirOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVEOpenFileOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERollbackQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
}
extern "C" {
    pub fn SAVERollbackQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
}
pub mod CmptScreenType {
    pub type Type = ::core::ffi::c_uint;
    pub const CMPT_SCREEN_TYPE_TV: Type = 1;
    pub const CMPT_SCREEN_TYPE_DRC: Type = 2;
    pub const CMPT_SCREEN_TYPE_BOTH: Type = 3;
}
extern "C" {
    pub fn CMPTGetDataSize(outSize: *mut u32) -> i32;
}
extern "C" {
    pub fn CMPTLaunchTitle(
        dataBuffer: *mut ::core::ffi::c_void,
        bufferSize: u32,
        titleId: u64,
    ) -> i32;
}
extern "C" {
    pub fn CMPTLaunchMenu(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
}
extern "C" {
    pub fn CMPTLaunchDataManager(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
}
extern "C" {
    pub fn CMPTAcctSetScreenType(type_: CmptScreenType::Type) -> i32;
}
extern "C" {
    pub fn CMPTCheckScreenState() -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEManualArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub titleId: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEShopArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub query: *mut ::core::ffi::c_char,
    pub querySize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub url: *mut ::core::ffi::c_char,
    pub urlSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgsWithCallback {
    pub browserArgs: SysAppBrowserArgs,
    pub cbUrl: *mut ::core::ffi::c_char,
    pub cbUrlSize: u32,
    pub hbmDisable: BOOL,
}
pub mod SysAppPFID {
    pub type Type = ::core::ffi::c_uint;
    pub const SYSAPP_PFID_WII_U_MENU: Type = 2;
    pub const SYSAPP_PFID_TVII: Type = 3;
    pub const SYSAPP_PFID_EMANUAL: Type = 4;
    pub const SYSAPP_PFID_HOME_MENU: Type = 5;
    pub const SYSAPP_PFID_MINI_MIIVERSE: Type = 7;
    pub const SYSAPP_PFID_BROWSER: Type = 8;
    pub const SYSAPP_PFID_MIIVERSE: Type = 9;
    pub const SYSAPP_PFID_ESHOP: Type = 10;
    pub const SYSAPP_PFID_FRIENDLIST: Type = 11;
    pub const SYSAPP_PFID_DOWNLOAD_MANAGEMENT: Type = 12;
    pub const SYSAPP_PFID_DOWNLOAD_GAME: Type = 15;
    pub const SYSAPP_PFID_MINTU: Type = 16;
    pub const SYSAPP_PFID_CABINETU: Type = 17;
    pub const SYSAPP_PFID_TEST_OVERLAY: Type = 31;
}
extern "C" {
    pub fn SYSSwitchToSyncControllerOnHBM() -> i32;
}
extern "C" {
    pub fn SYSSwitchToEManual() -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEManual(arg1: *mut SysAppEManualArgs) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEManualFromHBM(arg1: *mut SysAppEManualArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToEShop(arg1: *mut SysAppEShopArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToEShopTicketList(arg1: *mut SYSStandardArgsIn) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToEShopFromHBM(arg1: *mut SysAppEShopArgs) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToMainApp() -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowser(arg1: *mut SysAppBrowserArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowserForViewer(arg1: *mut SysAppBrowserArgs) -> i32;
}
extern "C" {
    pub fn SYSSwitchToBrowserForCallbackURL(arg1: *mut SysAppBrowserArgsWithCallback) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToBrowserForCallbackURLFromHBM(
        arg1: *mut SysAppBrowserArgsWithCallback,
    ) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToHBMWithMode(arg1: i32) -> i32;
}
extern "C" {
    pub fn _SYSSwitchToOverlayFromHBM(arg1: i32) -> i32;
}
extern "C" {
    pub fn SYSSwitchTo(pfid: SysAppPFID::Type) -> i32;
}
extern "C" {
    pub fn _SYSSwitchTo(pfid: SysAppPFID::Type) -> i32;
}
extern "C" {
    pub fn _SYSDirectlySwitchTo(pfid: SysAppPFID::Type) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
pub mod SYSSettingsJumpToTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_SETTINGS_JUMP_TO_NONE: Type = 0;
    pub const SYS_SETTINGS_JUMP_TO_INTERNET: Type = 1;
    pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT: Type = 2;
    pub const SYS_SETTINGS_JUMP_TO_TV_REMOTE: Type = 3;
    pub const SYS_SETTINGS_JUMP_TO_DATE_TIME: Type = 4;
    pub const SYS_SETTINGS_JUMP_TO_COUNTRY: Type = 5;
    pub const SYS_SETTINGS_JUMP_TO_SYSTEM_UPDATE: Type = 6;
    pub const SYS_SETTINGS_JUMP_TO_INITIAL_SETTINGS: Type = 100;
    pub const SYS_SETTINGS_JUMP_TO_UNKNOWN: Type = 101;
    pub const SYS_SETTINGS_JUMP_TO_WIPE_CONSOLE: Type = 102;
    pub const SYS_SETTINGS_JUMP_TO_QUICK_START_SETTINGS: Type = 103;
    pub const SYS_SETTINGS_JUMP_TO_TV_CONNECTION_TYPE: Type = 104;
    pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT_2: Type = 105;
    pub const SYS_SETTINGS_JUMP_TO_SOFTWARE_TRANSFER: Type = 255;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppSettingsArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub jumpTo: SYSSettingsJumpToTarget::Type,
    pub firstBootKind: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppParentalArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppNotificationArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub notificationFile: u32,
}
extern "C" {
    pub fn SYSRelaunchTitle(argc: u32, pa_Argv: *mut *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn SYSLaunchMenu();
}
extern "C" {
    pub fn SYSLaunchTitle(TitleId: u64);
}
extern "C" {
    pub fn _SYSLaunchTitleWithStdArgsInNoSplash(titleId: u64, stdArgs: *mut SYSStandardArgsIn);
}
extern "C" {
    pub fn _SYSLaunchMenuWithCheckingAccount(slot: u8);
}
extern "C" {
    pub fn SYSLaunchMiiStudio(args: *mut SysAppMiiMakerArgs);
}
extern "C" {
    pub fn _SYSLaunchMiiStudio(args: *mut _SysAppMiiMakerArgs);
}
extern "C" {
    pub fn _SYSLaunchSettings(args: *mut SysAppSettingsArgs);
}
extern "C" {
    pub fn _SYSLaunchParental(args: *mut SysAppParentalArgs);
}
extern "C" {
    pub fn _SYSLaunchNotifications(args: *mut SysAppNotificationArgs);
}
extern "C" {
    pub fn _SYSLaunchTitleByPathFromLauncher(path: *const ::core::ffi::c_char, unused: u32);
}
pub mod SYSTEM_APP_ID {
    pub type Type = ::core::ffi::c_uint;
    pub const SYSTEM_APP_ID_WII_U_MENU: Type = 0;
    pub const SYSTEM_APP_ID_SYSTEM_SETTINGS: Type = 1;
    pub const SYSTEM_APP_ID_PARENTAL_CONTROLS: Type = 2;
    pub const SYSTEM_APP_ID_USER_SETTINGS: Type = 3;
    pub const SYSTEM_APP_ID_MII_MAKER: Type = 4;
    pub const SYSTEM_APP_ID_ACCOUNT_SETTINGS: Type = 5;
    pub const SYSTEM_APP_ID_DAILY_LOG: Type = 6;
    pub const SYSTEM_APP_ID_NOTIFICATIONS: Type = 7;
    pub const SYSTEM_APP_ID_HEALTH_AND_SAFETY: Type = 8;
    pub const SYSTEM_APP_ID_ELECTRONIC_MANUAL: Type = 9;
    pub const SYSTEM_APP_ID_WIIU_CHAT: Type = 10;
    pub const SYSTEM_APP_ID_SOFTWARE_DATA_TRANSFER: Type = 11;
}
extern "C" {
    pub static SYSTEM_APP_ID_UPDATER: SYSTEM_APP_ID::Type;
}
extern "C" {
    pub static SYSTEM_APP_ID_HOME_MENU: SYSTEM_APP_ID::Type;
}
extern "C" {
    pub fn SYSCheckTitleExists(TitleId: u64) -> BOOL;
}
extern "C" {
    pub fn SYSGetPFIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    pub fn SYSGetUPIDFromTitleID(TitleId: u64) -> i32;
}
extern "C" {
    pub fn SYSGetCallerUPID() -> i32;
}
extern "C" {
    pub fn SYSGetCallerPFID() -> i32;
}
extern "C" {
    pub fn _SYSGetSystemApplicationTitleId(id: SYSTEM_APP_ID::Type) -> u64;
}
extern "C" {
    pub fn _SYSGetSystemApplicationTitleIdByProdArea(
        id: SYSTEM_APP_ID::Type,
        prod_area: MCPRegion::Type,
    ) -> u64;
}
extern "C" {
    pub fn SYSGetCallerTitleId() -> u64;
}
pub type LogHandlerFn =
    ::core::option::Option<unsafe extern "C" fn(msg: *const ::core::ffi::c_char)>;
extern "C" {
    pub fn WHBAddLogHandler(fn_: LogHandlerFn) -> BOOL;
}
extern "C" {
    pub fn WHBRemoveLogHandler(fn_: LogHandlerFn) -> BOOL;
}
extern "C" {
    pub fn WHBLogWrite(str_: *const ::core::ffi::c_char) -> BOOL;
}
extern "C" {
    pub fn WHBLogPrint(str_: *const ::core::ffi::c_char) -> BOOL;
}
extern "C" {
    pub fn WHBLogWritef(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
}
extern "C" {
    pub fn WHBLogPrintf(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
}
pub mod WHBFileError {
    pub type Type = ::core::ffi::c_int;
    pub const WHB_FILE_OK: Type = 0;
    pub const WHB_FILE_FATAL_ERROR: Type = -1;
}
extern "C" {
    pub fn WHBDeInitFileSystem() -> BOOL;
}
extern "C" {
    pub fn WHBOpenFile(path: *const ::core::ffi::c_char, mode: *const ::core::ffi::c_char) -> i32;
}
extern "C" {
    pub fn WHBGetFileSize(handle: i32) -> u32;
}
extern "C" {
    pub fn WHBReadFile(handle: i32, buf: *mut ::core::ffi::c_void, size: u32, count: u32) -> u32;
}
extern "C" {
    pub fn WHBCloseFile(handle: i32) -> i32;
}
extern "C" {
    pub fn WHBReadWholeFile(
        path: *const ::core::ffi::c_char,
        outSize: *mut u32,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn WHBFreeWholeFile(file: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn WHBProcInit();
}
extern "C" {
    pub fn WHBProcShutdown();
}
extern "C" {
    pub fn WHBProcStopRunning();
}
extern "C" {
    pub fn WHBProcIsRunning() -> BOOL;
}
extern "C" {
    pub fn WHBLogConsoleInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogConsoleFree();
}
extern "C" {
    pub fn WHBLogConsoleSetColor(color: u32);
}
extern "C" {
    pub fn WHBLogConsoleDraw();
}
extern "C" {
    pub fn WHBLogModuleInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogModuleDeinit() -> BOOL;
}
extern "C" {
    pub fn WHBMountSdCard() -> BOOL;
}
extern "C" {
    pub fn WHBGetSdCardMountPath() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn WHBUnmountSdCard() -> BOOL;
}
extern "C" {
    pub fn WHBInitializeSocketLibrary();
}
extern "C" {
    pub fn WHBDeinitializeSocketLibrary();
}
extern "C" {
    pub fn WHBLogCafeInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogCafeDeinit() -> BOOL;
}
extern "C" {
    pub fn WHBInitCrashHandler() -> BOOL;
}
extern "C" {
    pub fn WHBLogUdpInit() -> BOOL;
}
extern "C" {
    pub fn WHBLogUdpDeinit() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHBGfxShaderGroup {
    pub fetchShader: GX2FetchShader,
    pub fetchShaderProgram: *mut ::core::ffi::c_void,
    pub pixelShader: *mut GX2PixelShader,
    pub vertexShader: *mut GX2VertexShader,
    pub numAttributes: u32,
    pub attributes: [GX2AttribStream; 16usize],
}
extern "C" {
    pub fn WHBGfxInit() -> BOOL;
}
extern "C" {
    pub fn WHBGfxShutdown();
}
extern "C" {
    pub fn WHBGfxBeginRender();
}
extern "C" {
    pub fn WHBGfxFinishRender();
}
extern "C" {
    pub fn WHBGfxClearColor(r: f32, g: f32, b: f32, a: f32);
}
extern "C" {
    pub fn WHBGfxBeginRenderDRC();
}
extern "C" {
    pub fn WHBGfxFinishRenderDRC();
}
extern "C" {
    pub fn WHBGfxBeginRenderTV();
}
extern "C" {
    pub fn WHBGfxFinishRenderTV();
}
extern "C" {
    pub fn WHBGfxLoadGFDPixelShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2PixelShader;
}
extern "C" {
    pub fn WHBGfxFreePixelShader(shader: *mut GX2PixelShader) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDVertexShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2VertexShader;
}
extern "C" {
    pub fn WHBGfxFreeVertexShader(shader: *mut GX2VertexShader) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDShaderGroup(
        group: *mut WHBGfxShaderGroup,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn WHBGfxInitShaderAttribute(
        group: *mut WHBGfxShaderGroup,
        name: *const ::core::ffi::c_char,
        buffer: u32,
        offset: u32,
        format: GX2AttribFormat::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn WHBGfxInitFetchShader(group: *mut WHBGfxShaderGroup) -> BOOL;
}
extern "C" {
    pub fn WHBGfxFreeShaderGroup(group: *mut WHBGfxShaderGroup) -> BOOL;
}
extern "C" {
    pub fn WHBGfxLoadGFDTexture(index: u32, file: *const ::core::ffi::c_void) -> *mut GX2Texture;
}
extern "C" {
    pub fn WHBGfxFreeTexture(texture: *mut GX2Texture) -> BOOL;
}
extern "C" {
    pub fn WHBGfxGetTVColourBuffer() -> *mut GX2ColorBuffer;
}
extern "C" {
    pub fn WHBGfxGetTVDepthBuffer() -> *mut GX2DepthBuffer;
}
extern "C" {
    pub fn WHBGfxGetTVContextState() -> *mut GX2ContextState;
}
extern "C" {
    pub fn WHBGfxGetDRCColourBuffer() -> *mut GX2ColorBuffer;
}
extern "C" {
    pub fn WHBGfxGetDRCDepthBuffer() -> *mut GX2DepthBuffer;
}
extern "C" {
    pub fn WHBGfxGetDRCContextState() -> *mut GX2ContextState;
}
pub mod TVEPort {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_PORT_HDMI: Type = 0;
    pub const TVE_PORT_COMPONENT: Type = 1;
    pub const TVE_PORT_COMPOSITE: Type = 2;
    pub const TVE_PORT_SCART: Type = 3;
}
pub mod TVEHdmiState {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_HDMI_STATE_NONE: Type = 0;
    pub const TVE_HDMI_STATE_HTPG_OFF: Type = 1;
    pub const TVE_HDMI_STATE_RXWAIT: Type = 2;
    pub const TVE_HDMI_STATE_EDID_COMP: Type = 3;
    pub const TVE_HDMI_STATE_DUMMY_TMDS: Type = 4;
    pub const TVE_HDMI_STATE_W4WK: Type = 5;
    pub const TVE_HDMI_STATE_1STA: Type = 6;
    pub const TVE_HDMI_STATE_2NDA: Type = 7;
    pub const TVE_HDMI_STATE_3RDA: Type = 8;
    pub const TVE_HDMI_STATE_STAV_OFF: Type = 9;
    pub const TVE_HDMI_STATE_DONE: Type = 10;
    pub const TVE_HDMI_STATE_OTHER: Type = 11;
    pub const TVE_HDMI_STATE_TMDSDOWN: Type = 12;
    pub const TVE_HDMI_STATE_SHUTDOWN: Type = 13;
    pub const TVE_HDMI_STATE_WII: Type = 14;
    pub const TVE_HDMI_STATE_ERR_NRESET: Type = 15;
    pub const TVE_HDMI_STATE_ERR_INT_LINE: Type = 16;
    pub const TVE_HDMI_STATE_ERR_KEY_LOAD: Type = 17;
    pub const TVE_HDMI_STATE_ERR_EDID_READ: Type = 18;
    pub const TVE_HDMI_STATE_ERR_HOTPLUG: Type = 19;
    pub const TVE_HDMI_STATE_ERR_VSYNC: Type = 20;
    pub const TVE_HDMI_STATE_ERR_HDCP: Type = 21;
    pub const TVE_HDMI_STATE_ERR_SYS: Type = 22;
    pub const TVE_HDMI_STATE_ERR_CEC: Type = 23;
    pub const TVE_HDMI_STATE_ERR_W41A: Type = 24;
    pub const TVE_HDMI_STATE_ERR_W4ED: Type = 25;
    pub const TVE_HDMI_STATE_UNKNOWN_1A: Type = 26;
}
extern "C" {
    pub fn TVEGetAnalogStat(outState: *mut u32);
}
extern "C" {
    pub fn TVEGetCurrentPort() -> TVEPort::Type;
}
extern "C" {
    pub fn TVEGetHDMIErrorStat(outState: *mut TVEHdmiState::Type);
}
pub mod TVECECLogicalAddress {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_CEC_DEVICE_TV: Type = 0;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_1: Type = 1;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_2: Type = 2;
    pub const TVE_CEC_DEVICE_TUNER_1: Type = 3;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_1: Type = 4;
    pub const TVE_CEC_DEVICE_AUDIO_SYSTEM: Type = 5;
    pub const TVE_CEC_DEVICE_TUNER_2: Type = 6;
    pub const TVE_CEC_DEVICE_TUNER_3: Type = 7;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_2: Type = 8;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_3: Type = 9;
    pub const TVE_CEC_DEVICE_TUNER_4: Type = 10;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_3: Type = 11;
    pub const TVE_CEC_DEVICE_RESERVED_1: Type = 12;
    pub const TVE_CEC_DEVICE_RESERVED_2: Type = 13;
    pub const TVE_CEC_DEVICE_FREE_USE: Type = 14;
    pub const TVE_CEC_DEVICE_UNREGISTERED: Type = 15;
    pub const TVE_CEC_DEVICE_BROADCAST: Type = 15;
}
pub mod TVECECOpCode {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_CEC_OPCODE_FEATURE_ABORT: Type = 0;
    pub const TVE_CEC_OPCODE_IMAGE_VIEW_ON: Type = 4;
    pub const TVE_CEC_OPCODE_TUNER_STEP_INCREMENT: Type = 5;
    pub const TVE_CEC_OPCODE_TUNER_STEP_DECREMENT: Type = 6;
    pub const TVE_CEC_OPCODE_TUNER_DEVICE_STATUS: Type = 7;
    pub const TVE_CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: Type = 8;
    pub const TVE_CEC_OPCODE_RECORD_ON: Type = 9;
    pub const TVE_CEC_OPCODE_RECORD_STATUS: Type = 10;
    pub const TVE_CEC_OPCODE_RECORD_OFF: Type = 11;
    pub const TVE_CEC_OPCODE_TEXT_VIEW_ON: Type = 13;
    pub const TVE_CEC_OPCODE_RECORD_TV_SCREEN: Type = 15;
    pub const TVE_CEC_OPCODE_GIVE_DECK_STATUS: Type = 26;
    pub const TVE_CEC_OPCODE_DECK_STATUS: Type = 27;
    pub const TVE_CEC_OPCODE_SET_MENU_LANGUAGE: Type = 50;
    pub const TVE_CEC_OPCODE_CLEAR_ANALOGUE_TIMER: Type = 51;
    pub const TVE_CEC_OPCODE_SET_ANALOGUE_TIMER: Type = 52;
    pub const TVE_CEC_OPCODE_TIMER_STATUS: Type = 53;
    pub const TVE_CEC_OPCODE_STANDBY: Type = 54;
    pub const TVE_CEC_OPCODE_PLAY: Type = 65;
    pub const TVE_CEC_OPCODE_DECK_CONTROL: Type = 66;
    pub const TVE_CEC_OPCODE_TIMER_CLEARED_STATUS: Type = 67;
    pub const TVE_CEC_OPCODE_USER_CONTROL_PRESSED: Type = 68;
    pub const TVE_CEC_OPCODE_USER_CONTROL_RELEASE: Type = 69;
    pub const TVE_CEC_OPCODE_GIVE_OSD_NAME: Type = 70;
    pub const TVE_CEC_OPCODE_SET_OSD_NAME: Type = 71;
    pub const TVE_CEC_OPCODE_SET_OSD_STRING: Type = 100;
    pub const TVE_CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: Type = 103;
    pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: Type = 112;
    pub const TVE_CEC_OPCODE_GIVE_AUDIO_STATUS: Type = 113;
    pub const TVE_CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: Type = 114;
    pub const TVE_CEC_OPCODE_REPORT_AUDIO_STATUS: Type = 122;
    pub const TVE_CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: Type = 125;
    pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: Type = 126;
    pub const TVE_CEC_OPCODE_ROUTING_CHANGE: Type = 128;
    pub const TVE_CEC_OPCODE_ROUTING_INFORMATION: Type = 129;
    pub const TVE_CEC_OPCODE_ACTIVE_SOURCE: Type = 130;
    pub const TVE_CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: Type = 131;
    pub const TVE_CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: Type = 132;
    pub const TVE_CEC_OPCODE_REQUEST_ACTIVE_SOURCE: Type = 133;
    pub const TVE_CEC_OPCODE_SET_STREAM_PATH: Type = 134;
    pub const TVE_CEC_OPCODE_DEVICE_VENDOR_ID: Type = 135;
    pub const TVE_CEC_OPCODE_VENDOR_COMMAND: Type = 137;
    pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: Type = 138;
    pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: Type = 139;
    pub const TVE_CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: Type = 140;
    pub const TVE_CEC_OPCODE_MENU_REQUEST: Type = 141;
    pub const TVE_CEC_OPCODE_MENU_STATUS: Type = 142;
    pub const TVE_CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: Type = 143;
    pub const TVE_CEC_OPCODE_REPORT_POWER_STATUS: Type = 144;
    pub const TVE_CEC_OPCODE_GET_MENU_LANGUAGE: Type = 145;
    pub const TVE_CEC_OPCODE_SELECT_ANALOGUE_SERVICE: Type = 146;
    pub const TVE_CEC_OPCODE_SELECT_DIGITAL_SERVICE: Type = 147;
    pub const TVE_CEC_OPCODE_SET_DIGITAL_TIMER: Type = 151;
    pub const TVE_CEC_OPCODE_CLEAR_DIGITAL_TIMER: Type = 153;
    pub const TVE_CEC_OPCODE_SET_AUDIO_RATE: Type = 154;
    pub const TVE_CEC_OPCODE_INACTIVE_SOURCE: Type = 157;
    pub const TVE_CEC_OPCODE_CEC_VERSION: Type = 158;
    pub const TVE_CEC_OPCODE_GET_CEC_VERSION: Type = 159;
    pub const TVE_CEC_OPCODE_VENDOR_COMMAND_WITH_ID: Type = 160;
    pub const TVE_CEC_OPCODE_CLEAR_EXTERNAL_TIMER: Type = 161;
    pub const TVE_CEC_OPCODE_SET_EXTERNAL_TIMER: Type = 162;
    pub const TVE_CEC_OPCODE_ABORT: Type = 255;
}
extern "C" {
    pub fn TVECECInit() -> BOOL;
}
extern "C" {
    pub fn TVESetCECEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn TVEIsCECEnable() -> BOOL;
}
extern "C" {
    pub fn TVECECSendCommand(
        destination: TVECECLogicalAddress::Type,
        opCode: TVECECOpCode::Type,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
}
extern "C" {
    pub fn TVECECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress::Type,
        outOpCode: *mut TVECECOpCode::Type,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
}
pub type AXResult = i32;
pub mod AX_RESULT {
    pub type Type = ::core::ffi::c_int;
    pub const AX_RESULT_SUCCESS: Type = 0;
    pub const AX_RESULT_INVALID_DEVICE_TYPE: Type = -1;
    pub const AX_RESULT_INVALID_DRC_VS_MODE: Type = -13;
    pub const AX_RESULT_VOICE_IS_RUNNING: Type = -18;
    pub const AX_RESULT_DELAY_TOO_BIG: Type = -19;
}
pub type AXDRCVSMode = u32;
pub type AXDRCVSOutput = u32;
pub type AXDRCVSLC = u32;
pub type AXDRCVSSpeakerPosition = u32;
pub type AXDRCVSSurroundLevelGain = u32;
pub mod AX_DRC_VS_MODE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_OUTPUT {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_OUTPUT_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_LC {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_LC_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SPEAKER_POS {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_SPEAKER_POS_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SURROUND_GAIN {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_SURROUND_GAIN_UNKNOWN: Type = 0;
}
extern "C" {
    pub fn AXGetDRCVSMode(mode: *mut AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSMode(mode: AXDRCVSMode) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSDownmixBalance(output: AXDRCVSOutput, balance: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLC(lc: AXDRCVSLC) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiter(limit: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSLimiterThreshold(threshold: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSOutputGain(output: AXDRCVSOutput, gain: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSpeakerPosition(
        output: AXDRCVSOutput,
        pos: AXDRCVSSpeakerPosition,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundDepth(output: AXDRCVSOutput, depth: f32) -> AXResult;
}
extern "C" {
    pub fn AXSetDRCVSSurroundLevelGain(gain: AXDRCVSSurroundLevelGain) -> AXResult;
}
pub type AXDeviceFinalMixCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void),
>;
pub type AXDeviceMode = u32;
pub type AXDeviceType = u32;
pub mod AX_DEVICE_MODE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DEVICE_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DEVICE_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DEVICE_TYPE_TV: Type = 0;
    pub const AX_DEVICE_TYPE_DRC: Type = 1;
    pub const AX_DEVICE_TYPE_CONTROLLER: Type = 2;
}
extern "C" {
    pub fn AXGetDeviceMode(type_: AXDeviceType, mode: *mut AXDeviceMode) -> AXResult;
}
extern "C" {
    pub fn AXGetDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: *mut AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: AXDeviceFinalMixCallback,
    ) -> AXResult;
}
extern "C" {
    pub fn AXGetAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: *mut AXAuxCallback,
        userData: *mut *mut ::core::ffi::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: AXAuxCallback,
        userData: *mut ::core::ffi::c_void,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceLinearUpsampler(type_: AXDeviceType, unk0: u32, unk1: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceCompressor(type_: AXDeviceType, unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceUpsampleStage(type_: AXDeviceType, postFinalMix: BOOL) -> AXResult;
}
extern "C" {
    pub fn AXSetDeviceVolume(type_: AXDeviceType, id: u32, volume: u16) -> AXResult;
}
pub type AXFrameCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type AXInitRenderer = u32;
pub type AXInitPipeline = u32;
pub mod AX_INIT_RENDERER {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_INIT_RENDERER_32KHZ: Type = 0;
    pub const AX_INIT_RENDERER_48KHZ: Type = 1;
}
pub mod AX_INIT_PIPELINE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_INIT_PIPELINE_SINGLE: Type = 0;
    pub const AX_INIT_PIPELINE_FOUR_STAGE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXProfile {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXInitParams {
    pub renderer: AXInitRenderer,
    pub __unk78: [::core::ffi::c_char; 4usize],
    pub pipeline: AXInitPipeline,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXTransitionAudioBufferDevice {
    pub mode: AXDeviceMode,
    pub unk1: f32,
    pub unk2: u32,
    pub enabled: BOOL,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXTransitionAudioBuffer {
    pub unk1: u32,
    pub unk2: u32,
    pub length: u32,
    pub loopPoint: u32,
    pub audioBuffer: *mut ::core::ffi::c_void,
    pub audioBufferLen: u32,
    pub tv: AXTransitionAudioBufferDevice,
    pub drc: AXTransitionAudioBufferDevice,
}
extern "C" {
    pub fn AXInit();
}
extern "C" {
    pub fn AXQuit();
}
extern "C" {
    pub fn AXInitWithParams(params: *mut AXInitParams);
}
extern "C" {
    pub fn AXIsInit() -> BOOL;
}
extern "C" {
    pub fn AXInitProfile(profile: *mut AXProfile, count: u32);
}
extern "C" {
    pub fn AXGetSwapProfile(profile: *mut AXProfile, count: u32) -> u32;
}
extern "C" {
    pub fn AXSetDefaultMixerSelect(unk0: u32) -> AXResult;
}
extern "C" {
    pub fn AXRegisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
}
extern "C" {
    pub fn AXDeregisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
}
extern "C" {
    pub fn AXRegisterFrameCallback(callback: AXFrameCallback) -> AXFrameCallback;
}
extern "C" {
    pub fn AXGetInputSamplesPerFrame() -> u32;
}
extern "C" {
    pub fn AXGetInputSamplesPerSec() -> u32;
}
extern "C" {
    pub fn AXStartTransitionAudio();
}
extern "C" {
    pub fn AXSetUpTransitionAudio(buffer: *mut AXTransitionAudioBuffer);
}
pub type AXVoiceFormat = u16;
pub type AXVoiceLoop = u16;
pub type AXVoiceSrcType = u32;
pub type AXVoiceState = u32;
pub type AXVoiceRenderer = u32;
pub type AXVoiceSrcRatioResult = i32;
pub type AXVoiceType = u32;
pub type AXVoiceCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXVoiceCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32, arg3: u32),
>;
pub mod AX_VOICE_FORMAT {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_FORMAT_ADPCM: Type = 0;
    pub const AX_VOICE_FORMAT_LPCM16: Type = 10;
    pub const AX_VOICE_FORMAT_LPCM8: Type = 25;
}
pub mod AX_VOICE_LOOP {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_LOOP_DISABLED: Type = 0;
    pub const AX_VOICE_LOOP_ENABLED: Type = 1;
}
pub mod AX_VOICE_RENDERER {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_RENDERER_DSP: Type = 0;
    pub const AX_VOICE_RENDERER_CPU: Type = 1;
    pub const AX_VOICE_RENDERER_AUTO: Type = 2;
}
pub mod AX_VOICE_RATIO_RESULT {
    pub type Type = ::core::ffi::c_int;
    pub const AX_VOICE_RATIO_RESULT_SUCCESS: Type = 0;
    pub const AX_VOICE_RATIO_RESULT_LESS_THAN_ZERO: Type = -1;
    pub const AX_VOICE_RATIO_RESULT_GREATER_THAN_SOMETHING: Type = -2;
}
pub mod AX_VOICE_SRC_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_SRC_TYPE_NONE: Type = 0;
    pub const AX_VOICE_SRC_TYPE_LINEAR: Type = 1;
    pub const AX_VOICE_SRC_TYPE_UNK0: Type = 2;
    pub const AX_VOICE_SRC_TYPE_UNK1: Type = 3;
    pub const AX_VOICE_SRC_TYPE_UNK2: Type = 4;
}
pub mod AX_VOICE_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_STATE_STOPPED: Type = 0;
    pub const AX_VOICE_STATE_PLAYING: Type = 1;
}
pub mod AX_VOICE_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_TYPE_UNKNOWN: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceLink {
    pub next: *mut AXVoice,
    pub prev: *mut AXVoice,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceOffsets {
    pub dataType: AXVoiceFormat,
    pub loopingEnabled: AXVoiceLoop,
    pub loopOffset: u32,
    pub endOffset: u32,
    pub currentOffset: u32,
    pub data: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoice {
    pub index: u32,
    pub state: AXVoiceState,
    pub volume: u32,
    pub renderer: AXVoiceRenderer,
    pub link: AXVoiceLink,
    pub cbNext: *mut AXVoice,
    pub priority: u32,
    pub callback: AXVoiceCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub syncBits: u32,
    pub __unk79: [::core::ffi::c_char; 8usize],
    pub offsets: AXVoiceOffsets,
    pub callbackEx: AXVoiceCallbackExFn,
    pub callbackReason: u32,
    pub unk0: f32,
    pub unk1: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceDeviceBusMixData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceDeviceMixData {
    pub bus: [AXVoiceDeviceBusMixData; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceVeData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceAdpcmLoopData {
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceAdpcm {
    pub coefficients: [i16; 16usize],
    pub gain: u16,
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceSrc {
    pub ratio: u32,
    pub currentOffsetFrac: u16,
    pub lastSample: [i16; 4usize],
}
extern "C" {
    pub fn AXVoiceBegin(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXVoiceEnd(v: *mut AXVoice) -> i32;
}
extern "C" {
    pub fn AXAcquireVoice(
        priority: u32,
        callback: AXVoiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXAcquireVoiceEx(
        priority: u32,
        callback: AXVoiceCallbackExFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
}
extern "C" {
    pub fn AXCheckVoiceOffsets(offsets: *mut AXVoiceOffsets) -> BOOL;
}
extern "C" {
    pub fn AXFreeVoice(voice: *mut AXVoice);
}
extern "C" {
    pub fn AXGetMaxVoices() -> u32;
}
extern "C" {
    pub fn AXGetVoiceCurrentOffsetEx(
        voice: *mut AXVoice,
        samples: *const ::core::ffi::c_void,
    ) -> u32;
}
extern "C" {
    pub fn AXGetVoiceLoopCount(voice: *mut AXVoice) -> u32;
}
extern "C" {
    pub fn AXGetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXIsVoiceRunning(voice: *mut AXVoice) -> BOOL;
}
extern "C" {
    pub fn AXSetVoiceAdpcm(voice: *mut AXVoice, adpcm: *mut AXVoiceAdpcm);
}
extern "C" {
    pub fn AXSetVoiceAdpcmLoop(voice: *mut AXVoice, loopData: *mut AXVoiceAdpcmLoopData);
}
extern "C" {
    pub fn AXSetVoiceCurrentOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceDeviceMix(
        voice: *mut AXVoice,
        type_: AXDeviceType,
        id: u32,
        mixData: *mut AXVoiceDeviceMixData,
    ) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceEndOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceEndOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn AXSetVoiceInitialTimeDelay(voice: *mut AXVoice, delay: u16) -> AXResult;
}
extern "C" {
    pub fn AXSetVoiceLoopOffset(voice: *mut AXVoice, offset: u32);
}
extern "C" {
    pub fn AXSetVoiceLoopOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn AXSetVoiceLoop(voice: *mut AXVoice, loop_: AXVoiceLoop);
}
extern "C" {
    pub fn AXSetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
}
extern "C" {
    pub fn AXSetVoicePriority(voice: *mut AXVoice, priority: u32);
}
extern "C" {
    pub fn AXSetVoiceRmtIIRCoefs(voice: *mut AXVoice, filter: u16, ...);
}
extern "C" {
    pub fn AXSetVoiceSrc(voice: *mut AXVoice, src: *mut AXVoiceSrc);
}
extern "C" {
    pub fn AXSetVoiceSrcRatio(voice: *mut AXVoice, ratio: f32) -> AXVoiceSrcRatioResult;
}
extern "C" {
    pub fn AXSetVoiceSrcType(voice: *mut AXVoice, type_: AXVoiceSrcType);
}
extern "C" {
    pub fn AXSetVoiceState(voice: *mut AXVoice, state: AXVoiceState);
}
extern "C" {
    pub fn AXSetVoiceType(voice: *mut AXVoice, type_: AXVoiceType);
}
extern "C" {
    pub fn AXSetVoiceVe(voice: *mut AXVoice, veData: *mut AXVoiceVeData);
}
extern "C" {
    pub fn AXSetVoiceVeDelta(voice: *mut AXVoice, delta: i16);
}
extern "C" {
    pub fn GX2RSetAttributeBuffer(buffer: *mut GX2RBuffer, index: u32, stride: u32, offset: u32);
}
extern "C" {
    pub fn GX2RDrawIndexed(
        mode: GX2PrimitiveMode::Type,
        buffer: *mut GX2RBuffer,
        indexType: GX2IndexType::Type,
        count: u32,
        indexOffset: u32,
        vertexOffset: u32,
        numInstances: u32,
    );
}
extern "C" {
    pub fn GX2RCreateSurface(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RCreateSurfaceUserMemory(
        surface: *mut GX2Surface,
        image: *mut u8,
        mipmap: *mut u8,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RDestroySurfaceEx(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RInvalidateSurface(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn GX2RLockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn GX2RUnlockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    );
}
extern "C" {
    pub fn GX2RBeginDisplayListEx(
        displayList: *mut GX2RBuffer,
        unknown: u32,
        flags: GX2RResourceFlags::Type,
    );
}
extern "C" {
    pub fn GX2REndDisplayList(displayList: *mut GX2RBuffer) -> u32;
}
extern "C" {
    pub fn GX2RCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
extern "C" {
    pub fn GX2RDirectCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
}
pub type GX2RAllocFunction = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: GX2RResourceFlags::Type,
        arg2: u32,
        arg3: u32,
    ) -> *mut ::core::ffi::c_void,
>;
pub type GX2RFreeFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags::Type, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    pub fn GX2RInvalidateMemory(
        flags: GX2RResourceFlags::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
    );
}
extern "C" {
    pub fn GX2RIsUserMemory(flags: GX2RResourceFlags::Type) -> BOOL;
}
extern "C" {
    pub fn GX2RSetAllocator(allocFn: GX2RAllocFunction, freeFn: GX2RFreeFunction);
}
extern "C" {
    pub fn CCRSetCompatMode(compatMode: u32) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRHIDReport {
    pub __unk80: [::core::ffi::c_char; 128usize],
}
extern "C" {
    pub fn CCRHIDStart(
        drcSlot: u32,
        reportsBuffer: *mut CCRHIDReport,
        numReports: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRHIDStop(
        drcSlot: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn CCRHIDGetData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
}
extern "C" {
    pub fn CCRHIDGetBufferedData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
}
extern "C" {
    pub fn CCRHIDGetFirmwareVersion(report: *mut CCRHIDReport, firmwareVersion: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRHIDGetSequence(report: *mut CCRHIDReport, sequence: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRCFGInit() -> i32;
}
extern "C" {
    pub fn CCRCFGGetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCFGSetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
}
extern "C" {
    pub fn CCRCFGGetVersionCheckFlag(outFlag: *mut u32) -> i32;
}
extern "C" {
    pub fn CCRCFGSetVersionCheckFlag(flag: u32) -> i32;
}
pub type NTAGError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGFormatSettings {
    pub version: u8,
    pub __unk81: [::core::ffi::c_char; 3usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk82: [::core::ffi::c_char; 28usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGNoftHeader {
    pub magic: u32,
    pub version: u8,
    pub writeCount: u16,
    pub unknown: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGInfoHeader {
    pub rwHeaderOffset: u16,
    pub rwSize: u16,
    pub roHeaderOffset: u16,
    pub roSize: u16,
    pub uid: NFCUid,
    pub formatVersion: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGAreaHeader {
    pub magic: u16,
    pub offset: u16,
    pub size: u16,
    pub __unk83: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGAreaInfo {
    pub data: *mut ::core::ffi::c_void,
    pub size: u16,
    pub __unk84: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk85: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGData {
    pub uid: NFCUid,
    pub readOnly: u8,
    pub formatVersion: u8,
    pub __unk86: [::core::ffi::c_char; 3usize],
    pub rwInfo: NTAGAreaInfo,
    pub roInfo: NTAGAreaInfo,
    pub __unk87: [::core::ffi::c_char; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGInfoT2T {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub characterID: [u8; 3usize],
    pub numberingID: u16,
    pub figureType: u8,
    pub seriesID: u8,
    pub unknown: u32,
    pub applicationAreaWrites: u16,
    pub crcCounter: u16,
    pub crc: u32,
    pub fontRegion: u8,
    pub name: [u16; 10usize],
    pub mii: FFLStoreData,
    pub country: u8,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub accessID: u32,
    pub titleID: u64,
    pub reserved: [u8; 508usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGApplicationDataT2T {
    pub size: u16,
    pub data: [u8; 216usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T {
    pub uid: [u8; 9usize],
    pub internal: u8,
    pub lockBytes: [u8; 2usize],
    pub capabilityContainer: [u8; 4usize],
    pub section0: NTAGRawDataT2T__bindgen_ty_1,
    pub section1: NTAGRawDataT2T__bindgen_ty_2,
    pub section2: NTAGRawDataT2T__bindgen_ty_3,
    pub applicationData: [u8; 216usize],
    pub dynamicLock: [u8; 3usize],
    pub reserved0: u8,
    pub cfg0: [u8; 4usize],
    pub cfg1: [u8; 4usize],
    pub pwd: [u8; 4usize],
    pub pack: [u8; 2usize],
    pub reserved1: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_1 {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub country: u8,
    pub crcCounter: u16,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub crc: u32,
    pub name: [u16; 10usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_2 {
    pub tagHmac: [u8; 32usize],
    pub characterID: [u8; 3usize],
    pub figureType: u8,
    pub numberingID: u16,
    pub seriesID: u8,
    pub formatVersion: u8,
    pub unknown: u32,
    pub keygenSalt: [u8; 32usize],
    pub dataHmac: [u8; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_3 {
    pub mii: FFLStoreData,
    pub titleID: u64,
    pub applicationAreaWrites: u16,
    pub accessID: u32,
    pub reserved: [u8; 34usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataContainerT2T {
    pub size: u16,
    pub data: NTAGRawDataT2T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGDataT2T {
    pub tagInfo: NFCTagInfo,
    pub formatVersion: u8,
    pub info: NTAGInfoT2T,
    pub appData: NTAGApplicationDataT2T,
    pub raw: NTAGRawDataContainerT2T,
    pub __unk88: [::core::ffi::c_char; 32usize],
}
pub type NTAGCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        data: *mut NTAGData,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        data: *mut NTAGDataT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        tagInfo: *mut NFCTagInfo,
        rawData: *mut NTAGRawDataContainerT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn NTAGInit(chan: VPADChan::Type) -> NTAGError;
}
extern "C" {
    pub fn NTAGInitEx(chan: VPADChan::Type) -> NTAGError;
}
extern "C" {
    pub fn NTAGIsInit(chan: VPADChan::Type) -> BOOL;
}
extern "C" {
    pub fn NTAGProc(chan: VPADChan::Type);
}
extern "C" {
    pub fn NTAGShutdown(chan: VPADChan::Type) -> NTAGError;
}
extern "C" {
    pub fn NTAGAbort(
        chan: VPADChan::Type,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGFormat(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGSetReadOnly(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGSetTagDetectCallback(
        chan: VPADChan::Type,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn NTAGSetFormatSettings(settings: *mut NTAGFormatSettings);
}
extern "C" {
    pub fn NTAGRead(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGReadT2T(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGReadT2TRawData(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWrite(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2T(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        dataContainer: *mut NTAGRawDataContainerT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TConfigArea(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        cfg0: *mut u32,
        cfg1: *mut u32,
        pwd: *mut u32,
        pack: *mut u16,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TLockArea(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        lockBytes: *mut u32,
        dynamicLock: *mut u32,
        cc: *mut u32,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TRawData(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TRawDataEx(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
        authenticate: u8,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGWriteT2TWithConvert(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
}
extern "C" {
    pub fn NTAGConvertT2T(out: *mut NTAGDataT2T, in_: *mut NTAGDataT2T) -> NTAGError;
}
extern "C" {
    pub fn NTAGParseHeader(
        data: *mut ::core::ffi::c_void,
        outNoftHeader: *mut NTAGNoftHeader,
        outInfoHeader: *mut NTAGInfoHeader,
        outRwHeader: *mut NTAGAreaHeader,
        outRoHeader: *mut NTAGAreaHeader,
    ) -> NTAGError;
}
pub type NetConfEthCfgSpeed = u16;
pub type NetConfEthCfgDuplex = u16;
pub type NetConfEthCfgNegotiation = u16;
pub type NetConfWifiPrivacyMode = u16;
pub type NetConfProxyAuthType = u16;
pub type NetConfProxyStatus = u16;
pub type NetConfInterfaceType = u16;
pub type NetConfLinkState = u16;
pub type NetConfOperState = u16;
pub type NetConfAdminState = u16;
pub mod NetConfInterfaceTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_INTERFACE_TYPE_WIFI: Type = 0;
    pub const NET_CONF_INTERFACE_TYPE_ETHERNET: Type = 1;
}
pub mod NetConfEthCfgSpeedEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_ETH_CFG_SPEED_10M: Type = 10;
    pub const NET_CONF_ETH_CFG_SPEED_100M: Type = 100;
}
pub mod NetConfEthCfgDuplexEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_ETH_CFG_DUPLEX_HALF: Type = 1;
    pub const NET_CONF_ETH_CFG_DUPLEX_FULL: Type = 2;
}
pub mod NetConfEthCfgNegotiationEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_ETH_CFG_NEGOTIATION_MANUAL: Type = 1;
    pub const NET_CONF_ETH_CFG_NEGOTIATION_AUTO: Type = 2;
}
pub mod NetConfIPv4Mode {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_IPV4_MODE_DHCP: Type = 0;
    pub const NET_CONF_IPV4_MODE_MANUAL: Type = 2;
}
pub mod NetConfWifiPrivacyModeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_WIFI_PRIVACY_MODE_NONE: Type = 0;
    pub const NET_CONF_WIFI_PRIVACY_MODE_WEP: Type = 1;
    pub const NET_CONF_WIFI_PRIVACY_MODE_WPA2_PSK_TKIP: Type = 3;
    pub const NET_CONF_WIFI_PRIVACY_MODE_WPA_PSK_TKIP: Type = 4;
    pub const NET_CONF_WIFI_PRIVACY_MODE_WPA2_PSK_AES: Type = 5;
    pub const NET_CONF_WIFI_PRIVACY_MODE_WPA_PSK_AES: Type = 6;
}
pub mod NetConfProxyAuthTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_PROXY_AUTH_TYPE_NONE: Type = 0;
    pub const NET_CONF_PROXY_AUTH_TYPE_BASIC_AUTHENTICATION: Type = 1;
}
pub mod NetConfProxyStatusEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_PROXY_DISABLED: Type = 0;
    pub const NET_CONF_PROXY_ENABLED: Type = 1;
}
pub mod NetConfLinkStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_LINK_STATE_UP: Type = 1;
    pub const NET_CONF_LINK_STATE_DOWN: Type = 2;
    pub const NET_CONF_LINK_STATE_NEGOTIATE: Type = 3;
}
pub mod NetConfOperStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_OPER_STATE_UP: Type = 1;
    pub const NET_CONF_OPER_STATE_DOWN: Type = 2;
}
pub mod NetConfAdminStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_ADMIN_STATE_UP: Type = 1;
    pub const NET_CONF_ADMIN_STATE_DOWN: Type = 2;
}
pub mod NetConfProfile {
    pub type Type = ::core::ffi::c_uint;
    pub const NET_CONF_PROFILE_0: Type = 0;
    pub const NET_CONF_PROFILE_1: Type = 1;
    pub const NET_CONF_PROFILE_2: Type = 2;
    pub const NET_CONF_PROFILE_3: Type = 3;
    pub const NET_CONF_PROFILE_4: Type = 4;
    pub const NET_CONF_PROFILE_5: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfAllProfileState {
    pub __unk89: [::core::ffi::c_char; 24usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfEthCfg {
    pub speed: NetConfEthCfgSpeed,
    pub duplex: NetConfEthCfgDuplex,
    pub negotiation: NetConfEthCfgNegotiation,
    pub __unk90: [::core::ffi::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfIPv4Info {
    pub mode: NetConfIPv4Mode::Type,
    pub addr: u32,
    pub netmask: u32,
    pub nexthop: u32,
    pub ns1: u32,
    pub ns2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfMACAddr {
    pub MACAddr: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfProxyConfig {
    pub use_proxy: NetConfProxyStatus,
    pub port: u16,
    pub __unk91: [::core::ffi::c_char; 2usize],
    pub auth_type: NetConfProxyAuthType,
    pub host: [::core::ffi::c_char; 128usize],
    pub username: [::core::ffi::c_char; 128usize],
    pub password: [::core::ffi::c_char; 64usize],
    pub noproxy_hosts: [::core::ffi::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfValidFlags {
    pub __unk92: [::core::ffi::c_char; 24usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfigDataPrivacy {
    pub mode: NetConfWifiPrivacyMode,
    pub __unk93: [::core::ffi::c_char; 2usize],
    pub aes_key_len: u16,
    pub aes_key: [u8; 64usize],
    pub __unk94: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfigData {
    pub ssid: [u8; 32usize],
    pub ssidlength: u16,
    pub __unk95: [::core::ffi::c_char; 2usize],
    pub privacy: NetConfWifiConfigDataPrivacy,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfWifiConfig {
    pub config_method: u16,
    pub __unk96: [::core::ffi::c_char; 2usize],
    pub config: NetConfWifiConfigData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfOpt {
    pub __unk97: [::core::ffi::c_char; 705usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfInterface {
    pub if_index: u16,
    pub if_sate: u16,
    pub if_mtu: u32,
    pub ipv4Info: NetConfIPv4Info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfCfg {
    pub wl0: NetConfInterface,
    pub wifi: NetConfWifiConfig,
    pub eth0: NetConfInterface,
    pub ethCfg: NetConfEthCfg,
    pub proxy: NetConfProxyConfig,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfAOSSConfig {
    pub config: [NetConfWifiConfigData; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetConfIfState {
    pub if_state: u16,
    pub linkstate: NetConfLinkState,
    pub operstate: NetConfOperState,
    pub __unk98: [::core::ffi::c_char; 2usize],
}
extern "C" {
    pub fn netconf_init() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_close() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_delete_profile(id: NetConfProfile::Type) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_all_profile_state(state: *mut NetConfAllProfileState) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_address(
        interface: NetConfInterfaceType,
        assignedAddress: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_dns(
        interface: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_gateway(
        unk1: NetConfInterfaceType,
        gateway: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_assigned_subnet(
        unk1: NetConfInterfaceType,
        subnet: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_dns(
        unk1: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_eth_cfg(outCfg: *mut NetConfEthCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_adminstate(interface: NetConfInterfaceType) -> NetConfAdminState;
}
extern "C" {
    pub fn netconf_get_if_ipv4_info(info: *mut NetConfIPv4Info) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_ipv4_info_ex(
        interface: NetConfInterfaceType,
        info: *mut NetConfIPv4Info,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_linkstate(interface: NetConfInterfaceType) -> NetConfLinkState;
}
extern "C" {
    pub fn netconf_get_if_macaddr(
        interface: NetConfInterfaceType,
        info: *mut NetConfMACAddr,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_if_operstate(interface: NetConfInterfaceType) -> NetConfOperState;
}
extern "C" {
    pub fn netconf_get_ifstate(
        interface: NetConfInterfaceType,
        ifState: *mut NetConfIfState,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_interface_mtu(
        NetConfInterfaceType: NetConfInterfaceType,
        mtu: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_last_wifi_link_error(lastError: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_profile_state(
        interface: NetConfInterfaceType,
        profileState: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_proxy_config(proxyConfig: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn SOGetProxyConfig(config: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_running(running: *mut NetConfCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_startup_profile_id() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_valid_flags(validFlags: *mut NetConfValidFlags) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_get_wifi_cfg(wifiConfig: *mut NetConfWifiConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_getopt(
        unk1: u16,
        buffer: *mut NetConfOpt,
        bufferSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_read(
        profileId: NetConfProfile::Type,
        data: *mut NetConfCfg,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_write(
        profileId: NetConfProfile::Type,
        data: *mut NetConfCfg,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_load(profileId: NetConfProfile::Type) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_nv_store(profileId: NetConfProfile::Type) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_read_aoss_config(
        profileId: NetConfProfile::Type,
        data: *mut NetConfAOSSConfig,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_write_aoss_config(
        profileId: NetConfProfile::Type,
        data: *mut NetConfAOSSConfig,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_read_compat_profile_id(outProfileId: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_dns(
        interface: NetConfInterfaceType,
        dns1: *mut u32,
        dns2: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_eth_cfg(config: *mut NetConfEthCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_admin_state(
        interface: NetConfInterfaceType,
        unk2: NetConfAdminStateEnum::Type,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_ipv4_info(info: *mut NetConfIPv4Info) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_if_ipv4_info_ex(
        interface: NetConfInterfaceType,
        info: *mut NetConfIPv4Info,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_interface_mtu(
        interface: NetConfInterfaceType,
        mtu: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_proxy_config(config: *mut NetConfProxyConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_running(config: *mut NetConfCfg) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_startup_profile_id(profileId: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_valid_flag(unk1: u32, unk2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_set_wifi_cfg(config: *mut NetConfWifiConfig) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_setopt(
        unk1: u16,
        buffer: *mut NetConfOpt,
        bufferSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn netconf_write_compat_profile_id(unk1: u32) -> ::core::ffi::c_int;
}
pub type nsysnet_fd_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsysnet_fd_set {
    pub __fds_bits: nsysnet_fd_mask,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsysnet_timeval {
    pub tv_sec: ::core::ffi::c_long,
    pub tv_usec: ::core::ffi::c_long,
}
extern "C" {
    pub fn socket_lib_init();
}
extern "C" {
    pub fn socket_lib_finish();
}
extern "C" {
    pub fn __rplwrap_accept(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_bind(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socketclose(sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_connect(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getpeername(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getsockname(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_getsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_listen(
        sockfd: ::core::ffi::c_int,
        backlog: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_recv(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_recvfrom(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_send(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_sendto(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_setsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_shutdown(
        sockfd: ::core::ffi::c_int,
        how: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_select(
        nfds: ::core::ffi::c_int,
        readfds: *mut nsysnet_fd_set,
        writefds: *mut nsysnet_fd_set,
        exceptfds: *mut nsysnet_fd_set,
        timeout: *mut nsysnet_timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __rplwrap_inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_socketlasterr() -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut h_errno: ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::core::ffi::c_char,
    pub h_aliases: *mut *mut ::core::ffi::c_char,
    pub h_addrtype: ::core::ffi::c_int,
    pub h_length: ::core::ffi::c_int,
    pub h_addr_list: *mut *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::core::ffi::c_char,
    pub s_aliases: *mut *mut ::core::ffi::c_char,
    pub s_port: ::core::ffi::c_int,
    pub s_proto: *mut ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::core::ffi::c_int,
    pub ai_family: ::core::ffi::c_int,
    pub ai_socktype: ::core::ffi::c_int,
    pub ai_protocol: ::core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::core::ffi::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
extern "C" {
    pub fn gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        addr: *const ::core::ffi::c_void,
        len: socklen_t,
        type_: ::core::ffi::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getservbyname(
        name: *const ::core::ffi::c_char,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        port: ::core::ffi::c_int,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getaddrinfo(
        node: *const ::core::ffi::c_char,
        service: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freeaddrinfo(res: *mut addrinfo);
}
extern "C" {
    pub fn getnameinfo(
        addr: *const sockaddr,
        addrlen: socklen_t,
        host: *mut ::core::ffi::c_char,
        hostlen: socklen_t,
        serv: *mut ::core::ffi::c_char,
        servlen: socklen_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gai_strerror(ecode: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __rplwrap_gethostbyaddr(
        addr: *const ::core::ffi::c_void,
        len: usize,
        type_: ::core::ffi::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn __rplwrap_gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
}
extern "C" {
    pub fn __rplwrap_getaddrinfo(
        node: *const ::core::ffi::c_char,
        service: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_freeaddrinfo(res: *mut addrinfo);
}
extern "C" {
    pub fn __rplwrap_getnameinfo(
        addr: *const sockaddr,
        addrlen: socklen_t,
        host: *mut ::core::ffi::c_char,
        hostlen: socklen_t,
        serv: *mut ::core::ffi::c_char,
        servlen: socklen_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_clear_resolver_cache();
}
extern "C" {
    pub fn __rplwrap_set_resolver_allocator(
        alloc: ::core::option::Option<unsafe extern "C" fn(arg1: u32) -> *mut ::core::ffi::c_void>,
        free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_get_h_errno() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub fn __rplwrap_gai_strerror(ecode: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
pub type NSSLError = i32;
pub type NSSLContextHandle = i32;
pub type NSSLConnectionHandle = i32;
pub mod NSSLErrors {
    pub type Type = ::core::ffi::c_int;
    pub const NSSL_ERROR_OK: Type = 0;
    pub const NSSL_ERROR_GENERIC: Type = -1;
    pub const NSSL_ERROR_INVALID_NSSL_CONTEXT: Type = -2621441;
    pub const NSSL_ERROR_INVALID_CERT_ID: Type = -2621442;
    pub const NSSL_ERROR_CERT_LIMIT: Type = -2621443;
    pub const NSSL_ERROR_INVALID_NSSL_CONNECTION: Type = -2621444;
    pub const NSSL_ERROR_INVALID_CERT: Type = -2621445;
    pub const NSSL_ERROR_ZERO_RETURN: Type = -2621446;
    pub const NSSL_ERROR_WANT_READ: Type = -2621447;
    pub const NSSL_ERROR_WANT_WRITE: Type = -2621448;
    pub const NSSL_ERROR_IO_ERROR: Type = -2621449;
    pub const NSSL_ERROR_NSSL_LIB_ERROR: Type = -2621450;
    pub const NSSL_ERROR_UNKNOWN: Type = -2621451;
    pub const NSSL_ERROR_OUT_OF_MEMORY: Type = -2621452;
    pub const NSSL_ERROR_INVALID_STATE: Type = -2621453;
    pub const NSSL_ERROR_HANDSHAKE_ERROR: Type = -2621454;
    pub const NSSL_ERROR_NO_CERT: Type = -2621455;
    pub const NSSL_ERROR_INVALID_FD: Type = -2621456;
    pub const NSSL_ERROR_LIB_NOT_READY: Type = -2621457;
    pub const NSSL_ERROR_IPC_ERROR: Type = -2621458;
    pub const NSSL_ERROR_RESOURCE_LIMIT: Type = -2621459;
    pub const NSSL_ERROR_INVALID_HANDLE: Type = -2621460;
    pub const NSSL_ERROR_INVALID_CERT_TYPE: Type = -2621461;
    pub const NSSL_ERROR_INVALID_KEY_TYPE: Type = -2621462;
    pub const NSSL_ERROR_INVALID_SIZE: Type = -2621463;
    pub const NSSL_ERROR_NO_PEER_CERT: Type = -2621464;
    pub const NSSL_ERROR_INSUFFICIENT_SIZE: Type = -2621465;
    pub const NSSL_ERROR_NO_CIPHER: Type = -2621466;
    pub const NSSL_ERROR_INVALID_ARG: Type = -2621467;
    pub const NSSL_ERROR_INVALID_NSSL_SESSION: Type = -2621468;
    pub const NSSL_ERROR_NO_SESSION: Type = -2621469;
    pub const NSSL_ERROR_SSL_SHUTDOWN_ERROR: Type = -2621470;
    pub const NSSL_ERROR_CERT_SIZE_LIMIT: Type = -2621471;
    pub const NSSL_ERROR_CERT_NO_ACCESS: Type = -2621472;
    pub const NSSL_ERROR_INVALID_CERT_ID2: Type = -2621473;
    pub const NSSL_ERROR_CERT_READ_ERROR: Type = -2621474;
    pub const NSSL_ERROR_CERT_STORE_INIT_FAILURE: Type = -2621475;
    pub const NSSL_ERROR_INVALID_CERT_ENCODING: Type = -2621476;
    pub const NSSL_ERROR_CERT_STORE_ERROR: Type = -2621477;
    pub const NSSL_ERROR_PRIVATE_KEY_READ_ERROR: Type = -2621478;
    pub const NSSL_ERROR_INVALID_PRIVATE_KEY: Type = -2621479;
    pub const NSSL_ERROR_NOT_READY: Type = -2621480;
    pub const NSSL_ERROR_ENCRYPTION_ERROR: Type = -2621481;
    pub const NSSL_ERROR_NO_CERT_STORE: Type = -2621482;
    pub const NSSL_ERROR_PRIVATE_KEY_SIZE_LIMIT: Type = -2621483;
    pub const NSSL_ERROR_PROCESS_MAX_EXT_CERTS: Type = -2621484;
    pub const NSSL_ERROR_PROCESS_MAX_CONTEXTS: Type = -2621485;
    pub const NSSL_ERROR_PROCESS_MAX_CONNECTIONS: Type = -2621486;
    pub const NSSL_ERROR_CERT_NOT_EXPORTABLE: Type = -2621487;
    pub const NSSL_ERROR_INVALID_CERT_SIZE: Type = -2621488;
    pub const NSSL_ERROR_INVALID_KEY_SIZE: Type = -2621489;
}
pub mod NSSLServerCertId {
    pub type Type = ::core::ffi::c_uint;
    pub const NSSL_SERVER_CERT_GROUP_NINTENDO_FIRST: Type = 100;
    pub const NSSL_SERVER_CERT_NINTENDO_CA: Type = 100;
    pub const NSSL_SERVER_CERT_NINTENDO_CA_G2: Type = 101;
    pub const NSSL_SERVER_CERT_NINTENDO_CA_G3: Type = 102;
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA: Type = 103;
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G2: Type = 104;
    pub const NSSL_SERVER_CERT_NINTENDO_CLASS2_CA_G3: Type = 105;
    pub const NSSL_SERVER_CERT_GROUP_NINTENDO_LAST: Type = 105;
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_FIRST: Type = 1001;
    pub const NSSL_SERVER_CERT_BALTIMORE_CYBERTRUST_ROOT_CA: Type = 1001;
    pub const NSSL_SERVER_CERT_CYBERTRUST_GLOBAL_ROOT_CA: Type = 1002;
    pub const NSSL_SERVER_CERT_VERIZON_GLOBAL_ROOT_CA: Type = 1003;
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA: Type = 1004;
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R2: Type = 1005;
    pub const NSSL_SERVER_CERT_GLOBALSIGN_ROOT_CA_R3: Type = 1006;
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G3: Type = 1007;
    pub const NSSL_SERVER_CERT_VERISIGN_UNIVERSAL_ROOT_CA: Type = 1008;
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G5: Type = 1009;
    pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA_G3: Type = 1010;
    pub const NSSL_SERVER_CERT_THAWTE_PRIMARY_ROOT_CA: Type = 1011;
    pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA: Type = 1012;
    pub const NSSL_SERVER_CERT_GEOTRUST_GLOBAL_CA2: Type = 1013;
    pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA: Type = 1014;
    pub const NSSL_SERVER_CERT_GEOTRUST_PRIMARY_CA_G3: Type = 1015;
    pub const NSSL_SERVER_CERT_ADDTRUST_EXT_CA_ROOT: Type = 1016;
    pub const NSSL_SERVER_CERT_COMODO_CA: Type = 1017;
    pub const NSSL_SERVER_CERT_UTN_DATACORP_SGC_CA: Type = 1018;
    pub const NSSL_SERVER_CERT_UTN_USERFIRST_HARDWARE_CA: Type = 1019;
    pub const NSSL_SERVER_CERT_DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA: Type = 1020;
    pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA: Type = 1021;
    pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA: Type = 1022;
    pub const NSSL_SERVER_CERT_GTE_CYBERTRUST_GLOBAL_ROOT: Type = 1023;
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA: Type = 1024;
    pub const NSSL_SERVER_CERT_THAWTE_PREMIUM_SERVER_CA: Type = 1025;
    pub const NSSL_SERVER_CERT_EQUIFAX_SECURE_CA: Type = 1026;
    pub const NSSL_SERVER_CERT_ENTRUST_SECURE_SERVER_CA: Type = 1027;
    pub const NSSL_SERVER_CERT_VERISIGN_CLASS3_PUBLIC_PRIMARY_CA_G2: Type = 1028;
    pub const NSSL_SERVER_CERT_ENTRUST_CA_2048: Type = 1029;
    pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA: Type = 1030;
    pub const NSSL_SERVER_CERT_ENTRUST_ROOT_CA_G2: Type = 1031;
    pub const NSSL_SERVER_CERT_DIGICERT_ASSURED_ID_ROOT_CA_G2: Type = 1032;
    pub const NSSL_SERVER_CERT_DIGICERT_GLOBAL_ROOT_CA_G2: Type = 1033;
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_LAST: Type = 1033;
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_FIRST: Type = 1900;
    pub const NSSL_SERVER_CERT_COMODO_RSA_CA: Type = 1900;
    pub const NSSL_SERVER_CERT_USERTRUST_RSA_CA: Type = 1901;
    pub const NSSL_SERVER_CERT_GROUP_COMMERCIAL_4096_LAST: Type = 1901;
}
extern "C" {
    pub fn NSSLInit() -> NSSLError;
}
extern "C" {
    pub fn NSSLFinish() -> NSSLError;
}
extern "C" {
    pub fn NSSLCreateContext(unk: i32) -> NSSLContextHandle;
}
extern "C" {
    pub fn NSSLDestroyContext(context: NSSLContextHandle) -> NSSLError;
}
extern "C" {
    pub fn NSSLAddServerPKIExternal(
        context: NSSLContextHandle,
        cert: *const ::core::ffi::c_void,
        length: i32,
        unk: i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn NSSLAddServerPKI(context: NSSLContextHandle, pki: NSSLServerCertId::Type) -> NSSLError;
}
extern "C" {
    pub fn NSSLCreateConnection(
        context: NSSLContextHandle,
        host: *const ::core::ffi::c_char,
        hostLength: i32,
        options: i32,
        socket: i32,
        block: i32,
    ) -> NSSLConnectionHandle;
}
extern "C" {
    pub fn NSSLDestroyConnection(connection: NSSLConnectionHandle) -> NSSLError;
}
extern "C" {
    pub fn NSSLRead(
        connection: NSSLConnectionHandle,
        buffer: *const ::core::ffi::c_void,
        length: i32,
        outBytesRead: *mut i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn NSSLWrite(
        connection: NSSLConnectionHandle,
        buffer: *const ::core::ffi::c_void,
        length: i32,
        outBytesWritten: *mut i32,
    ) -> NSSLError;
}
extern "C" {
    pub fn set_multicast_state(multicastEnable: BOOL) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn AVMCECInit() -> BOOL;
}
extern "C" {
    pub fn AVMEnableCEC();
}
extern "C" {
    pub fn AVMDisableCEC();
}
extern "C" {
    pub fn AVMCECSendCommand(
        destination: TVECECLogicalAddress::Type,
        opCode: TVECECOpCode::Type,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
}
extern "C" {
    pub fn AVMCECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress::Type,
        outOpCode: *mut TVECECOpCode::Type,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
}
pub mod AVMDrcScanMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_0: Type = 0;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_1: Type = 1;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_3: Type = 3;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_255: Type = 255;
}
pub mod AVMDrcMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_MODE_NONE: Type = 0;
    pub const AVM_DRC_MODE_SINGLE: Type = 1;
    pub const AVM_DRC_MODE_DOUBLE: Type = 2;
}
pub mod AVMDrcSystemAudioMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_0: Type = 0;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_1: Type = 1;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_SURROUND: Type = 2;
}
extern "C" {
    pub fn AVMGetSystemDRCAudioMode(
        outAudioMode: *mut AVMDrcSystemAudioMode::Type,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn AVMGetDRCSystemAudioMode(outAudioMode: *mut AVMDrcSystemAudioMode::Type) -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCVertCount() -> u32;
}
extern "C" {
    pub fn AVMIsDRCFirstFlippDone() -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCScanMode(outScanMode: *mut AVMDrcScanMode::Type) -> BOOL;
}
extern "C" {
    pub fn AVMGetDRCMode(outMode: *mut AVMDrcMode::Type) -> BOOL;
}
extern "C" {
    pub fn AVMProbeDRCNum() -> u32;
}
extern "C" {
    pub fn AVMSetDRCEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn AVMSetDRCGamma(gamma: *mut f32) -> BOOL;
}
pub mod AVMTvAspectRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_ASPECT_RATIO_4_3: Type = 0;
    pub const AVM_TV_ASPECT_RATIO_16_9: Type = 1;
}
pub mod AVMTvResolution {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_RESOLUTION_576I: Type = 1;
    pub const AVM_TV_RESOLUTION_480I: Type = 2;
    pub const AVM_TV_RESOLUTION_480P: Type = 3;
    pub const AVM_TV_RESOLUTION_720P: Type = 4;
    pub const AVM_TV_RESOLUTION_720P_3D: Type = 5;
    pub const AVM_TV_RESOLUTION_1080I: Type = 6;
    pub const AVM_TV_RESOLUTION_1080P: Type = 7;
    pub const AVM_TV_RESOLUTION_480I_PAL60: Type = 10;
    pub const AVM_TV_RESOLUTION_576P: Type = 11;
    pub const AVM_TV_RESOLUTION_720P_50HZ: Type = 12;
    pub const AVM_TV_RESOLUTION_1080I_50HZ: Type = 13;
    pub const AVM_TV_RESOLUTION_1080P_50HZ: Type = 14;
}
pub mod AVMTvVideoRegion {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_VIDEO_REGION_NTSC: Type = 1;
    pub const AVM_TV_VIDEO_REGION_PAL: Type = 2;
}
extern "C" {
    pub fn AVMDebugIsNTSC() -> BOOL;
}
extern "C" {
    pub fn AVMGetCurrentPort(outPort: *mut TVEPort::Type) -> BOOL;
}
extern "C" {
    pub fn AVMGetHDMIState(outState: *mut TVEHdmiState::Type);
}
extern "C" {
    pub fn AVMGetTVAspectRatio(outAspectRatio: *mut AVMTvAspectRatio::Type) -> BOOL;
}
extern "C" {
    pub fn AVMGetTVScanMode(outResolution: *mut AVMTvResolution::Type) -> BOOL;
}
extern "C" {
    pub fn AVMGetTVUnderScan(outUnderScan: *mut u32) -> i32;
}
extern "C" {
    pub fn AVMIsAVOutReady() -> BOOL;
}
extern "C" {
    pub fn AVMSetTVAspectRatio(aspectRatio: AVMTvAspectRatio::Type) -> BOOL;
}
extern "C" {
    pub fn AVMSetTVEnable(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn AVMSetTVOutPort(port: TVEPort::Type, resolution: AVMTvResolution::Type) -> i32;
}
extern "C" {
    pub fn AVMSetTVScanMode(
        resolution: AVMTvResolution::Type,
        unknown: u32,
        port: TVEPort::Type,
    ) -> i32;
}
extern "C" {
    pub fn AVMSetTVScanResolution(resolution: AVMTvResolution::Type) -> i32;
}
extern "C" {
    pub fn AVMSetTVUnderScan(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMSetTVUnderScanParam(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMSetTVVideoRegion(
        videoRegion: AVMTvVideoRegion::Type,
        port: TVEPort::Type,
        resolution: AVMTvResolution::Type,
    ) -> i32;
}
extern "C" {
    pub fn AVMReadSystemAspectRatioConfig(outAspectRatio: *mut AVMTvAspectRatio::Type) -> i32;
}
extern "C" {
    pub fn AVMReadSystemPortConfig(outPort: *mut TVEPort::Type) -> i32;
}
extern "C" {
    pub fn AVMReadSystemTVUnderScanConfig(outUnderScan: *mut u32) -> i32;
}
extern "C" {
    pub fn AVMReadSystemVideoResConfig(outResolution: *mut AVMTvResolution::Type) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemAspectRatioConfig(aspectRatio: AVMTvAspectRatio::Type) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemTVUnderScanConfig(underScan: u32) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemVideoOutConfig(
        port: TVEPort::Type,
        resolution: AVMTvResolution::Type,
    ) -> i32;
}
extern "C" {
    pub fn AVMWriteSystemVideoResConfig(resolution: AVMTvResolution::Type) -> i32;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsDeviceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUsb: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubclass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsConfigDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub bMaxPower: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsInterfaceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsSetupPacket {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
}
pub mod UHSStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_STATUS_OK: Type = 0;
    pub const UHS_STATUS_HANDLE_INVALID_ARGS: Type = 4292804605;
    pub const UHS_STATUS_HANDLE_INVALID_STATE: Type = 4292804604;
}
pub mod UHSHandleState {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_HANDLE_STATE_INIT: Type = 0;
    pub const UHS_HANDLE_STATE_OPENING: Type = 1;
    pub const UHS_HANDLE_STATE_OPENED: Type = 2;
    pub const UHS_HANDLE_STATE_CLOSING: Type = 3;
    pub const UHS_HANDLE_STATE_CLOSED: Type = 4;
    pub const UHS_HANDLE_STATE_ERROR: Type = 5;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsConfig {
    pub controller_num: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub buffer_size: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsHandle {
    pub state: UHSHandleState::Type,
    pub ipc_buffer: *mut ::core::ffi::c_void,
    pub __unk99: [::core::ffi::c_char; 4usize],
    pub handle: u32,
    pub config: *mut UhsConfig,
    pub __unk100: [::core::ffi::c_char; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsInterfaceFilter {
    pub match_params: u16,
    pub vid: u16,
    pub pid: u16,
    pub __unk101: [::core::ffi::c_char; 4usize],
    pub dev_class: u8,
    pub dev_subclass: u8,
    pub dev_protocol: u8,
    pub if_class: u8,
    pub if_subclass: u8,
    pub if_protocol: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsEndpointDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
    pub __unk102: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsInterfaceProfile {
    pub if_handle: u32,
    pub __unk103: [::core::ffi::c_char; 36usize],
    pub dev_desc: UhsDeviceDescriptor,
    pub cfg_desc: UhsConfigDescriptor,
    pub if_desc: UhsInterfaceDescriptor,
    pub in_endpoints: [UhsEndpointDescriptor; 16usize],
    pub out_endpoints: [UhsEndpointDescriptor; 16usize],
}
pub mod UHSAdminDevType {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_ADMIN_DEV_RESET: Type = 1;
    pub const UHS_ADMIN_DEV_FREEZE: Type = 2;
    pub const UHS_ADMIN_DEV_SUSPEND: Type = 3;
    pub const UHS_ADMIN_DEV_RESUME: Type = 4;
    pub const UHS_ADMIN_DEV_DESTROY: Type = 5;
}
pub mod UHSAdminEpType {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_ADMIN_EP_ENABLE: Type = 1;
    pub const UHS_ADMIN_EP_DISABLE: Type = 2;
    pub const UHS_ADMIN_EP_CANCEL: Type = 3;
    pub const UHS_ADMIN_EP_CANCEL_RESET: Type = 4;
}
extern "C" {
    pub fn UhsClientOpen(handle: *mut UhsHandle, config: *mut UhsConfig) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsClientClose(handle: *mut UhsHandle) -> UHSStatus::Type;
}
pub type UHSDrvRegCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, profile: *mut UhsInterfaceProfile),
>;
extern "C" {
    pub fn UhsClassDrvReg(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        context: *mut ::core::ffi::c_void,
        callback: UHSDrvRegCallback,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsClassDrvUnReg(handle: *mut UhsHandle, drv_handle: u32) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsGetFullConfigDescriptor(
        handle: *mut UhsHandle,
        if_handle: u32,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsGetDescriptorString(
        handle: *mut UhsHandle,
        if_handle: u32,
        string_index: u8,
        as_unicode: BOOL,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsQueryInterfaces(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        profiles: *mut UhsInterfaceProfile,
        max_profiles: i32,
    ) -> UHSStatus::Type;
}
pub type UhsAcquireInterfaceCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, arg1: i32, arg2: i32),
>;
extern "C" {
    pub fn UhsAcquireInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        context: *mut ::core::ffi::c_void,
        callback: UhsAcquireInterfaceCallback,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsReleaseInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        no_reacquire: bool,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsAdministerDevice(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminDevType::Type,
        arg3: i32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsAdministerEndpoint(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminEpType::Type,
        endpointMask: u32,
        max_pending_requests: u32,
        max_request_size: u32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsClearEndpointHalt(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u32,
        direction: i32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsSubmitControlRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        buffer: *mut ::core::ffi::c_void,
        bRequest: u8,
        bmRequestType: u8,
        wValue: u16,
        wIndex: u16,
        wLength: u16,
        timeout: i32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsSubmitBulkRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus::Type;
}
extern "C" {
    pub fn UhsSubmitInterruptRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSemaphore {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk104: [::core::ffi::c_char; 4usize],
    pub count: i32,
    pub queue: OSThreadQueue,
}
extern "C" {
    pub fn OSInitSemaphore(semaphore: *mut OSSemaphore, count: i32);
}
extern "C" {
    pub fn OSInitSemaphoreEx(
        semaphore: *mut OSSemaphore,
        count: i32,
        name: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSGetSemaphoreCount(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSSignalSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
extern "C" {
    pub fn OSTryWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
}
pub type OSFiberEntryFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type OSFiberExEntryFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32, arg3: u32, arg4: u32)>;
extern "C" {
    pub fn OSSwitchFiber(entry: OSFiberEntryFn, stack: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    pub fn OSSwitchFiberEx(
        arg1: u32,
        arg2: u32,
        arg3: u32,
        arg4: u32,
        entry: OSFiberExEntryFn,
        stack: *mut ::core::ffi::c_void,
    ) -> i32;
}
pub type OSDynLoad_Module = *mut ::core::ffi::c_void;
pub mod OSDynLoad_Error {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_OK: Type = 0;
    pub const OS_DYNLOAD_OUT_OF_MEMORY: Type = 3134259202;
    pub const OS_DYNLOAD_INVALID_NOTIFY_PTR: Type = 3134259214;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME_PTR: Type = 3134259215;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME: Type = 3134259216;
    pub const OS_DYNLOAD_INVALID_ACQUIRE_PTR: Type = 3134259217;
    pub const OS_DYNLOAD_EMPTY_MODULE_NAME: Type = 3134259218;
    pub const OS_DYNLOAD_INVALID_ALLOCATOR_PTR: Type = 3134259223;
    pub const OS_DYNLOAD_OUT_OF_SYSTEM_MEMORY: Type = 3134259247;
    pub const OS_DYNLOAD_TLS_ALLOCATOR_LOCKED: Type = 3134259249;
    pub const OS_DYNLOAD_MODULE_NOT_FOUND: Type = 4294967290;
}
pub type OSDynLoadAllocFn = ::core::option::Option<
    unsafe extern "C" fn(
        size: i32,
        align: i32,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type,
>;
pub type OSDynLoadFreeFn =
    ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void)>;
pub mod OSDynLoad_ExportType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_EXPORT_FUNC: Type = 0;
    pub const OS_DYNLOAD_EXPORT_DATA: Type = 1;
}
pub mod OSDynLoad_EntryReason {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_LOADED: Type = 1;
    pub const OS_DYNLOAD_UNLOADED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_NotifyData {
    pub name: *mut ::core::ffi::c_char,
    pub textAddr: u32,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: u32,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub readAddr: u32,
    pub readOffset: u32,
    pub readSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_LoaderHeapStatistics {
    pub codeHeapUsed: u32,
    pub unk_0x04: u32,
    pub codeHeapFree: u32,
    pub codeHeapLargestFree: u32,
    pub dataHeapUsed: u32,
    pub unk_0x14: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_LoaderUserFileInfo {
    pub size: u32,
    pub magic: u32,
    pub pathStringLength: u32,
    pub pathString: *mut ::core::ffi::c_char,
    pub fileInfoFlags: u32,
    pub tlsModuleIndex: i16,
    pub tlsAlignShift: i16,
    pub tlsAddressStart: *mut ::core::ffi::c_void,
    pub tlsSectionSize: u32,
    pub shstrndx: u32,
    pub titleLocation: u32,
    pub __unk105: [::core::ffi::c_char; 56usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OSDynLoad_LoaderSectionInfo {
    pub type_: u32,
    pub flags: u32,
    pub address: *mut ::core::ffi::c_void,
    pub __bindgen_anon_1: OSDynLoad_LoaderSectionInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSDynLoad_LoaderSectionInfo__bindgen_ty_1 {
    pub size: u32,
    pub name: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_InternalData {
    pub handle: u32,
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub moduleName: *mut ::core::ffi::c_char,
    pub moduleNameLen: u32,
    pub sectionInfoCount: u32,
    pub sectionInfo: *mut OSDynLoad_LoaderSectionInfo,
    pub importModules: *mut *mut OSDynLoad_InternalData,
    pub importModuleCount: u32,
    pub userFileInfoSize: u32,
    pub userFileInfo: *mut OSDynLoad_LoaderUserFileInfo,
    pub notifyData: *mut OSDynLoad_NotifyData,
    pub entryPoint: *mut ::core::ffi::c_void,
    pub dataSectionSize: u32,
    pub dataSection: *mut ::core::ffi::c_void,
    pub loadSectionSize: u32,
    pub loadSection: *mut ::core::ffi::c_void,
    pub dynLoadFreeFn: OSDynLoadFreeFn,
    pub codeExports: *mut ::core::ffi::c_void,
    pub numCodeExports: u32,
    pub dataExports: *mut ::core::ffi::c_void,
    pub numDataExports: u32,
    pub next: *mut OSDynLoad_InternalData,
    pub __unk106: [::core::ffi::c_char; 60usize],
}
pub mod OSDynLoad_NotifyReason {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_NOTIFY_UNLOADED: Type = 0;
    pub const OS_DYNLOAD_NOTIFY_LOADED: Type = 1;
}
pub type OSDynLoadNotifyFunc = ::core::option::Option<
    unsafe extern "C" fn(
        module: OSDynLoad_Module,
        userContext: *mut ::core::ffi::c_void,
        notifyReason: OSDynLoad_NotifyReason::Type,
        infos: *mut OSDynLoad_NotifyData,
    ),
>;
extern "C" {
    pub fn OSDynLoad_Acquire(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_FindExport(
        module: OSDynLoad_Module,
        exportType: OSDynLoad_ExportType::Type,
        name: *const ::core::ffi::c_char,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_Release(module: OSDynLoad_Module);
}
extern "C" {
    pub fn OSDynLoad_SetAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_GetAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_SetTLSAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_GetTLSAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_GetLoaderHeapStatistics(
        outLoaderHeapStatistics: *mut OSDynLoad_LoaderHeapStatistics,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_GetModuleName(
        module: OSDynLoad_Module,
        nameBuf: *mut ::core::ffi::c_char,
        nameBufSize: *mut i32,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_GetNumberOfRPLs() -> i32;
}
extern "C" {
    pub fn OSDynLoad_GetRPLInfo(
        first: u32,
        count: u32,
        outInfos: *mut OSDynLoad_NotifyData,
    ) -> BOOL;
}
extern "C" {
    pub fn OSDynLoad_IsModuleLoaded(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_AddNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn OSDynLoad_DelNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
}
extern "C" {
    pub fn rpl_entry(
        module: OSDynLoad_Module,
        reason: OSDynLoad_EntryReason::Type,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct OSStopwatch {
    pub lock: OSSpinLock,
    pub name: *const ::core::ffi::c_char,
    pub hitCount: u32,
    pub totalTime: OSTime,
    pub minTime: OSTime,
    pub maxTime: OSTime,
    pub startTime: OSTime,
    pub running: BOOL,
    pub __unk107: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn OSInitStopwatch(stopwatch: *mut OSStopwatch, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSResetStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSStartStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSStopStopwatch(stopwatch: *mut OSStopwatch);
}
extern "C" {
    pub fn OSCheckStopwatch(stopwatch: *mut OSStopwatch) -> OSTime;
}
extern "C" {
    pub fn OSDumpStopwatch(stopwatch: *mut OSStopwatch);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexLink {
    pub next: *mut OSMutex,
    pub prev: *mut OSMutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk108: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
    pub owner: *mut OSThread,
    pub count: i32,
    pub link: OSMutexLink,
}
extern "C" {
    pub fn OSInitMutex(mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSInitMutexEx(mutex: *mut OSMutex, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSLockMutex(mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSTryLockMutex(mutex: *mut OSMutex) -> BOOL;
}
extern "C" {
    pub fn OSUnlockMutex(mutex: *mut OSMutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPoolFIFO {
    pub pushIndex: i32,
    pub popIndex: i32,
    pub count: i32,
    pub maxCount: i32,
    pub messages: *mut *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPoolAttributes {
    pub messageSize: u32,
    pub poolSize: u32,
    pub numMessages: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPool {
    pub magic: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub size: u32,
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub messageSize0x14: u32,
    pub messageSize0x18: u32,
    pub messageCount: u32,
    pub messages: *mut ::core::ffi::c_void,
    pub messageIndexSize: *mut u32,
    pub fifo: IPCBufPoolFIFO,
    pub mutex: OSMutex,
    pub __unk109: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn IPCBufPoolCreate(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        messageSize: u32,
        outNumMessages: *mut u32,
        unk0x0c: u32,
    ) -> *mut IPCBufPool;
}
extern "C" {
    pub fn IPCBufPoolAllocate(pool: *mut IPCBufPool, size: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn IPCBufPoolFree(
        pool: *mut IPCBufPool,
        message: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IPCBufPoolGetAttributes(
        pool: *mut IPCBufPool,
        attribs: *mut IPCBufPoolAttributes,
    ) -> IOSError::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSRendezvous {
    pub core: [u32; 3usize],
    pub __unk110: [::core::ffi::c_char; 4usize],
}
extern "C" {
    pub fn OSInitRendezvous(rendezvous: *mut OSRendezvous);
}
extern "C" {
    pub fn OSWaitRendezvous(rendezvous: *mut OSRendezvous, coreMask: u32) -> BOOL;
}
extern "C" {
    pub fn OSWaitRendezvousWithTimeout(
        rendezvous: *mut OSRendezvous,
        coreMask: u32,
        timeout: OSTime,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk111: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
extern "C" {
    pub fn OSFastCond_Init(condition: *mut OSFastCondition, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSFastCond_Wait(condition: *mut OSFastCondition, mutex: *mut OSFastMutex);
}
extern "C" {
    pub fn OSFastCond_Signal(condition: *mut OSFastCondition);
}
pub mod OSICICommand {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_ICI_COMMAND_INVALID_IC_RANGE: Type = 1;
    pub const OS_ICI_COMMAND_RESCHEDULE_CORE: Type = 2;
    pub const OS_ICI_COMMAND_HALT_CORE: Type = 3;
    pub const OS_ICI_COMMAND_PROC_EXIT: Type = 4;
    pub const OS_ICI_COMMAND_SET_DABR: Type = 5;
    pub const OS_ICI_COMMAND_PROC_SCHED: Type = 6;
    pub const OS_ICI_COMMAND_FAST_BG_EXIT: Type = 7;
    pub const OS_ICI_COMMAND_IOP_SHELL_CORE_TRACE: Type = 8;
    pub const OS_ICI_COMMAND_SYSTEM_FATAL: Type = 9;
    pub const OS_ICI_COMMAND_SET_IABR: Type = 10;
    pub const OS_ICI_COMMAND_PANIC_0X15: Type = 11;
    pub const OS_ICI_COMMAND_PROC_KILL: Type = 12;
    pub const OS_ICI_COMMAND_PROC_CRASH: Type = 13;
    pub const OS_ICI_COMMAND_UNKNOWN: Type = 14;
    pub const OS_ICI_COMMAND_OVERLAY_ARENA: Type = 15;
}
pub type OSExceptionCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(
        exceptionType: OSExceptionType::Type,
        interruptedContext: *mut OSContext,
        cbContext: *mut OSContext,
    ),
>;
pub type KernelTimerCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        exception: OSExceptionType::Type,
        interruptedContext: *mut OSContext,
        currentContext: *mut OSContext,
    ),
>;
pub type KernelTimerHandle = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSExceptionChainInfo {
    pub callback: OSExceptionCallbackExFn,
    pub stack: *mut ::core::ffi::c_void,
    pub context: *mut OSContext,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0 {
    pub upid: i32,
    pub rampid: i32,
    pub appFlags: u32,
    pub dataAreaStart: *mut ::core::ffi::c_void,
    pub dataAreaEnd: *mut ::core::ffi::c_void,
    pub physDataAreaStart: *mut ::core::ffi::c_void,
    pub physDataAreaEnd: *mut ::core::ffi::c_void,
    pub physAvailStart: *mut ::core::ffi::c_void,
    pub physAvailEnd: *mut ::core::ffi::c_void,
    pub physCodeGenStart: *mut ::core::ffi::c_void,
    pub physCodeGenEnd: *mut ::core::ffi::c_void,
    pub sdaBase: *mut ::core::ffi::c_void,
    pub sda2Base: *mut ::core::ffi::c_void,
    pub systemHeapSize: u32,
    pub stackEnd0: *mut ::core::ffi::c_void,
    pub stackEnd1: *mut ::core::ffi::c_void,
    pub stackEnd2: *mut ::core::ffi::c_void,
    pub stackBase0: *mut ::core::ffi::c_void,
    pub stackBase1: *mut ::core::ffi::c_void,
    pub stackBase2: *mut ::core::ffi::c_void,
    pub exceptionStackEnd0: *mut ::core::ffi::c_void,
    pub exceptionStackEnd1: *mut ::core::ffi::c_void,
    pub exceptionStackEnd2: *mut ::core::ffi::c_void,
    pub exceptionStackBase0: *mut ::core::ffi::c_void,
    pub exceptionStackBase1: *mut ::core::ffi::c_void,
    pub exceptionStackBase2: *mut ::core::ffi::c_void,
    pub lockedCacheBase0: *mut ::core::ffi::c_void,
    pub lockedCacheBase1: *mut ::core::ffi::c_void,
    pub lockedCacheBase2: *mut ::core::ffi::c_void,
    pub coreinit: KernelInfo0_CoreinitInfo,
    pub unk0x9C: u32,
    pub titleId: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0_CoreinitInfo {
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub textAddr: *mut ::core::ffi::c_void,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: *mut ::core::ffi::c_void,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub loadAddr: *mut ::core::ffi::c_void,
    pub loadOffset: u32,
    pub loadSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo6 {
    pub osTitleId: u64,
    pub unk0x08: u32,
    pub __unk112: [::core::ffi::c_char; 252usize],
}
extern "C" {
    pub fn __KernelSetUserModeExHandler(
        exceptionType: OSExceptionType::Type,
        chainInfo: *mut OSExceptionChainInfo,
        prevChainInfo: *mut OSExceptionChainInfo,
    );
}
extern "C" {
    pub fn __KernelAllocateTimer(
        arg1: KernelTimerCallbackFn,
        exceptionStack: *mut ::core::ffi::c_void,
        context: *mut OSContext,
    ) -> KernelTimerHandle;
}
extern "C" {
    pub fn __KernelPrimeTimer(
        handle: KernelTimerHandle,
        startTimeInTicks: u64,
        intervalInTicks: u64,
        unknown: u32,
    ) -> u32;
}
extern "C" {
    pub fn __KernelSendICI(
        cmd: OSICICommand::Type,
        arg1: *mut ::core::ffi::c_void,
        unknown1: u32,
        unknown2: u32,
    );
}
extern "C" {
    pub fn __KernelGetInfo(
        type_: u32,
        outBuffer: *mut ::core::ffi::c_void,
        outBufferSize: u32,
        core: u32,
    );
}
pub type IMEventMask = u32;
pub mod IMPadType {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_PAD_TYPE_NONE: Type = 0;
    pub const IM_PAD_TYPE_WII_REMOTE: Type = 1;
    pub const IM_PAD_TYPE_WIIU_PRO_CONTROLLER: Type = 2;
    pub const IM_PAD_TYPE_WII_REMOTE_EXTENSION: Type = 3;
    pub const IM_PAD_TYPE_WIIU_GAMEPAD: Type = 4;
}
pub mod IMDeviceState {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_DEVICE_STATE_CLEAR: Type = 0;
    pub const IM_DEVICE_STATE_INACTIVE: Type = 1;
    pub const IM_DEVICE_STATE_ACTIVE: Type = 2;
    pub const IM_DEVICE_STATE_HOME: Type = 3;
    pub const IM_DEVICE_STATE_POWER: Type = 4;
    pub const IM_DEVICE_STATE_SYNC: Type = 5;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMRequest {
    pub args: [u8; 128usize],
    pub ioctlVecs: [IOSVec; 2usize],
    pub handle: IOSHandle,
    pub request: i32,
    pub asyncCallback: IOSAsyncCallbackFn,
    pub asyncCallbackContext: *mut ::core::ffi::c_void,
    pub copySrc: *mut ::core::ffi::c_void,
    pub copyDst: *mut ::core::ffi::c_void,
    pub copySize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMHomeButtonParams {
    pub type_: IMPadType::Type,
    pub index: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMParameters {
    pub resetEnabled: u32,
    pub dimEnabled: u32,
    pub dimPeriod: u32,
    pub apdEnabled: u32,
    pub apdPeriod: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMDeviceStateEx {
    pub state: IMDeviceState::Type,
    pub params: IMHomeButtonParams,
}
pub mod IMParameter {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_PARAMETER_INACTIVE_SECONDS: Type = 0;
    pub const IM_PARAMETER_DIM_ENABLED: Type = 1;
    pub const IM_PARAMETER_DIM_PERIOD: Type = 2;
    pub const IM_PARAMETER_APD_ENABLED: Type = 3;
    pub const IM_PARAMETER_APD_PERIOD: Type = 4;
    pub const IM_PARAMETER_RESET_ENABLE: Type = 5;
    pub const IM_PARAMETER_RESET_SECONDS: Type = 6;
    pub const IM_PARAMETER_POWER_OFF_ENABLE: Type = 7;
    pub const IM_PARAMETER_APD_OCCURED: Type = 8;
    pub const IM_PARAMETER_DIM_ENABLE_TV: Type = 9;
    pub const IM_PARAMETER_DIM_ENABLE_DRC: Type = 10;
    pub const IM_PARAMETER_MAX: Type = 11;
}
pub mod IMTimer {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_TIMER_DIM: Type = 0;
    pub const IM_TIMER_APD: Type = 1;
}
pub mod IMEvent {
    pub type Type = ::core::ffi::c_int;
    pub const IM_EVENT_ACTIVE: Type = 1;
    pub const IM_EVENT_INACTIVE: Type = 2;
    pub const IM_EVENT_DIM: Type = 4;
    pub const IM_EVENT_UNDIM: Type = 8;
    pub const IM_EVENT_APD: Type = 16;
    pub const IM_EVENT_POWER: Type = 32;
    pub const IM_EVENT_HOME: Type = 64;
    pub const IM_EVENT_SYNC: Type = 128;
    pub const IM_EVENT_RESET: Type = 256;
    pub const IM_EVENT_CANCELLED: Type = -2147483648;
}
extern "C" {
    pub fn IM_Open() -> IOSHandle;
}
extern "C" {
    pub fn IM_Close(handle: IOSHandle) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetHomeButtonParams(
        handle: IOSHandle,
        request: *mut IMRequest,
        output: *mut IMHomeButtonParams,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetParameters(parameters: *mut IMParameters) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetNvParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetNvParameterWithoutHandleAndItb(
        parameter: IMParameter::Type,
        outValue: *mut u32,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetRuntimeParameter(
        parameter: IMParameter::Type,
        outValue: *mut u32,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetTimerRemaining(
        handle: IOSHandle,
        request: *mut IMRequest,
        timer: IMTimer::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetTimerRemainingSeconds(
        timer: IMTimer::Type,
        outSeconds: *mut u32,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_SetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        value: u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_SetRuntimeParameter(parameter: IMParameter::Type, value: u32) -> IOSError::Type;
}
extern "C" {
    pub fn IM_GetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        event: *mut IMEventMask,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_CancelGetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_SetDeviceState(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: IMDeviceState::Type,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn IM_SetDeviceStateEx(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: *mut IMDeviceStateEx,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
}
extern "C" {
    pub fn __rplwrap_exit(code: ::core::ffi::c_int);
}
extern "C" {
    pub fn _Exit(code: ::core::ffi::c_int) -> !;
}
pub type IMError = i32;
extern "C" {
    pub fn IMDisableAPD() -> IMError;
}
extern "C" {
    pub fn IMDisableDim() -> IMError;
}
extern "C" {
    pub fn IMEnableAPD() -> IMError;
}
extern "C" {
    pub fn IMEnableDim() -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsAPDEnabledBySysSettings(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMIsDimEnabled(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableDRC(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimEnableTV(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetDimPeriod(outValue: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeAPD(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMGetTimeBeforeDimming(outSeconds: *mut u32) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableDRC(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMSetDimEnableTV(value: BOOL) -> IMError;
}
extern "C" {
    pub fn IMStartAPDVideoMode() -> IMError;
}
extern "C" {
    pub static mut __OSSchedulerLock: *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSEnableScheduler();
}
extern "C" {
    pub fn __OSDisableScheduler();
}
extern "C" {
    pub fn __OSLockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn __OSUnlockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSIsSchedulerLocked(lockId: *mut ::core::ffi::c_void) -> BOOL;
}
extern "C" {
    pub fn __OSTryLockScheduler(lockId: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn __OSTouchSchedulerLock();
}
extern "C" {
    pub fn DCInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCFlushRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCStoreRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCFlushRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCStoreRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCZeroRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn DCTouchRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn ICInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
}
extern "C" {
    pub fn OSMemoryBarrier();
}
pub mod OSSavedFrameType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SAVED_FRAME_A: Type = 0;
    pub const OS_SAVED_FRAME_B: Type = 1;
}
pub mod OSSavedFrameScreen {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SAVED_FRAME_SCREEN_TV: Type = 2;
    pub const OS_SAVED_FRAME_SCREEN_DRC: Type = 4;
}
extern "C" {
    pub fn __OSClearSavedFrame(
        type_: OSSavedFrameType::Type,
        screen: OSSavedFrameScreen::Type,
    ) -> u32;
}
extern "C" {
    pub fn __OSGetSavedFrame(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameA(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameB(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
}
extern "C" {
    pub fn __OSGetSavedFrameGammaA(screen: OSSavedFrameScreen::Type, outGamma: *mut f32) -> BOOL;
}
extern "C" {
    pub fn __OSGetSavedFrameGammaB(screen: OSSavedFrameScreen::Type, outGamma: *mut f32) -> BOOL;
}
extern "C" {
    pub fn __OSGetSavedFramePtr(
        type_: OSSavedFrameType::Type,
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFramePtrForRead(
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFramePtrForWrite(
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetSavedFrames() -> u32;
}
extern "C" {
    pub fn __OSGetSavedFramesA() -> u32;
}
extern "C" {
    pub fn __OSGetSavedFramesB() -> u32;
}
extern "C" {
    pub fn __OSResetSavedFrame(screen: OSSavedFrameScreen::Type);
}
extern "C" {
    pub fn __OSSetSavedFrame(
        screen: OSSavedFrameScreen::Type,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSSetSavedFrameGamma(gamma: f32, screen: OSSavedFrameScreen::Type);
}
pub mod OSInterruptType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_INTERRUPT_TYPE_ERROR: Type = 0;
    pub const OS_INTERRUPT_TYPE_DSP: Type = 1;
    pub const OS_INTERRUPT_TYPE_GPU7: Type = 2;
    pub const OS_INTERRUPT_TYPE_GPIPPC: Type = 3;
    pub const OS_INTERRUPT_TYPE_PRIMARYI2C: Type = 4;
    pub const OS_INTERRUPT_TYPE_DSPAI: Type = 5;
    pub const OS_INTERRUPT_TYPE_DSPAI2: Type = 6;
    pub const OS_INTERRUPT_TYPE_DSPACC: Type = 7;
    pub const OS_INTERRUPT_TYPE_DSPDSP: Type = 8;
    pub const OS_INTERRUPT_TYPE_IPCPPC0: Type = 9;
    pub const OS_INTERRUPT_TYPE_IPCPPC1: Type = 10;
    pub const OS_INTERRUPT_TYPE_IPCPPC2: Type = 11;
    pub const OS_INTERRUPT_TYPE_AHB: Type = 12;
}
pub type OSUserInterruptHandler = ::core::option::Option<
    unsafe extern "C" fn(type_: OSInterruptType::Type, interruptedContext: *mut OSContext),
>;
extern "C" {
    pub fn OSEnableInterrupts() -> BOOL;
}
extern "C" {
    pub fn OSDisableInterrupts() -> BOOL;
}
extern "C" {
    pub fn OSRestoreInterrupts(enable: BOOL) -> BOOL;
}
extern "C" {
    pub fn OSIsInterruptEnabled() -> BOOL;
}
extern "C" {
    pub fn __OSSetInterruptHandler(
        type_: OSInterruptType::Type,
        handler: OSUserInterruptHandler,
    ) -> OSUserInterruptHandler;
}
extern "C" {
    pub fn __OSClearAndEnableInterrupt(type_: OSInterruptType::Type);
}
extern "C" {
    pub fn __OSDisableInterrupt(type_: OSInterruptType::Type);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk113: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
extern "C" {
    pub fn OSInitCond(condition: *mut OSCondition);
}
extern "C" {
    pub fn OSInitCondEx(condition: *mut OSCondition, name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSWaitCond(condition: *mut OSCondition, mutex: *mut OSMutex);
}
extern "C" {
    pub fn OSSignalCond(condition: *mut OSCondition);
}
pub mod COSReportLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const COS_REPORT_LEVEL_ERROR: Type = 0;
    pub const COS_REPORT_LEVEL_WARN: Type = 1;
    pub const COS_REPORT_LEVEL_INFO: Type = 2;
    pub const COS_REPORT_LEVEL_VERBOSE: Type = 3;
}
pub mod COSReportModule {
    pub type Type = ::core::ffi::c_uint;
    pub const COS_REPORT_MODULE_UNKNOWN_0: Type = 0;
    pub const COS_REPORT_MODULE_UNKNOWN_1: Type = 1;
    pub const COS_REPORT_MODULE_UNKNOWN_2: Type = 2;
    pub const COS_REPORT_MODULE_UNKNOWN_5: Type = 5;
}
extern "C" {
    pub fn COSVReport(
        module: COSReportModule::Type,
        level: COSReportLevel::Type,
        fmt: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn COSError(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSInfo(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSVerbose(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn COSWarn(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
}
pub type UCError = i32;
pub type UCHandle = i32;
pub mod UCCommand {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_CMD_READ_SYS_CONFIG: Type = 48;
    pub const UC_CMD_WRITE_SYS_CONFIG: Type = 49;
    pub const UC_CMD_DELETE_SYS_CONFIG: Type = 50;
    pub const UC_CMD_QUERY_SYS_CONFIG: Type = 51;
    pub const UC_CMD_LIST_SYS_CONFIG: Type = 52;
}
pub mod UCDataType {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_DATATYPE_UNDEFINED: Type = 0;
    pub const UC_DATATYPE_UNSIGNED_BYTE: Type = 1;
    pub const UC_DATATYPE_UNSIGNED_SHORT: Type = 2;
    pub const UC_DATATYPE_UNSIGNED_INT: Type = 3;
    pub const UC_DATATYPE_SIGNED_INT: Type = 4;
    pub const UC_DATATYPE_FLOAT: Type = 5;
    pub const UC_DATATYPE_STRING: Type = 6;
    pub const UC_DATATYPE_HEXBINARY: Type = 7;
    pub const UC_DATATYPE_COMPLEX: Type = 8;
    pub const UC_DATATYPE_INVALID: Type = 255;
}
pub mod UCErrors {
    pub type Type = ::core::ffi::c_int;
    pub const UC_ERROR_OK: Type = 0;
    pub const UC_ERROR_ERROR: Type = -1;
    pub const UC_ERROR_OTHER: Type = -2097153;
    pub const UC_ERROR_SYSTEM: Type = -2097154;
    pub const UC_ERROR_ALLOC: Type = -2097155;
    pub const UC_ERROR_OPCODE: Type = -2097156;
    pub const UC_ERROR_INVALID_PARAM: Type = -2097157;
    pub const UC_ERROR_INVALID_TYPE: Type = -2097158;
    pub const UC_ERROR_UNSUPPORTED: Type = -2097159;
    pub const UC_ERROR_NON_LEAF_NODE: Type = -2097160;
    pub const UC_ERROR_KEY_NOT_FOUND: Type = -2097161;
    pub const UC_ERROR_MODIFY: Type = -2097162;
    pub const UC_ERROR_STRING_TOO_LONG: Type = -2097163;
    pub const UC_ERROR_ROOT_KEYS_DIFFER: Type = -2097164;
    pub const UC_ERROR_INVALID_LOCATION: Type = -2097165;
    pub const UC_ERROR_BAD_COMMENT: Type = -2097166;
    pub const UC_ERROR_READ_ACCESS: Type = -2097167;
    pub const UC_ERROR_WRITE_ACCESS: Type = -2097168;
    pub const UC_ERROR_CREATE_ACCESS: Type = -2097169;
    pub const UC_ERROR_FILE_SYS_NAME: Type = -2097170;
    pub const UC_ERROR_FILE_SYS_INIT: Type = -2097171;
    pub const UC_ERROR_FILE_SYS_MOUNT: Type = -2097172;
    pub const UC_ERROR_FILE_OPEN: Type = -2097173;
    pub const UC_ERROR_FILE_STAT: Type = -2097174;
    pub const UC_ERROR_FILE_READ: Type = -2097175;
    pub const UC_ERROR_FILE_WRITE: Type = -2097176;
    pub const UC_ERROR_FILE_TOO_BIG: Type = -2097177;
    pub const UC_ERROR_FILE_REMOVE: Type = -2097178;
    pub const UC_ERROR_FILE_RENAME: Type = -2097179;
    pub const UC_ERROR_FILE_CLOSE: Type = -2097180;
    pub const UC_ERROR_FILE_SEEK: Type = -2097181;
    pub const UC_ERROR_FILE_CONFIRM: Type = -2097182;
    pub const UC_ERROR_FILE_BACKUP: Type = -2097183;
    pub const UC_ERROR_MALFORMED_XML: Type = -2097184;
    pub const UC_ERROR_VERSION: Type = -2097185;
    pub const UC_ERROR_NO_IPC_BUFFERS: Type = -2097186;
    pub const UC_ERROR_FILE_LOCK_NEEDED: Type = -2097188;
    pub const UC_ERROR_SYS_PROT: Type = -2097192;
}
pub mod UCFileSys {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_FILE_SYS_INVALID: Type = 0;
    pub const UC_FILE_SYS_SYS: Type = 1;
    pub const UC_FILE_SYS_SLC: Type = 2;
    pub const UC_FILE_SYS_RAM: Type = 3;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCSysConfig {
    pub name: [::core::ffi::c_char; 64usize],
    pub access: u32,
    pub dataType: UCDataType::Type,
    pub error: UCError,
    pub dataSize: u32,
    pub data: *mut ::core::ffi::c_void,
}
pub type UCAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: UCError,
        command: UCCommand::Type,
        count: u32,
        settings: *mut UCSysConfig,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCAsyncParams {
    pub callback: UCAsyncCallbackFn,
    pub context: *mut ::core::ffi::c_void,
    pub command: UCCommand::Type,
    pub unk0x0C: u32,
    pub count: u32,
    pub settings: *mut UCSysConfig,
    pub vecs: *mut IOSVec,
}
extern "C" {
    pub fn UCOpen() -> UCHandle;
}
extern "C" {
    pub fn UCClose(handle: UCHandle) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCDeleteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCReadSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
}
extern "C" {
    pub fn UCWriteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
}
extern "C" {
    pub fn __OSClearCopyData();
}
extern "C" {
    pub fn __OSAppendCopyData(data: *const ::core::ffi::c_void, size: u32) -> BOOL;
}
extern "C" {
    pub fn __OSGetCopyDataPtr() -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __OSGetCopyDataSize() -> u32;
}
extern "C" {
    pub fn __OSResizeCopyData(size: u32) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic(ptr: *mut u32, compare: u32, value: u32) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx(ptr: *mut u32, compare: u32, value: u32, old: *mut u32)
        -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSAddAtomic(ptr: *mut i32, value: i32) -> i32;
}
extern "C" {
    pub fn OSAndAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSOrAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSXorAtomic(ptr: *mut u32, value: u32) -> u32;
}
extern "C" {
    pub fn OSTestAndClearAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic(ptr: *mut u32, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSGetCoreCount() -> u32;
}
extern "C" {
    pub fn OSGetCoreId() -> u32;
}
extern "C" {
    pub fn OSGetMainCoreId() -> u32;
}
extern "C" {
    pub fn OSIsMainCore() -> BOOL;
}
pub mod SmdLockType {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_LOCK_TYPE_MUTEX: Type = 0;
    pub const SMD_LOCK_TYPE_DISABLE_INTERRUPTS: Type = 1;
    pub const SMD_LOCK_TYPE_NONE: Type = 2;
}
pub mod SmdPpcState {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_PPC_STATE_INVALID: Type = 0;
    pub const SMD_PPC_STATE_INITIALIZED: Type = 1;
    pub const SMD_PPC_STATE_CLOSED: Type = 2;
    pub const SMD_PPC_STATE_OPENED: Type = 3;
}
pub mod SmdInterfaceState {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_INTERFACE_STATE_OPENED: Type = 8738;
    pub const SMD_INTERFACE_STATE_CLOSED: Type = 13107;
}
pub mod SmdElementType {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_ELEMENT_TYPE_MESSAGE: Type = 0;
    pub const SMD_ELEMENT_TYPE_VECTOR_SPEC: Type = 1;
    pub const SMD_ELEMENT_TYPE_VECTOR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVectorSpec {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVector {
    pub command: u32,
    pub count: i32,
    pub vecs: [SmdVectorSpec; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdElement {
    pub type_: SmdElementType::Type,
    pub size: u32,
    pub __bindgen_anon_1: SmdElement__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdElement__bindgen_ty_1 {
    pub data: [u8; 248usize],
    pub spec: SmdVector,
    pub vectorPaddr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdReceiveData {
    pub type_: SmdElementType::Type,
    pub size: u32,
    pub __bindgen_anon_1: SmdReceiveData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdReceiveData__bindgen_ty_1 {
    pub message: [u8; 128usize],
    pub spec: SmdVector,
    pub vector: *mut SmdVector,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdInterface {
    pub state: SmdInterfaceState::Type,
    pub __unk114: [::core::ffi::c_char; 124usize],
    pub elementCount: u32,
    pub __unk115: [::core::ffi::c_char; 124usize],
    pub readOffset: i32,
    pub __unk116: [::core::ffi::c_char; 124usize],
    pub writeOffset: i32,
    pub __unk117: [::core::ffi::c_char; 124usize],
    pub bufPaddr: u32,
    pub __unk118: [::core::ffi::c_char; 124usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdCtrlTable {
    pub name: [::core::ffi::c_char; 16usize],
    pub reusedCount: u32,
    pub __unk119: [::core::ffi::c_char; 108usize],
    pub iopInterface: SmdInterface,
    pub __unk120: [::core::ffi::c_char; 64usize],
    pub ppcInterface: SmdInterface,
    pub __unk121: [::core::ffi::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpcCtrlTableVectors {
    pub ctrlTable: *mut SmdCtrlTable,
    pub ctrlTableSize: u32,
    pub writeBuf: *mut SmdElement,
    pub writeBufSize: u32,
    pub readBuf: *mut SmdElement,
    pub readBufSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpc {
    pub self_: *mut SmdPpc,
    pub ctrlTable: *mut SmdCtrlTable,
    pub lockType: SmdLockType::Type,
    pub mutex: OSMutex,
    pub messageCount: u32,
    pub writeBuf: *mut SmdElement,
    pub readBuf: *mut SmdElement,
    pub state: SmdPpcState::Type,
    pub __unk122: [::core::ffi::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdSimpleBufPool {
    pub self_: *mut SmdSimpleBufPool,
    pub mutex: OSMutex,
    pub poolData: *mut ::core::ffi::c_void,
    pub poolDataSize: u32,
    pub lockType: SmdLockType::Type,
    pub allocSize: u32,
    pub realAllocSize: u32,
    pub maxAllocCount: u32,
    pub allocPoolStart: *mut ::core::ffi::c_void,
    pub allocPoolEnd: *mut ::core::ffi::c_void,
    pub elementsIn: u32,
    pub freeErrorCount: u32,
    pub __unk123: [::core::ffi::c_char; 40usize],
}
extern "C" {
    pub fn smdPpcInit(
        buf: *mut ::core::ffi::c_void,
        bufSize: u32,
        messageCount: u32,
        name: *const ::core::ffi::c_char,
        lockType: SmdLockType::Type,
    ) -> *mut SmdPpc;
}
extern "C" {
    pub fn smdPpcGetCtrlTableVectors(
        smd: *mut SmdPpc,
        outVectors: *mut SmdPpcCtrlTableVectors,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcOpen(smd: *mut SmdPpc) -> i32;
}
extern "C" {
    pub fn smdPpcClose(smd: *mut SmdPpc) -> i32;
}
extern "C" {
    pub fn smdPpcGetInterfaceState(
        smd: *mut SmdPpc,
        outPpcState: *mut SmdInterfaceState::Type,
        outIopState: *mut SmdInterfaceState::Type,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcReceive(smd: *mut SmdPpc, data: *mut SmdReceiveData) -> i32;
}
extern "C" {
    pub fn smdPpcSendMessage(
        smd: *mut SmdPpc,
        message: *mut ::core::ffi::c_void,
        messageSize: u32,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcSendVectorSpec(
        smd: *mut SmdPpc,
        command: u32,
        specs: *mut SmdVectorSpec,
        specsCount: i32,
    ) -> i32;
}
extern "C" {
    pub fn smdPpcSendVector(smd: *mut SmdPpc, vector: *mut SmdVector) -> i32;
}
extern "C" {
    pub fn smdSimpleBufPoolCreate(
        poolData: *mut ::core::ffi::c_void,
        poolDataSize: u32,
        allocSize: u32,
        allocCount: u32,
        lockType: SmdLockType::Type,
    ) -> *mut SmdSimpleBufPool;
}
extern "C" {
    pub fn smdSimpleBufAlloc(
        pool: *mut SmdSimpleBufPool,
        outAlloc: *mut *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    pub fn smdSimpleBufFree(pool: *mut SmdSimpleBufPool, alloc: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    pub fn smdSimpleBufGetStatistics(
        pool: *mut SmdSimpleBufPool,
        allocCount: *mut u32,
        freeErrorCount: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn __OSGetSavedAudioFlags() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSGetTransitionAudioBuffer(
        buffer: *mut *mut ::core::ffi::c_void,
        size: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSSetTransitionAudioSize(size: u32);
}
pub type DisassemblyPrintFn =
    ::core::option::Option<unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, ...)>;
pub type DisassemblyFindSymbolFn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32,
>;
pub mod DisassemblePPCFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const DISASSEMBLE_PPC_FLAGS_NONE: Type = 0;
}
extern "C" {
    pub fn OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
}
extern "C" {
    pub fn __OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
}
extern "C" {
    pub fn OSReport(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportVerbose(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportInfo(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSReportWarn(fmt: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn OSPanic(
        file: *const ::core::ffi::c_char,
        line: u32,
        fmt: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn OSFatal(msg: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn OSGetSymbolName(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32;
}
extern "C" {
    pub fn OSGetUPID() -> u32;
}
extern "C" {
    pub fn OSIsDebuggerInitialized() -> BOOL;
}
extern "C" {
    pub fn OSIsDebuggerPresent() -> BOOL;
}
extern "C" {
    pub fn OSIsECOBoot() -> BOOL;
}
extern "C" {
    pub fn OSIsECOMode() -> BOOL;
}
extern "C" {
    pub fn __OSSetCrashRecovery(crashRecovery: u32);
}
extern "C" {
    pub fn __OSGetCrashRecovery() -> u32;
}
extern "C" {
    pub fn DisassemblePPCOpcode(
        opcode: *mut u32,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn DisassemblePPCRange(
        start: *mut ::core::ffi::c_void,
        end: *mut ::core::ffi::c_void,
        printFn: DisassemblyPrintFn,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    );
}
pub type BSPError = i32;
pub type BSPHardwareVersion = u32;
pub type BSPConsoleTypeRaw = u32;
pub mod BSPErrors {
    pub type Type = ::core::ffi::c_uint;
    pub const BSP_ERROR_OK: Type = 0;
    pub const BSP_ERROR_IOS_ERROR: Type = 64;
    pub const BSP_ERROR_RESPONSE_TOO_LARGE: Type = 128;
}
pub mod BSPHardwareVersions {
    pub type Type = ::core::ffi::c_uint;
    pub const BSP_HARDWARE_VERSION_UNKNOWN: Type = 0;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_1: Type = 1;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_2: Type = 268435457;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_PROD_FOR_WII: Type = 269484033;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO: Type = 269484040;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO_ESPRESSO: Type = 269484044;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD: Type = 536870913;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD_PROD_FOR_WII: Type = 537919489;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_EV: Type = 554696720;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_CAT: Type = 554696736;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_EV: Type = 555745296;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_CAT: Type = 555745312;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_EV: Type = 571473936;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_CAT: Type = 571473952;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_EV: Type = 588251152;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAT: Type = 588251168;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAFE: Type = 588251176;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_EV: Type = 605028368;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAT: Type = 605028384;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAFE: Type = 605028392;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV: Type = 621805584;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV_Y: Type = 621805585;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAT: Type = 621805600;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAFE: Type = 621805608;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV: Type = 638582800;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV_Y: Type = 638582801;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAT: Type = 638582816;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAFE: Type = 638582824;
}
extern "C" {
    pub fn bspInitializeShimInterface() -> BSPError;
}
extern "C" {
    pub fn bspShutdownShimInterface() -> BSPError;
}
extern "C" {
    pub fn bspGetHardwareVersion(version: *mut BSPHardwareVersion) -> BSPError;
}
extern "C" {
    pub fn bspGetConsoleTypeRaw(consoleTypeRaw: *mut BSPConsoleTypeRaw) -> BSPError;
}
extern "C" {
    pub fn bspInitialize(
        entityName: *const ::core::ffi::c_char,
        instance: u32,
        attributeName: *const ::core::ffi::c_char,
        optionSize: u32,
        pOptions: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspShutdown(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
    ) -> BSPError;
}
extern "C" {
    pub fn bspGetEntityVersion(
        entityName: *const ::core::ffi::c_char,
        entityVersion: *mut u32,
    ) -> BSPError;
}
extern "C" {
    pub fn bspRead(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspWrite(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn bspQuery(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
}
extern "C" {
    pub fn OSEnableForegroundExit();
}
extern "C" {
    pub fn OSReleaseForeground();
}
extern "C" {
    pub fn OSSavesDone_ReadyToRelease();
}
extern "C" {
    pub fn OSGetAtomic64(ptr: *mut u64) -> u64;
}
extern "C" {
    pub fn OSSetAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSCompareAndSwapAtomic64(ptr: *mut u64, compare: u64, value: u64) -> BOOL;
}
extern "C" {
    pub fn OSCompareAndSwapAtomicEx64(
        ptr: *mut u64,
        compare: u64,
        value: u64,
        old: *mut u64,
    ) -> BOOL;
}
extern "C" {
    pub fn OSSwapAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSAddAtomic64(ptr: *mut i64, value: i64) -> i64;
}
extern "C" {
    pub fn OSAndAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSOrAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSXorAtomic64(ptr: *mut u64, value: u64) -> u64;
}
extern "C" {
    pub fn OSTestAndClearAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
extern "C" {
    pub fn OSTestAndSetAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
}
extern "C" {
    pub fn __os_snprintf(
        buf: *mut ::core::ffi::c_char,
        n: usize,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
pub type MPTaskFunc = ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32) -> u32>;
pub mod MPTaskState {
    pub type Type = ::core::ffi::c_uint;
    pub const MP_TASK_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_STATE_READY: Type = 2;
    pub const MP_TASK_STATE_RUNNING: Type = 4;
    pub const MP_TASK_STATE_FINISHED: Type = 8;
}
pub mod MPTaskQueueState {
    pub type Type = ::core::ffi::c_uint;
    pub const MP_TASK_QUEUE_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_QUEUE_STATE_READY: Type = 2;
    pub const MP_TASK_QUEUE_STATE_STOPPING: Type = 4;
    pub const MP_TASK_QUEUE_STATE_STOPPED: Type = 8;
    pub const MP_TASK_QUEUE_STATE_FINISHED: Type = 16;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskInfo {
    pub state: MPTaskState::Type,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTask {
    pub self_: *mut MPTask,
    pub queue: *mut MPTaskQueue,
    pub state: MPTaskState::Type,
    pub func: MPTaskFunc,
    pub userArg1: u32,
    pub userArg2: u32,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
    pub userData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueueInfo {
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub tasksFinished: u32,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueue {
    pub self_: *mut MPTaskQueue,
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub __unk124: [::core::ffi::c_char; 4usize],
    pub tasksFinished: u32,
    pub __unk125: [::core::ffi::c_char; 8usize],
    pub queueIndex: u32,
    pub __unk126: [::core::ffi::c_char; 8usize],
    pub queueSize: u32,
    pub __unk127: [::core::ffi::c_char; 4usize],
    pub queue: *mut *mut MPTask,
    pub queueMaxSize: u32,
    pub lock: OSSpinLock,
}
extern "C" {
    pub fn MPInitTaskQ(queue: *mut MPTaskQueue, queueBuffer: *mut *mut MPTask, queueBufferLen: u32);
}
extern "C" {
    pub fn MPTermTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskQInfo(queue: *mut MPTaskQueue, info: *mut MPTaskQueueInfo) -> BOOL;
}
extern "C" {
    pub fn MPStartTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPStopTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPResetTaskQ(queue: *mut MPTaskQueue) -> BOOL;
}
extern "C" {
    pub fn MPEnqueTask(queue: *mut MPTaskQueue, task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPDequeTask(queue: *mut MPTaskQueue) -> *mut MPTask;
}
extern "C" {
    pub fn MPDequeTasks(
        queue: *mut MPTaskQueue,
        queueBuffer: *mut *mut MPTask,
        queueBufferLen: u32,
    ) -> u32;
}
extern "C" {
    pub fn MPWaitTaskQ(queue: *mut MPTaskQueue, mask: MPTaskQueueState::Type) -> BOOL;
}
extern "C" {
    pub fn MPWaitTaskQWithTimeout(
        queue: *mut MPTaskQueue,
        wmask: MPTaskQueueState::Type,
        timeout: OSTime,
    ) -> BOOL;
}
extern "C" {
    pub fn MPPrintTaskQStats(queue: *mut MPTaskQueue, unk: u32) -> BOOL;
}
extern "C" {
    pub fn MPInitTask(task: *mut MPTask, func: MPTaskFunc, userArg1: u32, userArg2: u32);
}
extern "C" {
    pub fn MPTermTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskInfo(task: *mut MPTask, info: *mut MPTaskInfo) -> BOOL;
}
extern "C" {
    pub fn MPGetTaskUserData(task: *mut MPTask) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn MPSetTaskUserData(task: *mut MPTask, userData: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn MPRunTasksFromTaskQ(queue: *mut MPTaskQueue, count: u32) -> BOOL;
}
extern "C" {
    pub fn MPRunTask(task: *mut MPTask) -> BOOL;
}
extern "C" {
    pub fn OSForceFullRelaunch();
}
extern "C" {
    pub fn OSRestartGame(argc: ::core::ffi::c_int, argv: *mut *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn OSShutdown() -> BOOL;
}
extern "C" {
    pub fn OSLaunchTitleByPathl(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        ...
    );
}
extern "C" {
    pub fn OSLaunchTitleByPathv(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSLaunchTitlel(titleId: u64, argc: ::core::ffi::c_int, ...);
}
extern "C" {
    pub fn OSLaunchTitlev(
        titleId: u64,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
}
pub mod OSMemoryMapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MAP_MEMORY_INVALID: Type = 0;
    pub const OS_MAP_MEMORY_READ_ONLY: Type = 1;
    pub const OS_MAP_MEMORY_READ_WRITE: Type = 2;
    pub const OS_MAP_MEMORY_FREE: Type = 3;
    pub const OS_MAP_MEMORY_ALLOCATED: Type = 4;
}
extern "C" {
    pub fn OSEffectiveToPhysical(virtualAddress: u32) -> u32;
}
extern "C" {
    pub fn __OSPhysicalToEffectiveCached(physicalAddress: u32) -> u32;
}
extern "C" {
    pub fn __OSPhysicalToEffectiveUncached(physicalAddress: u32) -> u32;
}
extern "C" {
    pub fn OSIsAddressValid(virtualAddress: u32) -> BOOL;
}
extern "C" {
    pub fn __OSValidateAddressSpaceRange(
        arg1: ::core::ffi::c_int,
        virtualAddress: u32,
        size: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn OSAllocVirtAddr(virtualAddress: u32, size: u32, align: u32) -> u32;
}
extern "C" {
    pub fn OSFreeVirtAddr(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    pub fn OSQueryVirtAddr(virtualAddress: u32) -> OSMemoryMapMode::Type;
}
extern "C" {
    pub fn OSMapMemory(
        virtualAddress: u32,
        physicalAddress: u32,
        size: u32,
        mode: OSMemoryMapMode::Type,
    ) -> BOOL;
}
extern "C" {
    pub fn OSUnmapMemory(virtualAddress: u32, size: u32) -> BOOL;
}
extern "C" {
    pub fn OSGetMapVirtAddrRange(outVirtualAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    pub fn OSGetAvailPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
extern "C" {
    pub fn OSGetDataPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
}
pub type FSACommand = u32;
pub type FSAIpcRequestType = u16;
pub type FSAClientHandle = IOSHandle;
pub type FSAFileHandle = u32;
pub type FSADirectoryHandle = u32;
pub type FSAEntryNum = u32;
pub type FSADirectoryEntry = FSDirectoryEntry;
pub type FSAStat = FSStat;
pub type FSAFilePosition = u32;
pub type FSAVolumeInfo = FSVolumeInfo;
pub type FSAAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError::Type,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSABlockInfo {
    pub __unk128: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSADeviceInfo {
    pub __unk129: [::core::ffi::c_char; 8usize],
    pub deviceSizeInSectors: u64,
    pub deviceSectorSize: u32,
    pub __unk130: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAFileSystemInfo {
    pub __unk131: [::core::ffi::c_char; 30usize],
}
pub mod FSAMountPriority {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_MOUNT_PRIORITY_BASE: Type = 1;
    pub const FSA_MOUNT_PRIORITY_RAM_DISK_CACHE: Type = 4;
    pub const FSA_MOUNT_PRIORITY_TITLE_UPDATE: Type = 9;
    pub const FSA_MOUNT_PRIORITY_UNMOUNT_ALL: Type = 2147483648;
}
pub mod FSAQueryInfoType {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_QUERY_INFO_FREE_SPACE_SIZE: Type = 0;
    pub const FSA_QUERY_INFO_DIR_SIZE: Type = 1;
    pub const FSA_QUERY_INFO_ENTRY_NUM: Type = 2;
    pub const FSA_QUERY_INFO_FILE_SYSTEM_INFO: Type = 3;
    pub const FSA_QUERY_INFO_DEVICE_INFO: Type = 4;
    pub const FSA_QUERY_INFO_STAT: Type = 5;
    pub const FSA_QUERY_INFO_BAD_BLOCK_INFO: Type = 6;
    pub const FSA_QUERY_INFO_JOURNAL_FREE_SPACE_SIZE: Type = 7;
    pub const FSA_QUERY_INFO_FRAGMENT_BLOCK_INFO: Type = 8;
}
pub mod FSAReadFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_READ_FLAG_NONE: Type = 0;
    pub const FSA_READ_FLAG_READ_WITH_POS: Type = 1;
}
pub mod FSAWriteFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_WRITE_FLAG_NONE: Type = 0;
    pub const FSA_WRITE_FLAG_READ_WITH_POS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAProcessInfo {
    pub titleId: u64,
    pub processId: u32,
    pub groupId: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawOpen {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawClose {
    pub handle: i32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawRead {
    pub __unk132: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawWrite {
    pub __unk133: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestAppendFile {
    pub size: u32,
    pub count: u32,
    pub handle: FSAFileHandle,
    pub unk0x0C: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeDir {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeMode {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode1: u32,
    pub mode2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestCloseDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestCloseFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestFlushFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestFlushQuota {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestGetInfoByQuery {
    pub path: [::core::ffi::c_char; 640usize],
    pub type_: FSAQueryInfoType::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestGetPosFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestIsEof {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeDir {
    pub path: [::core::ffi::c_char; 640usize],
    pub permission: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeQuota {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: u32,
    pub size: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMount {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub unk0x500: u32,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority::Type,
    pub process: FSAProcessInfo,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenDir {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenFile {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: [::core::ffi::c_char; 16usize],
    pub unk0x290: u32,
    pub unk0x294: u32,
    pub unk0x298: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestReadDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestReadFile {
    pub buffer: *mut u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub readFlags: FSAReadFlag::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRemove {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRename {
    pub oldPath: [::core::ffi::c_char; 640usize],
    pub newPath: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRewindDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestSetPosFile {
    pub handle: FSAFileHandle,
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestStatFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestTruncateFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmount {
    pub path: [::core::ffi::c_char; 640usize],
    pub unk0x280: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority::Type,
    pub process: FSAProcessInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestWriteFile {
    pub buffer: *const u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub writeFlags: FSAWriteFlag::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeOwner {
    pub path: [::core::ffi::c_char; 640usize],
    pub __unk134: [::core::ffi::c_char; 4usize],
    pub owner: u32,
    pub __unk135: [::core::ffi::c_char; 4usize],
    pub group: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSARequest {
    pub emulatedError: FSError::Type,
    pub __bindgen_anon_1: FSARequest__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSARequest__bindgen_ty_1 {
    pub rawOpen: FSARequestRawOpen,
    pub rawClose: FSARequestRawClose,
    pub rawRead: FSARequestRawRead,
    pub rawWrite: FSARequestRawWrite,
    pub appendFile: FSARequestAppendFile,
    pub changeDir: FSARequestChangeDir,
    pub changeMode: FSARequestChangeMode,
    pub closeDir: FSARequestCloseDir,
    pub closeFile: FSARequestCloseFile,
    pub flushFile: FSARequestFlushFile,
    pub flushQuota: FSARequestFlushQuota,
    pub getInfoByQuery: FSARequestGetInfoByQuery,
    pub getPosFile: FSARequestGetPosFile,
    pub isEof: FSARequestIsEof,
    pub makeDir: FSARequestMakeDir,
    pub makeQuota: FSARequestMakeQuota,
    pub mount: FSARequestMount,
    pub mountWithProcess: FSARequestMountWithProcess,
    pub openDir: FSARequestOpenDir,
    pub openFile: FSARequestOpenFile,
    pub readDir: FSARequestReadDir,
    pub readFile: FSARequestReadFile,
    pub remove: FSARequestRemove,
    pub rename: FSARequestRename,
    pub rewindDir: FSARequestRewindDir,
    pub setPosFile: FSARequestSetPosFile,
    pub statFile: FSARequestStatFile,
    pub truncateFile: FSARequestTruncateFile,
    pub unmount: FSARequestUnmount,
    pub unmountWithProcess: FSARequestUnmountWithProcess,
    pub writeFile: FSARequestWriteFile,
    pub changeOwner: FSARequestChangeOwner,
    pub __unk136: [::core::ffi::c_char; 1308usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseRawOpen {
    pub handle: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetCwd {
    pub path: [::core::ffi::c_char; 640usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetFileBlockAddress {
    pub address: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetPosFile {
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetVolumeInfo {
    pub volumeInfo: FSAVolumeInfo,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponseGetInfoByQuery {
    pub __bindgen_anon_1: FSAResponseGetInfoByQuery__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponseGetInfoByQuery__bindgen_ty_1 {
    pub badBlockInfo: FSABlockInfo,
    pub deviceInfo: FSADeviceInfo,
    pub dirSize: u64,
    pub entryNum: FSAEntryNum,
    pub fileSystemInfo: FSAFileSystemInfo,
    pub fragmentBlockInfo: FSABlockInfo,
    pub freeSpaceSize: u64,
    pub journalFreeSpaceSize: u64,
    pub stat: FSAStat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseOpenFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseOpenDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseReadDir {
    pub entry: FSADirectoryEntry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseStatFile {
    pub stat: FSAStat,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponse {
    pub word0: u32,
    pub __bindgen_anon_1: FSAResponse__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponse__bindgen_ty_1 {
    pub rawOpen: FSAResponseRawOpen,
    pub getCwd: FSAResponseGetCwd,
    pub getFileBlockAddress: FSAResponseGetFileBlockAddress,
    pub getPosFile: FSAResponseGetPosFile,
    pub getVolumeInfo: FSAResponseGetVolumeInfo,
    pub getInfoByQuery: FSAResponseGetInfoByQuery,
    pub openDir: FSAResponseOpenDir,
    pub openFile: FSAResponseOpenFile,
    pub readDir: FSAResponseReadDir,
    pub statFile: FSAResponseStatFile,
    pub __unk137: [::core::ffi::c_char; 655usize],
}
pub mod FSACommandEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_COMMAND_INVALID: Type = 0;
    pub const FSA_COMMAND_MOUNT: Type = 1;
    pub const FSA_COMMAND_UNMOUNT: Type = 2;
    pub const FSA_COMMAND_GET_VOLUME_INFO: Type = 3;
    pub const FSA_COMMAND_GET_ATTACH: Type = 4;
    pub const FSA_COMMAND_CHANGE_DIR: Type = 5;
    pub const FSA_COMMAND_GET_CWD: Type = 6;
    pub const FSA_COMMAND_MAKE_DIR: Type = 7;
    pub const FSA_COMMAND_REMOVE: Type = 8;
    pub const FSA_COMMAND_RENAME: Type = 9;
    pub const FSA_COMMAND_OPEN_DIR: Type = 10;
    pub const FSA_COMMAND_READ_DIR: Type = 11;
    pub const FSA_COMMAND_REWIND_DIR: Type = 12;
    pub const FSA_COMMAND_CLOSE_DIR: Type = 13;
    pub const FSA_COMMAND_OPEN_FILE: Type = 14;
    pub const FSA_COMMAND_READ_FILE: Type = 15;
    pub const FSA_COMMAND_WRITE_FILE: Type = 16;
    pub const FSA_COMMAND_GET_POS_FILE: Type = 17;
    pub const FSA_COMMAND_SET_POS_FILE: Type = 18;
    pub const FSA_COMMAND_IS_EOF: Type = 19;
    pub const FSA_COMMAND_STAT_FILE: Type = 20;
    pub const FSA_COMMAND_CLOSE_FILE: Type = 21;
    pub const FSA_COMMAND_GET_ERROR: Type = 22;
    pub const FSA_COMMAND_FLUSH_FILE: Type = 23;
    pub const FSA_COMMAND_GET_INFO_BY_QUERY: Type = 24;
    pub const FSA_COMMAND_APPEND_FILE: Type = 25;
    pub const FSA_COMMAND_TRUNCATE_FILE: Type = 26;
    pub const FSA_COMMAND_FLUSH_VOLUME: Type = 27;
    pub const FSA_COMMAND_ROLLBACK_VOLUME: Type = 28;
    pub const FSA_COMMAND_MAKE_QUOTA: Type = 29;
    pub const FSA_COMMAND_FLUSH_QUOTA: Type = 30;
    pub const FSA_COMMAND_ROLLBACK_QUOTA: Type = 31;
    pub const FSA_COMMAND_CHANGE_MODE: Type = 32;
    pub const FSA_COMMAND_OPEN_FILE_BY_STAT: Type = 33;
    pub const FSA_COMMAND_REGISTER_FLUSH_QUOTA: Type = 34;
    pub const FSA_COMMAND_FLUSH_MULTI_QUOTA: Type = 35;
    pub const FSA_COMMAND_GET_FILE_BLOCK_ADDRESS: Type = 37;
    pub const FSA_COMMAND_ADD_USER_PROCESS: Type = 101;
    pub const FSA_COMMAND_DEL_USER_PROCESS: Type = 102;
    pub const FSA_COMMAND_MOUNT_WITH_PROCESS: Type = 103;
    pub const FSA_COMMAND_UNMOUNT_WITH_PROCESS: Type = 104;
    pub const FSA_COMMAND_FORMAT: Type = 105;
    pub const FSA_COMMAND_RAW_OPEN: Type = 106;
    pub const FSA_COMMAND_RAW_READ: Type = 107;
    pub const FSA_COMMAND_RAW_WRITE: Type = 108;
    pub const FSA_COMMAND_RAW_CLOSE: Type = 109;
    pub const FSA_COMMAND_GET_LAST_FAILED_VOLUME: Type = 110;
    pub const FSA_COMMAND_GET_VOLUME_EXISTENCE: Type = 111;
    pub const FSA_COMMAND_CHANGE_OWNER: Type = 112;
    pub const FSA_COMMAND_CANCEL_GET_ATTACH: Type = 113;
    pub const FSA_COMMAND_REMOVE_QUOTA: Type = 114;
    pub const FSA_COMMAND_SET_CLIENT_PRIORITY: Type = 115;
    pub const FSA_COMMAND_APPLY_MEMORY_CACHE: Type = 116;
    pub const FSA_COMMAND_MAKE_LINK: Type = 117;
    pub const FSA_COMMAND_XFER_PARAMS: Type = 118;
    pub const FSA_COMMAND_EXEC_DEBUG_PROC: Type = 120;
    pub const FSA_COMMAND_DEBUG_SET_TITLE_ID: Type = 121;
    pub const FSA_COMMAND_DEBUG_SET_CAPABILITY: Type = 122;
    pub const FSA_COMMAND_SET_PROCESS_CONFIG: Type = 130;
    pub const FSA_COMMAND_CONFIG_SET_MEMORY_CACHE: Type = 131;
    pub const FSA_COMMAND_CONFIG_UNSET_MEMORY_CACHE: Type = 132;
    pub const FSA_COMMAND_CONFIG_SET_PRF2_CHAR_CODE: Type = 133;
    pub const FSA_COMMAND_GET_PROC_RESOURCE_USAGE: Type = 140;
    pub const FSA_COMMAND_GET_ALL_RESOURCE_USAGE: Type = 141;
    pub const FSA_COMMAND_SEND_PROFILE_CMD: Type = 142;
}
pub mod FSAIpcRequestTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_IPC_REQUEST_IOCTL: Type = 0;
    pub const FSA_IPC_REQUEST_IOCTLV: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAAsyncResult {
    pub ioMsgQueue: *mut OSMessageQueue,
    pub msg: FSMessage,
    pub userCallback: FSAAsyncCallbackFn,
    pub error: FSError::Type,
    pub command: FSACommand,
    pub request: *mut FSARequest,
    pub response: *mut FSAResponse,
    pub userContext: *mut ::core::ffi::c_void,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAShimBuffer {
    pub request: FSARequest,
    pub __unk138: [::core::ffi::c_char; 96usize],
    pub response: FSAResponse,
    pub __unk139: [::core::ffi::c_char; 109usize],
    pub ioctlvVec: [IOSVec; 3usize],
    pub __unk140: [::core::ffi::c_char; 92usize],
    pub command: FSACommand,
    pub clientHandle: u32,
    pub ipcReqType: FSAIpcRequestType,
    pub ioctlvVecIn: u8,
    pub ioctlvVecOut: u8,
    pub fsaAsyncResult: FSAAsyncResult,
}
pub type FSAClientAttachAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError::Type,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAClientAttachAsyncData {
    pub userCallback: FSAClientAttachAsyncCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
pub mod FSAMountFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_MOUNT_FLAG_LOCAL_MOUNT: Type = 0;
    pub const FSA_MOUNT_FLAG_BIND_MOUNT: Type = 1;
    pub const FSA_MOUNT_FLAG_GLOBAL_MOUNT: Type = 2;
}
pub mod FSAUnmountFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_UNMOUNT_FLAG_NONE: Type = 0;
    pub const FSA_UNMOUNT_FLAG_FORCE: Type = 2;
    pub const FSA_UNMOUNT_FLAG_BIND_MOUNT: Type = 2147483648;
}
extern "C" {
    pub fn FSAInit() -> FSError::Type;
}
extern "C" {
    pub fn FSAShutdown();
}
extern "C" {
    pub fn FSAGetClientNum() -> u32;
}
extern "C" {
    pub fn FSAAddClient(attachAsyncData: *mut FSAClientAttachAsyncData) -> FSAClientHandle;
}
extern "C" {
    pub fn FSADelClient(client: FSAClientHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetStatusStr(error: FSError::Type) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn __FSAShimDecodeIosErrorToFsaStatus(
        handle: IOSHandle,
        err: IOSError::Type,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAFlushMultiQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAFlushQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAFlushVolume(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAFreeAsyncResult(asyncResult: *mut FSAAsyncResult);
}
extern "C" {
    pub fn FSAGetAsyncResult(asyncResult: *mut OSMessage) -> FSAAsyncResult;
}
extern "C" {
    pub fn FSAMount(
        client: FSAClientHandle,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        flags: FSAMountFlags::Type,
        arg_buf: *mut ::core::ffi::c_void,
        arg_len: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAUnmount(
        client: FSAClientHandle,
        mountedTarget: *const ::core::ffi::c_char,
        flags: FSAUnmountFlags::Type,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAChangeDir(client: FSAClientHandle, path: *const ::core::ffi::c_char)
        -> FSError::Type;
}
extern "C" {
    pub fn FSAChangeMode(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        permission: FSMode::Type,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAOpenFileEx(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAOpenFileByStat(
        client: FSAClientHandle,
        stat: *mut FSAStat,
        mode: *const ::core::ffi::c_char,
        path: *const ::core::ffi::c_char,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetStatFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        stat: *mut FSAStat,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetStat(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        stat: *mut FSAStat,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSACloseFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSAAppendFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAAppendFileEx(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
        flags: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetPosFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        outPos: *mut u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAFlushFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSASetPosFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        pos: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSATruncateFile(client: FSAClientHandle, handle: FSAFileHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSAWriteFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAWriteFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAIsEof(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSAReadFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAReadFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARemove(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError::Type;
}
extern "C" {
    pub fn FSARename(
        client: FSAClientHandle,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAOpenDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        dirHandle: *mut FSADirectoryHandle,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAReadDir(
        client: FSAClientHandle,
        dirHandle: FSADirectoryHandle,
        directoryEntry: *mut FSADirectoryEntry,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARewindDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSACloseDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError::Type;
}
extern "C" {
    pub fn FSAMakeDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetCwd(
        client: FSAClientHandle,
        outPath: *mut ::core::ffi::c_char,
        outPathLen: u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetTransactionBlockPoolAttributes(
        messageSize: *mut u32,
        poolSize: *mut u32,
        numMessages: *mut u32,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetVolumeInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        outVolumeInfo: *mut FSAVolumeInfo,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAMakeQuota(
        client: FSAClientHandle,
        name: *const ::core::ffi::c_char,
        mode: u32,
        quota: u64,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARegisterFlushQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARollbackQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARollbackQuotaForce(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSARollbackVolume(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeSpaceSize: *mut u64,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetJournalFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        journalFreeSpaceSize: *mut u64,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetDirSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeDirSize: *mut u64,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetEntryNum(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        entryNum: *mut FSAEntryNum,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetFileSystemInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSAFileSystemInfo,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetDeviceInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSADeviceInfo,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetBadBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError::Type;
}
extern "C" {
    pub fn FSAGetFragmentBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSStopWatchAtomic {
    pub startTime: OSTime,
    pub totalTime: OSTime,
}
extern "C" {
    pub fn OSStopWatchStart(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchStop(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchLap(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
extern "C" {
    pub fn OSStopWatchReset(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
}
pub mod OSPerfMonArg {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_ARG_MMCR0: Type = 1;
    pub const OS_PM_ARG_MMCR1: Type = 2;
    pub const OS_PM_ARG_PMC1: Type = 4;
    pub const OS_PM_ARG_PMC2: Type = 8;
    pub const OS_PM_ARG_PMC3: Type = 16;
    pub const OS_PM_ARG_PMC4: Type = 32;
}
pub mod OSPerfMonMMCR0Flags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_MMCR0_PMC1_CURRENT: Type = 0;
    pub const OS_PM_MMCR0_PMC1_CPU_CYCLES: Type = 64;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED: Type = 128;
    pub const OS_PM_MMCR0_PMC1_TBL_RISING_TRANSITIONS: Type = 192;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_DISPATCHED: Type = 256;
    pub const OS_PM_MMCR0_PMC1_EIEIO_INSTRUCTIONS_COMPLETED: Type = 320;
    pub const OS_PM_MMCR0_PMC1_ITLB_SEARCH_CYCLES: Type = 384;
    pub const OS_PM_MMCR0_PMC1_L2_HITS: Type = 448;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_EA_DELIVERED: Type = 512;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED_MATCHES_IABR: Type = 576;
    pub const OS_PM_MMCR0_PMC1_SLOW_L1_MISSES: Type = 640;
    pub const OS_PM_MMCR0_PMC1_UNRESOLVED_BRANCHES: Type = 704;
    pub const OS_PM_MMCR0_PMC1_UNRESOLVED_STALL_CYCLES: Type = 768;
    pub const OS_PM_MMCR0_PMC1_L1_SHARED_STORES: Type = 896;
    pub const OS_PM_MMCR0_PMC1_L2_SHARED_INTERVENTIONS: Type = 960;
    pub const OS_PM_MMCR0_PMC1_CACHE_PARADOXES: Type = 1024;
    pub const OS_PM_MMCR0_PMC1_CIU_LOAD_REQUESTS: Type = 1280;
    pub const OS_PM_MMCR0_PMC1_BIU_ADDRESS_ONLY_REQUESTS: Type = 1344;
    pub const OS_PM_MMCR0_PMC1_CIU_PARADOXES: Type = 1408;
    pub const OS_PM_MMCR0_PMC1_60XE_BUS_DATA_BEATS: Type = 1472;
    pub const OS_PM_MMCR0_PMC2_CURRENT: Type = 0;
    pub const OS_PM_MMCR0_PMC2_CPU_CYCLES: Type = 1;
    pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_COMPLETED: Type = 2;
    pub const OS_PM_MMCR0_PMC2_TBL_RISING_TRANSITIONS: Type = 3;
    pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_DISPATCHED: Type = 4;
    pub const OS_PM_MMCR0_PMC2_L1_ICACHE_MISSES: Type = 5;
    pub const OS_PM_MMCR0_PMC2_ITLB_MISSES: Type = 6;
    pub const OS_PM_MMCR0_PMC2_L2_INSTRUCTION_MISSES: Type = 7;
    pub const OS_PM_MMCR0_PMC2_PRED_BRANCHES_NOT_TAKEN: Type = 8;
    pub const OS_PM_MMCR0_PMC2_RESERVED_LOADS: Type = 10;
    pub const OS_PM_MMCR0_PMC2_LOADS_AND_STORES: Type = 11;
    pub const OS_PM_MMCR0_PMC2_CACHE_SNOOPS: Type = 12;
    pub const OS_PM_MMCR0_PMC2_L1_TO_L2_CASTOUTS: Type = 13;
    pub const OS_PM_MMCR0_PMC2_SYSTEM_UNIT_INSTRUCTIONS: Type = 14;
    pub const OS_PM_MMCR0_PMC2_L1_INSTRUCTION_MISS_CYCLES: Type = 15;
    pub const OS_PM_MMCR0_PMC2_FIRST_SPECULATIVE_BRANCH_RESOLVES: Type = 16;
    pub const OS_PM_MMCR0_PMC2_L2_SHARED_STORES: Type = 17;
    pub const OS_PM_MMCR0_PMC2_L1_SHARED_INTERVENTIONS: Type = 18;
    pub const OS_PM_MMCR0_PMC2_CIU_STORE_REQUESTS: Type = 20;
    pub const OS_PM_MMCR0_PMC2_SLOW_OUTSTANDING_BIU_TRANSACTIONS: Type = 21;
    pub const OS_PM_MMCR0_PMC2_CIU_MODIFIED_INTERVENTIONS: Type = 22;
}
pub mod OSPerfMonMMCR1Flags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_MMCR1_PMC3_CURRENT: Type = 0;
    pub const OS_PM_MMCR1_PMC3_CPU_CYCLES: Type = 134217728;
    pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_COMPLETED: Type = 268435456;
    pub const OS_PM_MMCR1_PMC3_TBL_RISING_TRANSITIONS: Type = 402653184;
    pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_DISPATCHED: Type = 536870912;
    pub const OS_PM_MMCR1_PMC3_L1_DCACHE_MISSES: Type = 671088640;
    pub const OS_PM_MMCR1_PMC3_DTLB_MISSES: Type = 805306368;
    pub const OS_PM_MMCR1_PMC3_L2_DATA_MISSES: Type = 939524096;
    pub const OS_PM_MMCR1_PMC3_PRED_BRANCHES_TAKEN: Type = 1073741824;
    pub const OS_PM_MMCR1_PMC3_COND_STORES_COMPLETED: Type = 1342177280;
    pub const OS_PM_MMCR1_PMC3_FPU_INSTRUCTIONS_COMPLETED: Type = 1476395008;
    pub const OS_PM_MMCR1_PMC3_L2_CASTOUTS_BY_SNOOPS: Type = 1610612736;
    pub const OS_PM_MMCR1_PMC3_L2_CACHE_OPERATIONS: Type = 1744830464;
    pub const OS_PM_MMCR1_PMC3_L1_LOAD_MISS_CYCLES: Type = 2013265920;
    pub const OS_PM_MMCR1_PMC3_SECOND_SPECULATIVE_BRANCH_RESOLVES: Type = 2147483648;
    pub const OS_PM_MMCR1_PMC3_BPU_STALL_LR_CR_CYCLES: Type = 2281701376;
    pub const OS_PM_MMCR1_PMC3_L1_MODIFIED_INTERVENTIONS: Type = 2415919104;
    pub const OS_PM_MMCR1_PMC3_ICBI_SNOOPS: Type = 2550136832;
    pub const OS_PM_MMCR1_PMC3_CIU_ADDRESS_ONLY_REQUESTS: Type = 2684354560;
    pub const OS_PM_MMCR1_PMC3_BIU_LOAD_REQUESTS: Type = 2818572288;
    pub const OS_PM_MMCR1_PMC3_CIU_SHARED_INTERVENTIONS: Type = 2952790016;
    pub const OS_PM_MMCR1_PMC4_CURRENT: Type = 0;
    pub const OS_PM_MMCR1_PMC4_CPU_CYCLES: Type = 4194304;
    pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_COMPLETED: Type = 8388608;
    pub const OS_PM_MMCR1_PMC4_TBL_RISING_TRANSITIONS: Type = 12582912;
    pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_DISPATCHED: Type = 16777216;
    pub const OS_PM_MMCR1_PMC4_L2_CASTOUTS: Type = 20971520;
    pub const OS_PM_MMCR1_PMC4_DTLB_SEARCH_CYCLES: Type = 25165824;
    pub const OS_PM_MMCR1_PMC4_BRANCHES_MISPREDICTED: Type = 33554432;
    pub const OS_PM_MMCR1_PMC4_INTACT_COND_STORES_COMPLETED: Type = 41943040;
    pub const OS_PM_MMCR1_PMC4_SYNC_INSTRUCTIONS_COMPLETED: Type = 46137344;
    pub const OS_PM_MMCR1_PMC4_SNOOP_RETRIES: Type = 50331648;
    pub const OS_PM_MMCR1_PMC4_INTEGER_OPERATIONS: Type = 54525952;
    pub const OS_PM_MMCR1_PMC4_BPU_STALL_TWO_BRANCHES_CYCLES: Type = 58720256;
    pub const OS_PM_MMCR1_PMC4_L2_MODIFIED_INTERVENTIONS: Type = 67108864;
    pub const OS_PM_MMCR1_PMC4_TLBIE_SNOOPS: Type = 71303168;
    pub const OS_PM_MMCR1_PMC4_L2_BANK_REFRESH_OVERFLOWS: Type = 75497472;
    pub const OS_PM_MMCR1_PMC4_CIU_ARTRY_COUNT: Type = 83886080;
    pub const OS_PM_MMCR1_PMC4_BIU_STORE_REQUESTS: Type = 88080384;
    pub const OS_PM_MMCR1_PMC4_CIU_TWO_CORE_SHARED_INTERVENTIONS: Type = 92274688;
}
extern "C" {
    pub fn OSSetPerformanceMonitor(
        arg_mask: u32,
        mmcr0: u32,
        mmcr1: u32,
        pmc1: u32,
        pmc2: u32,
        pmc3: u32,
        pmc4: u32,
    );
}
pub mod OSCodegenSecMode {
    pub type Type = ::core::ffi::c_uint;
    pub const CODEGEN_RW_: Type = 0;
    pub const CODEGEN_R_X: Type = 1;
}
extern "C" {
    pub fn OSGetCodegenVirtAddrRange(
        outVirtualAddress: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
}
extern "C" {
    pub fn OSGetCodegenCore() -> u32;
}
extern "C" {
    pub fn OSGetCodegenMode() -> u32;
}
extern "C" {
    pub fn OSSwitchSecCodeGenMode(mode: OSCodegenSecMode::Type) -> BOOL;
}
extern "C" {
    pub fn OSGetSecCodeGenMode() -> u32;
}
extern "C" {
    pub fn OSCodegenCopy(
        dst: *mut ::core::ffi::c_void,
        src: *mut ::core::ffi::c_void,
        size: usize,
    ) -> BOOL;
}
pub mod OSMemoryType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MEM1: Type = 1;
    pub const OS_MEM2: Type = 2;
}
pub mod OSSharedDataType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SHAREDDATATYPE_FONT_CHINESE: Type = 0;
    pub const OS_SHAREDDATATYPE_FONT_KOREAN: Type = 1;
    pub const OS_SHAREDDATATYPE_FONT_STANDARD: Type = 2;
    pub const OS_SHAREDDATATYPE_FONT_TAIWANESE: Type = 3;
    pub const OS_SHAREDDATATYPE_FONT_MAX: Type = 4;
}
extern "C" {
    pub fn OSGetSharedData(
        type_: OSSharedDataType::Type,
        unk_r4: u32,
        outPtr: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
}
extern "C" {
    pub fn __OSRootLoadShared();
}
extern "C" {
    pub fn OSBlockMove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        size: u32,
        flush: BOOL,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSBlockSet(
        dst: *mut ::core::ffi::c_void,
        val: u8,
        size: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSAllocFromSystem(size: u32, align: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn OSFreeToSystem(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSGetForegroundBucket(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    pub fn OSGetForegroundBucketFreeArea(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
}
extern "C" {
    pub fn OSGetMemBound(
        type_: OSMemoryType::Type,
        outAddr: *mut u32,
        outSize: *mut u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __OSZeroProcessMemory(proccesID: u32);
}
extern "C" {
    pub fn OSGetTitleID() -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCoroutine {
    pub nia: u32,
    pub cr: u32,
    pub ugqr1: u32,
    pub stack: u32,
    pub sda2Base: u32,
    pub sdaBase: u32,
    pub gpr: [u32; 18usize],
    pub fpr: [f64; 18usize],
    pub psr: [f64; 18usize],
}
extern "C" {
    pub fn OSInitCoroutine(
        coroutine: *mut OSCoroutine,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn OSLoadCoroutine(coroutine: *mut OSCoroutine, result: u32) -> u32;
}
extern "C" {
    pub fn OSSaveCoroutine(coroutine: *mut OSCoroutine) -> u32;
}
extern "C" {
    pub fn OSSwitchCoroutine(from: *mut OSCoroutine, to: *mut OSCoroutine);
}
pub mod OSScreenID {
    pub type Type = ::core::ffi::c_uint;
    pub const SCREEN_TV: Type = 0;
    pub const SCREEN_DRC: Type = 1;
}
extern "C" {
    pub fn OSScreenInit();
}
extern "C" {
    pub fn OSScreenShutdown();
}
extern "C" {
    pub fn OSScreenGetBufferSizeEx(screen: OSScreenID::Type) -> u32;
}
extern "C" {
    pub fn OSScreenSetBufferEx(screen: OSScreenID::Type, addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn OSScreenClearBufferEx(screen: OSScreenID::Type, colour: u32);
}
extern "C" {
    pub fn OSScreenFlipBuffersEx(screen: OSScreenID::Type);
}
extern "C" {
    pub fn OSScreenPutFontEx(
        screen: OSScreenID::Type,
        column: u32,
        row: u32,
        buffer: *const ::core::ffi::c_char,
    );
}
extern "C" {
    pub fn OSScreenPutPixelEx(screen: OSScreenID::Type, x: u32, y: u32, colour: u32);
}
extern "C" {
    pub fn OSScreenEnableEx(screen: OSScreenID::Type, enable: BOOL);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: ::core::ffi::c_ulong,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memalign(
        arg1: ::core::ffi::c_ulong,
        arg2: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _memalign_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn _mallinfo_r(arg1: *mut _reent) -> mallinfo;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn _malloc_stats_r(arg1: *mut _reent);
}
extern "C" {
    pub fn mallopt(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mallopt_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn malloc_usable_size(arg1: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn _malloc_usable_size_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _valloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pvalloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _pvalloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn malloc_trim(arg1: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _malloc_trim_r(arg1: *mut _reent, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __malloc_lock(arg1: *mut _reent);
}
extern "C" {
    pub fn __malloc_unlock(arg1: *mut _reent);
}
extern "C" {
    pub fn mstats(arg1: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
pub type __builtin_va_list = [[u32; 3usize]; 1usize];
