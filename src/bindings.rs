/* automatically generated by rust-bindgen 0.70.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const FD_SETSIZE: u32 = 32;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const OS_MESSAGE_QUEUE_TAG: u32 = 1834182481;
pub const OS_FAST_MUTEX_TAG: u32 = 1716352088;
pub const OS_CONTEXT_TAG: u64 = 5715986497936849012;
pub const OS_ALARM_QUEUE_TAG: u32 = 1632398673;
pub const OS_ALARM_TAG: u32 = 1632399949;
pub const FS_MAX_PATH: u32 = 639;
pub const FS_MODE_LENGTH: u32 = 16;
pub const GX2_FALSE: u32 = 0;
pub const GX2_TRUE: u32 = 1;
pub const GX2_DISABLE: u32 = 0;
pub const GX2_ENABLE: u32 = 1;
pub const GX2_COMMAND_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_CONTEXT_STATE_ALIGNMENT: u32 = 256;
pub const GX2_SCAN_BUFFER_ALIGNMENT: u32 = 4096;
pub const GX2_SHADER_PROGRAM_ALIGNMENT: u32 = 256;
pub const GX2_VERTEX_BUFFER_ALIGNMENT: u32 = 64;
pub const GX2_INDEX_BUFFER_ALIGNMENT: u32 = 32;
pub const GX2_UNIFORM_BLOCK_ALIGNMENT: u32 = 256;
pub const GX2_COMMAND_BUFFER_SIZE: u32 = 4194304;
pub const GFD_HEADER_MAGIC: u32 = 1197897778;
pub const GFD_BLOCK_HEADER_MAGIC: u32 = 1112296315;
pub const GFD_RELOCATION_HEADER_MAGIC: u32 = 2101496907;
pub const GFD_FILE_VERSION_MAJOR: u32 = 7;
pub const GFD_FILE_VERSION_MINOR: u32 = 1;
pub const GFD_BLOCK_VERSION_MAJOR: u32 = 1;
pub const GFD_PATCH_MASK: u32 = 4293918720;
pub const GFD_PATCH_DATA: u32 = 3495952384;
pub const GFD_PATCH_TEXT: u32 = 3396337664;
pub const IOCPARM_SHIFT: u32 = 13;
pub const IOCPARM_MASK: u32 = 8191;
pub const IOCPARM_MAX: u32 = 8192;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOC_DIRMASK: u32 = 3758096384;
pub const SOL_SOCKET: i32 = -1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_DONTWAIT: u32 = 32;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_TCPSACK: u32 = 512;
pub const SO_WINSCALE: u32 = 1024;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_HOPCNT: u32 = 4105;
pub const SO_MAXMSG: u32 = 4112;
pub const SO_RXDATA: u32 = 4113;
pub const SO_TXDATA: u32 = 4114;
pub const SO_MYADDR: u32 = 4115;
pub const SO_NBIO: u32 = 4116;
pub const SO_BIO: u32 = 4117;
pub const SO_NONBLOCK: u32 = 4118;
pub const SO_UNKNOWN1019: u32 = 4121;
pub const SO_UNKNOWN101A: u32 = 4122;
pub const SO_UNKNOWN101B: u32 = 4123;
pub const SO_NOSLOWSTART: u32 = 16384;
pub const SO_RUSRBUF: u32 = 65536;
pub const OS_THREAD_TAG: u32 = 1950904900;
pub const CAMERA_WIDTH: u32 = 640;
pub const CAMERA_PITCH: u32 = 768;
pub const CAMERA_HEIGHT: u32 = 480;
pub const CAMERA_Y_BUFFER_SIZE: u32 = 368640;
pub const CAMERA_UV_BUFFER_SIZE: u32 = 184320;
pub const CAMERA_YUV_BUFFER_SIZE: u32 = 552960;
pub const CAMERA_YUV_BUFFER_ALIGNMENT: u32 = 256;
pub const CCR_CDC_IRDA_DATA_TRANSFER_SIZE: u32 = 520;
pub const SOL_TCP: u32 = 6;
pub const TCP_ACKDELAYTIME: u32 = 8193;
pub const TCP_NOACKDELAY: u32 = 8194;
pub const TCP_MAXSEG: u32 = 8195;
pub const TCP_NODELAY: u32 = 8196;
pub const TCP_UNKNOWN: u32 = 8197;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_UNKNOWN: u32 = 14;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const OS_EVENT_TAG: u32 = 1700163156;
pub const HPAD_STICK_AXIS_MIN: i32 = -56;
pub const HPAD_STICK_AXIS_MAX: u32 = 56;
pub const HPAD_SUBSTICK_AXIS_MIN: i32 = -44;
pub const HPAD_SUBSTICK_AXIS_MAX: u32 = 44;
pub const HPAD_TRIGGER_MIN: u32 = 0;
pub const HPAD_TRIGGER_MAX: u32 = 150;
pub const UDS_MAX_NODES: u32 = 16;
pub const UDS_BROADCAST_NODE_ID: u32 = 65535;
pub const WHB_SERVER_BUFFER_SIZE: u32 = 1024;
pub const USBCLASS_DEVICE: u32 = 0;
pub const USBCLASS_AUDIO: u32 = 1;
pub const USBCLASS_HID: u32 = 3;
pub const USBCLASS_STORAGE: u32 = 8;
pub const MATCH_ANY: u32 = 0;
pub const MATCH_DEV_VID: u32 = 1;
pub const MATCH_DEV_PID: u32 = 2;
pub const MATCH_DEV_CLASS: u32 = 16;
pub const MATCH_DEV_SUBCLASS: u32 = 32;
pub const MATCH_DEV_PROTOCOL: u32 = 64;
pub const MATCH_IF_CLASS: u32 = 128;
pub const MATCH_IF_SUBCLASS: u32 = 256;
pub const MATCH_IF_PROTOCOL: u32 = 512;
pub const UHS_CONFIG_BUFFER_SIZE: u32 = 4991;
pub const ENDPOINT_TRANSFER_OUT: u32 = 1;
pub const ENDPOINT_TRANSFER_IN: u32 = 2;
pub const TIMEOUT_NONE: i32 = -1;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_NUMERICSCOPE: u32 = 32;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const OS_SEMAPHORE_TAG: u32 = 1934649426;
pub const OS_MUTEX_TAG: u32 = 1834316888;
pub const IPC_BUF_POOL_MAGIC: u32 = 195948557;
pub const OS_FAST_CONDITION_TAG: u32 = 1716413526;
pub const OS_CONDITION_TAG: u32 = 1666081878;
pub const OS_TITLE_ID_COLDBOOT: i32 = -3;
pub const OS_TITLE_ID_REBOOT: i32 = -2;
pub const OS_PAGE_SIZE: u32 = 131072;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type wint_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type __ULong = ::core::ffi::c_ulong;
pub type _LOCK_RECURSIVE_T = ::core::ffi::c_int;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub deviceData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BOOL = i32;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
pub type std_basic_string___sv_type<_CharT> = std_basic_string_view<_CharT>;
pub type std_basic_string__If_sv = std_enable_if_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper<_CharT> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
    pub _M_sv: std_basic_string___sv_type<_CharT>,
}
impl<_CharT> Default for std_basic_string___sv_wrapper<_CharT> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
impl Default for std_basic_string__Alloc_hider {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod std_basic_string__bindgen_ty_1 {
    pub type Type = i32;
    pub const _S_local_capacity: Type = 0;
}
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u32,
}
impl<_CharT> Default for std_basic_string__bindgen_ty_2<_CharT> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl<_CharT> Default for std_basic_string<_CharT> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
pub type std___enable_if_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
pub type std___remove_cvref_t = std_remove_cv;
pub type std_enable_if_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_type<_Default> = _Default;
pub type std___detector___is_detected = std_false_type;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional__Base = u8;
pub type std_optional___not_self = std___not_;
pub type std_optional___not_tag = std___not_;
pub type std_optional__Requires = std_enable_if_t;
pub type std_optional_value_type<_Tp> = _Tp;
pub type std_string = std_basic_string<::core::ffi::c_char>;
pub type std_streamoff = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_StateT>>,
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
}
impl<_StateT> Default for std_fpos<_StateT> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_streampos = std_fpos<_mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
impl Default for std_char_traits {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct std___new_allocator {
    pub _address: u8,
}
pub type std___new_allocator_value_type<_Tp> = _Tp;
pub type std___new_allocator_size_type = usize;
pub type std___new_allocator_difference_type = isize;
pub type std___new_allocator_pointer<_Tp> = *mut _Tp;
pub type std___new_allocator_const_pointer<_Tp> = *const _Tp;
pub type std___new_allocator_reference<_Tp> = *mut _Tp;
pub type std___new_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___new_allocator_rebind {
    pub _address: u8,
}
pub type std___new_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std___allocator_base = std___new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type<_Tp> = _Tp;
pub type std_allocator_size_type = usize;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
impl Default for std_allocator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___ptr_traits_elem {
    pub _address: u8,
}
impl Default for std___ptr_traits_elem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std___ptr_traits_elem_t = std___ptr_traits_elem;
pub type std___ptr_traits_ptr_to_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_ptr_to_element_type<_Elt> = _Elt;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___ptr_traits_impl {
    pub _address: u8,
}
pub type std___ptr_traits_impl___diff_t = [u8; 0usize];
pub type std___ptr_traits_impl___rebind = std___type_identity;
pub type std___ptr_traits_impl_pointer<_Ptr> = _Ptr;
pub type std___ptr_traits_impl_element_type<_Elt> = _Elt;
pub type std___ptr_traits_impl_difference_type = std___detected_or_t;
pub type std___ptr_traits_impl_rebind = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
impl Default for std_pointer_traits {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
    pub current: _Iterator,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
impl<_Iterator> Default for std_reverse_iterator<_Iterator> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
impl Default for std___allocator_traits_base___rebind {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = std___type_identity;
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
impl Default for std_allocator_traits__Size {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string_view<_CharT> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_CharT>>,
    pub _M_len: usize,
    pub _M_str: *const _CharT,
}
pub type std_basic_string_view_traits_type<_Traits> = _Traits;
pub type std_basic_string_view_value_type<_CharT> = _CharT;
pub type std_basic_string_view_pointer<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_pointer<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_reference<_CharT> = *mut std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_reference<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_const_iterator<_CharT> =
    *const std_basic_string_view_value_type<_CharT>;
pub type std_basic_string_view_iterator<_CharT> = std_basic_string_view_const_iterator<_CharT>;
pub type std_basic_string_view_const_reverse_iterator<_CharT> =
    std_reverse_iterator<std_basic_string_view_const_iterator<_CharT>>;
pub type std_basic_string_view_reverse_iterator<_CharT> =
    std_basic_string_view_const_reverse_iterator<_CharT>;
pub type std_basic_string_view_size_type = usize;
pub type std_basic_string_view_difference_type = isize;
impl<_CharT> Default for std_basic_string_view<_CharT> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::core::ffi::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = _mbstate_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Iterator>>,
    pub _M_current: _Iterator,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator___convertible_from = std___enable_if_t;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
impl<_Iterator> Default for __gnu_cxx___normal_iterator<_Iterator> {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
impl Default for __gnu_cxx___alloc_traits {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadLink {
    pub next: *mut OSThread,
    pub prev: *mut OSThread,
}
impl Default for OSThreadLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk0: [::core::ffi::c_char; 4usize],
}
impl Default for OSThreadQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadSimpleQueue {
    pub head: *mut OSThread,
    pub tail: *mut OSThread,
}
impl Default for OSThreadSimpleQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSMessageFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MESSAGE_FLAGS_NONE: Type = 0;
    pub const OS_MESSAGE_FLAGS_BLOCKING: Type = 1;
    pub const OS_MESSAGE_FLAGS_HIGH_PRIORITY: Type = 2;
}
pub mod OSFunctionType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_FUNCTION_TYPE_HIO_OPEN: Type = 1;
    pub const OS_FUNCTION_TYPE_HIO_READ_ASYNC: Type = 2;
    pub const OS_FUNCTION_TYPE_HIO_WRITE_ASYNC: Type = 3;
    pub const OS_FUNCTION_TYPE_FSA_CMD_ASYNC: Type = 4;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC: Type = 5;
    pub const OS_FUNCTION_TYPE_FSA_PR_CMD_ASYNC_NO_ALLOC: Type = 6;
    pub const OS_FUNCTION_TYPE_FSA_ATTACH_EVENT: Type = 7;
    pub const OS_FUNCTION_TYPE_FS_CMD_ASYNC: Type = 8;
    pub const OS_FUNCTION_TYPE_FS_CMD_HANDLER: Type = 9;
    pub const OS_FUNCTION_TYPE_FS_ATTACH_EVENT: Type = 10;
    pub const OS_FUNCTION_TYPE_FS_STATE_CHANGE_EVENT: Type = 11;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessage {
    pub message: *mut ::core::ffi::c_void,
    pub args: [u32; 3usize],
}
impl Default for OSMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMessageQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk1: [::core::ffi::c_char; 4usize],
    pub sendQueue: OSThreadQueue,
    pub recvQueue: OSThreadQueue,
    pub messages: *mut OSMessage,
    pub size: u32,
    pub first: u32,
    pub used: u32,
}
impl Default for OSMessageQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSSystemInfo {
    pub busClockSpeed: u32,
    pub coreClockSpeed: u32,
    pub baseTime: i64,
    pub __unk2: [::core::ffi::c_char; 16usize],
}
pub type OSTick = i32;
pub type OSTime = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSCalendarTime {
    pub tm_sec: i32,
    pub tm_min: i32,
    pub tm_hour: i32,
    pub tm_mday: i32,
    pub tm_mon: i32,
    pub tm_year: i32,
    pub tm_wday: i32,
    pub tm_yday: i32,
    pub tm_msec: i32,
    pub tm_usec: i32,
}
pub type IOSHandle = i32;
pub mod IOSOpenMode {
    pub type Type = ::core::ffi::c_uint;
    pub const IOS_OPEN_READ: Type = 1;
    pub const IOS_OPEN_WRITE: Type = 2;
    pub const IOS_OPEN_READWRITE: Type = 3;
}
pub mod IOSError {
    pub type Type = ::core::ffi::c_int;
    pub const IOS_ERROR_OK: Type = 0;
    pub const IOS_ERROR_ACCESS: Type = -1;
    pub const IOS_ERROR_EXISTS: Type = -2;
    pub const IOS_ERROR_INTR: Type = -3;
    pub const IOS_ERROR_INVALID: Type = -4;
    pub const IOS_ERROR_MAX: Type = -5;
    pub const IOS_ERROR_NOEXISTS: Type = -6;
    pub const IOS_ERROR_QEMPTY: Type = -7;
    pub const IOS_ERROR_QFULL: Type = -8;
    pub const IOS_ERROR_UNKNOWN: Type = -9;
    pub const IOS_ERROR_NOTREADY: Type = -10;
    pub const IOS_ERROR_ECC: Type = -11;
    pub const IOS_ERROR_ECCCRIT: Type = -12;
    pub const IOS_ERROR_BADBLOCK: Type = -13;
    pub const IOS_ERROR_INVALIDOBJTYPE: Type = -14;
    pub const IOS_ERROR_INVALIDRNG: Type = -15;
    pub const IOS_ERROR_INVALIDFLAG: Type = -16;
    pub const IOS_ERROR_INVALIDFORMAT: Type = -17;
    pub const IOS_ERROR_INVALIDVERSION: Type = -18;
    pub const IOS_ERROR_INVALIDSIGNER: Type = -19;
    pub const IOS_ERROR_FAILCHECKVALUE: Type = -20;
    pub const IOS_ERROR_FAILINTERNAL: Type = -21;
    pub const IOS_ERROR_FAILALLOC: Type = -22;
    pub const IOS_ERROR_INVALIDSIZE: Type = -23;
    pub const IOS_ERROR_NOLINK: Type = -24;
    pub const IOS_ERROR_ANFAILED: Type = -25;
    pub const IOS_ERROR_MAXSEMCOUNT: Type = -26;
    pub const IOS_ERROR_SEMUNAVAILABLE: Type = -27;
    pub const IOS_ERROR_INVALIDHANDLE: Type = -28;
    pub const IOS_ERROR_INVALIDARG: Type = -29;
    pub const IOS_ERROR_NORESOURCE: Type = -30;
    pub const IOS_ERROR_BUSY: Type = -31;
    pub const IOS_ERROR_TIMEOUT: Type = -32;
    pub const IOS_ERROR_ALIGNMENT: Type = -33;
    pub const IOS_ERROR_BSP: Type = -34;
    pub const IOS_ERROR_DATAPENDING: Type = -35;
    pub const IOS_ERROR_EXPIRED: Type = -36;
    pub const IOS_ERROR_NOREADACCESS: Type = -37;
    pub const IOS_ERROR_NOWRITEACCESS: Type = -38;
    pub const IOS_ERROR_NOREADWRITEACCESS: Type = -39;
    pub const IOS_ERROR_CLIENTTXNLIMIT: Type = -40;
    pub const IOS_ERROR_STALEHANDLE: Type = -41;
    pub const IOS_ERROR_UNKNOWNVALUE: Type = -42;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOSVec {
    pub vaddr: *mut ::core::ffi::c_void,
    pub len: u32,
    pub paddr: *mut ::core::ffi::c_void,
}
impl Default for IOSVec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IOSAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: IOSError::Type, arg2: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexLink {
    pub next: *mut OSFastMutex,
    pub prev: *mut OSFastMutex,
}
impl Default for OSFastMutexLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk3: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadSimpleQueue,
    pub link: OSFastMutexLink,
    pub __unk4: [::core::ffi::c_char; 16usize],
}
impl Default for OSFastMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type OSContextState = u16;
pub mod OS_CONTEXT_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_CONTEXT_STATE_OSCALLBACK: Type = 8;
    pub const OS_CONTEXT_STATE_USERMODE_SAVED: Type = 16;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSContext {
    pub tag: u64,
    pub gpr: [u32; 32usize],
    pub cr: u32,
    pub lr: u32,
    pub ctr: u32,
    pub xer: u32,
    pub srr0: u32,
    pub srr1: u32,
    pub dsisr: u32,
    pub dar: u32,
    pub __unk5: [::core::ffi::c_char; 12usize],
    pub fpscr: u32,
    pub fpr: [f64; 32usize],
    pub spinLockCount: u16,
    pub state: OSContextState,
    pub gqr: [u32; 8usize],
    pub upir: u32,
    pub psf: [f64; 32usize],
    pub coretime: [u64; 3usize],
    pub starttime: u64,
    pub error: u32,
    pub __unk6: [::core::ffi::c_char; 4usize],
    pub pmc1: u32,
    pub pmc2: u32,
    pub pmc3: u32,
    pub pmc4: u32,
    pub mmcr0: u32,
    pub mmcr1: u32,
}
pub type OSAlarmCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut OSAlarm, arg2: *mut OSContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmQueue {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk7: [::core::ffi::c_char; 4usize],
    pub threadQueue: OSThreadQueue,
    pub head: *mut OSAlarm,
    pub tail: *mut OSAlarm,
}
impl Default for OSAlarmQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarmLink {
    pub prev: *mut OSAlarm,
    pub next: *mut OSAlarm,
}
impl Default for OSAlarmLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSAlarm {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk8: [::core::ffi::c_char; 4usize],
    pub callback: OSAlarmCallback,
    pub group: u32,
    pub __unk9: [::core::ffi::c_char; 4usize],
    pub nextFire: OSTime,
    pub link: OSAlarmLink,
    pub period: OSTime,
    pub start: OSTime,
    pub userData: *mut ::core::ffi::c_void,
    pub state: u32,
    pub threadQueue: OSThreadQueue,
    pub alarmQueue: *mut OSAlarmQueue,
    pub context: *mut OSContext,
}
impl Default for OSAlarm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FSDirectoryHandle = u32;
pub type FSFileHandle = u32;
pub type FSPriority = u32;
pub type FSTime = u64;
pub type FSStateChangeInfo = FSStateChangeParams;
pub mod FSErrorFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_ERROR_FLAG_NONE: Type = 0;
    pub const FS_ERROR_FLAG_MAX: Type = 1;
    pub const FS_ERROR_FLAG_ALREADY_OPEN: Type = 2;
    pub const FS_ERROR_FLAG_EXISTS: Type = 4;
    pub const FS_ERROR_FLAG_NOT_FOUND: Type = 8;
    pub const FS_ERROR_FLAG_NOT_FILE: Type = 16;
    pub const FS_ERROR_FLAG_NOT_DIR: Type = 32;
    pub const FS_ERROR_FLAG_ACCESS_ERROR: Type = 64;
    pub const FS_ERROR_FLAG_PERMISSION_ERROR: Type = 128;
    pub const FS_ERROR_FLAG_FILE_TOO_BIG: Type = 256;
    pub const FS_ERROR_FLAG_STORAGE_FULL: Type = 512;
    pub const FS_ERROR_FLAG_UNSUPPORTED_CMD: Type = 1024;
    pub const FS_ERROR_FLAG_JOURNAL_FULL: Type = 2048;
    pub const FS_ERROR_FLAG_ALL: Type = 4294967295;
}
pub mod FSStatus {
    pub type Type = ::core::ffi::c_int;
    pub const FS_STATUS_OK: Type = 0;
    pub const FS_STATUS_CANCELLED: Type = -1;
    pub const FS_STATUS_END: Type = -2;
    pub const FS_STATUS_MAX: Type = -3;
    pub const FS_STATUS_ALREADY_OPEN: Type = -4;
    pub const FS_STATUS_EXISTS: Type = -5;
    pub const FS_STATUS_NOT_FOUND: Type = -6;
    pub const FS_STATUS_NOT_FILE: Type = -7;
    pub const FS_STATUS_NOT_DIR: Type = -8;
    pub const FS_STATUS_ACCESS_ERROR: Type = -9;
    pub const FS_STATUS_PERMISSION_ERROR: Type = -10;
    pub const FS_STATUS_FILE_TOO_BIG: Type = -11;
    pub const FS_STATUS_STORAGE_FULL: Type = -12;
    pub const FS_STATUS_JOURNAL_FULL: Type = -13;
    pub const FS_STATUS_UNSUPPORTED_CMD: Type = -14;
    pub const FS_STATUS_MEDIA_NOT_READY: Type = -15;
    pub const FS_STATUS_MEDIA_ERROR: Type = -17;
    pub const FS_STATUS_CORRUPTED: Type = -18;
    pub const FS_STATUS_FATAL_ERROR: Type = -1024;
}
pub mod FSError {
    pub type Type = ::core::ffi::c_int;
    pub const FS_ERROR_OK: Type = 0;
    pub const FS_ERROR_NOT_INIT: Type = -196609;
    pub const FS_ERROR_BUSY: Type = -196610;
    pub const FS_ERROR_CANCELLED: Type = -196611;
    pub const FS_ERROR_END_OF_DIR: Type = -196612;
    pub const FS_ERROR_END_OF_FILE: Type = -196613;
    pub const FS_ERROR_MAX_MOUNT_POINTS: Type = -196624;
    pub const FS_ERROR_MAX_VOLUMES: Type = -196625;
    pub const FS_ERROR_MAX_CLIENTS: Type = -196626;
    pub const FS_ERROR_MAX_FILES: Type = -196627;
    pub const FS_ERROR_MAX_DIRS: Type = -196628;
    pub const FS_ERROR_ALREADY_OPEN: Type = -196629;
    pub const FS_ERROR_ALREADY_EXISTS: Type = -196630;
    pub const FS_ERROR_NOT_FOUND: Type = -196631;
    pub const FS_ERROR_NOT_EMPTY: Type = -196632;
    pub const FS_ERROR_ACCESS_ERROR: Type = -196633;
    pub const FS_ERROR_PERMISSION_ERROR: Type = -196634;
    pub const FS_ERROR_DATA_CORRUPTED: Type = -196635;
    pub const FS_ERROR_STORAGE_FULL: Type = -196636;
    pub const FS_ERROR_JOURNAL_FULL: Type = -196637;
    pub const FS_ERROR_UNAVAILABLE_COMMAND: Type = -196639;
    pub const FS_ERROR_UNSUPPORTED_COMMAND: Type = -196640;
    pub const FS_ERROR_INVALID_PARAM: Type = -196641;
    pub const FS_ERROR_INVALID_PATH: Type = -196642;
    pub const FS_ERROR_INVALID_BUFFER: Type = -196643;
    pub const FS_ERROR_INVALID_ALIGNMENT: Type = -196644;
    pub const FS_ERROR_INVALID_CLIENTHANDLE: Type = -196645;
    pub const FS_ERROR_INVALID_FILEHANDLE: Type = -196646;
    pub const FS_ERROR_INVALID_DIRHANDLE: Type = -196647;
    pub const FS_ERROR_NOT_FILE: Type = -196648;
    pub const FS_ERROR_NOT_DIR: Type = -196649;
    pub const FS_ERROR_FILE_TOO_BIG: Type = -196650;
    pub const FS_ERROR_OUT_OF_RANGE: Type = -196651;
    pub const FS_ERROR_OUT_OF_RESOURCES: Type = -196652;
    pub const FS_ERROR_MEDIA_NOT_READY: Type = -196672;
    pub const FS_ERROR_MEDIA_ERROR: Type = -196673;
    pub const FS_ERROR_WRITE_PROTECTED: Type = -196674;
    pub const FS_ERROR_INVALID_MEDIA: Type = -196675;
}
pub mod FSMode {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MODE_READ_OWNER: Type = 1024;
    pub const FS_MODE_WRITE_OWNER: Type = 512;
    pub const FS_MODE_EXEC_OWNER: Type = 256;
    pub const FS_MODE_READ_GROUP: Type = 64;
    pub const FS_MODE_WRITE_GROUP: Type = 32;
    pub const FS_MODE_EXEC_GROUP: Type = 16;
    pub const FS_MODE_READ_OTHER: Type = 4;
    pub const FS_MODE_WRITE_OTHER: Type = 2;
    pub const FS_MODE_EXEC_OTHER: Type = 1;
}
pub mod FSStatFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_STAT_DIRECTORY: Type = 2147483648;
    pub const FS_STAT_QUOTA: Type = 1610612736;
    pub const FS_STAT_FILE: Type = 16777216;
    pub const FS_STAT_ENCRYPTED_FILE: Type = 8388608;
    pub const FS_STAT_LINK: Type = 65536;
}
pub mod FSVolumeState {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_VOLUME_STATE_INITIAL: Type = 0;
    pub const FS_VOLUME_STATE_READY: Type = 1;
    pub const FS_VOLUME_STATE_NO_MEDIA: Type = 2;
    pub const FS_VOLUME_STATE_INVALID_MEDIA: Type = 3;
    pub const FS_VOLUME_STATE_DIRTY_MEDIA: Type = 4;
    pub const FS_VOLUME_STATE_WRONG_MEDIA: Type = 5;
    pub const FS_VOLUME_STATE_MEDIA_ERROR: Type = 6;
    pub const FS_VOLUME_STATE_DATA_CORRUPTED: Type = 7;
    pub const FS_VOLUME_STATE_WRITE_PROTECTED: Type = 8;
    pub const FS_VOLUME_STATE_JOURNAL_FULL: Type = 9;
    pub const FS_VOLUME_STATE_FATAL: Type = 10;
    pub const FS_VOLUME_STATE_INVALID: Type = 11;
}
pub mod FSMediaState {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MEDIA_STATE_READY: Type = 0;
    pub const FS_MEDIA_STATE_NO_MEDIA: Type = 1;
    pub const FS_MEDIA_STATE_INVALID_MEDIA: Type = 2;
    pub const FS_MEDIA_STATE_DIRTY_MEDIA: Type = 3;
    pub const FS_MEDIA_STATE_MEDIA_ERROR: Type = 4;
}
pub mod FSMountSourceType {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_MOUNT_SOURCE_SD: Type = 0;
    pub const FS_MOUNT_SOURCE_UNK: Type = 1;
}
pub mod FSOpenFileFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FS_OPEN_FLAG_NONE: Type = 0;
    pub const FS_OPEN_FLAG_UNENCRYPTED: Type = 1;
    pub const FS_OPEN_FLAG_PREALLOC_SIZE: Type = 2;
}
pub type FSAsyncCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSClient,
        arg2: *mut FSCmdBlock,
        arg3: FSStatus::Type,
        arg4: u32,
    ),
>;
pub type FSStateChangeCallback = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSClient,
        arg2: FSVolumeState::Type,
        arg3: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSFsm {
    pub __unk10: [::core::ffi::c_char; 56usize],
}
impl Default for FSFsm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdQueue {
    pub __unk11: [::core::ffi::c_char; 68usize],
}
impl Default for FSCmdQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMessage {
    pub data: *mut ::core::ffi::c_void,
    pub __unk12: [::core::ffi::c_char; 8usize],
    pub type_: OSFunctionType::Type,
}
impl Default for FSMessage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBodyLink {
    pub next: *mut FSClientBody,
    pub prev: *mut FSClientBody,
}
impl Default for FSClientBodyLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClientBody {
    pub __unk13: [::core::ffi::c_char; 5188usize],
    pub clientHandle: IOSHandle,
    pub fsm: FSFsm,
    pub cmdQueue: FSCmdQueue,
    pub lastDequeuedCommand: *mut FSCmdBlockBody,
    pub emulatedError: FSError::Type,
    pub __unk14: [::core::ffi::c_char; 148usize],
    pub mutex: OSFastMutex,
    pub __unk15: [::core::ffi::c_char; 4usize],
    pub fsmAlarm: OSAlarm,
    pub lastError: FSError::Type,
    pub isLastErrorWithoutVolume: bool,
    pub fsCmdHandlerMsg: FSMessage,
    pub lastMountSourceDevice: [::core::ffi::c_char; 16usize],
    pub findMountSourceType: FSMountSourceType::Type,
    pub link: FSClientBodyLink,
    pub client: *mut FSClient,
}
impl Default for FSClientBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSClient {
    pub __unk16: [::core::ffi::c_char; 5888usize],
}
impl Default for FSClient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlock {
    pub __unk17: [::core::ffi::c_char; 2688usize],
}
impl Default for FSCmdBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSStat {
    pub flags: FSStatFlags::Type,
    pub mode: FSMode::Type,
    pub owner: u32,
    pub group: u32,
    pub size: u32,
    pub allocSize: u32,
    pub quotaSize: u64,
    pub entryId: u32,
    pub created: FSTime,
    pub modified: FSTime,
    pub __unk18: [::core::ffi::c_char; 48usize],
}
impl Default for FSStat {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSStateChangeParams {
    pub callback: FSStateChangeCallback,
    pub param: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSStateChangeParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncData {
    pub callback: FSAsyncCallback,
    pub param: u32,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSAsyncData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAsyncResult {
    pub asyncData: FSAsyncData,
    pub ioMsg: FSMessage,
    pub client: *mut FSClient,
    pub block: *mut FSCmdBlock,
    pub status: FSStatus::Type,
}
impl Default for FSAsyncResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSCmdBlockBody {
    pub __unk19: [::core::ffi::c_char; 2412usize],
    pub asyncResult: FSAsyncResult,
    pub __unk20: [::core::ffi::c_char; 104usize],
}
impl Default for FSCmdBlockBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSDirectoryEntry {
    pub info: FSStat,
    pub name: [::core::ffi::c_char; 256usize],
}
impl Default for FSDirectoryEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSMountSource {
    pub __unk21: [::core::ffi::c_char; 768usize],
}
impl Default for FSMountSource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSVolumeInfo {
    pub flags: u32,
    pub mediaState: FSMediaState::Type,
    pub __unk22: [::core::ffi::c_char; 4usize],
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub unk0x14: i32,
    pub unk0x18: i32,
    pub __unk23: [::core::ffi::c_char; 16usize],
    pub volumeLabel: [::core::ffi::c_char; 128usize],
    pub volumeId: [::core::ffi::c_char; 128usize],
    pub devicePath: [::core::ffi::c_char; 16usize],
    pub mountPath: [::core::ffi::c_char; 128usize],
}
impl Default for FSVolumeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NNResult {
    pub value: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_Result {
    pub mValue: i32,
}
pub mod nn_Result_Level {
    pub type Type = ::core::ffi::c_int;
    pub const LEVEL_SUCCESS: Type = 0;
    pub const LEVEL_FATAL: Type = -1;
    pub const LEVEL_USAGE: Type = -2;
    pub const LEVEL_STATUS: Type = -3;
    pub const LEVEL_END: Type = -7;
}
pub mod nn_Result_LegacyLevel {
    pub type Type = ::core::ffi::c_int;
    pub const LEVEL_INFO: Type = 1;
    pub const LEVEL_RESET: Type = -4;
    pub const LEVEL_REINIT: Type = -5;
    pub const LEVEL_PERMANENT: Type = -6;
    pub const LEVEL_TEMPORARY: Type = -7;
}
pub mod nn_Result_Module {
    pub type Type = ::core::ffi::c_uint;
    pub const RESULT_MODULE_COMMON: Type = 0;
    pub const RESULT_MODULE_NN_IPC: Type = 1;
    pub const RESULT_MODULE_NN_BOSS: Type = 2;
    pub const RESULT_MODULE_NN_ACP: Type = 3;
    pub const RESULT_MODULE_NN_IOS: Type = 4;
    pub const RESULT_MODULE_NN_NIM: Type = 5;
    pub const RESULT_MODULE_NN_PDM: Type = 6;
    pub const RESULT_MODULE_NN_ACT: Type = 7;
    pub const RESULT_MODULE_NN_NGC: Type = 8;
    pub const RESULT_MODULE_NN_ECA: Type = 9;
    pub const RESULT_MODULE_NN_NUP: Type = 10;
    pub const RESULT_MODULE_NN_NDM: Type = 11;
    pub const RESULT_MODULE_NN_FP: Type = 12;
    pub const RESULT_MODULE_NN_AC: Type = 13;
    pub const RESULT_MODULE_NN_CONNTEST: Type = 14;
    pub const RESULT_MODULE_NN_DRMAPP: Type = 15;
    pub const RESULT_MODULE_NN_TELNET: Type = 16;
    pub const RESULT_MODULE_NN_OLV: Type = 17;
    pub const RESULT_MODULE_NN_VCTL: Type = 18;
    pub const RESULT_MODULE_NN_NEIA: Type = 19;
    pub const RESULT_MODULE_NN_SPM: Type = 20;
    pub const RESULT_MODULE_NN_EMD: Type = 21;
    pub const RESULT_MODULE_NN_EC: Type = 22;
    pub const RESULT_MODULE_NN_CIA: Type = 23;
    pub const RESULT_MODULE_NN_SL: Type = 24;
    pub const RESULT_MODULE_NN_ECO: Type = 25;
    pub const RESULT_MODULE_NN_TRIAL: Type = 26;
    pub const RESULT_MODULE_NN_NFP: Type = 27;
    pub const RESULT_MODULE_NN_TEST: Type = 125;
}
pub mod nn_Result_LegacyModule {
    pub type Type = ::core::ffi::c_uint;
    pub const MODULE_COMMON: Type = 0;
    pub const MODULE_NN_KERNEL: Type = 1;
    pub const MODULE_NN_UTIL: Type = 2;
    pub const MODULE_NN_FILE_SERVER: Type = 3;
    pub const MODULE_NN_LOADER_SERVER: Type = 4;
    pub const MODULE_NN_TCB: Type = 5;
    pub const MODULE_NN_OS: Type = 6;
    pub const MODULE_NN_DBG: Type = 7;
    pub const MODULE_NN_DMNT: Type = 8;
    pub const MODULE_NN_PDN: Type = 9;
    pub const MODULE_NN_GX: Type = 10;
    pub const MODULE_NN_I2C: Type = 11;
    pub const MODULE_NN_GPIO: Type = 12;
    pub const MODULE_NN_DD: Type = 13;
    pub const MODULE_NN_CODEC: Type = 14;
    pub const MODULE_NN_SPI: Type = 15;
    pub const MODULE_NN_PXI: Type = 16;
    pub const MODULE_NN_FS: Type = 17;
    pub const MODULE_NN_DI: Type = 18;
    pub const MODULE_NN_HID: Type = 19;
    pub const MODULE_NN_CAMERA: Type = 20;
    pub const MODULE_NN_PI: Type = 21;
    pub const MODULE_NN_PM: Type = 22;
    pub const MODULE_NN_PMLOW: Type = 23;
    pub const MODULE_NN_FSI: Type = 24;
    pub const MODULE_NN_SRV: Type = 25;
    pub const MODULE_NN_NDM: Type = 26;
    pub const MODULE_NN_NWM: Type = 27;
    pub const MODULE_NN_SOCKET: Type = 28;
    pub const MODULE_NN_LDR: Type = 29;
    pub const MODULE_NN_ACC: Type = 30;
    pub const MODULE_NN_ROMFS: Type = 31;
    pub const MODULE_NN_AM: Type = 32;
    pub const MODULE_NN_HIO: Type = 33;
    pub const MODULE_NN_UPDATER: Type = 34;
    pub const MODULE_NN_MIC: Type = 35;
    pub const MODULE_NN_FND: Type = 36;
    pub const MODULE_NN_MP: Type = 37;
    pub const MODULE_NN_MPWL: Type = 38;
    pub const MODULE_NN_AC: Type = 39;
    pub const MODULE_NN_HTTP: Type = 40;
    pub const MODULE_NN_DSP: Type = 41;
    pub const MODULE_NN_SND: Type = 42;
    pub const MODULE_NN_DLP: Type = 43;
    pub const MODULE_NN_HIOLOW: Type = 44;
    pub const MODULE_NN_CSND: Type = 45;
    pub const MODULE_NN_SSL: Type = 46;
    pub const MODULE_NN_AMLOW: Type = 47;
    pub const MODULE_NN_NEX: Type = 48;
    pub const MODULE_NN_FRIENDS: Type = 49;
    pub const MODULE_NN_RDT: Type = 50;
    pub const MODULE_NN_APPLET: Type = 51;
    pub const MODULE_NN_NIM: Type = 52;
    pub const MODULE_NN_PTM: Type = 53;
    pub const MODULE_NN_MIDI: Type = 54;
    pub const MODULE_NN_MC: Type = 55;
    pub const MODULE_NN_SWC: Type = 56;
    pub const MODULE_NN_FATFS: Type = 57;
    pub const MODULE_NN_NGC: Type = 58;
    pub const MODULE_NN_CARD: Type = 59;
    pub const MODULE_NN_CARDNOR: Type = 60;
    pub const MODULE_NN_SDMC: Type = 61;
    pub const MODULE_NN_BOSS: Type = 62;
    pub const MODULE_NN_DBM: Type = 63;
    pub const MODULE_NN_CFG: Type = 64;
    pub const MODULE_NN_PS: Type = 65;
    pub const MODULE_NN_CEC: Type = 66;
    pub const MODULE_NN_IR: Type = 67;
    pub const MODULE_NN_UDS: Type = 68;
    pub const MODULE_NN_PL: Type = 69;
    pub const MODULE_NN_CUP: Type = 70;
    pub const MODULE_NN_GYROSCOPE: Type = 71;
    pub const MODULE_NN_MCU: Type = 72;
    pub const MODULE_NN_NS: Type = 73;
    pub const MODULE_NN_NEWS: Type = 74;
    pub const MODULE_NN_RO: Type = 75;
    pub const MODULE_NN_GD: Type = 76;
    pub const MODULE_NN_CARDSPI: Type = 77;
    pub const MODULE_NN_EC: Type = 78;
    pub const MODULE_NN_WEBBRS: Type = 79;
    pub const MODULE_NN_TEST: Type = 80;
    pub const MODULE_NN_ENC: Type = 81;
    pub const MODULE_NN_PIA: Type = 82;
    pub const MODULE_APPLICATION: Type = 510;
}
pub mod nn_Result_LegacySummary {
    pub type Type = ::core::ffi::c_uint;
    pub const SUMMARY_SUCCESS: Type = 0;
    pub const SUMMARY_NOTHING_HAPPENED: Type = 1;
    pub const SUMMARY_WOULD_BLOCK: Type = 2;
    pub const SUMMARY_OUT_OF_RESOURCE: Type = 3;
    pub const SUMMARY_NOT_FOUND: Type = 4;
    pub const SUMMARY_INVALID_STATE: Type = 5;
    pub const SUMMARY_NOT_SUPPORTED: Type = 6;
    pub const SUMMARY_INVALID_ARGUMENT: Type = 7;
    pub const SUMMARY_WRONG_ARGUMENT: Type = 8;
    pub const SUMMARY_CANCELLED: Type = 9;
    pub const SUMMARY_STATUS_CHANGED: Type = 10;
    pub const SUMMARY_INTERNAL: Type = 11;
}
pub mod nn_Result_LegacySignature {
    pub type Type = ::core::ffi::c_uint;
    pub const SIGNATURE_IS_LEGACY: Type = 3;
}
pub mod nn_swkbd_ControllerType {
    pub type Type = ::core::ffi::c_int;
    pub const WiiRemote0: Type = 0;
    pub const WiiRemote1: Type = 1;
    pub const WiiRemote2: Type = 2;
    pub const WiiRemote3: Type = 3;
    pub const DrcGamepad: Type = 4;
}
pub mod nn_swkbd_LanguageType {
    pub type Type = ::core::ffi::c_int;
    pub const Japanese: Type = 0;
    pub const English: Type = 1;
    pub const French: Type = 2;
    pub const German: Type = 3;
    pub const Italian: Type = 4;
    pub const Spanish: Type = 5;
    pub const SimplifiedChinese: Type = 6;
    pub const Korean: Type = 7;
    pub const Dutch: Type = 8;
    pub const Portuguese: Type = 9;
    pub const Russian: Type = 10;
    pub const TraditionalChinese: Type = 11;
    pub const Invalid: Type = 12;
}
pub mod nn_swkbd_RegionType {
    pub type Type = ::core::ffi::c_int;
    pub const Japan: Type = 0;
    pub const USA: Type = 1;
    pub const Europe: Type = 2;
    pub const China: Type = 3;
    pub const Korea: Type = 4;
    pub const Taiwan: Type = 5;
}
pub mod nn_swkbd_State {
    pub type Type = ::core::ffi::c_int;
    pub const Hidden: Type = 0;
    pub const FadeIn: Type = 1;
    pub const Visible: Type = 2;
    pub const FadeOut: Type = 3;
}
pub mod nn_swkbd_InputFormType {
    pub type Type = ::core::ffi::c_int;
    pub const InputForm0: Type = 0;
    pub const Default: Type = 1;
}
pub mod nn_swkbd_KeyboardMode {
    pub type Type = ::core::ffi::c_int;
    pub const Full: Type = 0;
    pub const Numpad: Type = 1;
    pub const Utf8: Type = 2;
    pub const NNID: Type = 3;
}
pub mod nn_swkbd_PasswordMode {
    pub type Type = ::core::ffi::c_int;
    pub const Clear: Type = 0;
    pub const Hide: Type = 1;
    pub const Fade: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_ConfigArg {
    pub languageType: nn_swkbd_LanguageType::Type,
    pub controllerType: nn_swkbd_ControllerType::Type,
    pub keyboardMode: nn_swkbd_KeyboardMode::Type,
    pub accessFlags: u32,
    pub unk_0x10: u32,
    pub unk_0x14: i32,
    pub unk_0x18: bool,
    pub okString: *const u16,
    pub numpadCharLeft: u16,
    pub numpadCharRight: u16,
    pub showWordSuggestions: bool,
    pub __unk35: [::core::ffi::c_char; 3usize],
    pub unk_0x28: u8,
    pub unk_0x29: u8,
    pub unk_0x2A: u8,
    pub disableNewLine: bool,
    pub __unk36: [::core::ffi::c_char; 112usize],
    pub unk_0x9C: u32,
    pub drawSysWiiPointer: bool,
    pub unk_0xA4: i32,
}
impl Default for nn_swkbd_ConfigArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_swkbd_ReceiverArg {
    pub unk_0x00: u32,
    pub unk_0x04: u32,
    pub unk_0x08: u32,
    pub unk_0x0C: i32,
    pub unk_0x10: u32,
    pub unk_0x14: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_KeyboardArg {
    pub configArg: nn_swkbd_ConfigArg,
    pub receiverArg: nn_swkbd_ReceiverArg,
}
impl Default for nn_swkbd_KeyboardArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_InputFormArg {
    pub type_: nn_swkbd_InputFormType::Type,
    pub unk_0x04: i32,
    pub initialText: *const u16,
    pub hintText: *const u16,
    pub maxTextLength: i32,
    pub passwordMode: nn_swkbd_PasswordMode::Type,
    pub unk_0x18: u32,
    pub drawInput0Cursor: bool,
    pub higlightInitialText: bool,
    pub showCopyPasteButtons: bool,
    pub __unk37: [::core::ffi::c_char; 1usize],
}
impl Default for nn_swkbd_InputFormArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_AppearArg {
    pub keyboardArg: nn_swkbd_KeyboardArg,
    pub inputFormArg: nn_swkbd_InputFormArg,
}
impl Default for nn_swkbd_AppearArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_CreateArg {
    pub workMemory: *mut ::core::ffi::c_void,
    pub regionType: nn_swkbd_RegionType::Type,
    pub unk_0x08: u32,
    pub fsClient: *mut FSClient,
}
impl Default for nn_swkbd_CreateArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_ControllerInfo {
    pub vpad: *mut VPADStatus,
    pub kpad: [*mut KPADStatus; 4usize],
}
impl Default for nn_swkbd_ControllerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_swkbd_DrawStringInfo {
    pub __unk38: [::core::ffi::c_char; 28usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_swkbd_KeyboardCondition {
    pub unk_0x00: u32,
    pub unk_0x04: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_IEventReceiver {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_IControllerEventObj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_swkbd_ISoundObj {
    _unused: [u8; 0],
}
pub mod nn_erreula_ControllerType {
    pub type Type = ::core::ffi::c_int;
    pub const WiiRemote0: Type = 0;
    pub const WiiRemote1: Type = 1;
    pub const WiiRemote2: Type = 2;
    pub const WiiRemote3: Type = 3;
    pub const DrcGamepad: Type = 4;
}
pub mod nn_erreula_ErrorType {
    pub type Type = ::core::ffi::c_int;
    pub const Code: Type = 0;
    pub const Message: Type = 1;
    pub const Message1Button: Type = 2;
    pub const Message2Button: Type = 3;
}
pub mod nn_erreula_LangType {
    pub type Type = ::core::ffi::c_int;
    pub const Japanese: Type = 0;
    pub const English: Type = 1;
    pub const French: Type = 2;
    pub const German: Type = 3;
    pub const Italian: Type = 4;
    pub const Spanish: Type = 5;
    pub const SimplifiedChinese: Type = 6;
    pub const Korean: Type = 7;
    pub const Dutch: Type = 8;
    pub const Portuguese: Type = 9;
    pub const Russian: Type = 10;
    pub const TraditionalChinese: Type = 11;
    pub const Invalid: Type = 12;
}
pub mod nn_erreula_RegionType {
    pub type Type = ::core::ffi::c_int;
    pub const Japan: Type = 0;
    pub const USA: Type = 1;
    pub const Europe: Type = 2;
    pub const China: Type = 3;
    pub const Korea: Type = 4;
    pub const Taiwan: Type = 5;
}
pub mod nn_erreula_ResultType {
    pub type Type = ::core::ffi::c_int;
    pub const None: Type = 0;
    pub const Exited: Type = 1;
}
pub mod nn_erreula_RenderTarget {
    pub type Type = ::core::ffi::c_int;
    pub const Tv: Type = 0;
    pub const Drc: Type = 1;
    pub const Both: Type = 2;
}
pub mod nn_erreula_State {
    pub type Type = ::core::ffi::c_int;
    pub const Hidden: Type = 0;
    pub const FadeIn: Type = 1;
    pub const Visible: Type = 2;
    pub const FadeOut: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_erreula_ErrorArg {
    pub errorType: nn_erreula_ErrorType::Type,
    pub renderTarget: nn_erreula_RenderTarget::Type,
    pub controllerType: nn_erreula_ControllerType::Type,
    pub unknown0x0C: u32,
    pub errorCode: i32,
    pub unknown0x14: u32,
    pub errorMessage: *const u16,
    pub button1Label: *const u16,
    pub button2Label: *const u16,
    pub errorTitle: *const u16,
    pub unknown0x28: bool,
    pub __unk53: [::core::ffi::c_char; 3usize],
}
impl Default for nn_erreula_ErrorArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_erreula_AppearArg {
    pub errorArg: nn_erreula_ErrorArg,
}
impl Default for nn_erreula_AppearArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_erreula_CreateArg {
    pub workMemory: *mut ::core::ffi::c_void,
    pub region: nn_erreula_RegionType::Type,
    pub language: nn_erreula_LangType::Type,
    pub fsClient: *mut FSClient,
}
impl Default for nn_erreula_CreateArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_erreula_ControllerInfo {
    pub vpad: *const VPADStatus,
    pub kpad: [*const KPADStatus; 4usize],
}
impl Default for nn_erreula_ControllerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_erreula_HomeNixSignArg {
    pub unknown0x00: u32,
}
pub mod nn_nfp_ResultDescription {
    pub type Type = ::core::ffi::c_uint;
    pub const RESULT_OUT_OF_RANGE: Type = 14080;
    pub const RESULT_INVALID_PARAM: Type = 14208;
    pub const RESULT_INVALID_ALIGNMENT: Type = 14336;
    pub const RESULT_INVALID_STATE: Type = 25600;
    pub const RESULT_INVALID_TAG: Type = 51200;
    pub const RESULT_INVALID_TAG_INFO: Type = 51840;
    pub const RESULT_NO_BACKUPENTRY: Type = 58752;
    pub const RESULT_NO_REGISTER_INFO: Type = 67840;
    pub const RESULT_APP_AREA_MISSING: Type = 66560;
    pub const RESULT_APP_AREA_TAGID_MISMATCH: Type = 72960;
    pub const RESULT_APP_AREA_ALREADY_EXISTS: Type = 69120;
    pub const RESULT_APP_AREA_ACCESS_ID_MISMATCH: Type = 70400;
    pub const RESULT_NO_BACKUP_SAVEDATA: Type = 231552;
    pub const RESULT_SYSTEM_ERROR: Type = 256128;
    pub const RESULT_FATAL: Type = 383744;
}
pub mod nn_nfp_NfpState {
    pub type Type = u32;
    pub const Uninitialized: Type = 0;
    pub const Initialized: Type = 1;
    pub const Searching: Type = 2;
    pub const Found: Type = 3;
    pub const Removed: Type = 4;
    pub const Mounted: Type = 5;
    pub const Unknown6: Type = 6;
    pub const MountedROM: Type = 7;
}
pub mod nn_nfp_AdminFlags {
    pub type Type = u8;
    pub const IsRegistered: Type = 1;
    pub const HasApplicationData: Type = 2;
}
pub mod nn_nfp_TagType {
    pub type Type = u8;
    pub const Unknown: Type = 0;
    pub const Type1Tag: Type = 1;
    pub const Type2Tag: Type = 2;
    pub const Type3Tag: Type = 4;
    pub const Iso15693: Type = 32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_nfp_Date {
    pub year: u16,
    pub month: u8,
    pub day: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_ApplicationAreaCreateInfo {
    pub accessID: u32,
    pub data: *mut ::core::ffi::c_void,
    pub size: u32,
    pub reserved: [u8; 48usize],
}
impl Default for nn_nfp_ApplicationAreaCreateInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_nfp_TagId {
    pub size: u8,
    pub uid: [u8; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_TagInfo {
    pub id: nn_nfp_TagId,
    pub reserved0: [u8; 21usize],
    pub technology: NFCTechnology,
    pub tag_type: nn_nfp_TagType::Type,
    pub reserved1: [u8; 50usize],
}
impl Default for nn_nfp_TagInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_CommonInfo {
    pub lastWriteDate: nn_nfp_Date,
    pub writes: u16,
    pub characterID: [u8; 3usize],
    pub seriesID: u8,
    pub numberingID: u16,
    pub figureType: u8,
    pub figureVersion: u8,
    pub applicationAreaSize: u16,
    pub reserved: [u8; 48usize],
}
impl Default for nn_nfp_CommonInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_RegisterInfo {
    pub mii: FFLStoreData,
    pub name: [u16; 11usize],
    pub fontRegion: u8,
    pub country: u8,
    pub registerDate: nn_nfp_Date,
    pub reserved: [u8; 44usize],
}
impl Default for nn_nfp_RegisterInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_ReadOnlyInfo {
    pub characterID: [u8; 3usize],
    pub seriesID: u8,
    pub numberingID: u16,
    pub figureType: u8,
    pub reserved: [u8; 47usize],
}
impl Default for nn_nfp_ReadOnlyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_nfp_RomInfo = nn_nfp_ReadOnlyInfo;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_RegisterInfoSet {
    pub mii: FFLStoreData,
    pub name: [u16; 11usize],
    pub fontRegion: u8,
    pub reserved: [u8; 45usize],
}
impl Default for nn_nfp_RegisterInfoSet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_AdminInfo {
    pub titleID: u64,
    pub accessID: u32,
    pub applicationAreaWrites: u16,
    pub flags: nn_nfp_AdminFlags::Type,
    pub formatVersion: u8,
    pub platform: u8,
    pub reserved: [u8; 47usize],
}
impl Default for nn_nfp_AdminInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod nn_nfp_AmiiboSettingsMode {
    pub type Type = u32;
    pub const Register: Type = 0;
    pub const DeleteGameData: Type = 1;
    pub const Restore: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_AmiiboSettingsArgsIn {
    pub mode: nn_nfp_AmiiboSettingsMode::Type,
    pub tag_info: nn_nfp_TagInfo,
    pub is_registered: bool,
    pub padding: [u8; 3usize],
    pub register_info: nn_nfp_RegisterInfo,
    pub common_info: nn_nfp_CommonInfo,
    pub reserved: [u8; 32usize],
}
impl Default for nn_nfp_AmiiboSettingsArgsIn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_AmiiboSettingsArgs {
    pub standardArgs: SYSStandardArgs,
    pub argsIn: nn_nfp_AmiiboSettingsArgsIn,
}
impl Default for nn_nfp_AmiiboSettingsArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_nfp_AmiiboSettingsResult {
    pub result: i32,
    pub tag_info: nn_nfp_TagInfo,
    pub register_info: nn_nfp_RegisterInfo,
    pub common_info: nn_nfp_CommonInfo,
    pub reserved: [u8; 32usize],
}
impl Default for nn_nfp_AmiiboSettingsResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_acp_DrcLedStatus = u8;
pub type nn_acp_DrcLedPattern = u32;
pub mod nn_sl_MediaType {
    pub type Type = ::core::ffi::c_uint;
    pub const NN_SL_MEDIA_TYPE_MLC: Type = 0;
    pub const NN_SL_MEDIA_TYPE_SLC: Type = 1;
    pub const NN_SL_MEDIA_TYPE_ODD: Type = 2;
    pub const NN_SL_MEDIA_TYPE_USB: Type = 3;
    pub const NN_SL_MEDIA_TYPE_HFIO: Type = 4;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_LaunchInfo {
    pub titleId: u64,
    pub appType: MCPAppType::Type,
    pub mediaType: nn_sl_MediaType::Type,
    pub parameter: [::core::ffi::c_char; 2048usize],
}
impl Default for nn_sl_LaunchInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_LaunchInfoDatabaseEntry {
    pub id: u64,
    pub launchInfo: nn_sl_LaunchInfo,
}
impl Default for nn_sl_LaunchInfoDatabaseEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct nn_sl_LaunchInfoDatabaseHeader {
    pub version: u32,
    pub magic: u32,
    pub maxEntries: u32,
    pub entryCount: u32,
    pub currentId: u64,
    pub entries: __IncompleteArrayField<nn_sl_LaunchInfoDatabaseEntry>,
    pub sha1Hash: [::core::ffi::c_char; 20usize],
}
impl Default for nn_sl_LaunchInfoDatabaseHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_IconInfo {
    pub data: [u8; 65580usize],
    pub name: [::core::ffi::c_char; 128usize],
}
impl Default for nn_sl_IconInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_AccountUUID {
    pub uuid: [::core::ffi::c_char; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_DRCImagePaletteColor {
    pub b: u8,
    pub g: u8,
    pub r: u8,
    pub a: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_DRCImagePalette {
    pub values: [nn_sl_DRCImagePaletteColor; 256usize],
}
impl Default for nn_sl_DRCImagePalette {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo {
    pub numAccounts: u8,
    pub defaultAccountIndex: u8,
    pub uuids: [nn_sl_AccountUUID; 12usize],
    pub __unk82: [::core::ffi::c_char; 72usize],
    pub isNetworkAccount: [u8; 12usize],
    pub isPasswordCacheEnabled: [u8; 12usize],
    pub titleIds: [u64; 10usize],
    pub isOnDisc: [u8; 10usize],
    pub killerNotificationsTitleId: u64,
    pub serialId: u32,
    pub __unk83: [::core::ffi::c_char; 192usize],
    pub accountSceneImage: nn_sl_TransferableInfo__bindgen_ty_1,
    pub quickStartScene1: nn_sl_TransferableInfo__bindgen_ty_2,
    pub quickStartScene2: nn_sl_TransferableInfo__bindgen_ty_3,
    pub killerNotificationMain: nn_sl_TransferableInfo__bindgen_ty_4,
    pub killerNotificationButton: nn_sl_TransferableInfo__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo__bindgen_ty_1 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixelIndex: [[u8; 412usize]; 206usize],
}
impl Default for nn_sl_TransferableInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo__bindgen_ty_2 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixelIndex: [[u8; 1630usize]; 129usize],
}
impl Default for nn_sl_TransferableInfo__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo__bindgen_ty_3 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixelIndex: [[u8; 854usize]; 85usize],
}
impl Default for nn_sl_TransferableInfo__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo__bindgen_ty_4 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixel: [[u8; 854usize]; 400usize],
}
impl Default for nn_sl_TransferableInfo__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TransferableInfo__bindgen_ty_5 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixelIndex: [[u8; 487usize]; 160usize],
}
impl Default for nn_sl_TransferableInfo__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nn_sl_TransferableInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_TitleInfo {
    pub titleId: u64,
    pub appType: MCPAppType::Type,
    pub mediaType: nn_sl_MediaType::Type,
    pub __unk84: [::core::ffi::c_char; 16usize],
}
impl Default for nn_sl_TitleInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_TitleMetaInfo {
    pub isPreOrder: bool,
    pub __unk85: [::core::ffi::c_char; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_WhiteList {
    pub titleTypes: [MCPAppType::Type; 50usize],
    pub titleTypeCount: u32,
    pub __unk86: [::core::ffi::c_char; 4usize],
    pub titleIds: [u64; 50usize],
    pub titleIdCount: u32,
}
impl Default for nn_sl_WhiteList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_Account {
    pub uuid: [::core::ffi::c_char; 16usize],
    pub isNetworkAccount: u32,
    pub isPasswordCacheEnabled: u8,
    pub age: u8,
    pub __unk87: [::core::ffi::c_char; 2usize],
    pub gender: u32,
    pub simpleAddressId: u32,
    pub isMailAddressValidated: u8,
    pub __unk88: [::core::ffi::c_char; 1usize],
    pub bday_year: u16,
    pub bday_month: u8,
    pub bday_day: u8,
    pub __unk89: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_AccountInfo {
    pub account_index: [u8; 12usize],
    pub __unk90: [::core::ffi::c_char; 4usize],
    pub num_of_accounts: u32,
    pub accounts: [nn_sl_Account; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_Setting {
    pub caffeine: nn_sl_Setting__bindgen_ty_1,
    pub pushAutoDelivery: bool,
    pub __unk92: [::core::ffi::c_char; 3usize],
    pub edmStandbyModeLength: u32,
    pub language: u32,
    pub prodArea: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_Setting__bindgen_ty_1 {
    pub enabled: bool,
    pub pushEnabled: bool,
    pub adEnabled: bool,
    pub drcLedEnable: bool,
    pub pushInterval: u16,
    pub __unk91: [::core::ffi::c_char; 2usize],
    pub pushTimeSlot: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_KillerNotificationTransferRecord {
    pub __unk93: [::core::ffi::c_char; 24usize],
}
pub mod nn_sl_Region {
    pub type Type = ::core::ffi::c_uint;
    pub const REGION_JPN: Type = 0;
    pub const REGION_USA: Type = 1;
    pub const REGION_EUR: Type = 2;
}
pub mod nn_sl_TransferMode {
    pub type Type = ::core::ffi::c_uint;
    pub const TRANSFER_MODE_UNKWN_1: Type = 1;
    pub const TRANSFER_MODE_UNKWN_2: Type = 2;
    pub const TRANSFER_MODE_UNKWN_3: Type = 3;
}
pub mod nn_sl_Language {
    pub type Type = ::core::ffi::c_uint;
    pub const Japanese: Type = 0;
    pub const English: Type = 1;
    pub const French: Type = 2;
    pub const German: Type = 3;
    pub const Italian: Type = 4;
    pub const Spanish: Type = 5;
    pub const SimplifiedChinese: Type = 6;
    pub const Korean: Type = 7;
    pub const Dutch: Type = 8;
    pub const Portuguese: Type = 9;
    pub const Russian: Type = 10;
    pub const TraditionalChinese: Type = 11;
}
pub mod nn_sl_SeekOrigin {
    pub type Type = ::core::ffi::c_uint;
    pub const SeekSet: Type = 0;
}
pub type nn_sl_details_IStream_ReadFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IStreamInternal,
        bytesRead: *mut u32,
        buffer: *mut ::core::ffi::c_void,
        readSize: u32,
    ) -> nn_Result,
>;
pub type nn_sl_details_IStream_WriteFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IStreamInternal,
        bytesWritten: *mut u32,
        buffer: *mut ::core::ffi::c_void,
        writeSize: u32,
    ) -> nn_Result,
>;
pub type nn_sl_details_IStream_GetSizeFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_IStreamInternal, fileSize: *mut u32) -> nn_Result,
>;
pub type nn_sl_details_IStream_SeekFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IStreamInternal,
        offset: i32,
        seekOrigin: nn_sl_SeekOrigin::Type,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IStreamInternalVTable {
    pub instance: *mut nn_sl_details_IStreamBase,
    pub info: u32,
    pub __unk94: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk95: [::core::ffi::c_char; 4usize],
    pub ReadFn: nn_sl_details_IStream_ReadFn,
    pub __unk96: [::core::ffi::c_char; 4usize],
    pub WriteFn: nn_sl_details_IStream_WriteFn,
    pub __unk97: [::core::ffi::c_char; 4usize],
    pub GetSizeFn: nn_sl_details_IStream_GetSizeFn,
    pub __unk98: [::core::ffi::c_char; 4usize],
    pub SeekFn: nn_sl_details_IStream_SeekFn,
}
impl Default for nn_sl_details_IStreamInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IStreamInternal {
    pub vtable: *mut nn_sl_details_IStreamInternalVTable,
}
impl Default for nn_sl_details_IStreamInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IStreamBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IStreamBase {
    pub vtable_: *const nn_sl_details_IStreamBase__bindgen_vtable,
}
impl Default for nn_sl_details_IStreamBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IAccountInfoAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IAccountInfoAccessorInternal,
        arg2: *mut nn_sl_AccountInfo,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IAccountInfoAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IAccountInfoAccessorBase,
    pub info: u32,
    pub __unk99: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk100: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IAccountInfoAccessor_GetFn,
}
impl Default for nn_sl_details_IAccountInfoAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IAccountInfoAccessorInternal {
    pub vtable: *mut nn_sl_details_IAccountInfoAccessorInternalVTable,
}
impl Default for nn_sl_details_IAccountInfoAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IAccountInfoAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IAccountInfoAccessorBase {
    pub vtable_: *const nn_sl_details_IAccountInfoAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IAccountInfoAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_AccountInfoAccessorFromPtr {
    pub _base: nn_sl_details_IAccountInfoAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IAccountInfoAccessorInternal,
}
impl Default for nn_sl_details_AccountInfoAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IKillerNotificationAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IKillerNotificationAccessorInternal,
        outKillerNotifications: *mut nn_sl_KillerNotification,
        outKillerNotificationsNum: *mut ::core::ffi::c_int,
        maxKillerNotifications: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IKillerNotificationAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IKillerNotificationAccessorBase,
    pub info: u32,
    pub __unk121: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk122: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IKillerNotificationAccessor_GetFn,
}
impl Default for nn_sl_details_IKillerNotificationAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IKillerNotificationAccessorInternal {
    pub vtable: *mut nn_sl_details_IKillerNotificationAccessorInternalVTable,
}
impl Default for nn_sl_details_IKillerNotificationAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IKillerNotificationAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IKillerNotificationAccessorBase {
    pub vtable_: *const nn_sl_details_IKillerNotificationAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IKillerNotificationAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_KillerNotificationAccessorFromPtr {
    pub _base: nn_sl_details_IKillerNotificationAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IKillerNotificationAccessorInternal,
}
impl Default for nn_sl_details_KillerNotificationAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ILaunchedTitleListAccessor_GetByAccountFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfoSize: *mut ::core::ffi::c_int,
        inTitleInfosSize: ::core::ffi::c_int,
        userId: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ILaunchedTitleListAccessorInternalVTable {
    pub instance: *mut nn_sl_details_ILaunchedTitleListAccessorBase,
    pub info: u32,
    pub __unk123: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk124: [::core::ffi::c_char; 4usize],
    pub GetByAccountFn: nn_sl_details_ILaunchedTitleListAccessor_GetByAccountFn,
}
impl Default for nn_sl_details_ILaunchedTitleListAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ILaunchedTitleListAccessorInternal {
    pub vtable: *mut nn_sl_details_ILaunchedTitleListAccessorInternalVTable,
}
impl Default for nn_sl_details_ILaunchedTitleListAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ILaunchedTitleListAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ILaunchedTitleListAccessorBase {
    pub vtable_: *const nn_sl_details_ILaunchedTitleListAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_ILaunchedTitleListAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_LaunchedTitleListAccessorFromPtr {
    pub _base: nn_sl_details_ILaunchedTitleListAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
}
impl Default for nn_sl_details_LaunchedTitleListAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ISerializer_SerializeFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ISerializerInternal,
        arg2: *mut ::core::ffi::c_void,
        arg3: u32,
    ) -> nn_Result,
>;
pub type nn_sl_details_ISerializer_DeserializeFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ISerializerInternal,
        arg2: *mut ::core::ffi::c_void,
        arg3: u32,
    ) -> nn_Result,
>;
pub type nn_sl_details_ISerializer_GetCountFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_ISerializerInternal, arg2: *mut u32) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ISerializerInternalVTable {
    pub instance: *mut nn_sl_ISerializerBase,
    pub info: u32,
    pub __unk125: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk126: [::core::ffi::c_char; 4usize],
    pub SerializeFn: nn_sl_details_ISerializer_SerializeFn,
    pub __unk127: [::core::ffi::c_char; 4usize],
    pub DeserializeFn: nn_sl_details_ISerializer_DeserializeFn,
    pub __unk128: [::core::ffi::c_char; 4usize],
    pub GetCountFn: nn_sl_details_ISerializer_GetCountFn,
}
impl Default for nn_sl_details_ISerializerInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ISerializerInternal {
    pub vtable: *mut nn_sl_details_ISerializerInternalVTable,
}
impl Default for nn_sl_details_ISerializerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ISerializerBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ISerializerBase {
    pub vtable_: *const nn_sl_details_ISerializerBase__bindgen_vtable,
}
impl Default for nn_sl_details_ISerializerBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_SerializerFromPtr {
    pub _base: nn_sl_details_ISerializerBase,
    pub mInstancePtr: *mut nn_sl_details_ISerializerInternal,
}
impl Default for nn_sl_details_SerializerFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ISettingAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ISettingAccessorInternal,
        arg2: *mut nn_sl_Setting,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ISettingAccessorInternalVTable {
    pub instance: *mut nn_sl_details_ISettingAccessorBase,
    pub info: u32,
    pub __unk129: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk130: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_ISettingAccessor_GetFn,
}
impl Default for nn_sl_details_ISettingAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ISettingAccessorInternal {
    pub vtable: *mut nn_sl_details_ISettingAccessorInternalVTable,
}
impl Default for nn_sl_details_ISettingAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ISettingAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ISettingAccessorBase {
    pub vtable_: *const nn_sl_details_ISettingAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_ISettingAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_SettingAccessorFromPtr {
    pub _base: nn_sl_details_ISettingAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_ISettingAccessorInternal,
}
impl Default for nn_sl_details_SettingAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ITimeAccessor_GetNetworkTimeFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITimeAccessorInternal,
        arg2: *mut OSTime,
        arg3: *mut bool,
    ) -> nn_Result,
>;
pub type nn_sl_details_ITimeAccessor_GetLocalTimeFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITimeAccessorInternal,
        arg2: *mut OSTime,
        arg3: *mut bool,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITimeAccessorInternalVTable {
    pub instance: *mut nn_sl_details_ITimeAccessorBase,
    pub info: u32,
    pub __unk131: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk132: [::core::ffi::c_char; 4usize],
    pub GetNetworkTimeFn: nn_sl_details_ITimeAccessor_GetNetworkTimeFn,
    pub __unk133: [::core::ffi::c_char; 4usize],
    pub GetLocalTimeFn: nn_sl_details_ITimeAccessor_GetLocalTimeFn,
}
impl Default for nn_sl_details_ITimeAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITimeAccessorInternal {
    pub vtable: *mut nn_sl_details_ITimeAccessorInternalVTable,
}
impl Default for nn_sl_details_ITimeAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ITimeAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ITimeAccessorBase {
    pub vtable_: *const nn_sl_details_ITimeAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_ITimeAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_TimeAccessorFromPtr {
    pub _base: nn_sl_details_ITimeAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_ITimeAccessorInternal,
}
impl Default for nn_sl_details_TimeAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_FileStreamInternal {
    pub vtable: *mut ::core::ffi::c_void,
    pub fsClient: *mut FSClient,
    pub fsCmdBlock: *mut FSCmdBlock,
    pub fileHandle: FSFileHandle,
}
impl Default for nn_sl_details_FileStreamInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_LoadFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
            arg2: *mut nn_sl_details_IStreamInternal,
        ) -> nn_Result,
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_LoadInitialFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        ) -> nn_Result,
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_StoreFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
            arg2: *mut nn_sl_details_IStreamInternal,
        ) -> nn_Result,
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_FinalizeFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        ),
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_GetRecordCountFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        ) -> u32,
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_GetRecordsFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
            arg2: *mut nn_sl_KillerNotificationTransferRecord,
            arg3: u32,
        ) -> u32,
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_RegisterRecordsFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
            arg2: *const nn_sl_KillerNotificationTransferRecord,
            arg3: u32,
        ),
    >;
pub type nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_RegisterRecordsOtherFn =
    ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
            arg2: *const u32,
            arg3: u32,
        ) -> nn_Result,
    >;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IKillerNotificationTransferRecordManagerInternalVTable {
    pub instance: *mut nn_sl_details_IKillerNotificationTransferRecordManagerBase,
    pub __unk134: [::core::ffi::c_char; 16usize],
    pub LoadFn: nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_LoadFn,
    pub __unk135: [::core::ffi::c_char; 4usize],
    pub LoadInitialFn:
        nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_LoadInitialFn,
    pub __unk136: [::core::ffi::c_char; 4usize],
    pub StoreFn: nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_StoreFn,
    pub __unk137: [::core::ffi::c_char; 4usize],
    pub FinalizeFn: nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_FinalizeFn,
    pub __unk138: [::core::ffi::c_char; 4usize],
    pub GetRecordCountFn:
        nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_GetRecordCountFn,
    pub __unk139: [::core::ffi::c_char; 4usize],
    pub GetRecordsFn:
        nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_GetRecordsFn,
    pub __unk140: [::core::ffi::c_char; 4usize],
    pub RegisterRecordsFn:
        nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_RegisterRecordsFn,
    pub __unk141: [::core::ffi::c_char; 4usize],
    pub RegisterRecordsOtherFn:
        nn_sl_details_IKillerNotificationTransferRecordManagerInternVTable_RegisterRecordsOtherFn,
}
impl Default for nn_sl_details_IKillerNotificationTransferRecordManagerInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IKillerNotificationTransferRecordManagerInternal {
    pub vtable: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternalVTable,
}
impl Default for nn_sl_details_IKillerNotificationTransferRecordManagerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IKillerNotificationTransferRecordManagerIntern =
    nn_sl_details_IKillerNotificationTransferRecordManagerInternal;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal {
    pub vtable: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternalVTable,
    pub killerNotificationTransferRecordManagerImpl: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IKillerNotificationTransferRecordManagerBase__bindgen_vtable(
    ::core::ffi::c_void,
);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IKillerNotificationTransferRecordManagerBase {
    pub vtable_: *const nn_sl_details_IKillerNotificationTransferRecordManagerBase__bindgen_vtable,
}
impl Default for nn_sl_details_IKillerNotificationTransferRecordManagerBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_KillerNotificationTransferRecordManagerFromPtr {
    pub _base: nn_sl_details_IKillerNotificationTransferRecordManagerBase,
    pub mInstancePtr: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
}
impl Default for nn_sl_details_KillerNotificationTransferRecordManagerFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IDiscCachedTitleAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfosSize: *mut ::core::ffi::c_int,
        maxTitleInfos: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IDiscCachedTitleAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IDiscCachedTitleAccessorBase,
    pub info: u32,
    pub __unk142: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk143: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IDiscCachedTitleAccessor_GetFn,
}
impl Default for nn_sl_details_IDiscCachedTitleAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IDiscCachedTitleAccessorInternal {
    pub vtable: *mut nn_sl_details_IDiscCachedTitleAccessorInternalVTable,
}
impl Default for nn_sl_details_IDiscCachedTitleAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IDiscCachedTitleAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IDiscCachedTitleAccessorBase {
    pub vtable_: *const nn_sl_details_IDiscCachedTitleAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IDiscCachedTitleAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_DiscCachedTitleAccessorFromPtr {
    pub _base: nn_sl_details_IDiscCachedTitleAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
}
impl Default for nn_sl_details_DiscCachedTitleAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IInstalledTitleListAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfosSize: *mut ::core::ffi::c_int,
        maxTitleInfos: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IInstalledTitleListAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IInstalledTitleListAccessorBase,
    pub info: u32,
    pub __unk144: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk145: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IInstalledTitleListAccessor_GetFn,
}
impl Default for nn_sl_details_IInstalledTitleListAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IInstalledTitleListAccessorInternal {
    pub vtable: *mut nn_sl_details_IInstalledTitleListAccessorInternalVTable,
}
impl Default for nn_sl_details_IInstalledTitleListAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IInstalledTitleListAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IInstalledTitleListAccessorBase {
    pub vtable_: *const nn_sl_details_IInstalledTitleListAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IInstalledTitleListAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_InstalledTitleListAccessorFromPtr {
    pub _base: nn_sl_details_IInstalledTitleListAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
}
impl Default for nn_sl_details_InstalledTitleListAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IMetaInfoAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IMetaInfoAccessorInternal,
        arg2: *mut nn_sl_TitleMetaInfo,
        arg3: *const nn_sl_TitleInfo,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IMetaInfoAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IMetaInfoAccessorBase,
    pub info: u32,
    pub __unk146: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk147: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IMetaInfoAccessor_GetFn,
}
impl Default for nn_sl_details_IMetaInfoAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IMetaInfoAccessorInternal {
    pub vtable: *mut nn_sl_details_IMetaInfoAccessorInternalVTable,
}
impl Default for nn_sl_details_IMetaInfoAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IMetaInfoAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IMetaInfoAccessorBase {
    pub vtable_: *const nn_sl_details_IMetaInfoAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IMetaInfoAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_MetaInfoAccessorFromPtr {
    pub _base: nn_sl_details_IMetaInfoAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IMetaInfoAccessorInternal,
}
impl Default for nn_sl_details_MetaInfoAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ITitleListAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITitleListAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfosNum: *mut ::core::ffi::c_int,
        maxTitleInfosNum: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITitleListAccessorInternalVTable {
    pub instance: *mut nn_sl_details_ITitleListAccessorBase,
    pub info: u32,
    pub __unk148: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk149: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_ITitleListAccessor_GetFn,
}
impl Default for nn_sl_details_ITitleListAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITitleListAccessorInternal {
    pub vtable: *mut nn_sl_details_ITitleListAccessorInternalVTable,
}
impl Default for nn_sl_details_ITitleListAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ITitleListAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ITitleListAccessorBase {
    pub vtable_: *const nn_sl_details_ITitleListAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_ITitleListAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_TitleListAccessorFromPtr {
    pub _base: nn_sl_details_ITitleListAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_ITitleListAccessorInternal,
}
impl Default for nn_sl_details_TitleListAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITitleListCacheInternal {
    pub titleListAccessor: *mut nn_sl_details_ITitleListAccessorInternal,
    pub launchedTitleListAccessor: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
    pub installedTitleListAccessor: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
    pub discCachedTitleAccessor: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
    pub titleInfoSerializer: *mut nn_sl_details_ISerializerInternal,
    pub timeAccessor: *mut nn_sl_details_ITimeAccessorInternal,
    pub metaInfoAccessor: *mut nn_sl_details_IMetaInfoAccessorInternal,
    pub __unk150: [::core::ffi::c_char; 24usize],
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_ITitleListCacheInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_TitleListCacheInternal = nn_sl_details_ITitleListCacheInternal;
#[repr(C)]
pub struct nn_sl_details_ITitleListCacheBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ITitleListCacheBase {
    pub vtable_: *const nn_sl_details_ITitleListCacheBase__bindgen_vtable,
}
impl Default for nn_sl_details_ITitleListCacheBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_KillerNotificationSelectorInternal {
    pub launchedTitleListAccessor: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
    pub killerNotificationAccessor: *mut nn_sl_details_IKillerNotificationAccessorInternal,
    pub titleListCache: *mut nn_sl_details_ITitleListCacheInternal,
    pub killerNotificationSerializer: *mut nn_sl_details_ISerializerInternal,
    pub settingsAccessor: *mut nn_sl_details_ISettingAccessorInternal,
    pub accountInfoAccessor: *mut nn_sl_details_IAccountInfoAccessorInternal,
    pub timeAccessor: *mut nn_sl_details_ITimeAccessorInternal,
    pub killerNotificationTransferRecordManager:
        *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_KillerNotificationSelectorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_ITransferrer_TransferDeprecatedFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITransferrerInternal,
        arg2: *mut ::core::ffi::c_void,
        arg3: u32,
        arg4: bool,
        arg5: ::core::ffi::c_int,
    ) -> nn_Result,
>;
pub type nn_sl_details_ITransferrer_TransferFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITransferrerInternal,
        arg2: *mut ::core::ffi::c_void,
        arg3: u32,
        arg4: bool,
        arg5: nn_sl_TransferMode::Type,
    ) -> nn_Result,
>;
pub type nn_sl_details_ITransferrer_CancelTransferFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_ITransferrerInternal) -> nn_Result,
>;
pub type nn_sl_details_ITransferrer_InvalidateNotificationFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_ITransferrerInternal, arg2: u32) -> nn_Result,
>;
pub type nn_sl_details_ITransferrer_DisplayNotificationFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITransferrerInternal,
        arg2: u32,
        arg3: u32,
        arg4: u32,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITransferrerInternalVTable {
    pub instance: *mut nn_sl_details_ITransferrerBase,
    pub info: u32,
    pub __unk151: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk152: [::core::ffi::c_char; 4usize],
    pub TransferDeprecatedFn: nn_sl_details_ITransferrer_TransferDeprecatedFn,
    pub __unk153: [::core::ffi::c_char; 4usize],
    pub TransferFn: nn_sl_details_ITransferrer_TransferFn,
    pub __unk154: [::core::ffi::c_char; 4usize],
    pub CancelTransferFn: nn_sl_details_ITransferrer_CancelTransferFn,
    pub __unk155: [::core::ffi::c_char; 4usize],
    pub InvalidateNotificationFn: nn_sl_details_ITransferrer_InvalidateNotificationFn,
    pub __unk156: [::core::ffi::c_char; 4usize],
    pub DisplayNotificationFn: nn_sl_details_ITransferrer_DisplayNotificationFn,
}
impl Default for nn_sl_details_ITransferrerInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITransferrerInternal {
    pub vtable: *mut nn_sl_details_ITransferrerInternalVTable,
}
impl Default for nn_sl_details_ITransferrerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ITransferrerBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ITransferrerBase {
    pub vtable_: *const nn_sl_details_ITransferrerBase__bindgen_vtable,
}
impl Default for nn_sl_details_ITransferrerBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_TransferrerFromPtr {
    pub _base: nn_sl_details_ITransferrerBase,
    pub mInstancePtr: *mut nn_sl_details_ITransferrerInternal,
}
impl Default for nn_sl_details_TransferrerFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IPreferentialTitleAccessorBase_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IPreferentialTitleAccessorInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: *mut u32,
        arg4: ::core::ffi::c_int,
        arg5: u32,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IPreferentialTitleAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IPreferentialTitleAccessorBase,
    pub info: u32,
    pub __unk157: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk158: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IPreferentialTitleAccessorBase_GetFn,
}
impl Default for nn_sl_details_IPreferentialTitleAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IPreferentialTitleAccessorInternal {
    pub vtable: *mut nn_sl_details_IPreferentialTitleAccessorInternalVTable,
}
impl Default for nn_sl_details_IPreferentialTitleAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IPreferentialTitleAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IPreferentialTitleAccessorBase {
    pub vtable_: *const nn_sl_details_IPreferentialTitleAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IPreferentialTitleAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_PreferentialTitleAccessorFromPtr {
    pub _base: nn_sl_details_IPreferentialTitleAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IPreferentialTitleAccessorInternal,
}
impl Default for nn_sl_details_PreferentialTitleAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_DrcManagerInternal {
    pub drcTransferrer: *mut nn_sl_details_ITransferrerInternal,
    pub settingsAccessor: *mut nn_sl_details_ISettingAccessorInternal,
    pub timeAccessor: *mut nn_sl_details_ITimeAccessorInternal,
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_DrcManagerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IBlackListAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IBlackListAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfosSize: *mut ::core::ffi::c_int,
        maxTitleInfos: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IBlackListAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IBlackListAccessorBase,
    pub info: u32,
    pub __unk159: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk160: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IBlackListAccessor_GetFn,
}
impl Default for nn_sl_details_IBlackListAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IBlackListAccessorInternal {
    pub vtable: *mut nn_sl_details_IBlackListAccessorInternalVTable,
}
impl Default for nn_sl_details_IBlackListAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IBlackListAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IBlackListAccessorBase {
    pub vtable_: *const nn_sl_details_IBlackListAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IBlackListAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_BlackListAccessorFromPtr {
    pub _base: nn_sl_details_IBlackListAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IBlackListAccessorInternal,
}
impl Default for nn_sl_details_BlackListAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IDefaultTitleAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IDefaultTitleAccessorInternal,
        outTitleInfos: *mut nn_sl_TitleInfo,
        outTitleInfosSize: *mut ::core::ffi::c_int,
        maxTitleInfos: ::core::ffi::c_int,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IDefaultTitleAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IDefaultTitleAccessorBase,
    pub info: u32,
    pub __unk161: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk162: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IDefaultTitleAccessor_GetFn,
}
impl Default for nn_sl_details_IDefaultTitleAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IDefaultTitleAccessorInternal {
    pub vtable: *mut nn_sl_details_IDefaultTitleAccessorInternalVTable,
}
impl Default for nn_sl_details_IDefaultTitleAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IDefaultTitleAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IDefaultTitleAccessorBase {
    pub vtable_: *const nn_sl_details_IDefaultTitleAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IDefaultTitleAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_DefaultTitleAccessorFromPtr {
    pub _base: nn_sl_details_IDefaultTitleAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IDefaultTitleAccessorInternal,
}
impl Default for nn_sl_details_DefaultTitleAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IWhiteListAccessor_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IWhiteListAccessorInternal,
        arg2: *mut nn_sl_WhiteList,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IWhiteListAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IWhiteListAccessorBase,
    pub info: u32,
    pub __unk163: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk164: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_IWhiteListAccessor_GetFn,
}
impl Default for nn_sl_details_IWhiteListAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IWhiteListAccessorInternal {
    pub vtable: *mut nn_sl_details_IWhiteListAccessorInternalVTable,
}
impl Default for nn_sl_details_IWhiteListAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IWhiteListAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IWhiteListAccessorBase {
    pub vtable_: *const nn_sl_details_IWhiteListAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IWhiteListAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_WhiteListAccessorFromPtr {
    pub _base: nn_sl_details_IWhiteListAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IWhiteListAccessorInternal,
}
impl Default for nn_sl_details_WhiteListAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_QuickStartApplicationSelectorInternal {
    pub preferentialTitleAccessor: *mut nn_sl_details_IPreferentialTitleAccessorInternal,
    pub defaultTitleAccessor: *mut nn_sl_details_IDefaultTitleAccessorInternal,
    pub whiteListAccessor: *mut nn_sl_details_IWhiteListAccessorInternal,
    pub titleListCache: *mut nn_sl_details_ITitleListCacheInternal,
    pub settingsAccessor: *mut nn_sl_details_ISettingAccessorInternal,
    pub blackListAccessor: *mut nn_sl_details_IBlackListAccessorInternal,
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_QuickStartApplicationSelectorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IconInfoAccessor_GetTitleIconInfoFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IIconInfoAccessorInternal,
        arg2: *mut nn_sl_IconInfo,
        arg3: *const nn_sl_TitleInfo,
        arg4: nn_sl_Language::Type,
    ) -> nn_Result,
>;
pub type nn_sl_details_IconInfoAccessor_GetMiiIconFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_IIconInfoAccessorInternal,
        buffer: *mut ::core::ffi::c_void,
        buffer_size: u32,
        slot: u32,
    ) -> nn_Result,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IIconInfoAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IIconInfoAccessorBase,
    pub info: u32,
    pub __unk165: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk166: [::core::ffi::c_char; 4usize],
    pub GetTitleIconInfoFn: nn_sl_details_IconInfoAccessor_GetTitleIconInfoFn,
    pub __unk167: [::core::ffi::c_char; 4usize],
    pub GetMiiIconFn: nn_sl_details_IconInfoAccessor_GetMiiIconFn,
    pub __unk168: [::core::ffi::c_char; 4usize],
}
impl Default for nn_sl_details_IIconInfoAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IIconInfoAccessorInternal {
    pub vtable: *mut nn_sl_details_IIconInfoAccessorInternalVTable,
}
impl Default for nn_sl_details_IIconInfoAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IIconInfoAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IIconInfoAccessorBase {
    pub vtable_: *const nn_sl_details_IIconInfoAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IIconInfoAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IconInfoAccessorFromPtr {
    pub _base: nn_sl_details_IIconInfoAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IIconInfoAccessorInternal,
}
impl Default for nn_sl_details_IconInfoAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_TitleIconCache_LoadFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_ITitleIconCacheInternal) -> nn_Result,
>;
pub type nn_sl_details_TitleIconCache_UpdateFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITitleIconCacheInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: ::core::ffi::c_int,
    ) -> nn_Result,
>;
pub type nn_sl_details_TitleIconCache_StoreFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_ITitleIconCacheInternal) -> nn_Result,
>;
pub type nn_sl_details_TitleIconCache_GetFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut nn_sl_details_ITitleIconCacheInternal,
        arg2: *mut nn_sl_IconInfo,
        arg3: ::core::ffi::c_int,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITitleIconCacheInternalVTable {
    pub instance: *mut nn_sl_details_ITitleIconCacheBase,
    pub __unk169: [::core::ffi::c_char; 4usize],
    pub __unk170: [::core::ffi::c_char; 4usize],
    pub destructor: *mut ::core::ffi::c_void,
    pub __unk171: [::core::ffi::c_char; 4usize],
    pub LoadFn: nn_sl_details_TitleIconCache_LoadFn,
    pub __unk172: [::core::ffi::c_char; 4usize],
    pub UpdateFn: nn_sl_details_TitleIconCache_UpdateFn,
    pub __unk173: [::core::ffi::c_char; 4usize],
    pub StoreFn: nn_sl_details_TitleIconCache_StoreFn,
    pub __unk174: [::core::ffi::c_char; 4usize],
    pub GetFn: nn_sl_details_TitleIconCache_GetFn,
}
impl Default for nn_sl_details_ITitleIconCacheInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ITitleIconCacheInternal {
    pub vtable: *mut nn_sl_details_ITitleIconCacheInternalVTable,
}
impl Default for nn_sl_details_ITitleIconCacheInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_ITitleIconCacheBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_ITitleIconCacheBase {
    pub vtable_: *const nn_sl_details_ITitleIconCacheBase__bindgen_vtable,
}
impl Default for nn_sl_details_ITitleIconCacheBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_TitleIconCacheFromPtr {
    pub _base: nn_sl_details_ITitleIconCacheBase,
    pub mInstancePtr: *mut nn_sl_details_ITitleIconCacheInternal,
}
impl Default for nn_sl_details_TitleIconCacheFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_LaunchInfoDatabaseInternal {
    pub currentIdPtr: *mut u64,
    pub entryCountPtr: *mut u32,
    pub maxEntriesPtr: *mut u32,
    pub pDatabase: *mut ::core::ffi::c_void,
    pub entriesPtr: *mut nn_sl_LaunchInfoDatabaseEntry,
    pub systemTablePtr: *mut nn_sl_LaunchInfoDatabaseEntry,
    pub systemTableNum: u32,
}
impl Default for nn_sl_details_LaunchInfoDatabaseInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_DataCreatorInternal {
    pub iconInfoAccessor: *mut nn_sl_details_IIconInfoAccessorInternal,
    pub accountInfoAccessor: *mut nn_sl_details_IAccountInfoAccessorInternal,
    pub settingInfoAccessor: *mut nn_sl_details_ISettingAccessorInternal,
    pub titleIconCache: *mut nn_sl_details_ITitleIconCacheInternal,
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_DataCreatorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_sl_details_IUpdatePackageAccessor_PackageExistsFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_IUpdatePackageAccessorInternal) -> bool,
>;
pub type nn_sl_details_IUpdatePackageAccessor_IsUpdatePackageDownloadedFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nn_sl_details_IUpdatePackageAccessorInternal) -> bool,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IUpdatePackageAccessorInternalVTable {
    pub instance: *mut nn_sl_details_IUpdatePackageAccessorBase,
    pub info: u32,
    pub __unk175: [::core::ffi::c_char; 4usize],
    pub destructor: u32,
    pub __unk176: [::core::ffi::c_char; 4usize],
    pub PackageExistsFn: nn_sl_details_IUpdatePackageAccessor_PackageExistsFn,
    pub __unk177: [::core::ffi::c_char; 4usize],
    pub IsUpdatePackageDownloadedFn:
        nn_sl_details_IUpdatePackageAccessor_IsUpdatePackageDownloadedFn,
    pub __unk178: [::core::ffi::c_char; 4usize],
}
impl Default for nn_sl_details_IUpdatePackageAccessorInternalVTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_IUpdatePackageAccessorInternal {
    pub vtable: *mut nn_sl_details_IUpdatePackageAccessorInternalVTable,
}
impl Default for nn_sl_details_IUpdatePackageAccessorInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_sl_details_IUpdatePackageAccessorBase__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_IUpdatePackageAccessorBase {
    pub vtable_: *const nn_sl_details_IUpdatePackageAccessorBase__bindgen_vtable,
}
impl Default for nn_sl_details_IUpdatePackageAccessorBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_details_UpdatePackageAccessorFromPtr {
    pub _base: nn_sl_details_IUpdatePackageAccessorBase,
    pub mInstancePtr: *mut nn_sl_details_IUpdatePackageAccessorInternal,
}
impl Default for nn_sl_details_UpdatePackageAccessorFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_ConditionInternal {
    pub settingAccessor: *mut nn_sl_details_ISettingAccessorInternal,
    pub updatePackageAccessor: *mut nn_sl_details_IUpdatePackageAccessorInternal,
    pub previousSendingTimeSerializer: *mut nn_sl_details_ISerializerInternal,
    pub timeAccessor: *mut nn_sl_details_ITimeAccessorInternal,
    pub vtable: *mut ::core::ffi::c_void,
}
impl Default for nn_sl_details_ConditionInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_KillerNotificationTransferRecordStreamInternal {
    pub vtable: *mut ::core::ffi::c_void,
    pub fileStream: nn_sl_details_FileStreamInternal,
    pub unkn1: u32,
    pub __unk179: [::core::ffi::c_char; 132usize],
}
impl Default for nn_sl_details_KillerNotificationTransferRecordStreamInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_TitleIconCacheInternal {
    pub vtable: *mut ::core::ffi::c_void,
    pub num: u32,
    pub cachedIconsBuffer: *mut ::core::ffi::c_void,
    pub iconInfoAccessor: *mut nn_sl_details_IIconInfoAccessorInternal,
    pub iconInfoSerializer: *mut nn_sl_details_ISerializerInternal,
    pub settingAccessor: *mut nn_sl_details_ISettingAccessorInternal,
}
impl Default for nn_sl_details_TitleIconCacheInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_details_CacheManagerInternal {
    pub quickStartTitleInfoSerializer: *mut nn_sl_details_ISerializerInternal,
    pub killerNotificationSerializer: *mut nn_sl_details_ISerializerInternal,
    pub jumpTitleInfoSerializer: *mut nn_sl_details_ISerializerInternal,
}
impl Default for nn_sl_details_CacheManagerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IStream {
    pub _base: nn_sl_details_IStreamBase,
    pub mInstance: nn_sl_details_IStreamInternal,
    pub mVTable: nn_sl_details_IStreamInternalVTable,
}
impl Default for nn_sl_IStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IAccountInfoAccessor {
    pub _base: nn_sl_details_IAccountInfoAccessorBase,
    pub mInstance: nn_sl_details_IAccountInfoAccessorInternal,
    pub mVTable: nn_sl_details_IAccountInfoAccessorInternalVTable,
}
impl Default for nn_sl_IAccountInfoAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod nn_sl_KillerNotificationType {
    pub type Type = ::core::ffi::c_uint;
    pub const PROMOTION: Type = 0;
    pub const PUSH_APP: Type = 1;
    pub const NON_COMMERCIAL: Type = 2;
}
pub mod nn_sl_KillerNotificationNotificationPattern {
    pub type Type = ::core::ffi::c_uint;
    pub const NORMAL: Type = 0;
    pub const SILENT: Type = 1;
}
pub mod nn_sl_KillerNotificationGender {
    pub type Type = ::core::ffi::c_uint;
    pub const UNKNOWN: Type = 0;
    pub const MALE: Type = 1;
    pub const FEMALE: Type = 2;
}
pub mod nn_sl_KillerNotificationAllowLocalAccount {
    pub type Type = i8;
    pub const ALLOW: Type = 0;
    pub const NOT_ALLOW: Type = 1;
}
pub mod nn_sl_KillerNotificationAccountMailActivation {
    pub type Type = i8;
    pub const NOT_ACTIVATED: Type = 0;
    pub const ANYBODY: Type = 1;
}
pub mod nn_sl_KillerNotificationConjunction {
    pub type Type = ::core::ffi::c_uint;
    pub const AND: Type = 0;
    pub const OR: Type = 1;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotificationInstalledTitleFilter {
    pub titleId: u64,
    pub conjunction: nn_sl_KillerNotificationConjunction::Type,
}
impl Default for nn_sl_KillerNotificationInstalledTitleFilter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotificationPlayedTitleFilter {
    pub titleId: u64,
    pub conjunction: nn_sl_KillerNotificationConjunction::Type,
}
impl Default for nn_sl_KillerNotificationPlayedTitleFilter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_KillerNotificationTitleFilter {
    pub titleId: u64,
    pub __unk101: [::core::ffi::c_char; 4usize],
    pub played: i32,
    pub __unk102: [::core::ffi::c_char; 4usize],
    pub installed: i32,
}
#[repr(C, packed)]
pub struct nn_sl_KillerNotification {
    pub serialId: u32,
    pub version: u32,
    pub __unk103: [::core::ffi::c_char; 16usize],
    pub deleteFlag: bool,
    pub language: [::core::ffi::c_char; 4usize],
    pub __unk104: [::core::ffi::c_char; 3usize],
    pub type_: nn_sl_KillerNotificationType::Type,
    pub notificationPattern: nn_sl_KillerNotificationNotificationPattern::Type,
    pub launchApplication: nn_sl_KillerNotification__bindgen_ty_1,
    pub priority: u32,
    pub images: nn_sl_KillerNotification__bindgen_ty_2,
    pub displayCondition: nn_sl_KillerNotification__bindgen_ty_3,
    pub __unk119: [::core::ffi::c_char; 8usize],
    pub formatVersion: u32,
    pub tags: u32,
    pub __unk120: [::core::ffi::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_1 {
    pub titleId: u64,
    pub parameter: [::core::ffi::c_char; 2048usize],
}
impl Default for nn_sl_KillerNotification__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_KillerNotification__bindgen_ty_2 {
    pub main: nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_1,
    pub button: nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_2,
    pub __unk105: __IncompleteArrayField<::core::ffi::c_char>,
    pub banner: [::core::ffi::c_char; 290416usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_1 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixels: [[u8; 854usize]; 400usize],
}
impl Default for nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_2 {
    pub palette: nn_sl_DRCImagePalette,
    pub pixels: [[u8; 487usize]; 160usize],
}
impl Default for nn_sl_KillerNotification__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nn_sl_KillerNotification__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3 {
    pub __unk106: [::core::ffi::c_char; 12usize],
    pub duration: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_1,
    pub __unk107: [::core::ffi::c_char; 4usize],
    pub lifetime: u32,
    pub __unk108: [::core::ffi::c_char; 4usize],
    pub account: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_2,
    pub titleFilter: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_3,
    pub __unk110: [::core::ffi::c_char; 1usize],
    pub ageRestriction: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_4,
    pub accountMailActivation: nn_sl_KillerNotificationAccountMailActivation::Type,
    pub __unk112: [::core::ffi::c_char; 11usize],
    pub accountBirthMonth: u32,
    pub __unk113: [::core::ffi::c_char; 4usize],
    pub anticipatoryDownload: i8,
    pub __unk114: [::core::ffi::c_char; 15usize],
    pub __bindgen_anon_1: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_5,
    pub __unk116: [::core::ffi::c_char; 12usize],
    pub __bindgen_anon_2: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_6,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_1 {
    pub startUnixTime: u64,
    pub endUnixTime: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_2 {
    pub age: nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
    pub gender: nn_sl_KillerNotificationGender::Type,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub lowerBound: u32,
    pub upperBound: u32,
}
impl Default for nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_3 {
    pub titleCount: u32,
    pub __unk109: [::core::ffi::c_char; 4usize],
    pub titles: [nn_sl_KillerNotificationTitleFilter; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_4 {
    pub allowLocalAccount: nn_sl_KillerNotificationAllowLocalAccount::Type,
    pub __unk111: [::core::ffi::c_char; 2usize],
    pub ageRestrictionLowerBound: u32,
}
impl Default for nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_5 {
    pub installedTitleCount: i32,
    pub installedConjunction: nn_sl_KillerNotificationConjunction::Type,
    pub __unk115: [::core::ffi::c_char; 4usize],
    pub installedTitleFilter: [nn_sl_KillerNotificationInstalledTitleFilter; 2usize],
}
impl Default for nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_6 {
    pub playedTitleFilterCount: u32,
    pub playedConjunction: nn_sl_KillerNotificationConjunction::Type,
    pub __unk117: [::core::ffi::c_char; 4usize],
    pub played_duration_sinceUnixTime: u32,
    pub __unk118: [::core::ffi::c_char; 4usize],
    pub playedTitleFilter: [nn_sl_KillerNotificationPlayedTitleFilter; 2usize],
}
impl Default for nn_sl_KillerNotification__bindgen_ty_3__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nn_sl_KillerNotification__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for nn_sl_KillerNotification {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IKillerNotificationAccessor {
    pub _base: nn_sl_details_IKillerNotificationAccessorBase,
    pub mInstance: nn_sl_details_IKillerNotificationAccessorInternal,
    pub mVTable: nn_sl_details_IKillerNotificationAccessorInternalVTable,
}
impl Default for nn_sl_IKillerNotificationAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ILaunchedTitleListAccessor {
    pub _base: nn_sl_details_ILaunchedTitleListAccessorBase,
    pub mInstance: nn_sl_details_ILaunchedTitleListAccessorInternal,
    pub mVTable: nn_sl_details_ILaunchedTitleListAccessorInternalVTable,
}
impl Default for nn_sl_ILaunchedTitleListAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod nn_sl_LaunchedTitleListAccessorType {
    pub type Type = ::core::ffi::c_uint;
    pub const TITLE_LIST_ACCESSOR_LAUNCHED_TITLES: Type = 0;
    pub const TITLE_LIST_ACCESSOR_PLAY_STATS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_sl_ISerializerBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ISerializer {
    pub _base: nn_sl_details_ISerializerBase,
    pub mInstance: nn_sl_details_ISerializerInternal,
    pub mVTable: nn_sl_details_ISerializerInternalVTable,
}
impl Default for nn_sl_ISerializer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ISettingAccessor {
    pub _base: nn_sl_details_ISettingAccessorBase,
    pub mInstance: nn_sl_details_ISettingAccessorInternal,
    pub mVTable: nn_sl_details_ISettingAccessorInternalVTable,
}
impl Default for nn_sl_ISettingAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ITimeAccessor {
    pub _base: nn_sl_details_ITimeAccessorBase,
    pub mInstance: nn_sl_details_ITimeAccessorInternal,
    pub mVTable: nn_sl_details_ITimeAccessorInternalVTable,
}
impl Default for nn_sl_ITimeAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_FileStream {
    pub _base: nn_sl_details_IStreamBase,
    pub mInstance: nn_sl_details_FileStreamInternal,
}
impl Default for nn_sl_FileStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IKillerNotificationTransferRecordManager {
    pub _base: nn_sl_details_IKillerNotificationTransferRecordManagerBase,
    pub mInstance: nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    pub mVTable: nn_sl_details_IKillerNotificationTransferRecordManagerInternalVTable,
}
impl Default for nn_sl_IKillerNotificationTransferRecordManager {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_KillerNotificationTransferRecordManager {
    pub _base: nn_sl_details_IKillerNotificationTransferRecordManagerBase,
    pub mInstance: nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
}
impl Default for nn_sl_KillerNotificationTransferRecordManager {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_KillerNotificationTransferRecordManagerInternal {
    pub _base: nn_sl_details_IKillerNotificationTransferRecordManagerBase,
    pub mInstance: nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal,
}
impl Default for nn_sl_KillerNotificationTransferRecordManagerInternal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_DiscCachedTitleAccessor {
    pub _base: nn_sl_details_IDiscCachedTitleAccessorBase,
    pub mInstance: nn_sl_details_IDiscCachedTitleAccessorInternal,
    pub mVTable: nn_sl_details_IDiscCachedTitleAccessorInternalVTable,
}
impl Default for nn_sl_DiscCachedTitleAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IInstalledTitleListAccessor {
    pub _base: nn_sl_details_IInstalledTitleListAccessorBase,
    pub mInstance: nn_sl_details_IInstalledTitleListAccessorInternal,
    pub mVTable: nn_sl_details_IInstalledTitleListAccessorInternalVTable,
}
impl Default for nn_sl_IInstalledTitleListAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_MetaInfoAccessor {
    pub _base: nn_sl_details_IMetaInfoAccessorBase,
    pub mInstance: nn_sl_details_IMetaInfoAccessorInternal,
    pub mVTable: nn_sl_details_IMetaInfoAccessorInternalVTable,
}
impl Default for nn_sl_MetaInfoAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ITitleListAccessor {
    pub _base: nn_sl_details_ITitleListAccessorBase,
    pub mInstance: nn_sl_details_ITitleListAccessorInternal,
    pub mVTable: nn_sl_details_ITitleListAccessorInternalVTable,
}
impl Default for nn_sl_ITitleListAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_TitleListCache {
    pub _base: nn_sl_details_ITitleListCacheBase,
    pub mInstance: nn_sl_details_ITitleListCacheInternal,
    pub mTitleListAccessor: nn_sl_details_TitleListAccessorFromPtr,
    pub mLaunchedTitleListAccessor: nn_sl_details_LaunchedTitleListAccessorFromPtr,
    pub mInstalledTitleListAccessor: nn_sl_details_InstalledTitleListAccessorFromPtr,
    pub mDiscCachedTitleAccessor: nn_sl_details_DiscCachedTitleAccessorFromPtr,
    pub mTitleInfoSerializer: nn_sl_details_SerializerFromPtr,
    pub mTimeAccessor: nn_sl_details_TimeAccessorFromPtr,
    pub mMetaInfoAccessor: nn_sl_details_MetaInfoAccessorFromPtr,
}
impl Default for nn_sl_TitleListCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_TitleListCacheFromPtr {
    pub _base: nn_sl_details_ITitleListCacheBase,
    pub mPtrInstance: *mut nn_sl_details_ITitleListCacheInternal,
}
impl Default for nn_sl_TitleListCacheFromPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_KillerNotificationSelector {
    pub mInstance: nn_sl_details_KillerNotificationSelectorInternal,
    pub mLaunchedTitleListAccessor: nn_sl_details_LaunchedTitleListAccessorFromPtr,
    pub mKillerNotificationAccessor: nn_sl_details_KillerNotificationAccessorFromPtr,
    pub mTitleListCache: nn_sl_TitleListCacheFromPtr,
    pub mKillerNotificationSerializer: nn_sl_details_SerializerFromPtr,
    pub mSettingAccessor: nn_sl_details_SettingAccessorFromPtr,
    pub mAccountInfoAccessor: nn_sl_details_AccountInfoAccessorFromPtr,
    pub mTimeAccessor: nn_sl_details_TimeAccessorFromPtr,
    pub mKillerNotificationTransferRecordManager:
        nn_sl_details_KillerNotificationTransferRecordManagerFromPtr,
}
impl Default for nn_sl_KillerNotificationSelector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ITransferrer {
    pub _base: nn_sl_details_ITransferrerBase,
    pub mInstance: nn_sl_details_ITransferrerInternal,
    pub mVTable: nn_sl_details_ITransferrerInternalVTable,
}
impl Default for nn_sl_ITransferrer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IPreferentialTitleAccessor {
    pub _base: nn_sl_details_IPreferentialTitleAccessorBase,
    pub mInstance: nn_sl_details_IPreferentialTitleAccessorInternal,
    pub mVTable: nn_sl_details_IPreferentialTitleAccessorInternalVTable,
}
impl Default for nn_sl_IPreferentialTitleAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_DrcManager {
    pub mInstance: nn_sl_details_DrcManagerInternal,
    pub mTransferrer: nn_sl_details_TransferrerFromPtr,
    pub mSettingAccessor: nn_sl_details_SettingAccessorFromPtr,
    pub mTimeAccessor: nn_sl_details_TimeAccessorFromPtr,
}
impl Default for nn_sl_DrcManager {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IBlackListAccessor {
    pub _base: nn_sl_details_IBlackListAccessorBase,
    pub mInstance: nn_sl_details_IBlackListAccessorInternal,
    pub mVTable: nn_sl_details_IBlackListAccessorInternalVTable,
}
impl Default for nn_sl_IBlackListAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IDefaultTitleAccessor {
    pub _base: nn_sl_details_IDefaultTitleAccessorBase,
    pub mInstance: nn_sl_details_IDefaultTitleAccessorInternal,
    pub mVTable: nn_sl_details_IDefaultTitleAccessorInternalVTable,
}
impl Default for nn_sl_IDefaultTitleAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IWhiteListAccessor {
    pub _base: nn_sl_details_IWhiteListAccessorBase,
    pub mInstance: nn_sl_details_IWhiteListAccessorInternal,
    pub mVTable: nn_sl_details_IWhiteListAccessorInternalVTable,
}
impl Default for nn_sl_IWhiteListAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_QuickStartApplicationSelector {
    pub mInstance: nn_sl_details_QuickStartApplicationSelectorInternal,
    pub mPreferentialTitleAccessorFromPtr: nn_sl_details_PreferentialTitleAccessorFromPtr,
    pub mDefaultTitleAccessorFromPtr: nn_sl_details_DefaultTitleAccessorFromPtr,
    pub mWhiteListAccessorFromPtr: nn_sl_details_WhiteListAccessorFromPtr,
    pub mTitleListCacheFromPtr: nn_sl_TitleListCacheFromPtr,
    pub mSettingAccessorFromPtr: nn_sl_details_SettingAccessorFromPtr,
    pub mBlackListAccessorFromPtr: nn_sl_details_BlackListAccessorFromPtr,
}
impl Default for nn_sl_QuickStartApplicationSelector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IIconInfoAccessor {
    pub _base: nn_sl_details_IIconInfoAccessorBase,
    pub mInstance: nn_sl_details_IIconInfoAccessorInternal,
    pub mVTable: nn_sl_details_IIconInfoAccessorInternalVTable,
}
impl Default for nn_sl_IIconInfoAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_ITitleIconCache {
    pub _base: nn_sl_details_ITitleIconCacheBase,
    pub mInstance: nn_sl_details_ITitleIconCacheInternal,
    pub mVTable: nn_sl_details_ITitleIconCacheInternalVTable,
}
impl Default for nn_sl_ITitleIconCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_LaunchInfoDatabase {
    pub mInstance: nn_sl_details_LaunchInfoDatabaseInternal,
}
impl Default for nn_sl_LaunchInfoDatabase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_DataCreator {
    pub mInstance: nn_sl_details_DataCreatorInternal,
    pub mIconInfoAccessor: nn_sl_details_IconInfoAccessorFromPtr,
    pub mAccountInfoAccessor: nn_sl_details_AccountInfoAccessorFromPtr,
    pub mSettingAccessor: nn_sl_details_SettingAccessorFromPtr,
    pub mTitleIconCache: nn_sl_details_TitleIconCacheFromPtr,
}
impl Default for nn_sl_DataCreator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_IUpdatePackageAccessor {
    pub _base: nn_sl_details_IUpdatePackageAccessorBase,
    pub mInstance: nn_sl_details_IUpdatePackageAccessorInternal,
    pub mVTable: nn_sl_details_IUpdatePackageAccessorInternalVTable,
}
impl Default for nn_sl_IUpdatePackageAccessor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_Condition {
    pub mInstance: nn_sl_details_ConditionInternal,
    pub mSettingAccessor: nn_sl_details_SettingAccessorFromPtr,
    pub mUpdatePackageAccessor: nn_sl_details_UpdatePackageAccessorFromPtr,
    pub mPreviousSendingTimeSerializer: nn_sl_details_SerializerFromPtr,
    pub mTimeAccessor: nn_sl_details_TimeAccessorFromPtr,
}
impl Default for nn_sl_Condition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_KillerNotificationTransferRecordStream {
    pub _base: nn_sl_details_IStreamBase,
    pub mInstance: *mut nn_sl_details_KillerNotificationTransferRecordStreamInternal,
}
impl Default for nn_sl_KillerNotificationTransferRecordStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_TitleIconCache {
    pub _base: nn_sl_details_ITitleIconCacheBase,
    pub mInstance: nn_sl_details_TitleIconCacheInternal,
}
impl Default for nn_sl_TitleIconCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nn_sl_CacheManager {
    pub mInstance: nn_sl_details_CacheManagerInternal,
    pub mQuickStartTitleInfoSerializer: nn_sl_details_SerializerFromPtr,
    pub mKillerNotificationSerializer: nn_sl_details_SerializerFromPtr,
    pub mJumpTitleInfoSerializer: nn_sl_details_SerializerFromPtr,
}
impl Default for nn_sl_CacheManager {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod nn_spm_StorageType {
    pub type Type = u32;
    pub const STORAGE_TYPE_RAW: Type = 0;
    pub const STORAGE_TYPE_WFS: Type = 1;
}
pub type nn_spm_StorageIndex = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_spm_VolumeId {
    pub id: [::core::ffi::c_char; 16usize],
}
impl nn_spm_VolumeId {
    #[inline]
    pub unsafe fn Compare(&self, other: *const nn_spm_VolumeId) -> i32 {
        nn_spm_VolumeId_Compare(self, other)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_spm_StorageListItem {
    pub index: nn_spm_StorageIndex,
    pub __unk180: [::core::ffi::c_char; 4usize],
    pub type_: nn_spm_StorageType::Type,
}
impl Default for nn_spm_StorageListItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_spm_StorageInfo {
    pub path: [::core::ffi::c_char; 640usize],
    pub connection_type_string: [::core::ffi::c_char; 8usize],
    pub format_string: [::core::ffi::c_char; 8usize],
    pub __unk181: [::core::ffi::c_char; 4usize],
    pub type_: nn_spm_StorageType::Type,
    pub volumeId: nn_spm_VolumeId,
}
impl Default for nn_spm_StorageInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_ac_ConfigIdNum = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_cfg_CTR_UserName {
    pub name: [u16; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_uds_Cafe_ScrambledLocalFriendCode {
    pub localFriendCode: u64,
    pub networkNodeId: u16,
    pub xorKey: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_uds_Cafe_NodeInformation {
    pub scrambledLocalFriendCode: nn_uds_Cafe_ScrambledLocalFriendCode,
    pub username: nn_cfg_CTR_UserName,
    pub networkNodeId: u16,
    pub __unk182: [::core::ffi::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_uds_Cafe_ConnectionStatus {
    pub status: u32,
    pub reason: u32,
    pub networkNodeId: u16,
    pub changedNodes: u16,
    pub nodes: [u16; 16usize],
    pub totalNodes: u8,
    pub maxNodes: u8,
    pub nodeBitmask: u16,
}
pub const nn_uds_Cafe_kWorkMemorySize: u32 = 81920;
pub type nn_uds_Cafe_EndpointDescriptor = u32;
pub mod nn_uds_Cafe_PollStateChangeFlags {
    pub type Type = u8;
    pub const UDS_POLL_NONBLOCK: Type = 1;
}
pub mod nn_uds_Cafe_ReceiveFlags {
    pub type Type = u8;
    pub const UDS_RECEIVE_NONBLOCK: Type = 1;
}
pub mod nn_dlp_Cafe_PollStateChangeFlags {
    pub type Type = u8;
    pub const DLP_POLL_NONBLOCK: Type = 1;
}
pub mod nn_dlp_Cafe_ClientState {
    pub type Type = u32;
    pub const Accepted: Type = 5;
    pub const Receiving: Type = 6;
    pub const Ready: Type = 7;
    pub const Connecting: Type = 64;
}
pub mod nn_dlp_Cafe_ServerState {
    pub type Type = u32;
    pub const Uninitialized: Type = 0;
    pub const Idle: Type = 1;
    pub const Open: Type = 2;
    pub const DistributingInternal: Type = 7;
    pub const Distributed: Type = 8;
    pub const Finished: Type = 9;
    pub const Failed: Type = 10;
    pub const Distributing: Type = 11;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_dlp_Cafe_Server {
    pub _address: u8,
}
impl nn_dlp_Cafe_Server {
    #[inline]
    pub unsafe fn AcceptClient(nodeId: u16) -> nn_Result {
        nn_dlp_Cafe_Server_AcceptClient(nodeId)
    }
    #[inline]
    pub unsafe fn CloseSessions() -> nn_Result {
        nn_dlp_Cafe_Server_CloseSessions()
    }
    #[inline]
    pub unsafe fn DisconnectClient(nodeId: u16) -> nn_Result {
        nn_dlp_Cafe_Server_DisconnectClient(nodeId)
    }
    #[inline]
    pub unsafe fn Finalize() -> nn_Result {
        nn_dlp_Cafe_Server_Finalize()
    }
    #[inline]
    pub unsafe fn GetClientInfo(
        clientInfo: *mut nn_uds_Cafe_NodeInformation,
        nodeId: u16,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_GetClientInfo(clientInfo, nodeId)
    }
    #[inline]
    pub unsafe fn GetClientState(
        state: *mut nn_dlp_Cafe_ClientState::Type,
        nodeId: u16,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_GetClientState(state, nodeId)
    }
    #[inline]
    pub unsafe fn GetClientState1(
        state: *mut nn_dlp_Cafe_ClientState::Type,
        unitsTotal: *mut u32,
        unitsReceived: *mut u32,
        nodeId: u16,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_GetClientState1(state, unitsTotal, unitsReceived, nodeId)
    }
    #[inline]
    pub unsafe fn GetConnectingClients(
        receivedLength: *mut u16,
        connectingClients: *mut u16,
        length: u16,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_GetConnectingClients(receivedLength, connectingClients, length)
    }
    #[inline]
    pub unsafe fn GetState(state: *mut nn_dlp_Cafe_ServerState::Type) -> nn_Result {
        nn_dlp_Cafe_Server_GetState(state)
    }
    #[inline]
    pub unsafe fn Initialize(
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_Initialize(maxClientNum, uniqueId, childIndex, userName)
    }
    #[inline]
    pub unsafe fn Initialize1(
        dupNoticeNeed: *mut bool,
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result {
        nn_dlp_Cafe_Server_Initialize1(dupNoticeNeed, maxClientNum, uniqueId, childIndex, userName)
    }
    #[inline]
    pub unsafe fn OpenSessions(isManualAccept: bool, channel: u8) -> nn_Result {
        nn_dlp_Cafe_Server_OpenSessions(isManualAccept, channel)
    }
    #[inline]
    pub unsafe fn PollStateChange(flags: u8) -> nn_Result {
        nn_dlp_Cafe_Server_PollStateChange(flags)
    }
    #[inline]
    pub unsafe fn RebootAllClients(passPhrase: *const ::core::ffi::c_char) -> nn_Result {
        nn_dlp_Cafe_Server_RebootAllClients(passPhrase)
    }
    #[inline]
    pub unsafe fn StartDistribution() -> nn_Result {
        nn_dlp_Cafe_Server_StartDistribution()
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_dlp_Cafe_ServerPrivate {
    pub _address: u8,
}
impl nn_dlp_Cafe_ServerPrivate {
    #[inline]
    pub unsafe fn GetInternalState(state: *mut nn_dlp_Cafe_ServerState::Type) -> nn_Result {
        nn_dlp_Cafe_ServerPrivate_GetInternalState(state)
    }
    #[inline]
    pub unsafe fn Initialize(
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        blockBufferSize: u32,
        blockBufferNum: u32,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result {
        nn_dlp_Cafe_ServerPrivate_Initialize(
            maxClientNum,
            uniqueId,
            childIndex,
            blockBufferSize,
            blockBufferNum,
            userName,
        )
    }
    #[inline]
    pub unsafe fn Initialize1(
        dupNoticeNeed: *mut bool,
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        blockBufferSize: u32,
        blockBufferNum: u32,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result {
        nn_dlp_Cafe_ServerPrivate_Initialize1(
            dupNoticeNeed,
            maxClientNum,
            uniqueId,
            childIndex,
            blockBufferSize,
            blockBufferNum,
            userName,
        )
    }
}
pub mod nn_pdm_PlayDiaryFlags {
    pub type Type = u16;
    pub const PLAYDIARY_FLAG_DEFAULT: Type = 0;
    pub const PLAYDIARY_FLAG_PLAYED_IN_WII_MODE: Type = 256;
    pub const PLAYDIARY_FLAG_UNKNOWN_0A00: Type = 2560;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_pdm_PlayDiary {
    pub title_id: u64,
    pub playtime: u32,
    pub date: u16,
    pub flags: nn_pdm_PlayDiaryFlags::Type,
}
impl Default for nn_pdm_PlayDiary {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_pdm_PlayStats {
    pub title_id: u64,
    pub playtime: u32,
    pub times_played: u16,
    pub first_time_played: u16,
    pub last_time_played: u16,
    pub __unk184: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_pdm_PlayEvent {
    pub title_id: u64,
    pub __unk185: [::core::ffi::c_char; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_pdm_PlayLog {
    pub title_id: u64,
    pub __unk186: [::core::ffi::c_char; 16usize],
}
pub type nn_act_ACTLoadOption = u32;
pub type nn_act_SlotNo = u8;
pub type nn_act_LocalFriendCode = u64;
pub type nn_act_PersistentId = u32;
pub type nn_act_PrincipalId = u32;
pub type nn_act_SimpleAddressId = u32;
pub type nn_act_TransferrableId = u64;
pub const nn_act_AccountIdSize: usize = 17;
pub const nn_act_DeviceHashSize: usize = 8;
pub const nn_act_NfsPasswordSize: usize = 17;
pub const nn_act_MiiNameSize: usize = 11;
pub const nn_act_UuidSize: usize = 16;
pub mod nn_fp_NotificationType {
    pub type Type = ::core::ffi::c_uint;
    pub const NOTIFICATION_ONLINE: Type = 1;
    pub const NOTIFICATION_OFFLINE: Type = 2;
    pub const NOTIFICATION_PREFERENCE: Type = 3;
    pub const NOTIFICATION_FRIEND_ONLINE: Type = 4;
    pub const NOTIFICATION_FRIEND_OFFLINE: Type = 5;
    pub const NOTIFICATION_FRIEND_PRESENCE: Type = 6;
    pub const NOTIFICATION_FRIEND_MII: Type = 7;
    pub const NOTIFICATION_FRIEND_PROFILE: Type = 8;
    pub const NOTIFICATION_FRIEND_ADDED: Type = 9;
    pub const NOTIFICATION_FRIEND_REMOVED: Type = 10;
    pub const NOTIFICATION_MY_REQUEST_ADDED: Type = 11;
    pub const NOTIFICATION_MY_REQUEST_REMOVED: Type = 12;
    pub const NOTIFICATION_MY_REQUEST_UPDATED: Type = 13;
    pub const NOTIFICATION_BLACKLIST_ADDED: Type = 14;
    pub const NOTIFICATION_BLACKLIST_REMOVED: Type = 15;
    pub const NOTIFICATION_BLACKLIST_UPDATED: Type = 16;
    pub const NOTIFICATION_REQUEST_ADDED: Type = 17;
    pub const NOTIFICATION_REQUEST_REMOVED: Type = 18;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_DateTime {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minutes: u8,
    pub seconds: u8,
    pub milliseconds: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_GameKey {
    pub titleId: u64,
    pub unk_0x8: u16,
    pub unk_0xC: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_RecentPlayRecord {
    pub principalId: nn_act_PrincipalId,
    pub unk_0x04: u16,
    pub inGameName: [u16; 17usize],
    pub myMiiName: [u16; 17usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_RecentPlayRecordEx {
    pub playRecord: nn_fp_RecentPlayRecord,
    pub game: nn_fp_GameKey,
    pub date: nn_fp_DateTime,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_Preference {
    pub unk_0x00: bool,
    pub unk_0x01: bool,
    pub unk_0x02: bool,
    pub __unk187: [::core::ffi::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_GameMode {
    pub joinAvailabilityFlag: BOOL,
    pub matchmakeSystemType: u32,
    pub joinGameId: u32,
    pub joinGameMode: u32,
    pub ownerPrincipalId: nn_act_PrincipalId,
    pub joinGroupId: u32,
    pub applicationArg: [u8; 20usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_Presence {
    pub gameMode: nn_fp_GameMode,
    pub region: u8,
    pub language: u8,
    pub platform: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_FriendPresence {
    pub _base: nn_fp_Presence,
    pub isOnline: bool,
    pub isValid: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_fp_MyPresence {
    pub _base: nn_fp_Presence,
    pub presenceText: [u16; 64usize],
}
impl Default for nn_fp_MyPresence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_fp_BasicInfo {
    pub __unk188: [::core::ffi::c_char; 104usize],
}
impl Default for nn_fp_BasicInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_fp_BlackListedPrincipal {
    pub __unk189: [::core::ffi::c_char; 176usize],
}
impl Default for nn_fp_BlackListedPrincipal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_Profile {
    pub __unk190: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_Comment {
    pub unk_0x00: u8,
    pub unk_0x01: u8,
    pub comment: [u16; 17usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_fp_FriendData {
    pub __unk191: [::core::ffi::c_char; 552usize],
}
impl Default for nn_fp_FriendData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_fp_GameModeDescription {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_fp_FriendRequest {
    pub __unk192: [::core::ffi::c_char; 356usize],
}
impl Default for nn_fp_FriendRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nn_fp_FPAsyncCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: nn_Result, arg2: *mut ::core::ffi::c_void)>;
pub type nn_fp_NotificationHandlerFn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: nn_fp_NotificationType::Type,
        arg2: nn_act_PrincipalId,
        arg3: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_idb_FileHeaderEntry {
    pub titleId: u64,
    pub u1: u32,
    pub __unk193: [::core::ffi::c_char; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_idb_FileHeader {
    pub version: u32,
    pub entries: [nn_idb_FileHeaderEntry; 300usize],
}
impl Default for nn_idb_FileHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nn_idb_IconDataKey {
    pub titleId: u64,
    pub u1: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_idb_Utf16NameBuffer {
    pub utf16Str: [u16; 256usize],
}
impl Default for nn_idb_Utf16NameBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nn_idb_IconDataRaw {
    pub titleID: u64,
    pub __unk194: [::core::ffi::c_char; 12usize],
    pub u6: [::core::ffi::c_char; 16usize],
    pub __unk195: [::core::ffi::c_char; 12usize],
    pub names: [nn_idb_Utf16NameBuffer; 15usize],
    pub __unk196: [::core::ffi::c_char; 512usize],
    pub icon: [u8; 65580usize],
    pub __unk197: [::core::ffi::c_char; 4usize],
}
impl Default for nn_idb_IconDataRaw {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct nn_idb_IDBReader {
    pub mPath: std_string,
    pub mFileHeader: *mut nn_idb_FileHeader,
    pub mFile: *mut FILE,
    pub mInitDone: bool,
}
impl Default for nn_idb_IDBReader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl nn_idb_IDBReader {
    #[inline]
    pub unsafe fn LoadIconDataFromIdb(
        &self,
        titleId: u64,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> nn_Result {
        nn_idb_IDBReader_LoadIconDataFromIdb(self, titleId, iconData)
    }
    #[inline]
    pub unsafe fn SearchFromDataBase(
        &self,
        key: *mut nn_idb_IconDataKey,
        outIndex: *mut u32,
    ) -> bool {
        nn_idb_IDBReader_SearchFromDataBase(self, key, outIndex)
    }
    #[inline]
    pub unsafe fn LoadIconDataFromDatabase(
        &self,
        index: u32,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> bool {
        nn_idb_IDBReader_LoadIconDataFromDatabase(self, index, iconData)
    }
    #[inline]
    pub unsafe fn LoadIconData(
        &self,
        titleId: u64,
        u1: u32,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> bool {
        nn_idb_IDBReader_LoadIconData(self, titleId, u1, iconData)
    }
    #[inline]
    pub unsafe fn Initialize(&mut self, path: *const std_string) -> bool {
        nn_idb_IDBReader_Initialize(self, path)
    }
    #[inline]
    pub unsafe fn Initialize1(&mut self) -> bool {
        nn_idb_IDBReader_Initialize1(self)
    }
    #[inline]
    pub unsafe fn Finalize(&mut self) {
        nn_idb_IDBReader_Finalize(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        nn_idb_IDBReader_IDBReader_destructor(self)
    }
}
pub mod WPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_CHAN_0: Type = 0;
    pub const WPAD_CHAN_1: Type = 1;
    pub const WPAD_CHAN_2: Type = 2;
    pub const WPAD_CHAN_3: Type = 3;
    pub const WPAD_CHAN_4: Type = 4;
    pub const WPAD_CHAN_5: Type = 5;
    pub const WPAD_CHAN_6: Type = 6;
}
pub mod WPADDataFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_FMT_CORE: Type = 0;
    pub const WPAD_FMT_CORE_ACC: Type = 1;
    pub const WPAD_FMT_CORE_ACC_DPD: Type = 2;
    pub const WPAD_FMT_NUNCHUK: Type = 3;
    pub const WPAD_FMT_NUNCHUK_ACC: Type = 4;
    pub const WPAD_FMT_NUNCHUK_ACC_DPD: Type = 5;
    pub const WPAD_FMT_CLASSIC: Type = 6;
    pub const WPAD_FMT_CLASSIC_ACC: Type = 7;
    pub const WPAD_FMT_CLASSIC_ACC_DPD: Type = 8;
    pub const WPAD_FMT_CORE_ACC_DPD_FULL: Type = 9;
    pub const WPAD_FMT_TRAIN: Type = 10;
    pub const WPAD_FMT_GUITAR: Type = 11;
    pub const WPAD_FMT_BALANCE_BOARD: Type = 12;
    pub const WPAD_FMT_DRUM: Type = 15;
    pub const WPAD_FMT_MPLUS: Type = 16;
    pub const WPAD_FMT_TAIKO: Type = 17;
    pub const WPAD_FMT_PRO_CONTROLLER: Type = 22;
}
pub mod WPADExtensionType {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_EXT_CORE: Type = 0;
    pub const WPAD_EXT_NUNCHUK: Type = 1;
    pub const WPAD_EXT_CLASSIC: Type = 2;
    pub const WPAD_EXT_MPLUS: Type = 5;
    pub const WPAD_EXT_MPLUS_NUNCHUK: Type = 6;
    pub const WPAD_EXT_MPLUS_CLASSIC: Type = 7;
    pub const WPAD_EXT_PRO_CONTROLLER: Type = 31;
    pub const WPAD_EXT_DEV_NOT_FOUND: Type = 253;
    pub const WPAD_EXT_UNKNOWN: Type = 255;
}
pub mod WPADButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_BUTTON_LEFT: Type = 1;
    pub const WPAD_BUTTON_RIGHT: Type = 2;
    pub const WPAD_BUTTON_DOWN: Type = 4;
    pub const WPAD_BUTTON_UP: Type = 8;
    pub const WPAD_BUTTON_PLUS: Type = 16;
    pub const WPAD_BUTTON_2: Type = 256;
    pub const WPAD_BUTTON_1: Type = 512;
    pub const WPAD_BUTTON_B: Type = 1024;
    pub const WPAD_BUTTON_A: Type = 2048;
    pub const WPAD_BUTTON_MINUS: Type = 4096;
    pub const WPAD_BUTTON_Z: Type = 8192;
    pub const WPAD_BUTTON_C: Type = 16384;
    pub const WPAD_BUTTON_HOME: Type = 32768;
}
pub mod WPADNunchukButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_NUNCHUK_STICK_EMULATION_LEFT: Type = 1;
    pub const WPAD_NUNCHUK_STICK_EMULATION_RIGHT: Type = 2;
    pub const WPAD_NUNCHUK_STICK_EMULATION_DOWN: Type = 4;
    pub const WPAD_NUNCHUK_STICK_EMULATION_UP: Type = 8;
    pub const WPAD_NUNCHUK_BUTTON_Z: Type = 8192;
    pub const WPAD_NUNCHUK_BUTTON_C: Type = 16384;
}
pub mod WPADClassicButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_CLASSIC_BUTTON_UP: Type = 1;
    pub const WPAD_CLASSIC_BUTTON_LEFT: Type = 2;
    pub const WPAD_CLASSIC_BUTTON_ZR: Type = 4;
    pub const WPAD_CLASSIC_BUTTON_X: Type = 8;
    pub const WPAD_CLASSIC_BUTTON_A: Type = 16;
    pub const WPAD_CLASSIC_BUTTON_Y: Type = 32;
    pub const WPAD_CLASSIC_BUTTON_B: Type = 64;
    pub const WPAD_CLASSIC_BUTTON_ZL: Type = 128;
    pub const WPAD_CLASSIC_BUTTON_R: Type = 512;
    pub const WPAD_CLASSIC_BUTTON_PLUS: Type = 1024;
    pub const WPAD_CLASSIC_BUTTON_HOME: Type = 2048;
    pub const WPAD_CLASSIC_BUTTON_MINUS: Type = 4096;
    pub const WPAD_CLASSIC_BUTTON_L: Type = 8192;
    pub const WPAD_CLASSIC_BUTTON_DOWN: Type = 16384;
    pub const WPAD_CLASSIC_BUTTON_RIGHT: Type = 32768;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_LEFT: Type = 65536;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_RIGHT: Type = 131072;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_DOWN: Type = 262144;
    pub const WPAD_CLASSIC_STICK_L_EMULATION_UP: Type = 524288;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_LEFT: Type = 1048576;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_RIGHT: Type = 2097152;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_DOWN: Type = 4194304;
    pub const WPAD_CLASSIC_STICK_R_EMULATION_UP: Type = 8388608;
}
pub mod WPADProButton {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_PRO_BUTTON_UP: Type = 1;
    pub const WPAD_PRO_BUTTON_LEFT: Type = 2;
    pub const WPAD_PRO_TRIGGER_ZR: Type = 4;
    pub const WPAD_PRO_BUTTON_X: Type = 8;
    pub const WPAD_PRO_BUTTON_A: Type = 16;
    pub const WPAD_PRO_BUTTON_Y: Type = 32;
    pub const WPAD_PRO_BUTTON_B: Type = 64;
    pub const WPAD_PRO_TRIGGER_ZL: Type = 128;
    pub const WPAD_PRO_RESERVED: Type = 256;
    pub const WPAD_PRO_TRIGGER_R: Type = 512;
    pub const WPAD_PRO_BUTTON_PLUS: Type = 1024;
    pub const WPAD_PRO_BUTTON_HOME: Type = 2048;
    pub const WPAD_PRO_BUTTON_MINUS: Type = 4096;
    pub const WPAD_PRO_TRIGGER_L: Type = 8192;
    pub const WPAD_PRO_BUTTON_DOWN: Type = 16384;
    pub const WPAD_PRO_BUTTON_RIGHT: Type = 32768;
    pub const WPAD_PRO_BUTTON_STICK_R: Type = 65536;
    pub const WPAD_PRO_BUTTON_STICK_L: Type = 131072;
    pub const WPAD_PRO_STICK_L_EMULATION_UP: Type = 2097152;
    pub const WPAD_PRO_STICK_L_EMULATION_DOWN: Type = 1048576;
    pub const WPAD_PRO_STICK_L_EMULATION_LEFT: Type = 262144;
    pub const WPAD_PRO_STICK_L_EMULATION_RIGHT: Type = 524288;
    pub const WPAD_PRO_STICK_R_EMULATION_UP: Type = 33554432;
    pub const WPAD_PRO_STICK_R_EMULATION_DOWN: Type = 16777216;
    pub const WPAD_PRO_STICK_R_EMULATION_LEFT: Type = 4194304;
    pub const WPAD_PRO_STICK_R_EMULATION_RIGHT: Type = 8388608;
}
pub mod WPADLed {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_LED_ONE: Type = 1;
    pub const WPAD_LED_TWO: Type = 2;
    pub const WPAD_LED_THREE: Type = 4;
    pub const WPAD_LED_FOUR: Type = 8;
}
pub mod WPADDpdFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_DPD_FMT_NONE: Type = 0;
    pub const WPAD_DPD_FMT_BASIC: Type = 1;
    pub const WPAD_DPD_FMT_EXTENDED: Type = 3;
    pub const WPAD_DPD_FMT_FULL: Type = 5;
}
pub mod WPADSpeakerCmd {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_SPEAKER_CMD_OFF: Type = 0;
    pub const WPAD_SPEAKER_CMD_ON: Type = 1;
    pub const WPAD_SPEAKER_CMD_MUTE: Type = 2;
    pub const WPAD_SPEAKER_CMD_UNMUTE: Type = 3;
    pub const WPAD_SPEAKER_CMD_PLAY: Type = 4;
    pub const WPAD_SPEAKER_CMD_ON_ALT: Type = 5;
}
pub mod WPADMplsMode {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_MPLS_MODE_DISABLE: Type = 0;
    pub const WPAD_MPLS_MODE_MPLS_ONLY: Type = 4;
    pub const WPAD_MPLS_MODE_MPLS_NUNCHUK: Type = 5;
    pub const WPAD_MPLS_MODE_MPLS_CLASSIC: Type = 7;
}
pub mod WPADPeripheralSpace {
    pub type Type = ::core::ffi::c_uint;
    pub const WPAD_PERIPHERAL_SPACE_SPEAKER: Type = 162;
    pub const WPAD_PERIPHERAL_SPACE_EXTENSION: Type = 164;
    pub const WPAD_PERIPHERAL_SPACE_MOTIONPLUS: Type = 166;
    pub const WPAD_PERIPHERAL_SPACE_DPD: Type = 176;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADVec2D {
    pub x: i16,
    pub y: i16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADStatusProController {
    pub __unk24: [::core::ffi::c_char; 40usize],
    pub extensionType: u8,
    pub err: u8,
    pub __unk25: [::core::ffi::c_char; 2usize],
    pub buttons: u32,
    pub leftStick: WPADVec2D,
    pub rightStick: WPADVec2D,
    pub __unk26: [::core::ffi::c_char; 8usize],
    pub dataFormat: WPADDataFormat::Type,
}
impl Default for WPADStatusProController {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADInfo {
    pub irEnabled: u32,
    pub speakerEnabled: u32,
    pub extensionAttached: u32,
    pub batteryLow: u32,
    pub batteryNearEmpty: u32,
    pub batteryLevel: u8,
    pub led: u8,
    pub protocol: u8,
    pub firmware: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueueElement {
    pub data: [u8; 48usize],
}
impl Default for WPADiQueueElement {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WPADiQueue {
    pub frontIndex: u8,
    pub backIndex: u8,
    pub __unk27: [::core::ffi::c_char; 2usize],
    pub elements: *mut WPADiQueueElement,
    pub capacity: u32,
}
impl Default for WPADiQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WPADAddress {
    pub btDeviceAddress: [u8; 6usize],
}
pub type WPADIsMplsAttachedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlLedCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlDpdCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADControlSpeakerCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADGetInfoCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADReadMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADWriteMemoryCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type)>;
pub type WPADExtensionCallback = ::core::option::Option<
    unsafe extern "C" fn(chan: WPADChan::Type, ext: WPADExtensionType::Type),
>;
pub type WPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADiSendCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub type WPADiWriteGameDataCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: WPADChan::Type, status: i32)>;
pub use self::WPADChan::Type as KPADChan;
pub use self::WPADDataFormat::Type as KPADDataFormat;
pub use self::WPADExtensionType::Type as KPADExtensionType;
pub use self::WPADMplsMode::Type as KPADMplsMode;
pub mod KPADError {
    pub type Type = ::core::ffi::c_int;
    pub const KPAD_ERROR_OK: Type = 0;
    pub const KPAD_ERROR_NO_SAMPLES: Type = -1;
    pub const KPAD_ERROR_INVALID_CONTROLLER: Type = -2;
    pub const KPAD_ERROR_WPAD_UNINIT: Type = -3;
    pub const KPAD_ERROR_BUSY: Type = -4;
    pub const KPAD_ERROR_UNINITIALIZED: Type = -5;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub pos: KPADVec2D,
    pub __unk28: [::core::ffi::c_char; 12usize],
    pub angle: KPADVec2D,
    pub __unk29: [::core::ffi::c_char; 32usize],
    pub extensionType: u8,
    pub error: i8,
    pub posValid: i8,
    pub format: u8,
    pub __bindgen_anon_1: KPADStatus__bindgen_ty_1,
    pub __unk31: [::core::ffi::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union KPADStatus__bindgen_ty_1 {
    pub nunchuk: KPADStatus__bindgen_ty_1__bindgen_ty_1,
    pub classic: KPADStatus__bindgen_ty_1__bindgen_ty_2,
    pub pro: KPADStatus__bindgen_ty_1__bindgen_ty_3,
    pub __unk30: [::core::ffi::c_char; 80usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_1 {
    pub stick: KPADVec2D,
    pub acc: KPADVec3D,
    pub accMagnitude: f32,
    pub accVariation: f32,
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_2 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub leftTrigger: f32,
    pub rightTrigger: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KPADStatus__bindgen_ty_1__bindgen_ty_3 {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: KPADVec2D,
    pub rightStick: KPADVec2D,
    pub charging: i32,
    pub wired: i32,
}
impl Default for KPADStatus__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for KPADStatus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KPADConnectCallback = WPADConnectCallback;
pub mod VPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_CHAN_0: Type = 0;
    pub const VPAD_CHAN_1: Type = 1;
}
pub mod VPADIRCStatusFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_IRC_STATUS_FLAG_HAS_DATA: Type = 1;
    pub const VPAD_IRC_STATUS_FLAG_CONNECTED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VPADGyroStatus {
    _unused: [u8; 0],
}
pub mod VPADButtons {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_BUTTON_A: Type = 32768;
    pub const VPAD_BUTTON_B: Type = 16384;
    pub const VPAD_BUTTON_X: Type = 8192;
    pub const VPAD_BUTTON_Y: Type = 4096;
    pub const VPAD_BUTTON_LEFT: Type = 2048;
    pub const VPAD_BUTTON_RIGHT: Type = 1024;
    pub const VPAD_BUTTON_UP: Type = 512;
    pub const VPAD_BUTTON_DOWN: Type = 256;
    pub const VPAD_BUTTON_ZL: Type = 128;
    pub const VPAD_BUTTON_ZR: Type = 64;
    pub const VPAD_BUTTON_L: Type = 32;
    pub const VPAD_BUTTON_R: Type = 16;
    pub const VPAD_BUTTON_PLUS: Type = 8;
    pub const VPAD_BUTTON_MINUS: Type = 4;
    pub const VPAD_BUTTON_HOME: Type = 2;
    pub const VPAD_BUTTON_SYNC: Type = 1;
    pub const VPAD_BUTTON_STICK_R: Type = 131072;
    pub const VPAD_BUTTON_STICK_L: Type = 262144;
    pub const VPAD_BUTTON_TV: Type = 65536;
    pub const VPAD_STICK_R_EMULATION_LEFT: Type = 67108864;
    pub const VPAD_STICK_R_EMULATION_RIGHT: Type = 33554432;
    pub const VPAD_STICK_R_EMULATION_UP: Type = 16777216;
    pub const VPAD_STICK_R_EMULATION_DOWN: Type = 8388608;
    pub const VPAD_STICK_L_EMULATION_LEFT: Type = 1073741824;
    pub const VPAD_STICK_L_EMULATION_RIGHT: Type = 536870912;
    pub const VPAD_STICK_L_EMULATION_UP: Type = 268435456;
    pub const VPAD_STICK_L_EMULATION_DOWN: Type = 134217728;
}
pub mod VPADTouchPadValidity {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_VALID: Type = 0;
    pub const VPAD_INVALID_X: Type = 1;
    pub const VPAD_INVALID_Y: Type = 2;
}
pub mod VPADTouchPadResolution {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_TP_1920X1080: Type = 0;
    pub const VPAD_TP_1280X720: Type = 1;
    pub const VPAD_TP_854X480: Type = 2;
}
pub mod VPADReadError {
    pub type Type = ::core::ffi::c_int;
    pub const VPAD_READ_SUCCESS: Type = 0;
    pub const VPAD_READ_NO_SAMPLES: Type = -1;
    pub const VPAD_READ_INVALID_CONTROLLER: Type = -2;
    pub const VPAD_READ_BUSY: Type = -4;
    pub const VPAD_READ_UNINITIALIZED: Type = -5;
}
pub mod VPADLcdMode {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_LCD_STANDBY: Type = 0;
    pub const VPAD_LCD_OFF: Type = 1;
    pub const VPAD_LCD_ON: Type = 255;
}
pub mod VPADGyroZeroDriftMode {
    pub type Type = ::core::ffi::c_uint;
    pub const VPAD_GYRO_ZERODRIFT_LOOSE: Type = 0;
    pub const VPAD_GYRO_ZERODRIFT_STANDARD: Type = 1;
    pub const VPAD_GYRO_ZERODRIFT_TIGHT: Type = 2;
    pub const VPAD_GYRO_ZERODRIFT_NONE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADVec2D {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADVec3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADDirection {
    pub x: VPADVec3D,
    pub y: VPADVec3D,
    pub z: VPADVec3D,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADTouchCalibrationParam {
    pub adjustX: u16,
    pub adjustY: u16,
    pub scaleX: f32,
    pub scaleY: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADTouchData {
    pub x: u16,
    pub y: u16,
    pub touched: u16,
    pub validity: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADAccStatus {
    pub acc: VPADVec3D,
    pub magnitude: f32,
    pub variation: f32,
    pub vertical: VPADVec2D,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VPADStatus {
    pub hold: u32,
    pub trigger: u32,
    pub release: u32,
    pub leftStick: VPADVec2D,
    pub rightStick: VPADVec2D,
    pub accelorometer: VPADAccStatus,
    pub gyro: VPADVec3D,
    pub angle: VPADVec3D,
    pub error: u8,
    pub __unk32: [::core::ffi::c_char; 1usize],
    pub tpNormal: VPADTouchData,
    pub tpFiltered1: VPADTouchData,
    pub tpFiltered2: VPADTouchData,
    pub __unk33: [::core::ffi::c_char; 2usize],
    pub direction: VPADDirection,
    pub usingHeadphones: BOOL,
    pub mag: VPADVec3D,
    pub slideVolume: u8,
    pub battery: u8,
    pub micStatus: u8,
    pub slideVolumeEx: u8,
    pub __unk34: [::core::ffi::c_char; 8usize],
}
pub type VPADSamplingCallback = ::core::option::Option<unsafe extern "C" fn(chan: VPADChan::Type)>;
pub type MICHandle = ::core::ffi::c_int;
pub mod MICError {
    pub type Type = ::core::ffi::c_int;
    pub const MIC_ERROR_OK: Type = 0;
    pub const MIC_ERROR_NOT_OPENED: Type = -1;
    pub const MIC_ERROR_INVALID_HANDLE: Type = -2;
    pub const MIC_ERROR_INIT: Type = -5;
    pub const MIC_ERROR_ALREADY_CLOSED: Type = -7;
    pub const MIC_ERROR_INVALID_INSTANCE: Type = -8;
}
pub mod MICInstance {
    pub type Type = ::core::ffi::c_uint;
    pub const MIC_INSTANCE_0: Type = 0;
    pub const MIC_INSTANCE_1: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MICWorkMemory {
    pub sampleMaxCount: usize,
    pub sampleBuffer: *mut ::core::ffi::c_void,
}
impl Default for MICWorkMemory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MICStatus {
    pub state: ::core::ffi::c_int,
    pub availableData: ::core::ffi::c_int,
    pub bufferPos: ::core::ffi::c_int,
}
pub type NFCError = i32;
pub type NFCProtocol = u8;
pub type NFCTechnology = u8;
pub type NFCTechnologyMask = u8;
pub type NFCNDEFFlags = u8;
pub mod NFCMode {
    pub type Type = ::core::ffi::c_int;
    pub const NFC_MODE_INVALID: Type = -1;
    pub const NFC_MODE_IDLE: Type = 0;
    pub const NFC_MODE_ACTIVE: Type = 1;
}
pub mod NFCProtocolEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_PROTOCOL_UNKNOWN: Type = 0;
    pub const NFC_PROTOCOL_T1T: Type = 1;
    pub const NFC_PROTOCOL_T2T: Type = 2;
    pub const NFC_PROTOCOL_T3T: Type = 3;
    pub const NFC_PROTOCOL_ISO_DEP: Type = 4;
    pub const NFC_PROTOCOL_15693: Type = 131;
}
pub mod NFCTechnologyEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_TECHNOLOGY_A: Type = 0;
    pub const NFC_TECHNOLOGY_B: Type = 1;
    pub const NFC_TECHNOLOGY_F: Type = 2;
    pub const NFC_TECHNOLOGY_ISO15693: Type = 6;
}
pub mod NFCTechnologyMaskEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_TECHNOLOGY_MASK_ALL: Type = 0;
    pub const NFC_TECHNOLOGY_MASK_A: Type = 1;
    pub const NFC_TECHNOLOGY_MASK_B: Type = 2;
    pub const NFC_TECHNOLOGY_MASK_F: Type = 4;
    pub const NFC_TECHNOLOGY_MASK_ISO15693: Type = 8;
}
pub mod NFCNDEFFlagsEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const NFC_NDEF_FLAG_READ_ONLY: Type = 1;
    pub const NFC_NDEF_FLAG_FORMATED: Type = 2;
    pub const NFC_NDEF_FLAG_SUPPORTED: Type = 4;
    pub const NFC_NDEF_FLAG_UNKNOWN: Type = 8;
    pub const NFC_NDEF_FLAG_FORMATABLE: Type = 16;
    pub const NFC_NDEF_FLAG_SOFT_LOCKABLE: Type = 32;
    pub const NFC_NDEF_FLAG_HARD_LOCKABLE: Type = 64;
    pub const NFC_NDEF_FLAG_OTP: Type = 128;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCUid {
    pub uid: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCTagInfo {
    pub uidSize: u8,
    pub uid: [u8; 10usize],
    pub technology: NFCTechnology,
    pub protocol: NFCProtocol,
    pub __unk39: [::core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFCNTAGVersion {
    pub header: u8,
    pub vendorId: u8,
    pub productType: u8,
    pub productSubtype: u8,
    pub majorProductVersion: u8,
    pub minorProductversion: u8,
    pub storageSize: u8,
    pub protocolType: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFCReadT2TResult {
    pub numReads: u8,
    pub read0Start: u8,
    pub read0End: u8,
    pub read1Start: u8,
    pub read1End: u8,
    pub read2Start: u8,
    pub read2End: u8,
    pub read3Start: u8,
    pub read3End: u8,
    pub data: [u8; 928usize],
}
impl Default for NFCReadT2TResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NFCCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCTagDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(chan: VPADChan::Type, hasTag: BOOL, userContext: *mut ::core::ffi::c_void),
>;
pub type NFCDetectCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        hasLockedData: BOOL,
        flags: NFCNDEFFlags,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        responseSize: u32,
        responseData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCRawDataTwiceCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        numCompleted: u8,
        response0Size: u32,
        response0Data: *mut ::core::ffi::c_void,
        response1Size: u32,
        response1Data: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        uid: *mut NFCUid,
        readOnly: BOOL,
        dataSize: u32,
        data: *mut ::core::ffi::c_void,
        lockedDataSize: u32,
        lockedData: *mut ::core::ffi::c_void,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        rfDiscId: u8,
        protocol: NFCProtocol,
        technology: NFCTechnology,
        uidSize: u8,
        uid: *mut u8,
        version: *mut NFCNTAGVersion,
        result: *mut NFCReadT2TResult,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        tagInfo: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NFCGetTagInfoMultiCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NFCError,
        numTagInfos: u8,
        tagInfo0: *mut NFCTagInfo,
        tagInfo1: *mut NFCTagInfo,
        tagInfo2: *mut NFCTagInfo,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub mod GX2AAMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_AA_MODE1X: Type = 0;
    pub const GX2_AA_MODE2X: Type = 1;
    pub const GX2_AA_MODE4X: Type = 2;
    pub const GX2_AA_MODE8X: Type = 3;
}
pub mod GX2AlphaToMaskMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ALPHA_TO_MASK_MODE_NON_DITHERED: Type = 0;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_0: Type = 1;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_90: Type = 2;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_180: Type = 3;
    pub const GX2_ALPHA_TO_MASK_MODE_DITHER_270: Type = 4;
}
pub mod GX2AspectRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ASPECT_RATIO_4_3: Type = 0;
    pub const GX2_ASPECT_RATIO_16_9: Type = 1;
}
pub mod GX2AttribFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ATTRIB_TYPE_8: Type = 0;
    pub const GX2_ATTRIB_TYPE_4_4: Type = 1;
    pub const GX2_ATTRIB_TYPE_16: Type = 2;
    pub const GX2_ATTRIB_TYPE_16_FLOAT: Type = 3;
    pub const GX2_ATTRIB_TYPE_8_8: Type = 4;
    pub const GX2_ATTRIB_TYPE_32: Type = 5;
    pub const GX2_ATTRIB_TYPE_32_FLOAT: Type = 6;
    pub const GX2_ATTRIB_TYPE_16_16: Type = 7;
    pub const GX2_ATTRIB_TYPE_16_16_FLOAT: Type = 8;
    pub const GX2_ATTRIB_TYPE_10_11_11_FLOAT: Type = 9;
    pub const GX2_ATTRIB_TYPE_8_8_8_8: Type = 10;
    pub const GX2_ATTRIB_TYPE_10_10_10_2: Type = 11;
    pub const GX2_ATTRIB_TYPE_32_32: Type = 12;
    pub const GX2_ATTRIB_TYPE_32_32_FLOAT: Type = 13;
    pub const GX2_ATTRIB_TYPE_16_16_16_16: Type = 14;
    pub const GX2_ATTRIB_TYPE_16_16_16_16_FLOAT: Type = 15;
    pub const GX2_ATTRIB_TYPE_32_32_32: Type = 16;
    pub const GX2_ATTRIB_TYPE_32_32_32_FLOAT: Type = 17;
    pub const GX2_ATTRIB_TYPE_32_32_32_32: Type = 18;
    pub const GX2_ATTRIB_TYPE_32_32_32_32_FLOAT: Type = 19;
    pub const GX2_ATTRIB_FLAG_INTEGER: Type = 256;
    pub const GX2_ATTRIB_FLAG_SIGNED: Type = 512;
    pub const GX2_ATTRIB_FLAG_DEGAMMA: Type = 1024;
    pub const GX2_ATTRIB_FLAG_SCALED: Type = 2048;
    pub const GX2_ATTRIB_FORMAT_UNORM_8: Type = 0;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8: Type = 4;
    pub const GX2_ATTRIB_FORMAT_UNORM_8_8_8_8: Type = 10;
    pub const GX2_ATTRIB_FORMAT_UINT_8: Type = 256;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8: Type = 260;
    pub const GX2_ATTRIB_FORMAT_UINT_8_8_8_8: Type = 266;
    pub const GX2_ATTRIB_FORMAT_SNORM_8: Type = 512;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8: Type = 516;
    pub const GX2_ATTRIB_FORMAT_SNORM_8_8_8_8: Type = 522;
    pub const GX2_ATTRIB_FORMAT_SINT_8: Type = 768;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8: Type = 772;
    pub const GX2_ATTRIB_FORMAT_SINT_8_8_8_8: Type = 778;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32: Type = 2054;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32: Type = 2061;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32: Type = 2065;
    pub const GX2_ATTRIB_FORMAT_FLOAT_32_32_32_32: Type = 2067;
}
pub mod GX2AttribIndexType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ATTRIB_INDEX_PER_VERTEX: Type = 0;
    pub const GX2_ATTRIB_INDEX_PER_INSTANCE: Type = 1;
}
pub mod GX2BlendMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BLEND_MODE_ZERO: Type = 0;
    pub const GX2_BLEND_MODE_ONE: Type = 1;
    pub const GX2_BLEND_MODE_SRC_COLOR: Type = 2;
    pub const GX2_BLEND_MODE_INV_SRC_COLOR: Type = 3;
    pub const GX2_BLEND_MODE_SRC_ALPHA: Type = 4;
    pub const GX2_BLEND_MODE_INV_SRC_ALPHA: Type = 5;
    pub const GX2_BLEND_MODE_DST_ALPHA: Type = 6;
    pub const GX2_BLEND_MODE_INV_DST_ALPHA: Type = 7;
    pub const GX2_BLEND_MODE_DST_COLOR: Type = 8;
    pub const GX2_BLEND_MODE_INV_DST_COLOR: Type = 9;
    pub const GX2_BLEND_MODE_SRC_ALPHA_SAT: Type = 10;
    pub const GX2_BLEND_MODE_BOTH_SRC_ALPHA: Type = 11;
    pub const GX2_BLEND_MODE_BOTH_INV_SRC_ALPHA: Type = 12;
    pub const GX2_BLEND_MODE_BLEND_FACTOR: Type = 13;
    pub const GX2_BLEND_MODE_INV_BLEND_FACTOR: Type = 14;
    pub const GX2_BLEND_MODE_SRC1_COLOR: Type = 15;
    pub const GX2_BLEND_MODE_INV_SRC1_COLOR: Type = 16;
    pub const GX2_BLEND_MODE_SRC1_ALPHA: Type = 17;
    pub const GX2_BLEND_MODE_INV_SRC1_ALPHA: Type = 18;
    pub const GX2_BLEND_MODE_CONSTANT_ALPHA: Type = 19;
    pub const GX2_BLEND_MODE_INV_CONSTANT_ALPHA: Type = 20;
}
pub mod GX2BlendCombineMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BLEND_COMBINE_MODE_ADD: Type = 0;
    pub const GX2_BLEND_COMBINE_MODE_SUB: Type = 1;
    pub const GX2_BLEND_COMBINE_MODE_MIN: Type = 2;
    pub const GX2_BLEND_COMBINE_MODE_MAX: Type = 3;
    pub const GX2_BLEND_COMBINE_MODE_REV_SUB: Type = 4;
}
pub mod GX2BufferingMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_BUFFERING_MODE_SINGLE: Type = 1;
    pub const GX2_BUFFERING_MODE_DOUBLE: Type = 2;
    pub const GX2_BUFFERING_MODE_TRIPLE: Type = 3;
}
pub mod GX2ChannelMask {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_CHANNEL_MASK_R: Type = 1;
    pub const GX2_CHANNEL_MASK_G: Type = 2;
    pub const GX2_CHANNEL_MASK_RG: Type = 3;
    pub const GX2_CHANNEL_MASK_B: Type = 4;
    pub const GX2_CHANNEL_MASK_RB: Type = 5;
    pub const GX2_CHANNEL_MASK_GB: Type = 6;
    pub const GX2_CHANNEL_MASK_RGB: Type = 7;
    pub const GX2_CHANNEL_MASK_A: Type = 8;
    pub const GX2_CHANNEL_MASK_RA: Type = 9;
    pub const GX2_CHANNEL_MASK_GA: Type = 10;
    pub const GX2_CHANNEL_MASK_RGA: Type = 11;
    pub const GX2_CHANNEL_MASK_BA: Type = 12;
    pub const GX2_CHANNEL_MASK_RBA: Type = 13;
    pub const GX2_CHANNEL_MASK_GBA: Type = 14;
    pub const GX2_CHANNEL_MASK_RGBA: Type = 15;
}
pub mod GX2ClearFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_CLEAR_FLAGS_DEPTH: Type = 1;
    pub const GX2_CLEAR_FLAGS_STENCIL: Type = 2;
    pub const GX2_CLEAR_FLAGS_BOTH: Type = 3;
}
pub mod GX2CompareFunction {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_COMPARE_FUNC_NEVER: Type = 0;
    pub const GX2_COMPARE_FUNC_LESS: Type = 1;
    pub const GX2_COMPARE_FUNC_EQUAL: Type = 2;
    pub const GX2_COMPARE_FUNC_LEQUAL: Type = 3;
    pub const GX2_COMPARE_FUNC_GREATER: Type = 4;
    pub const GX2_COMPARE_FUNC_NOT_EQUAL: Type = 5;
    pub const GX2_COMPARE_FUNC_GEQUAL: Type = 6;
    pub const GX2_COMPARE_FUNC_ALWAYS: Type = 7;
}
pub mod GX2DrcRenderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DRC_RENDER_MODE_DISABLED: Type = 0;
    pub const GX2_DRC_RENDER_MODE_SINGLE: Type = 1;
    pub const GX2_DRC_RENDER_MODE_DOUBLE: Type = 2;
}
pub mod GX2EventType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_EVENT_TYPE_START_OF_PIPE_INTERRUPT: Type = 0;
    pub const GX2_EVENT_TYPE_END_OF_PIPE_INTERRUPT: Type = 1;
    pub const GX2_EVENT_TYPE_VSYNC: Type = 2;
    pub const GX2_EVENT_TYPE_FLIP: Type = 3;
    pub const GX2_EVENT_TYPE_DISPLAY_LIST_OVERRUN: Type = 4;
}
pub mod GX2EndianSwapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ENDIAN_SWAP_NONE: Type = 0;
    pub const GX2_ENDIAN_SWAP_8_IN_16: Type = 1;
    pub const GX2_ENDIAN_SWAP_8_IN_32: Type = 2;
    pub const GX2_ENDIAN_SWAP_DEFAULT: Type = 3;
}
pub mod GX2FetchShaderType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_FETCH_SHADER_TESSELLATION_NONE: Type = 0;
    pub const GX2_FETCH_SHADER_TESSELLATION_LINE: Type = 1;
    pub const GX2_FETCH_SHADER_TESSELLATION_TRIANGLE: Type = 2;
    pub const GX2_FETCH_SHADER_TESSELLATION_QUAD: Type = 3;
}
pub mod GX2FrontFace {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_FRONT_FACE_CCW: Type = 0;
    pub const GX2_FRONT_FACE_CW: Type = 1;
}
pub mod GX2IndexType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INDEX_TYPE_U16_LE: Type = 0;
    pub const GX2_INDEX_TYPE_U32_LE: Type = 1;
    pub const GX2_INDEX_TYPE_U16: Type = 4;
    pub const GX2_INDEX_TYPE_U32: Type = 9;
}
pub mod GX2InvalidateMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INVALIDATE_MODE_NONE: Type = 0;
    pub const GX2_INVALIDATE_MODE_ATTRIBUTE_BUFFER: Type = 1;
    pub const GX2_INVALIDATE_MODE_TEXTURE: Type = 2;
    pub const GX2_INVALIDATE_MODE_UNIFORM_BLOCK: Type = 4;
    pub const GX2_INVALIDATE_MODE_SHADER: Type = 8;
    pub const GX2_INVALIDATE_MODE_COLOR_BUFFER: Type = 16;
    pub const GX2_INVALIDATE_MODE_DEPTH_BUFFER: Type = 32;
    pub const GX2_INVALIDATE_MODE_CPU: Type = 64;
    pub const GX2_INVALIDATE_MODE_STREAM_OUT_BUFFER: Type = 128;
    pub const GX2_INVALIDATE_MODE_EXPORT_BUFFER: Type = 256;
    pub const GX2_INVALIDATE_MODE_CPU_ATTRIBUTE_BUFFER: Type = 65;
    pub const GX2_INVALIDATE_MODE_CPU_TEXTURE: Type = 66;
    pub const GX2_INVALIDATE_MODE_CPU_SHADER: Type = 72;
}
pub mod GX2InitAttributes {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_INIT_END: Type = 0;
    pub const GX2_INIT_CMD_BUF_BASE: Type = 1;
    pub const GX2_INIT_CMD_BUF_POOL_SIZE: Type = 2;
    pub const GX2_INIT_ARGC: Type = 7;
    pub const GX2_INIT_ARGV: Type = 8;
    pub const GX2_INIT_PROFILE_MODE: Type = 9;
    pub const GX2_INIT_TOSS_STAGE: Type = 10;
    pub const GX2_INIT_APP_IO_THREAD_STACK_SIZE: Type = 11;
}
pub mod GX2LogicOp {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_LOGIC_OP_CLEAR: Type = 0;
    pub const GX2_LOGIC_OP_NOR: Type = 17;
    pub const GX2_LOGIC_OP_INV_AND: Type = 34;
    pub const GX2_LOGIC_OP_INV_COPY: Type = 51;
    pub const GX2_LOGIC_OP_REV_AND: Type = 68;
    pub const GX2_LOGIC_OP_INV: Type = 85;
    pub const GX2_LOGIC_OP_XOR: Type = 102;
    pub const GX2_LOGIC_OP_NOT_AND: Type = 119;
    pub const GX2_LOGIC_OP_AND: Type = 136;
    pub const GX2_LOGIC_OP_EQUIV: Type = 153;
    pub const GX2_LOGIC_OP_NOP: Type = 170;
    pub const GX2_LOGIC_OP_INV_OR: Type = 187;
    pub const GX2_LOGIC_OP_COPY: Type = 204;
    pub const GX2_LOGIC_OP_REV_OR: Type = 221;
    pub const GX2_LOGIC_OP_OR: Type = 238;
    pub const GX2_LOGIC_OP_SET: Type = 255;
}
pub mod GX2PrimitiveMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_PRIMITIVE_MODE_POINTS: Type = 1;
    pub const GX2_PRIMITIVE_MODE_LINES: Type = 2;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP: Type = 3;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES: Type = 4;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_FAN: Type = 5;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP: Type = 6;
    pub const GX2_PRIMITIVE_MODE_LINES_ADJACENCY: Type = 10;
    pub const GX2_PRIMITIVE_MODE_LINE_STRIP_ADJACENCY: Type = 11;
    pub const GX2_PRIMITIVE_MODE_TRIANGLES_ADJACENCY: Type = 12;
    pub const GX2_PRIMITIVE_MODE_TRIANGLE_STRIP_ADJACENCY: Type = 13;
    pub const GX2_PRIMITIVE_MODE_RECTS: Type = 17;
    pub const GX2_PRIMITIVE_MODE_LINE_LOOP: Type = 18;
    pub const GX2_PRIMITIVE_MODE_QUADS: Type = 19;
    pub const GX2_PRIMITIVE_MODE_QUAD_STRIP: Type = 20;
}
pub mod GX2PolygonMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_POLYGON_MODE_POINT: Type = 0;
    pub const GX2_POLYGON_MODE_LINE: Type = 1;
    pub const GX2_POLYGON_MODE_TRIANGLE: Type = 2;
}
pub mod GX2RenderTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_RENDER_TARGET_0: Type = 0;
    pub const GX2_RENDER_TARGET_1: Type = 1;
    pub const GX2_RENDER_TARGET_2: Type = 2;
    pub const GX2_RENDER_TARGET_3: Type = 3;
    pub const GX2_RENDER_TARGET_4: Type = 4;
    pub const GX2_RENDER_TARGET_5: Type = 5;
    pub const GX2_RENDER_TARGET_6: Type = 6;
    pub const GX2_RENDER_TARGET_7: Type = 7;
}
pub mod GX2RoundingMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_ROUNDING_MODE_ROUND_TO_EVEN: Type = 0;
    pub const GX2_ROUNDING_MODE_TRUNCATE: Type = 1;
}
pub mod GX2SamplerVarType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_1D: Type = 0;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_2D: Type = 1;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_3D: Type = 3;
    pub const GX2_SAMPLER_VAR_TYPE_SAMPLER_CUBE: Type = 4;
}
pub mod GX2ScanTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SCAN_TARGET_TV0: Type = 1;
    pub const GX2_SCAN_TARGET_TV1: Type = 2;
    pub const GX2_SCAN_TARGET_DRC0: Type = 4;
    pub const GX2_SCAN_TARGET_DRC1: Type = 8;
    pub const GX2_SCAN_TARGET_TV: Type = 1;
    pub const GX2_SCAN_TARGET_DRC: Type = 4;
}
pub mod GX2ShaderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SHADER_MODE_UNIFORM_REGISTER: Type = 0;
    pub const GX2_SHADER_MODE_UNIFORM_BLOCK: Type = 1;
    pub const GX2_SHADER_MODE_GEOMETRY_SHADER: Type = 2;
    pub const GX2_SHADER_MODE_COMPUTE_SHADER: Type = 3;
}
pub mod GX2ShaderVarType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SHADER_VAR_TYPE_VOID: Type = 0;
    pub const GX2_SHADER_VAR_TYPE_BOOL: Type = 1;
    pub const GX2_SHADER_VAR_TYPE_INT: Type = 2;
    pub const GX2_SHADER_VAR_TYPE_UINT: Type = 3;
    pub const GX2_SHADER_VAR_TYPE_FLOAT: Type = 4;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE: Type = 5;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2: Type = 6;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3: Type = 7;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4: Type = 8;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2: Type = 9;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3: Type = 10;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4: Type = 11;
    pub const GX2_SHADER_VAR_TYPE_BOOL2: Type = 12;
    pub const GX2_SHADER_VAR_TYPE_BOOL3: Type = 13;
    pub const GX2_SHADER_VAR_TYPE_BOOL4: Type = 14;
    pub const GX2_SHADER_VAR_TYPE_INT2: Type = 15;
    pub const GX2_SHADER_VAR_TYPE_INT3: Type = 16;
    pub const GX2_SHADER_VAR_TYPE_INT4: Type = 17;
    pub const GX2_SHADER_VAR_TYPE_UINT2: Type = 18;
    pub const GX2_SHADER_VAR_TYPE_UINT3: Type = 19;
    pub const GX2_SHADER_VAR_TYPE_UINT4: Type = 20;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X2: Type = 21;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X3: Type = 22;
    pub const GX2_SHADER_VAR_TYPE_FLOAT2X4: Type = 23;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X2: Type = 24;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X3: Type = 25;
    pub const GX2_SHADER_VAR_TYPE_FLOAT3X4: Type = 26;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X2: Type = 27;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X3: Type = 28;
    pub const GX2_SHADER_VAR_TYPE_FLOAT4X4: Type = 29;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X2: Type = 30;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X3: Type = 31;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE2X4: Type = 32;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X2: Type = 33;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X3: Type = 34;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE3X4: Type = 35;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X2: Type = 36;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X3: Type = 37;
    pub const GX2_SHADER_VAR_TYPE_DOUBLE4X4: Type = 38;
}
pub mod GX2StencilFunction {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_STENCIL_FUNCTION_KEEP: Type = 0;
    pub const GX2_STENCIL_FUNCTION_ZERO: Type = 1;
    pub const GX2_STENCIL_FUNCTION_REPLACE: Type = 2;
    pub const GX2_STENCIL_FUNCTION_INCR_CLAMP: Type = 3;
    pub const GX2_STENCIL_FUNCTION_DECR_CLAMP: Type = 4;
    pub const GX2_STENCIL_FUNCTION_INV: Type = 5;
    pub const GX2_STENCIL_FUNCTION_INCR_WRAP: Type = 6;
    pub const GX2_STENCIL_FUNCTION_DECR_WRAP: Type = 7;
}
pub mod GX2SurfaceDim {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SURFACE_DIM_TEXTURE_1D: Type = 0;
    pub const GX2_SURFACE_DIM_TEXTURE_2D: Type = 1;
    pub const GX2_SURFACE_DIM_TEXTURE_3D: Type = 2;
    pub const GX2_SURFACE_DIM_TEXTURE_CUBE: Type = 3;
    pub const GX2_SURFACE_DIM_TEXTURE_1D_ARRAY: Type = 4;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_ARRAY: Type = 5;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA: Type = 6;
    pub const GX2_SURFACE_DIM_TEXTURE_2D_MSAA_ARRAY: Type = 7;
}
pub mod GX2SurfaceFormat {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SURFACE_FORMAT_INVALID: Type = 0;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4: Type = 2;
    pub const GX2_SURFACE_FORMAT_UNORM_R4_G4_B4_A4: Type = 11;
    pub const GX2_SURFACE_FORMAT_UNORM_R8: Type = 1;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8: Type = 7;
    pub const GX2_SURFACE_FORMAT_UNORM_R8_G8_B8_A8: Type = 26;
    pub const GX2_SURFACE_FORMAT_UNORM_R16: Type = 5;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16: Type = 15;
    pub const GX2_SURFACE_FORMAT_UNORM_R16_G16_B16_A16: Type = 31;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G6_B5: Type = 8;
    pub const GX2_SURFACE_FORMAT_UNORM_R5_G5_B5_A1: Type = 10;
    pub const GX2_SURFACE_FORMAT_UNORM_A1_B5_G5_R5: Type = 12;
    pub const GX2_SURFACE_FORMAT_UNORM_R24_X8: Type = 17;
    pub const GX2_SURFACE_FORMAT_UNORM_A2_B10_G10_R10: Type = 27;
    pub const GX2_SURFACE_FORMAT_UNORM_R10_G10_B10_A2: Type = 25;
    pub const GX2_SURFACE_FORMAT_UNORM_BC1: Type = 49;
    pub const GX2_SURFACE_FORMAT_UNORM_BC2: Type = 50;
    pub const GX2_SURFACE_FORMAT_UNORM_BC3: Type = 51;
    pub const GX2_SURFACE_FORMAT_UNORM_BC4: Type = 52;
    pub const GX2_SURFACE_FORMAT_UNORM_BC5: Type = 53;
    pub const GX2_SURFACE_FORMAT_UNORM_NV12: Type = 129;
    pub const GX2_SURFACE_FORMAT_UINT_R8: Type = 257;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8: Type = 263;
    pub const GX2_SURFACE_FORMAT_UINT_R8_G8_B8_A8: Type = 282;
    pub const GX2_SURFACE_FORMAT_UINT_R16: Type = 261;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16: Type = 271;
    pub const GX2_SURFACE_FORMAT_UINT_R16_G16_B16_A16: Type = 287;
    pub const GX2_SURFACE_FORMAT_UINT_R32: Type = 269;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32: Type = 285;
    pub const GX2_SURFACE_FORMAT_UINT_R32_G32_B32_A32: Type = 290;
    pub const GX2_SURFACE_FORMAT_UINT_A2_B10_G10_R10: Type = 283;
    pub const GX2_SURFACE_FORMAT_UINT_R10_G10_B10_A2: Type = 281;
    pub const GX2_SURFACE_FORMAT_UINT_X24_G8: Type = 273;
    pub const GX2_SURFACE_FORMAT_UINT_G8_X24: Type = 284;
    pub const GX2_SURFACE_FORMAT_SNORM_R8: Type = 513;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8: Type = 519;
    pub const GX2_SURFACE_FORMAT_SNORM_R8_G8_B8_A8: Type = 538;
    pub const GX2_SURFACE_FORMAT_SNORM_R16: Type = 517;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16: Type = 527;
    pub const GX2_SURFACE_FORMAT_SNORM_R16_G16_B16_A16: Type = 543;
    pub const GX2_SURFACE_FORMAT_SNORM_R10_G10_B10_A2: Type = 537;
    pub const GX2_SURFACE_FORMAT_SNORM_BC4: Type = 564;
    pub const GX2_SURFACE_FORMAT_SNORM_BC5: Type = 565;
    pub const GX2_SURFACE_FORMAT_SINT_R8: Type = 769;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8: Type = 775;
    pub const GX2_SURFACE_FORMAT_SINT_R8_G8_B8_A8: Type = 794;
    pub const GX2_SURFACE_FORMAT_SINT_R16: Type = 773;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16: Type = 783;
    pub const GX2_SURFACE_FORMAT_SINT_R16_G16_B16_A16: Type = 799;
    pub const GX2_SURFACE_FORMAT_SINT_R32: Type = 781;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32: Type = 797;
    pub const GX2_SURFACE_FORMAT_SINT_R32_G32_B32_A32: Type = 802;
    pub const GX2_SURFACE_FORMAT_SINT_R10_G10_B10_A2: Type = 793;
    pub const GX2_SURFACE_FORMAT_SRGB_R8_G8_B8_A8: Type = 1050;
    pub const GX2_SURFACE_FORMAT_SRGB_BC1: Type = 1073;
    pub const GX2_SURFACE_FORMAT_SRGB_BC2: Type = 1074;
    pub const GX2_SURFACE_FORMAT_SRGB_BC3: Type = 1075;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32: Type = 2062;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32: Type = 2078;
    pub const GX2_SURFACE_FORMAT_FLOAT_R32_G32_B32_A32: Type = 2083;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16: Type = 2054;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16: Type = 2064;
    pub const GX2_SURFACE_FORMAT_FLOAT_R16_G16_B16_A16: Type = 2080;
    pub const GX2_SURFACE_FORMAT_FLOAT_R11_G11_B10: Type = 2070;
    pub const GX2_SURFACE_FORMAT_FLOAT_D24_S8: Type = 2065;
    pub const GX2_SURFACE_FORMAT_FLOAT_X8_X24: Type = 2076;
}
pub mod GX2SurfaceUse {
    pub type Type = ::core::ffi::c_int;
    pub const GX2_SURFACE_USE_NONE: Type = 0;
    pub const GX2_SURFACE_USE_TEXTURE: Type = 1;
    pub const GX2_SURFACE_USE_COLOR_BUFFER: Type = 2;
    pub const GX2_SURFACE_USE_DEPTH_BUFFER: Type = 4;
    pub const GX2_SURFACE_USE_SCAN_BUFFER: Type = 8;
    pub const GX2_SURFACE_USE_TV: Type = -2147483648;
    pub const GX2_SURFACE_USE_TEXTURE_COLOR_BUFFER_TV: Type = -2147483645;
}
pub mod GX2TessellationMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TESSELLATION_MODE_DISCRETE: Type = 0;
    pub const GX2_TESSELLATION_MODE_CONTINUOUS: Type = 1;
    pub const GX2_TESSELLATION_MODE_ADAPTIVE: Type = 2;
}
pub mod GX2TexBorderType {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_BORDER_TYPE_TRANSPARENT_BLACK: Type = 0;
    pub const GX2_TEX_BORDER_TYPE_BLACK: Type = 1;
    pub const GX2_TEX_BORDER_TYPE_WHITE: Type = 2;
    pub const GX2_TEX_BORDER_TYPE_VARIABLE: Type = 3;
}
pub mod GX2TexClampMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_CLAMP_MODE_WRAP: Type = 0;
    pub const GX2_TEX_CLAMP_MODE_MIRROR: Type = 1;
    pub const GX2_TEX_CLAMP_MODE_CLAMP: Type = 2;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE: Type = 3;
    pub const GX2_TEX_CLAMP_MODE_CLAMP_HALF_BORDER: Type = 4;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_HALF_BORDER: Type = 5;
    pub const GX2_TEX_CLAMP_MODE_CLAMP_BORDER: Type = 6;
    pub const GX2_TEX_CLAMP_MODE_MIRROR_ONCE_BORDER: Type = 7;
}
pub mod GX2TexMipFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_MIP_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_MIP_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_MIP_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexMipPerfMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_MIP_PERF_MODE_DISABLE: Type = 0;
}
pub mod GX2TexXYFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_XY_FILTER_MODE_POINT: Type = 0;
    pub const GX2_TEX_XY_FILTER_MODE_LINEAR: Type = 1;
    pub const GX2_TEX_XY_FILTER_MODE_BICUBIC: Type = 2;
}
pub mod GX2TexAnisoRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_ANISO_RATIO_NONE: Type = 0;
    pub const GX2_TEX_ANISO_RATIO_2_TO_1: Type = 1;
    pub const GX2_TEX_ANISO_RATIO_4_TO_1: Type = 2;
    pub const GX2_TEX_ANISO_RATIO_8_TO_1: Type = 3;
    pub const GX2_TEX_ANISO_RATIO_16_TO_1: Type = 4;
}
pub mod GX2TexZFilterMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_Z_FILTER_MODE_NONE: Type = 0;
    pub const GX2_TEX_Z_FILTER_MODE_POINT: Type = 1;
    pub const GX2_TEX_Z_FILTER_MODE_LINEAR: Type = 2;
}
pub mod GX2TexZPerfMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TEX_Z_PERF_MODE_DISABLED: Type = 0;
}
pub mod GX2TileMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TILE_MODE_DEFAULT: Type = 0;
    pub const GX2_TILE_MODE_LINEAR_ALIGNED: Type = 1;
    pub const GX2_TILE_MODE_TILED_1D_THIN1: Type = 2;
    pub const GX2_TILE_MODE_TILED_1D_THICK: Type = 3;
    pub const GX2_TILE_MODE_TILED_2D_THIN1: Type = 4;
    pub const GX2_TILE_MODE_TILED_2D_THIN2: Type = 5;
    pub const GX2_TILE_MODE_TILED_2D_THIN4: Type = 6;
    pub const GX2_TILE_MODE_TILED_2D_THICK: Type = 7;
    pub const GX2_TILE_MODE_TILED_2B_THIN1: Type = 8;
    pub const GX2_TILE_MODE_TILED_2B_THIN2: Type = 9;
    pub const GX2_TILE_MODE_TILED_2B_THIN4: Type = 10;
    pub const GX2_TILE_MODE_TILED_2B_THICK: Type = 11;
    pub const GX2_TILE_MODE_TILED_3D_THIN1: Type = 12;
    pub const GX2_TILE_MODE_TILED_3D_THICK: Type = 13;
    pub const GX2_TILE_MODE_TILED_3B_THIN1: Type = 14;
    pub const GX2_TILE_MODE_TILED_3B_THICK: Type = 15;
    pub const GX2_TILE_MODE_LINEAR_SPECIAL: Type = 16;
}
pub mod GX2TVRenderMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TV_RENDER_MODE_DISABLED: Type = 0;
    pub const GX2_TV_RENDER_MODE_STANDARD_480P: Type = 1;
    pub const GX2_TV_RENDER_MODE_WIDE_480P: Type = 2;
    pub const GX2_TV_RENDER_MODE_WIDE_720P: Type = 3;
    pub const GX2_TV_RENDER_MODE_WIDE_1080P: Type = 5;
}
pub mod GX2TVScanMode {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_TV_SCAN_MODE_NONE: Type = 0;
    pub const GX2_TV_SCAN_MODE_576I: Type = 1;
    pub const GX2_TV_SCAN_MODE_480I: Type = 2;
    pub const GX2_TV_SCAN_MODE_480P: Type = 3;
    pub const GX2_TV_SCAN_MODE_720P: Type = 4;
    pub const GX2_TV_SCAN_MODE_1080I: Type = 6;
    pub const GX2_TV_SCAN_MODE_1080P: Type = 7;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Sampler {
    pub regs: [u32; 3usize],
}
pub mod GX2RResourceFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2R_RESOURCE_BIND_NONE: Type = 0;
    pub const GX2R_RESOURCE_BIND_TEXTURE: Type = 1;
    pub const GX2R_RESOURCE_BIND_COLOR_BUFFER: Type = 2;
    pub const GX2R_RESOURCE_BIND_DEPTH_BUFFER: Type = 4;
    pub const GX2R_RESOURCE_BIND_SCAN_BUFFER: Type = 8;
    pub const GX2R_RESOURCE_BIND_VERTEX_BUFFER: Type = 16;
    pub const GX2R_RESOURCE_BIND_INDEX_BUFFER: Type = 32;
    pub const GX2R_RESOURCE_BIND_UNIFORM_BLOCK: Type = 64;
    pub const GX2R_RESOURCE_BIND_SHADER_PROGRAM: Type = 128;
    pub const GX2R_RESOURCE_BIND_STREAM_OUTPUT: Type = 256;
    pub const GX2R_RESOURCE_BIND_DISPLAY_LIST: Type = 512;
    pub const GX2R_RESOURCE_BIND_GS_RING_BUFFER: Type = 1024;
    pub const GX2R_RESOURCE_USAGE_CPU_READ: Type = 2048;
    pub const GX2R_RESOURCE_USAGE_CPU_WRITE: Type = 4096;
    pub const GX2R_RESOURCE_USAGE_GPU_READ: Type = 8192;
    pub const GX2R_RESOURCE_USAGE_GPU_WRITE: Type = 16384;
    pub const GX2R_RESOURCE_USAGE_DMA_READ: Type = 32768;
    pub const GX2R_RESOURCE_USAGE_DMA_WRITE: Type = 65536;
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM1: Type = 131072;
    pub const GX2R_RESOURCE_USAGE_FORCE_MEM2: Type = 262144;
    pub const GX2R_RESOURCE_DISABLE_CPU_INVALIDATE: Type = 1048576;
    pub const GX2R_RESOURCE_DISABLE_GPU_INVALIDATE: Type = 2097152;
    pub const GX2R_RESOURCE_LOCKED_READ_ONLY: Type = 4194304;
    pub const GX2R_RESOURCE_GX2R_ALLOCATED: Type = 536870912;
    pub const GX2R_RESOURCE_LOCKED: Type = 1073741824;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2RBuffer {
    pub flags: GX2RResourceFlags::Type,
    pub elemSize: u32,
    pub elemCount: u32,
    pub buffer: *mut ::core::ffi::c_void,
}
impl Default for GX2RBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2FetchShader {
    pub type_: GX2FetchShaderType::Type,
    pub regs: GX2FetchShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub attribCount: u32,
    pub numDivisors: u32,
    pub divisors: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2FetchShader__bindgen_ty_1 {
    pub sq_pgm_resources_fs: u32,
}
impl Default for GX2FetchShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformBlock {
    pub name: *const ::core::ffi::c_char,
    pub offset: u32,
    pub size: u32,
}
impl Default for GX2UniformBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2UniformVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub offset: u32,
    pub block: i32,
}
impl Default for GX2UniformVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2UniformInitialValue {
    pub value: [f32; 4usize],
    pub offset: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2LoopVar {
    pub offset: u32,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2SamplerVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2SamplerVarType::Type,
    pub location: u32,
}
impl Default for GX2SamplerVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribVar {
    pub name: *const ::core::ffi::c_char,
    pub type_: GX2ShaderVarType::Type,
    pub count: u32,
    pub location: u32,
}
impl Default for GX2AttribVar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2VertexShader {
    pub regs: GX2VertexShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub attribVarCount: u32,
    pub attribVars: *mut GX2AttribVar,
    pub ringItemsize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2VertexShader__bindgen_ty_1 {
    pub sq_pgm_resources_vs: u32,
    pub vgt_primitiveid_en: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub pa_cl_vs_out_cntl: u32,
    pub sq_vtx_semantic_clear: u32,
    pub num_sq_vtx_semantic: u32,
    pub sq_vtx_semantic: [u32; 32usize],
    pub vgt_strmout_buffer_en: u32,
    pub vgt_vertex_reuse_block_cntl: u32,
    pub vgt_hos_reuse_depth: u32,
}
impl Default for GX2VertexShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2PixelShader {
    pub regs: GX2PixelShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PixelShader__bindgen_ty_1 {
    pub sq_pgm_resources_ps: u32,
    pub sq_pgm_exports_ps: u32,
    pub spi_ps_in_control_0: u32,
    pub spi_ps_in_control_1: u32,
    pub num_spi_ps_input_cntl: u32,
    pub spi_ps_input_cntls: [u32; 32usize],
    pub cb_shader_mask: u32,
    pub cb_shader_control: u32,
    pub db_shader_control: u32,
    pub spi_input_z: u32,
}
impl Default for GX2PixelShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2GeometryShader {
    pub regs: GX2GeometryShader__bindgen_ty_1,
    pub size: u32,
    pub program: *mut ::core::ffi::c_void,
    pub vertexProgramSize: u32,
    pub vertexProgram: *mut ::core::ffi::c_void,
    pub mode: GX2ShaderMode::Type,
    pub uniformBlockCount: u32,
    pub uniformBlocks: *mut GX2UniformBlock,
    pub uniformVarCount: u32,
    pub uniformVars: *mut GX2UniformVar,
    pub initialValueCount: u32,
    pub initialValues: *mut GX2UniformInitialValue,
    pub loopVarCount: u32,
    pub loopVars: *mut GX2LoopVar,
    pub samplerVarCount: u32,
    pub samplerVars: *mut GX2SamplerVar,
    pub ringItemSize: u32,
    pub hasStreamOut: BOOL,
    pub streamOutStride: [u32; 4usize],
    pub gx2rBuffer: GX2RBuffer,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2GeometryShader__bindgen_ty_1 {
    pub sq_pgm_resources_gs: u32,
    pub vgt_gs_out_prim_type: u32,
    pub vgt_gs_mode: u32,
    pub pa_cl_vs_out_cntl: u32,
    pub sq_pgm_resources_vs: u32,
    pub sq_gs_vert_itemsize: u32,
    pub spi_vs_out_config: u32,
    pub num_spi_vs_out_id: u32,
    pub spi_vs_out_id: [u32; 10usize],
    pub vgt_strmout_buffer_en: u32,
}
impl Default for GX2GeometryShader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2AttribStream {
    pub location: u32,
    pub buffer: u32,
    pub offset: u32,
    pub format: GX2AttribFormat::Type,
    pub type_: GX2AttribIndexType::Type,
    pub aluDivisor: u32,
    pub mask: u32,
    pub endianSwap: GX2EndianSwapMode::Type,
}
impl Default for GX2AttribStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Surface {
    pub dim: GX2SurfaceDim::Type,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mipLevels: u32,
    pub format: GX2SurfaceFormat::Type,
    pub aa: GX2AAMode::Type,
    pub __bindgen_anon_1: GX2Surface__bindgen_ty_1,
    pub imageSize: u32,
    pub image: *mut ::core::ffi::c_void,
    pub mipmapSize: u32,
    pub mipmaps: *mut ::core::ffi::c_void,
    pub tileMode: GX2TileMode::Type,
    pub swizzle: u32,
    pub alignment: u32,
    pub pitch: u32,
    pub mipLevelOffset: [u32; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GX2Surface__bindgen_ty_1 {
    pub use_: GX2SurfaceUse::Type,
    pub resourceFlags: GX2RResourceFlags::Type,
}
impl Default for GX2Surface__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GX2Surface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2DepthBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub hiZPtr: *mut ::core::ffi::c_void,
    pub hiZSize: u32,
    pub depthClear: f32,
    pub stencilClear: u32,
    pub regs: [u32; 7usize],
}
impl Default for GX2DepthBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2ColorBuffer {
    pub surface: GX2Surface,
    pub viewMip: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub aaBuffer: *mut ::core::ffi::c_void,
    pub aaSize: u32,
    pub regs: [u32; 5usize],
}
impl Default for GX2ColorBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Rect {
    pub left: i32,
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2Point {
    pub x: i32,
    pub y: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GX2Texture {
    pub surface: GX2Surface,
    pub viewFirstMip: u32,
    pub viewNumMips: u32,
    pub viewFirstSlice: u32,
    pub viewNumSlices: u32,
    pub compMap: u32,
    pub regs: [u32; 5usize],
}
impl Default for GX2Texture {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod GFDBlockType {
    pub type Type = ::core::ffi::c_uint;
    pub const GFD_BLOCK_END_OF_FILE: Type = 1;
    pub const GFD_BLOCK_PADDING: Type = 2;
    pub const GFD_BLOCK_VERTEX_SHADER_HEADER: Type = 3;
    pub const GFD_BLOCK_VERTEX_SHADER_PROGRAM: Type = 5;
    pub const GFD_BLOCK_PIXEL_SHADER_HEADER: Type = 6;
    pub const GFD_BLOCK_PIXEL_SHADER_PROGRAM: Type = 7;
    pub const GFD_BLOCK_GEOMETRY_SHADER_HEADER: Type = 8;
    pub const GFD_BLOCK_GEOMETRY_SHADER_PROGRAM: Type = 9;
    pub const GFD_BLOCK_GEOMETRY_SHADER_COPY_PROGRAM: Type = 10;
    pub const GFD_BLOCK_TEXTURE_HEADER: Type = 11;
    pub const GFD_BLOCK_TEXTURE_IMAGE: Type = 12;
    pub const GFD_BLOCK_TEXTURE_MIPMAP: Type = 13;
    pub const GFD_BLOCK_COMPUTE_SHADER_HEADER: Type = 14;
    pub const GFD_BLOCK_COMPUTE_SHADER_PROGRAM: Type = 15;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFDHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub gpuVersion: u32,
    pub align: u32,
    pub unk1: u32,
    pub unk2: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFDBlockHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub majorVersion: u32,
    pub minorVersion: u32,
    pub type_: GFDBlockType::Type,
    pub dataSize: u32,
    pub id: u32,
    pub index: u32,
}
impl Default for GFDBlockHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GFDRelocationHeader {
    pub magic: u32,
    pub headerSize: u32,
    pub unk1: u32,
    pub dataSize: u32,
    pub dataOffset: u32,
    pub textSize: u32,
    pub textOffset: u32,
    pub patchBase: u32,
    pub patchCount: u32,
    pub patchOffset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiodgname_arg {
    pub len: ::core::ffi::c_int,
    pub buf: *mut ::core::ffi::c_void,
}
impl Default for fiodgname_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub ss_padding: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::core::ffi::c_int,
    pub l_linger: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ShadowState {
    pub config: [u32; 2816usize],
    pub context: [u32; 1024usize],
    pub alu: [u32; 2048usize],
    pub loop_: [u32; 96usize],
    pub __unk40: [::core::ffi::c_char; 128usize],
    pub resource: [u32; 3486usize],
    pub __unk41: [::core::ffi::c_char; 136usize],
    pub sampler: [u32; 162usize],
    pub __unk42: [::core::ffi::c_char; 120usize],
}
impl Default for GX2ShadowState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2ContextState {
    pub shadowState: GX2ShadowState,
    pub __unk43: [::core::ffi::c_char; 4usize],
    pub shadowDisplayListSize: u32,
    pub __unk44: [::core::ffi::c_char; 1528usize],
    pub shadowDisplayList: [u32; 192usize],
}
impl Default for GX2ContextState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GX2DRCConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(drcSlot: u32, attached: BOOL)>;
pub mod GX2DebugCaptureInterfaceVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_INTERFACE_VERSION: Type = 1;
}
pub mod GX2DebugCaptureStartFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_NONE: Type = 0;
    pub const GX2_DEBUG_CAPTURE_START_FLAGS_DISABLE_GX2DRAWDONE: Type = 1;
}
pub mod GX2DebugCaptureEndFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_NONE: Type = 0;
    pub const GX2_DEBUG_CAPTURE_END_FLAGS_DISABLE_GX2FLUSH: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2DebugCaptureInterface {
    pub version: u32,
    pub onShutdown: ::core::option::Option<unsafe extern "C" fn()>,
    pub setAllocator: ::core::option::Option<unsafe extern "C" fn()>,
    pub onCaptureStart:
        ::core::option::Option<unsafe extern "C" fn(filename: *const ::core::ffi::c_char)>,
    pub onCaptureEnd: ::core::option::Option<unsafe extern "C" fn()>,
    pub isCaptureEnabled: ::core::option::Option<unsafe extern "C" fn() -> BOOL>,
    pub onAlloc: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32, align: u32),
    >,
    pub onFree: ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>,
    pub onUnknownMemory:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void, size: u32)>,
    pub setOutputSurface: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub onSwapScanBuffers: ::core::option::Option<unsafe extern "C" fn(surface: *mut GX2Surface)>,
    pub submitToRing: ::core::option::Option<
        unsafe extern "C" fn(
            unk1: *mut ::core::ffi::c_void,
            unk2: u32,
            unk3: *mut u32,
            outSubmitTimestamp: *mut u64,
        ),
    >,
}
pub mod GX2_SQ_SEL {
    pub type Type = ::core::ffi::c_uint;
    pub const GX2_SQ_SEL_X: Type = 0;
    pub const GX2_SQ_SEL_Y: Type = 1;
    pub const GX2_SQ_SEL_Z: Type = 2;
    pub const GX2_SQ_SEL_W: Type = 3;
    pub const GX2_SQ_SEL_R: Type = 0;
    pub const GX2_SQ_SEL_G: Type = 1;
    pub const GX2_SQ_SEL_B: Type = 2;
    pub const GX2_SQ_SEL_A: Type = 3;
    pub const GX2_SQ_SEL_0: Type = 4;
    pub const GX2_SQ_SEL_1: Type = 5;
    pub const GX2_SQ_SEL_MASK: Type = 7;
}
pub type GX2EventCallbackFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2EventType::Type, arg2: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2DisplayListOverrunData {
    pub oldList: *mut ::core::ffi::c_void,
    pub oldSize: u32,
    pub newList: *mut ::core::ffi::c_void,
    pub newSize: u32,
    pub __unk45: [::core::ffi::c_char; 8usize],
}
impl Default for GX2DisplayListOverrunData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GX2ApertureHandle = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AAMaskReg {
    pub pa_sc_aa_mask: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AlphaTestReg {
    pub sx_alpha_test_control: u32,
    pub sx_alpha_ref: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2AlphaToMaskReg {
    pub db_alpha_to_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GX2BlendControlReg {
    pub target: GX2RenderTarget::Type,
    pub cb_blend_control: u32,
}
impl Default for GX2BlendControlReg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2BlendConstantColorReg {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ColorControlReg {
    pub cb_color_control: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2DepthStencilControlReg {
    pub db_depth_control: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2StencilMaskReg {
    pub db_stencilrefmask: u32,
    pub db_stencilrefmask_bf: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2LineWidthReg {
    pub pa_su_line_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PointSizeReg {
    pub pa_su_point_size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PointLimitsReg {
    pub pa_su_point_minmax: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PolygonControlReg {
    pub pa_su_sc_mode_cntl: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2PolygonOffsetReg {
    pub pa_su_poly_offset_front_scale: u32,
    pub pa_su_poly_offset_front_offset: u32,
    pub pa_su_poly_offset_back_scale: u32,
    pub pa_su_poly_offset_back_offset: u32,
    pub pa_su_poly_offset_clamp: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ScissorReg {
    pub pa_sc_generic_scissor_tl: u32,
    pub pa_sc_generic_scissor_br: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2TargetChannelMaskReg {
    pub cb_target_mask: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GX2ViewportReg {
    pub pa_cl_vport_xscale: u32,
    pub pa_cl_vport_xoffset: u32,
    pub pa_cl_vport_yscale: u32,
    pub pa_cl_vport_yoffset: u32,
    pub pa_cl_vport_zscale: u32,
    pub pa_cl_vport_zoffset: u32,
    pub pa_cl_gb_vert_clip_adj: u32,
    pub pa_cl_gb_vert_disc_adj: u32,
    pub pa_cl_gb_horz_clip_adj: u32,
    pub pa_cl_gb_horz_disc_adj: u32,
    pub pa_sc_vport_zmin: u32,
    pub pa_sc_vport_zmax: u32,
}
pub type H264DECFptrOutputFn =
    ::core::option::Option<unsafe extern "C" fn(output: *mut H264DecodeOutput)>;
pub mod H264Error {
    pub type Type = ::core::ffi::c_uint;
    pub const H264_ERROR_OK: Type = 0;
    pub const H264_ERROR_INVALID_PPS: Type = 24;
    pub const H264_ERROR_INVALID_SPS: Type = 26;
    pub const H264_ERROR_INVALID_SLICEHEADER: Type = 61;
    pub const H264_ERROR_GENERIC: Type = 16777216;
    pub const H264_ERROR_INVALID_PARAMETER: Type = 16842752;
    pub const H264_ERROR_OUT_OF_MEMORY: Type = 16908288;
    pub const H264_ERROR_INVALID_PROFILE: Type = 17301504;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct H264DecodedVuiParameters {
    pub aspect_ratio_info_present_flag: u8,
    pub aspect_ratio_idc: u8,
    pub sar_width: i16,
    pub sar_height: i16,
    pub overscan_info_present_flag: u8,
    pub overscan_appropriate_flag: u8,
    pub video_signal_type_present_flag: u8,
    pub video_format: u8,
    pub video_full_range_flag: u8,
    pub colour_description_present_flag: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub chroma_loc_info_present_flag: u8,
    pub chroma_sample_loc_type_top_field: u8,
    pub chroma_sample_loc_type_bottom_field: u8,
    pub timing_info_present_flag: u8,
    pub __unk46: [::core::ffi::c_char; 1usize],
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub fixed_frame_rate_flag: u8,
    pub nal_hrd_parameters_present_flag: u8,
    pub vcl_hrd_parameters_present_flag: u8,
    pub low_delay_hrd_flag: u8,
    pub pic_struct_present_flag: u8,
    pub bitstream_restriction_flag: u8,
    pub motion_vectors_over_pic_boundaries_flag: u8,
    pub __unk47: [::core::ffi::c_char; 1usize],
    pub max_bytes_per_pic_denom: i16,
    pub max_bits_per_mb_denom: i16,
    pub log2_max_mv_length_horizontal: i16,
    pub log2_max_mv_length_vertical: i16,
    pub num_reorder_frames: i16,
    pub max_dec_frame_buffering: i16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeResult {
    pub status: i32,
    pub __unk48: [::core::ffi::c_char; 4usize],
    pub timestamp: f64,
    pub width: i32,
    pub height: i32,
    pub nextLine: i32,
    pub cropEnableFlag: u8,
    pub __unk49: [::core::ffi::c_char; 3usize],
    pub cropTop: i32,
    pub cropBottom: i32,
    pub cropLeft: i32,
    pub cropRight: i32,
    pub panScanEnableFlag: u8,
    pub __unk50: [::core::ffi::c_char; 3usize],
    pub panScanTop: i32,
    pub panScanBottom: i32,
    pub panScanLeft: i32,
    pub panScanRight: i32,
    pub framebuffer: *mut ::core::ffi::c_void,
    pub vui_parameters_present_flag: u8,
    pub __unk51: [::core::ffi::c_char; 3usize],
    pub vui_parameters: *mut H264DecodedVuiParameters,
    pub __unk52: [::core::ffi::c_char; 40usize],
}
impl Default for H264DecodeResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct H264DecodeOutput {
    pub frameCount: i32,
    pub decodeResults: *mut *mut H264DecodeResult,
    pub userMemory: *mut ::core::ffi::c_void,
}
impl Default for H264DecodeOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod H264Parameter {
    pub type Type = ::core::ffi::c_uint;
    pub const H264_PARAMETER_FRAME_POINTER_OUTPUT: Type = 1;
    pub const H264_PARAMETER_OUTPUT_PER_FRAME: Type = 536870914;
    pub const H264_PARAMETER_UNKNOWN_20000010: Type = 536870928;
    pub const H264_PARAMETER_UNKNOWN_20000030: Type = 536870960;
    pub const H264_PARAMETER_UNKNOWN_20000040: Type = 536870976;
    pub const H264_PARAMETER_USER_MEMORY: Type = 1879048193;
}
pub mod HIDAttachEvent {
    pub type Type = ::core::ffi::c_uint;
    pub const HID_DEVICE_DETACH: Type = 0;
    pub const HID_DEVICE_ATTACH: Type = 1;
}
pub type HIDAttachCallback = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut HIDClient,
        device: *mut HIDDevice,
        attach: HIDAttachEvent::Type,
    ) -> i32,
>;
pub type HIDCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: u32,
        error: i32,
        buffer: *mut u8,
        bytesTransferred: u32,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HIDDevice {
    pub handle: u32,
    pub physicalDeviceInst: u32,
    pub vid: u16,
    pub pid: u16,
    pub interfaceIndex: u8,
    pub subClass: u8,
    pub protocol: u8,
    pub __unk54: [::core::ffi::c_char; 1usize],
    pub maxPacketSizeRx: u16,
    pub maxPacketSizeTx: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIDClient {
    pub next: *mut HIDClient,
    pub attachCallback: HIDAttachCallback,
}
impl Default for HIDClient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type OSExceptionCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(context: *mut OSContext) -> BOOL>;
pub mod OSExceptionMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EXCEPTION_MODE_SYSTEM: Type = 0;
    pub const OS_EXCEPTION_MODE_THREAD: Type = 1;
    pub const OS_EXCEPTION_MODE_GLOBAL: Type = 2;
    pub const OS_EXCEPTION_MODE_THREAD_ALL_CORES: Type = 3;
    pub const OS_EXCEPTION_MODE_GLOBAL_ALL_CORES: Type = 4;
}
pub mod OSExceptionType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EXCEPTION_TYPE_SYSTEM_RESET: Type = 0;
    pub const OS_EXCEPTION_TYPE_MACHINE_CHECK: Type = 1;
    pub const OS_EXCEPTION_TYPE_DSI: Type = 2;
    pub const OS_EXCEPTION_TYPE_ISI: Type = 3;
    pub const OS_EXCEPTION_TYPE_EXTERNAL_INTERRUPT: Type = 4;
    pub const OS_EXCEPTION_TYPE_ALIGNMENT: Type = 5;
    pub const OS_EXCEPTION_TYPE_PROGRAM: Type = 6;
    pub const OS_EXCEPTION_TYPE_FLOATING_POINT: Type = 7;
    pub const OS_EXCEPTION_TYPE_DECREMENTER: Type = 8;
    pub const OS_EXCEPTION_TYPE_SYSTEM_CALL: Type = 9;
    pub const OS_EXCEPTION_TYPE_TRACE: Type = 10;
    pub const OS_EXCEPTION_TYPE_PERFORMANCE_MONITOR: Type = 11;
    pub const OS_EXCEPTION_TYPE_BREAKPOINT: Type = 12;
    pub const OS_EXCEPTION_TYPE_SYSTEM_INTERRUPT: Type = 13;
    pub const OS_EXCEPTION_TYPE_ICI: Type = 14;
}
pub type OSThreadState = u8;
pub type OSThreadRequest = u32;
pub type OSThreadAttributes = u8;
pub type OSThreadType = u32;
pub type OSThreadEntryPointFn = ::core::option::Option<
    unsafe extern "C" fn(
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
pub type OSThreadCleanupCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub type OSThreadDeallocatorFn = ::core::option::Option<
    unsafe extern "C" fn(thread: *mut OSThread, stack: *mut ::core::ffi::c_void),
>;
pub mod OSThreadSpecificID {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_SPECIFIC_0: Type = 0;
    pub const OS_THREAD_SPECIFIC_1: Type = 1;
    pub const OS_THREAD_SPECIFIC_2: Type = 2;
    pub const OS_THREAD_SPECIFIC_3: Type = 3;
    pub const OS_THREAD_SPECIFIC_4: Type = 4;
    pub const OS_THREAD_SPECIFIC_5: Type = 5;
    pub const OS_THREAD_SPECIFIC_6: Type = 6;
    pub const OS_THREAD_SPECIFIC_7: Type = 7;
    pub const OS_THREAD_SPECIFIC_8: Type = 8;
    pub const OS_THREAD_SPECIFIC_9: Type = 9;
    pub const OS_THREAD_SPECIFIC_10: Type = 10;
    pub const OS_THREAD_SPECIFIC_11: Type = 11;
    pub const OS_THREAD_SPECIFIC_12: Type = 12;
    pub const OS_THREAD_SPECIFIC_13: Type = 13;
    pub const OS_THREAD_SPECIFIC_WUT_RESERVED_0: Type = 14;
    pub const OS_THREAD_SPECIFIC_WUT_RESERVED_1: Type = 15;
}
pub mod OS_THREAD_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_STATE_NONE: Type = 0;
    pub const OS_THREAD_STATE_READY: Type = 1;
    pub const OS_THREAD_STATE_RUNNING: Type = 2;
    pub const OS_THREAD_STATE_WAITING: Type = 4;
    pub const OS_THREAD_STATE_MORIBUND: Type = 8;
}
pub mod OS_THREAD_REQUEST {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_REQUEST_NONE: Type = 0;
    pub const OS_THREAD_REQUEST_SUSPEND: Type = 1;
    pub const OS_THREAD_REQUEST_CANCEL: Type = 2;
}
pub mod OS_THREAD_ATTRIB {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU0: Type = 1;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU1: Type = 2;
    pub const OS_THREAD_ATTRIB_AFFINITY_CPU2: Type = 4;
    pub const OS_THREAD_ATTRIB_AFFINITY_ANY: Type = 7;
    pub const OS_THREAD_ATTRIB_DETACHED: Type = 8;
    pub const OS_THREAD_ATTRIB_STACK_USAGE: Type = 32;
    pub const OS_THREAD_ATTRIB_UNKNOWN: Type = 128;
}
pub mod OS_THREAD_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_THREAD_TYPE_DRIVER: Type = 0;
    pub const OS_THREAD_TYPE_IO: Type = 1;
    pub const OS_THREAD_TYPE_APP: Type = 2;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSThreadGHSExceptionHandling {
    pub __unk55: [::core::ffi::c_char; 104usize],
    pub eh_globals: *mut ::core::ffi::c_void,
    pub eh_mem_manage: [*mut ::core::ffi::c_void; 9usize],
    pub eh_store_globals: [*mut ::core::ffi::c_void; 6usize],
    pub eh_store_globals_tdeh: [*mut ::core::ffi::c_void; 76usize],
}
impl Default for OSThreadGHSExceptionHandling {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexQueue {
    pub head: *mut OSMutex,
    pub tail: *mut OSMutex,
    pub parent: *mut ::core::ffi::c_void,
    pub __unk56: [::core::ffi::c_char; 4usize],
}
impl Default for OSMutexQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastMutexQueue {
    pub head: *mut OSFastMutex,
    pub tail: *mut OSFastMutex,
}
impl Default for OSFastMutexQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSTLSSection {
    pub data: *mut ::core::ffi::c_void,
    pub __unk57: [::core::ffi::c_char; 4usize],
}
impl Default for OSTLSSection {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSThread {
    pub context: OSContext,
    pub tag: u32,
    pub state: OSThreadState,
    pub attr: OSThreadAttributes,
    pub id: u16,
    pub suspendCounter: i32,
    pub priority: i32,
    pub basePriority: i32,
    pub exitValue: i32,
    pub coreRunQueue: [*mut OSThreadQueue; 3usize],
    pub coreRunQueueLink: [OSThreadLink; 3usize],
    pub queue: *mut OSThreadQueue,
    pub link: OSThreadLink,
    pub joinQueue: OSThreadQueue,
    pub mutex: *mut OSMutex,
    pub mutexQueue: OSMutexQueue,
    pub activeLink: OSThreadLink,
    pub stackStart: *mut ::core::ffi::c_void,
    pub stackEnd: *mut ::core::ffi::c_void,
    pub entryPoint: OSThreadEntryPointFn,
    pub ghsExceptionHandling: OSThreadGHSExceptionHandling,
    pub alarmCancelled: BOOL,
    pub specific: [*mut ::core::ffi::c_void; 16usize],
    pub type_: OSThreadType,
    pub name: *const ::core::ffi::c_char,
    pub waitEventTimeoutAlarm: *mut OSAlarm,
    pub userStackPointer: *mut ::core::ffi::c_void,
    pub cleanupCallback: OSThreadCleanupCallbackFn,
    pub deallocator: OSThreadDeallocatorFn,
    pub cancelState: BOOL,
    pub requestFlag: OSThreadRequest,
    pub needSuspend: i32,
    pub suspendResult: i32,
    pub suspendQueue: OSThreadQueue,
    pub __unk58: [::core::ffi::c_char; 4usize],
    pub runQuantumTicks: i64,
    pub coreTimeConsumedNs: u64,
    pub wakeCount: u64,
    pub unk0x610: OSTime,
    pub unk0x618: OSTime,
    pub unk0x620: OSTime,
    pub unk0x628: OSTime,
    pub dsiCallback: [OSExceptionCallbackFn; 3usize],
    pub isiCallback: [OSExceptionCallbackFn; 3usize],
    pub programCallback: [OSExceptionCallbackFn; 3usize],
    pub perfMonCallback: [OSExceptionCallbackFn; 3usize],
    pub stackSyncObjAllowed: BOOL,
    pub tlsSectionCount: u16,
    pub __unk59: [::core::ffi::c_char; 2usize],
    pub tlsSections: *mut OSTLSSection,
    pub fastMutex: *mut OSFastMutex,
    pub contendedFastMutexes: OSFastMutexQueue,
    pub fastMutexQueue: OSFastMutexQueue,
    pub alignCallback: [OSExceptionCallbackFn; 3usize],
    pub reserved: [u32; 5usize],
}
impl Default for OSThread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CAMHandle = ::core::ffi::c_int;
pub type CAMError = ::core::ffi::c_int;
pub mod CamError {
    pub type Type = ::core::ffi::c_int;
    pub const CAMERA_ERROR_OK: Type = 0;
    pub const CAMERA_ERROR_INVALID_ARG: Type = -1;
    pub const CAMERA_ERROR_INVALID_HANDLE: Type = -2;
    pub const CAMERA_ERROR_TOO_MANY_SURFACES: Type = -4;
    pub const CAMERA_ERROR_INSUFFICIENT_MEMORY: Type = -5;
    pub const CAMERA_ERROR_NOT_READY: Type = -6;
    pub const CAMERA_ERROR_UNINITIALIZED: Type = -8;
    pub const CAMERA_ERROR_UVC: Type = -9;
    pub const CAMERA_ERROR_UVD_CONTEXT: Type = -10;
    pub const CAMERA_ERROR_DEVICE_IN_USE: Type = -12;
    pub const CAMERA_ERROR_UVD_SESSION: Type = -13;
    pub const CAMERA_ERROR_SEGMENT_VIOLATION: Type = -15;
}
pub mod CamFps {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_FPS_15: Type = 0;
    pub const CAMERA_FPS_30: Type = 1;
}
pub mod CamStreamType {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_STREAM_TYPE_1: Type = 0;
}
pub mod CamEventType {
    pub type Type = ::core::ffi::c_uint;
    pub const CAMERA_DECODE_DONE: Type = 0;
    pub const CAMERA_DRC_DETACH: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CAMEventData {
    pub eventType: CamEventType::Type,
    pub __bindgen_anon_1: CAMEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CAMEventData__bindgen_ty_1 {
    pub decode: CAMEventData__bindgen_ty_1__bindgen_ty_1,
    pub detach: CAMEventData__bindgen_ty_1__bindgen_ty_2,
    pub args: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_1 {
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub handle: CAMHandle,
    pub failed: BOOL,
}
impl Default for CAMEventData__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMEventData__bindgen_ty_1__bindgen_ty_2 {
    pub connected: BOOL,
    pub handle: CAMHandle,
}
impl Default for CAMEventData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CAMEventData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CAMEventHandler =
    ::core::option::Option<unsafe extern "C" fn(camEventData: *mut CAMEventData)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMMode {
    pub forceDrc: BOOL,
    pub fps: CamFps::Type,
}
impl Default for CAMMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMWorkMem {
    pub size: u32,
    pub pMem: *mut ::core::ffi::c_void,
}
impl Default for CAMWorkMem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMStreamInfo {
    pub type_: CamStreamType::Type,
    pub height: u32,
    pub width: u32,
}
impl Default for CAMStreamInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSetupInfo {
    pub streamInfo: CAMStreamInfo,
    pub workMem: CAMWorkMem,
    pub eventHandler: CAMEventHandler,
    pub mode: CAMMode,
    pub threadAffinity: u32,
    pub __unk60: [::core::ffi::c_char; 16usize],
}
impl Default for CAMSetupInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMSurface {
    pub surfaceSize: i32,
    pub surfaceBuffer: *mut ::core::ffi::c_void,
    pub height: i32,
    pub width: i32,
    pub pitch: i32,
    pub alignment: i32,
    pub tileMode: i32,
    pub pixelFormat: i32,
}
impl Default for CAMSurface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProcUISaveCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type ProcUISaveCallbackEx =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub type ProcUICallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> u32>;
pub mod ProcUICallbackType {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCUI_CALLBACK_ACQUIRE: Type = 0;
    pub const PROCUI_CALLBACK_RELEASE: Type = 1;
    pub const PROCUI_CALLBACK_EXIT: Type = 2;
    pub const PROCUI_CALLBACK_NET_IO_START: Type = 3;
    pub const PROCUI_CALLBACK_NET_IO_STOP: Type = 4;
    pub const PROCUI_CALLBACK_HOME_BUTTON_DENIED: Type = 5;
}
pub mod ProcUIStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const PROCUI_STATUS_IN_FOREGROUND: Type = 0;
    pub const PROCUI_STATUS_IN_BACKGROUND: Type = 1;
    pub const PROCUI_STATUS_RELEASE_FOREGROUND: Type = 2;
    pub const PROCUI_STATUS_EXITING: Type = 3;
}
pub type CCRCDCDestination = u8;
pub type CCRCDCWpsStatusType = u32;
pub type CCRCDCWakeState = u8;
pub type CCRCDCUicConfigId = u8;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCRegisterCallbackData {
    pub attached: i32,
    pub chan: u32,
    pub __unk61: [::core::ffi::c_char; 6usize],
}
pub type CCRCDCRegisterCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut CCRCDCRegisterCallbackData, arg2: *mut ::core::ffi::c_void),
>;
pub mod CCRCDCDestinationEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_DESTINATION_DRH: Type = 1;
    pub const CCR_CDC_DESTINATION_DRC0: Type = 2;
    pub const CCR_CDC_DESTINATION_DRC1: Type = 3;
}
pub mod CCRCDCWpsStatusEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_WPS_STATUS_PAIRED: Type = 0;
    pub const CCR_CDC_WPS_STATUS_SEARCHING: Type = 1;
    pub const CCR_CDC_WPS_STATUS_PAIRING: Type = 2;
}
pub mod CCRCDCDrcStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_DRC_STATE_ACTIVE: Type = 0;
    pub const CCR_CDC_DRC_STATE_PAIRING: Type = 1;
    pub const CCR_CDC_DRC_STATE_FWUPDATE: Type = 2;
    pub const CCR_CDC_DRC_STATE_STANDALONE: Type = 3;
    pub const CCR_CDC_DRC_STATE_BACKGROUND: Type = 4;
    pub const CCR_CDC_DRC_STATE_SLEEP: Type = 5;
    pub const CCR_CDC_DRC_STATE_STANDBY: Type = 6;
    pub const CCR_CDC_DRC_STATE_WOWLSETTING: Type = 7;
    pub const CCR_CDC_DRC_STATE_DKSETTING: Type = 8;
    pub const CCR_CDC_DRC_STATE_UNKNOWN9: Type = 9;
    pub const CCR_CDC_DRC_STATE_WIIACTIVE: Type = 10;
    pub const CCR_CDC_DRC_STATE_LOW_BATTERY: Type = 11;
    pub const CCR_CDC_DRC_STATE_SUBACTIVE: Type = 12;
}
pub mod CCRCDCWakeStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_WAKE_STATE_ACTIVE: Type = 1;
    pub const CCR_CDC_WAKE_STATE_BACKGROUND: Type = 2;
}
pub mod CCRCDCBoardVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_BOARD_VERSION_DK1: Type = 0;
    pub const CCR_CDC_BOARD_VERSION_DK1_EP_DK2: Type = 1;
    pub const CCR_CDC_BOARD_VERSION_DP1: Type = 2;
    pub const CCR_CDC_BOARD_VERSION_DP2: Type = 3;
    pub const CCR_CDC_BOARD_VERSION_DK3: Type = 4;
    pub const CCR_CDC_BOARD_VERSION_DK4: Type = 5;
    pub const CCR_CDC_BOARD_VERSION_PREDP3_DP3: Type = 6;
    pub const CCR_CDC_BOARD_VERSION_DK5: Type = 7;
    pub const CCR_CDC_BOARD_VERSION_DP4: Type = 8;
    pub const CCR_CDC_BOARD_VERSION_DKMP: Type = 9;
    pub const CCR_CDC_BOARD_VERSION_DP5: Type = 10;
    pub const CCR_CDC_BOARD_VERSION_MASS: Type = 11;
    pub const CCR_CDC_BOARD_VERSION_DKMP2: Type = 12;
    pub const CCR_CDC_BOARD_VERSION_DRC_I: Type = 13;
    pub const CCR_CDC_BOARD_VERSION_DKTVMP: Type = 14;
}
pub mod CCRCDCChipVersion {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_CHIP_VERSION_TS: Type = 16;
    pub const CCR_CDC_CHIP_VERSION_ES1: Type = 32;
    pub const CCR_CDC_CHIP_VERSION_ES2: Type = 48;
    pub const CCR_CDC_CHIP_VERSION_ES3: Type = 64;
    pub const CCR_CDC_CHIP_VERSION_MS01: Type = 65;
}
pub mod CCRCDCUicConfigIdEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_BANK: Type = 0;
    pub const CCR_CDC_UIC_CONFIG_ID_MIC_CONFIG: Type = 2;
    pub const CCR_CDC_UIC_CONFIG_ID_ACC_CALIBRATION_VALUE: Type = 3;
    pub const CCR_CDC_UIC_CONFIG_ID_TP_CALIBRATION_VALUE: Type = 5;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK7: Type = 7;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK8: Type = 8;
    pub const CCR_CDC_UIC_CONFIG_ID_LANGUAGE_EXT_ID: Type = 9;
    pub const CCR_CDC_UIC_CONFIG_ID_TV_CONTROL_ID: Type = 10;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_2: Type = 11;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_3: Type = 12;
    pub const CCR_CDC_UIC_CONFIG_ID_EXT_ID_4: Type = 13;
    pub const CCR_CDC_UIC_CONFIG_ID_INIT_BOOT_FLAG: Type = 14;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK15: Type = 15;
    pub const CCR_CDC_UIC_CONFIG_ID_LCD_MODE: Type = 16;
    pub const CCR_CDC_UIC_CONFIG_ID_RC_DATABASE_EXT_ID: Type = 17;
    pub const CCR_CDC_UIC_CONFIG_ID_UNK18: Type = 18;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_ENABLE_FLAG: Type = 19;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_INITIAL_BOOT_FLAG: Type = 20;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_CAFFEINE_SLOT: Type = 21;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_SOUND_MODE: Type = 22;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_INFO: Type = 23;
    pub const CCR_CDC_UIC_CONFIG_ID_CAFFEINE_NOTIFICATION_READ_COUNT: Type = 24;
}
pub mod CCRCDCExt {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_EXT_LANGUAGE: Type = 0;
    pub const CCR_CDC_EXT_RC_DATABASE: Type = 1;
    pub const CCR_CDC_EXT_UNK2: Type = 2;
    pub const CCR_CDC_EXT_UNK3: Type = 3;
    pub const CCR_CDC_EXT_UNK4: Type = 4;
}
pub mod CCRCDCDrhStateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_CDC_SYS_DRH_STATE_NORADIO: Type = 0;
    pub const CCR_CDC_SYS_DRH_STATE_WII: Type = 1;
    pub const CCR_CDC_SYS_DRH_STATE_UNK2: Type = 2;
    pub const CCR_CDC_SYS_DRH_STATE_NODRC: Type = 3;
    pub const CCR_CDC_SYS_DRH_STATE_ECO: Type = 4;
    pub const CCR_CDC_SYS_DRH_STATE_UNK7F: Type = 127;
    pub const CCR_CDC_SYS_DRH_STATE_CAFE: Type = 255;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCMacAddress {
    pub device: CCRCDCDestination,
    pub address: [u8; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCWpsArgs {
    pub hasArgs: u8,
    pub pin: [::core::ffi::c_char; 8usize],
    pub timeout: u16,
    pub pairDestination: CCRCDCDestination,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCSysMessage {
    pub message: u16,
    pub timeout: u16,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCSysInfo {
    pub boardVersion: CCRCDCBoardVersion::Type,
    pub chipVersion: CCRCDCChipVersion::Type,
    pub lvcVersion: u32,
    pub umiVersion: u32,
    pub unknown: u32,
    pub sdCis: u32,
    pub splId: u32,
}
impl Default for CCRCDCSysInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCEepromData {
    pub version: u32,
    pub data: [u8; 768usize],
}
impl Default for CCRCDCEepromData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCWowlWakeDrcArg {
    pub __unk62: [::core::ffi::c_char; 6usize],
    pub state: CCRCDCWakeState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCRCDCUicConfig {
    pub configId: CCRCDCUicConfigId,
    pub size: u8,
    pub data: [u8; 256usize],
}
impl Default for CCRCDCUicConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCFWInfo {
    pub imageSize: u32,
    pub blockSize: u32,
    pub imageVersion: u32,
    pub sequencePerSession: u32,
    pub updateProgress: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCSoftwareVersion {
    pub runningVersion: u32,
    pub activeVersion: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCDrcState {
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCDrhState {
    pub state: u8,
}
pub type CCRCDCIrdaCommand = u8;
pub type CCRCDCIrdaBitrate = u8;
pub type CCRCDCIrdaConnectionType = u8;
pub mod CCRCDCIrdaCommandEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_COMMAND_CONNECT: Type = 0;
    pub const CCR_IRDA_COMMAND_SEND: Type = 1;
    pub const CCR_IRDA_COMMAND_RECEIVE: Type = 2;
    pub const CCR_IRDA_COMMAND_DISCONNECT: Type = 3;
}
pub mod CCRCDCIrdaBitrateEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_BITRATE_115200: Type = 0;
    pub const CCR_IRDA_BITRATE_96000: Type = 1;
    pub const CCR_IRDA_BITRATE_72000: Type = 2;
    pub const CCR_IRDA_BITRATE_57600: Type = 3;
    pub const CCR_IRDA_BITRATE_48000: Type = 4;
    pub const CCR_IRDA_BITRATE_38400: Type = 5;
    pub const CCR_IRDA_BITRATE_36000: Type = 6;
    pub const CCR_IRDA_BITRATE_24000: Type = 7;
    pub const CCR_IRDA_BITRATE_19200: Type = 8;
    pub const CCR_IRDA_BITRATE_18000: Type = 9;
    pub const CCR_IRDA_BITRATE_12000: Type = 10;
    pub const CCR_IRDA_BITRATE_9600: Type = 11;
    pub const CCR_IRDA_BITRATE_7200: Type = 13;
    pub const CCR_IRDA_BITRATE_6000: Type = 13;
    pub const CCR_IRDA_BITRATE_4800: Type = 14;
    pub const CCR_IRDA_BITRATE_3000: Type = 15;
}
pub mod CCRCDCIrdaConnectionTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_IRDA_CONNECTION_WAIT: Type = 0;
    pub const CCR_IRDA_CONNECTION_REQUIRE: Type = 1;
    pub const CCR_IRDA_CONNECTION_ANY: Type = 2;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaConnectRequest {
    pub command: CCRCDCIrdaCommand,
    pub timeout: u16,
    pub bitrate: CCRCDCIrdaBitrate,
    pub receiveSize: u16,
    pub targetId: u8,
    pub type_: CCRCDCIrdaConnectionType,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaConnectReply {
    pub result: u8,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaSendRequest {
    pub command: CCRCDCIrdaCommand,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
impl Default for CCRCDCIrdaSendRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaSendReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaReceiveRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
pub struct CCRCDCIrdaReceiveReply {
    pub result: u8,
    pub size: u16,
    pub data: __IncompleteArrayField<u8>,
}
impl Default for CCRCDCIrdaReceiveReply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectRequest {
    pub command: CCRCDCIrdaCommand,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaDisconnectReply {
    pub result: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaSmallPacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaSmallPacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let dataSize: u8 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRCDCIrdaLargePacketHeader {
    pub magic: u8,
    pub sessionId: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub receiveSize: u16,
}
impl CCRCDCIrdaLargePacketHeader {
    #[inline]
    pub fn unk(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isLarge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isLarge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dataSize(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_dataSize(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unk: u8,
        isLarge: u8,
        dataSize: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk: u8 = unsafe { ::core::mem::transmute(unk) };
            unk as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isLarge: u8 = unsafe { ::core::mem::transmute(isLarge) };
            isLarge as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let dataSize: u16 = unsafe { ::core::mem::transmute(dataSize) };
            dataSize as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod IRCResult {
    pub type Type = ::core::ffi::c_uint;
    pub const IRC_RESULT_SUCCESS: Type = 0;
    pub const IRC_RESULT_INVALID_RECEIVE_SIZE: Type = 3;
    pub const IRC_RESULT_INVALID_PACKET: Type = 5;
    pub const IRC_RESULT_NO_DATA: Type = 6;
    pub const IRC_RESULT_ALREADY_CONNECTED: Type = 11;
    pub const IRC_IR_UNAVAILABLE: Type = 12;
    pub const IRC_RESULT_UNINITIALIZED: Type = 13;
    pub const IRC_RESULT_NOT_CONNECTED: Type = 13;
    pub const IRC_RESULT_CONNECT_FAILED: Type = 15;
    pub const IRC_RESULT_RECEIVE_FAILED: Type = 16;
    pub const IRC_RESULT_SEND_FAILED: Type = 17;
    pub const IRC_RESULT_DISCONNECT_FAILED: Type = 18;
}
pub type IRCConnectCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type IRCReceiveCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::core::ffi::c_void, size: u16, result: IRCResult::Type),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KBDAttachEvent {
    pub channel: u8,
    pub __unk63: [::core::ffi::c_char; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KBDKeyEvent {
    pub channel: u8,
    pub hidCode: u8,
    pub __unk64: [::core::ffi::c_char; 2usize],
    pub isPressedDown: BOOL,
    pub __unk65: [::core::ffi::c_char; 4usize],
    pub asUTF16Character: u16,
    pub __unk66: [::core::ffi::c_char; 2usize],
}
pub type KDBAttachCallback =
    ::core::option::Option<unsafe extern "C" fn(channel: *mut KBDAttachEvent)>;
pub type KDBKeyCallback = ::core::option::Option<unsafe extern "C" fn(event: *mut KBDKeyEvent)>;
pub mod KDBCountry {
    pub type Type = ::core::ffi::c_uint;
    pub const KDB_COUNTRY_UNKNOWN_0: Type = 0;
    pub const KDB_COUNTRY_UNKNOWN_1: Type = 1;
    pub const KDB_COUNTRY_UNKNOWN_2: Type = 2;
    pub const KDB_COUNTRY_UNKNOWN_3: Type = 3;
    pub const KDB_COUNTRY_UNKNOWN_4: Type = 4;
    pub const KDB_COUNTRY_UNKNOWN_5: Type = 5;
    pub const KDB_COUNTRY_UNKNOWN_6: Type = 6;
    pub const KDB_COUNTRY_UNKNOWN_7: Type = 7;
    pub const KDB_COUNTRY_UNKNOWN_8: Type = 8;
    pub const KDB_COUNTRY_UNKNOWN_9: Type = 9;
    pub const KDB_COUNTRY_UNKNOWN_10: Type = 10;
    pub const KDB_COUNTRY_UNKNOWN_11: Type = 11;
    pub const KDB_COUNTRY_UNKNOWN_12: Type = 12;
    pub const KDB_COUNTRY_UNKNOWN_13: Type = 13;
    pub const KDB_COUNTRY_UNKNOWN_14: Type = 14;
    pub const KDB_COUNTRY_UNKNOWN_15: Type = 15;
    pub const KDB_COUNTRY_UNKNOWN_16: Type = 16;
    pub const KDB_COUNTRY_UNKNOWN_17: Type = 17;
    pub const KDB_COUNTRY_UNKNOWN_18: Type = 18;
}
pub mod KDBError {
    pub type Type = ::core::ffi::c_uint;
    pub const KDB_ERROR_NONE: Type = 0;
    pub const KDB_ERROR_NOT_INITIALIZED: Type = 2;
    pub const KDB_ERROR_ALREADY_INITIALIZED: Type = 3;
    pub const KDB_ERROR_INVALID_COUNTRY: Type = 4;
}
pub type nfds_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pollfd {
    pub fd: ::core::ffi::c_int,
    pub events: ::core::ffi::c_int,
    pub revents: ::core::ffi::c_int,
}
pub type DMAETimeStamp = u64;
pub mod DMAESwapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const DMAE_SWAP_NONE: Type = 0;
    pub const DMAE_SWAP_16: Type = 1;
    pub const DMAE_SWAP_32: Type = 2;
    pub const DMAE_SWAP_64: Type = 3;
}
pub mod SOMemOptRequest {
    pub type Type = ::core::ffi::c_uint;
    pub const SOMEMOPT_REQUEST_INIT: Type = 1;
    pub const SOMEMOPT_REQUEST_GET_BYTES_USED: Type = 2;
    pub const SOMEMOPT_REQUEST_WAIT_FOR_INIT: Type = 3;
    pub const SOMEMOPT_REQUEST_CANCEL_WAIT: Type = 4;
}
pub mod SOMemOptFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const SOMEMOPT_FLAGS_NONE: Type = 0;
    pub const SOMEMOPT_FLAGS_BIG_BUFFERS: Type = 1;
}
pub mod FFLCreateIDFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FFL_CREATE_ID_FLAG_WII_U: Type = 5;
    pub const FFL_CREATE_ID_FLAG_TEMPORARY: Type = 2;
    pub const FFL_CREATE_ID_FLAG_NORMAL: Type = 8;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLCreateID {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub deviceHash: [u8; 6usize],
}
impl Default for FFLCreateID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FFLCreateID {
    #[inline]
    pub fn flags(&self) -> FFLCreateIDFlags::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: FFLCreateIDFlags::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: FFLCreateIDFlags::Type,
        timestamp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataCore {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub mii_version: u8,
    pub author_id: u64,
    pub mii_id: FFLCreateID,
    pub unk_0x16: u16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub mii_name: [u16; 10usize],
    pub size: u8,
    pub fatness: u8,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hair_type: u8,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 20usize]>,
}
impl Default for FFLiMiiDataCore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FFLiMiiDataCore {
    #[inline]
    pub fn birth_platform(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_birth_platform(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x00_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x00_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x01_b4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x01_b4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn font_region(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_font_region(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn region_move(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_move(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x02_b6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unk_0x02_b6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copyable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_copyable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        birth_platform: u8,
        unk_0x00_b4: u8,
        unk_0x01_b0: u8,
        unk_0x01_b4: u8,
        font_region: u8,
        region_move: u8,
        unk_0x02_b6: u8,
        copyable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let birth_platform: u8 = unsafe { ::core::mem::transmute(birth_platform) };
            birth_platform as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unk_0x00_b4: u8 = unsafe { ::core::mem::transmute(unk_0x00_b4) };
            unk_0x00_b4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let unk_0x01_b0: u8 = unsafe { ::core::mem::transmute(unk_0x01_b0) };
            unk_0x01_b0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let unk_0x01_b4: u8 = unsafe { ::core::mem::transmute(unk_0x01_b4) };
            unk_0x01_b4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let font_region: u8 = unsafe { ::core::mem::transmute(font_region) };
            font_region as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let region_move: u8 = unsafe { ::core::mem::transmute(region_move) };
            region_move as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let unk_0x02_b6: u8 = unsafe { ::core::mem::transmute(unk_0x02_b6) };
            unk_0x02_b6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let copyable: u8 = unsafe { ::core::mem::transmute(copyable) };
            copyable as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn unk_0x18_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x18_b1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x18_b1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_day(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_birth_day(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn birth_month(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_birth_month(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn gender(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gender(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        unk_0x18_b0: u16,
        unk_0x18_b1: u16,
        color: u16,
        birth_day: u16,
        birth_month: u16,
        gender: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unk_0x18_b0: u16 = unsafe { ::core::mem::transmute(unk_0x18_b0) };
            unk_0x18_b0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unk_0x18_b1: u16 = unsafe { ::core::mem::transmute(unk_0x18_b1) };
            unk_0x18_b1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let birth_day: u16 = unsafe { ::core::mem::transmute(birth_day) };
            birth_day as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let birth_month: u16 = unsafe { ::core::mem::transmute(birth_month) };
            birth_month as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let gender: u16 = unsafe { ::core::mem::transmute(gender) };
            gender as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn blush_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_blush_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_style(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_style(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn face_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_face_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn face_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_face_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn local_only(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_local_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hair_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hair_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_hair_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        blush_type: u8,
        face_style: u8,
        face_color: u8,
        face_type: u8,
        local_only: u8,
        hair_mirrored: u8,
        hair_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let blush_type: u8 = unsafe { ::core::mem::transmute(blush_type) };
            blush_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let face_style: u8 = unsafe { ::core::mem::transmute(face_style) };
            face_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let face_color: u8 = unsafe { ::core::mem::transmute(face_color) };
            face_color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let face_type: u8 = unsafe { ::core::mem::transmute(face_type) };
            face_type as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let local_only: u8 = unsafe { ::core::mem::transmute(local_only) };
            local_only as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let hair_mirrored: u8 = unsafe { ::core::mem::transmute(hair_mirrored) };
            hair_mirrored as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let hair_color: u8 = unsafe { ::core::mem::transmute(hair_color) };
            hair_color as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn eye_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eye_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_eye_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eye_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(23usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eye_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(23usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eye_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eye_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(43usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(43usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(48usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(48usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_distance(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(55usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_distance(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(55usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn eyebrow_rotation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(59usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_eyebrow_rotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(59usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_nose_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(71usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_nose_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(71usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nose_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(75usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_nose_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(75usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_thickness(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(80usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_thickness(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(80usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(83usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(83usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(87usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(87usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(90usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(90usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x40(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unk_0x40(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(104usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(104usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mouth_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(107usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mouth_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(107usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_height(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(112usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(112usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mustache_scale(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(118usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mustache_scale(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(118usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_color(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(122usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(122usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn beard_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(125usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_beard_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_height(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(128usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_glass_height(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(128usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(133usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(133usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_color(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(137usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_glass_color(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(137usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn glass_type(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(140usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_glass_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(140usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn unk_0x46_b0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(144usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unk_0x46_b0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_ypos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(145usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_ypos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(145usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_xpos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(150usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mole_xpos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(150usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_scale(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(155usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_mole_scale(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(155usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mole_enabled(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(159usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mole_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_4.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        eye_thickness: u32,
        eye_scale: u32,
        eye_color: u32,
        eye_type: u32,
        eye_height: u32,
        eye_distance: u32,
        eye_rotation: u32,
        eyebrow_thickness: u32,
        eyebrow_scale: u32,
        eyebrow_color: u32,
        eyebrow_type: u32,
        eyebrow_height: u32,
        eyebrow_distance: u32,
        eyebrow_rotation: u32,
        nose_height: u32,
        nose_scale: u32,
        nose_type: u32,
        mouth_thickness: u32,
        mouth_scale: u32,
        mouth_color: u32,
        mouth_type: u32,
        unk_0x40: u32,
        mustache_type: u32,
        mouth_height: u32,
        mustache_height: u32,
        mustache_scale: u32,
        beard_color: u32,
        beard_type: u32,
        glass_height: u16,
        glass_scale: u16,
        glass_color: u16,
        glass_type: u16,
        unk_0x46_b0: u16,
        mole_ypos: u16,
        mole_xpos: u16,
        mole_scale: u16,
        mole_enabled: u16,
    ) -> __BindgenBitfieldUnit<[u8; 20usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 20usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let eye_thickness: u32 = unsafe { ::core::mem::transmute(eye_thickness) };
            eye_thickness as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let eye_scale: u32 = unsafe { ::core::mem::transmute(eye_scale) };
            eye_scale as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let eye_color: u32 = unsafe { ::core::mem::transmute(eye_color) };
            eye_color as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let eye_type: u32 = unsafe { ::core::mem::transmute(eye_type) };
            eye_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let eye_height: u32 = unsafe { ::core::mem::transmute(eye_height) };
            eye_height as u64
        });
        __bindgen_bitfield_unit.set(23usize, 4u8, {
            let eye_distance: u32 = unsafe { ::core::mem::transmute(eye_distance) };
            eye_distance as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let eye_rotation: u32 = unsafe { ::core::mem::transmute(eye_rotation) };
            eye_rotation as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let eyebrow_thickness: u32 = unsafe { ::core::mem::transmute(eyebrow_thickness) };
            eyebrow_thickness as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let eyebrow_scale: u32 = unsafe { ::core::mem::transmute(eyebrow_scale) };
            eyebrow_scale as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let eyebrow_color: u32 = unsafe { ::core::mem::transmute(eyebrow_color) };
            eyebrow_color as u64
        });
        __bindgen_bitfield_unit.set(43usize, 5u8, {
            let eyebrow_type: u32 = unsafe { ::core::mem::transmute(eyebrow_type) };
            eyebrow_type as u64
        });
        __bindgen_bitfield_unit.set(48usize, 7u8, {
            let eyebrow_height: u32 = unsafe { ::core::mem::transmute(eyebrow_height) };
            eyebrow_height as u64
        });
        __bindgen_bitfield_unit.set(55usize, 4u8, {
            let eyebrow_distance: u32 = unsafe { ::core::mem::transmute(eyebrow_distance) };
            eyebrow_distance as u64
        });
        __bindgen_bitfield_unit.set(59usize, 5u8, {
            let eyebrow_rotation: u32 = unsafe { ::core::mem::transmute(eyebrow_rotation) };
            eyebrow_rotation as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let nose_height: u32 = unsafe { ::core::mem::transmute(nose_height) };
            nose_height as u64
        });
        __bindgen_bitfield_unit.set(71usize, 4u8, {
            let nose_scale: u32 = unsafe { ::core::mem::transmute(nose_scale) };
            nose_scale as u64
        });
        __bindgen_bitfield_unit.set(75usize, 5u8, {
            let nose_type: u32 = unsafe { ::core::mem::transmute(nose_type) };
            nose_type as u64
        });
        __bindgen_bitfield_unit.set(80usize, 3u8, {
            let mouth_thickness: u32 = unsafe { ::core::mem::transmute(mouth_thickness) };
            mouth_thickness as u64
        });
        __bindgen_bitfield_unit.set(83usize, 4u8, {
            let mouth_scale: u32 = unsafe { ::core::mem::transmute(mouth_scale) };
            mouth_scale as u64
        });
        __bindgen_bitfield_unit.set(87usize, 3u8, {
            let mouth_color: u32 = unsafe { ::core::mem::transmute(mouth_color) };
            mouth_color as u64
        });
        __bindgen_bitfield_unit.set(90usize, 6u8, {
            let mouth_type: u32 = unsafe { ::core::mem::transmute(mouth_type) };
            mouth_type as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let unk_0x40: u32 = unsafe { ::core::mem::transmute(unk_0x40) };
            unk_0x40 as u64
        });
        __bindgen_bitfield_unit.set(104usize, 3u8, {
            let mustache_type: u32 = unsafe { ::core::mem::transmute(mustache_type) };
            mustache_type as u64
        });
        __bindgen_bitfield_unit.set(107usize, 5u8, {
            let mouth_height: u32 = unsafe { ::core::mem::transmute(mouth_height) };
            mouth_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 6u8, {
            let mustache_height: u32 = unsafe { ::core::mem::transmute(mustache_height) };
            mustache_height as u64
        });
        __bindgen_bitfield_unit.set(118usize, 4u8, {
            let mustache_scale: u32 = unsafe { ::core::mem::transmute(mustache_scale) };
            mustache_scale as u64
        });
        __bindgen_bitfield_unit.set(122usize, 3u8, {
            let beard_color: u32 = unsafe { ::core::mem::transmute(beard_color) };
            beard_color as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let beard_type: u32 = unsafe { ::core::mem::transmute(beard_type) };
            beard_type as u64
        });
        __bindgen_bitfield_unit.set(128usize, 5u8, {
            let glass_height: u16 = unsafe { ::core::mem::transmute(glass_height) };
            glass_height as u64
        });
        __bindgen_bitfield_unit.set(133usize, 4u8, {
            let glass_scale: u16 = unsafe { ::core::mem::transmute(glass_scale) };
            glass_scale as u64
        });
        __bindgen_bitfield_unit.set(137usize, 3u8, {
            let glass_color: u16 = unsafe { ::core::mem::transmute(glass_color) };
            glass_color as u64
        });
        __bindgen_bitfield_unit.set(140usize, 4u8, {
            let glass_type: u16 = unsafe { ::core::mem::transmute(glass_type) };
            glass_type as u64
        });
        __bindgen_bitfield_unit.set(144usize, 1u8, {
            let unk_0x46_b0: u16 = unsafe { ::core::mem::transmute(unk_0x46_b0) };
            unk_0x46_b0 as u64
        });
        __bindgen_bitfield_unit.set(145usize, 5u8, {
            let mole_ypos: u16 = unsafe { ::core::mem::transmute(mole_ypos) };
            mole_ypos as u64
        });
        __bindgen_bitfield_unit.set(150usize, 5u8, {
            let mole_xpos: u16 = unsafe { ::core::mem::transmute(mole_xpos) };
            mole_xpos as u64
        });
        __bindgen_bitfield_unit.set(155usize, 4u8, {
            let mole_scale: u16 = unsafe { ::core::mem::transmute(mole_scale) };
            mole_scale as u64
        });
        __bindgen_bitfield_unit.set(159usize, 1u8, {
            let mole_enabled: u16 = unsafe { ::core::mem::transmute(mole_enabled) };
            mole_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLiMiiDataOfficial {
    pub core: FFLiMiiDataCore,
    pub creator_name: [u16; 10usize],
}
impl Default for FFLiMiiDataOfficial {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FFLStoreData {
    pub data: FFLiMiiDataOfficial,
    pub unk_0x5C: u16,
    pub checksum: u16,
}
impl Default for FFLStoreData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSEventMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_EVENT_MODE_MANUAL: Type = 0;
    pub const OS_EVENT_MODE_AUTO: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSEvent {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk67: [::core::ffi::c_char; 4usize],
    pub value: BOOL,
    pub queue: OSThreadQueue,
    pub mode: OSEventMode::Type,
}
impl Default for OSEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYSArgID = u32;
pub type SYSArgType = u32;
pub type SYSDeserializeCallback = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut SYSDeserializeArg, userArg: *mut ::core::ffi::c_void),
>;
pub mod SYSArgIDEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_ARG_ID_END: Type = 0;
    pub const SYS_ARG_ID_ANCHOR: Type = 100;
    pub const SYS_ARG_ID_RESULT: Type = 101;
    pub const SYS_ARG_ID_URL: Type = 200;
    pub const SYS_ARG_ID_MIV_DATA: Type = 300;
    pub const SYS_ARG_ID_JOIN_PID: Type = 400;
}
pub mod SYSArgTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_ARG_TYPE_UINT32: Type = 1;
    pub const SYS_ARG_TYPE_UINT64: Type = 2;
    pub const SYS_ARG_TYPE_DATA: Type = 3;
    pub const SYS_ARG_TYPE_STRING: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SYSArgDataBlock {
    pub id: SYSArgID,
    pub type_: SYSArgType,
    pub __bindgen_anon_1: SYSArgDataBlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSArgDataBlock__bindgen_ty_1 {
    pub uint32: u32,
    pub uint64: u64,
    pub data: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1,
    pub string: SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SYSArgDataBlock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2 {
    pub ptr: *const ::core::ffi::c_char,
    pub size: u32,
}
impl Default for SYSArgDataBlock__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SYSArgDataBlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SYSArgDataBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SYSCallerInfo {
    pub upid: u32,
    pub __unk68: [::core::ffi::c_char; 4usize],
    pub titleID: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSDeserializeArg {
    pub argName: *const ::core::ffi::c_char,
    pub size: u32,
    pub data: *mut ::core::ffi::c_void,
}
impl Default for SYSDeserializeArg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsOut {
    pub data: *const ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SYSStandardArgsOut {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgsIn {
    pub argString: *const ::core::ffi::c_char,
    pub size: u32,
}
impl Default for SYSStandardArgsIn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSStandardArgs {
    pub anchorData: *mut ::core::ffi::c_void,
    pub anchorSize: u32,
    pub resultData: *mut ::core::ffi::c_void,
    pub resultSize: u32,
}
impl Default for SYSStandardArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod ACPResult {
    pub type Type = ::core::ffi::c_int;
    pub const ACP_RESULT_SUCCESS: Type = 0;
    pub const ACP_RESULT_INVALID: Type = -200;
    pub const ACP_RESULT_INVALID_PARAMETER: Type = -201;
    pub const ACP_RESULT_INVALID_FILE: Type = -202;
    pub const ACP_RESULT_INVALID_XML_FILE: Type = -203;
    pub const ACP_RESULT_FILE_ACCESS_MODE: Type = -204;
    pub const ACP_RESULT_INVALID_NETWORK_TIME: Type = -205;
    pub const ACP_RESULT_NOT_FOUND: Type = -500;
    pub const ACP_RESULT_FILE_NOT_FOUND: Type = -501;
    pub const ACP_RESULT_DIR_NOT_FOUND: Type = -502;
    pub const ACP_RESULT_DEVICE_NOT_FOUND: Type = -503;
    pub const ACP_RESULT_TITLE_NOT_FOUND: Type = -504;
    pub const ACP_RESULT_APPLICATION_NOT_FOUND: Type = -505;
    pub const ACP_RESULT_SYSTEM_CONFIG_NOT_FOUND: Type = -506;
    pub const ACP_RESULT_XML_ITEM_NOT_FOUND: Type = -507;
    pub const ACP_RESULT_ALREADY_EXISTS: Type = -600;
    pub const ACP_RESULT_FILE_ALREADY_EXISTS: Type = -601;
    pub const ACP_RESULT_DIR_ALREADY_EXISTS: Type = -602;
    pub const ACP_RESULT_ALREADY_DONE: Type = -700;
    pub const ACP_RESULT_AUTHENTICATION: Type = -1000;
    pub const ACP_RESULT_INVALID_REGION: Type = -1001;
    pub const ACP_RESULT_RESTRICTED_RATING: Type = -1002;
    pub const ACP_RESULT_NOT_PRESENT_RATING: Type = -1003;
    pub const ACP_RESULT_PENDING_RATING: Type = -1004;
    pub const ACP_RESULT_NET_SETTING_REQUIRED: Type = -1005;
    pub const ACP_RESULT_NET_ACCOUNT_REQUIRED: Type = -1006;
    pub const ACP_RESULT_NET_ACCOUNT_ERROR: Type = -1007;
    pub const ACP_RESULT_BROWSER_REQUIRED: Type = -1008;
    pub const ACP_RESULT_OLV_REQUIRED: Type = -1009;
    pub const ACP_RESULT_PINCODE_REQUIRED: Type = -1010;
    pub const ACP_RESULT_INCORRECT_PINCODE: Type = -1011;
    pub const ACP_RESULT_INVALID_LOGO: Type = -1012;
    pub const ACP_RESULT_DEMO_EXPIRED_NUMBER: Type = -1013;
    pub const ACP_RESULT_DRC_REQUIRED: Type = -1014;
    pub const ACP_RESULT_NO_PERMISSION: Type = -1100;
    pub const ACP_RESULT_NO_FILE_PERMISSION: Type = -1101;
    pub const ACP_RESULT_NO_DIR_PERMISSION: Type = -1102;
    pub const ACP_RESULT_BUSY: Type = -1300;
    pub const ACP_RESULT_USB_STORAGE_NOT_READY: Type = -1301;
    pub const ACP_RESULT_CANCELLED: Type = -1400;
    pub const ACP_RESULT_RESOURCE: Type = -1500;
    pub const ACP_RESULT_DEVICE_FULL: Type = -1501;
    pub const ACP_RESULT_JOURNAL_FULL: Type = -1502;
    pub const ACP_RESULT_SYSTEM_MEMORY: Type = -1503;
    pub const ACP_RESULT_FS_RESOURCE: Type = -1504;
    pub const ACP_RESULT_IPC_RESOURCE: Type = -1505;
    pub const ACP_RESULT_NOT_INITIALISED: Type = -1600;
    pub const ACP_RESULT_ACCOUNT_ERROR: Type = -1700;
    pub const ACP_RESULT_UNSUPPORTED: Type = -1800;
    pub const ACP_RESULT_DATA_CORRUPTED: Type = -2000;
    pub const ACP_RESULT_DEVICE: Type = -2001;
    pub const ACP_RESULT_SLC_DATA_CORRUPTED: Type = -2002;
    pub const ACP_RESULT_MLC_DATA_CORRUPTED: Type = -2003;
    pub const ACP_RESULT_USB_DATA_CORRUPTED: Type = -2004;
    pub const ACP_RESULT_MEDIA: Type = -2100;
    pub const ACP_RESULT_MEDIA_NOT_READY: Type = -2101;
    pub const ACP_RESULT_MEDIA_BROKEN: Type = -2102;
    pub const ACP_RESULT_ODD_MEDIA_NOT_READY: Type = -2103;
    pub const ACP_RESULT_ODD_MEDIA_BROKEN: Type = -2104;
    pub const ACP_RESULT_USB_MEDIA_NOT_READY: Type = -2105;
    pub const ACP_RESULT_USB_MEDIA_BROKEN: Type = -2106;
    pub const ACP_RESULT_MEDIA_WRITE_PROTECTED: Type = -2107;
    pub const ACP_RESULT_USB_WRITE_PROTECTED: Type = -2108;
    pub const ACP_RESULT_MII: Type = -2200;
    pub const ACP_RESULT_ENCRYPTION_ERROR: Type = -2201;
    pub const ACP_RESULT_GENERIC_ERROR: Type = -4096;
}
pub mod ACPDeviceType {
    pub type Type = ::core::ffi::c_uint;
    pub const ACP_DEVICE_TYPE_AUTO: Type = 1;
    pub const ACP_DEVICE_TYPE_ODD: Type = 2;
    pub const ACP_DEVICE_TYPE_HFIODISC: Type = 2;
    pub const ACP_DEVICE_TYPE_MLC: Type = 3;
    pub const ACP_DEVICE_TYPE_HFIOMLC: Type = 3;
    pub const ACP_DEVICE_TYPE_USB: Type = 4;
}
pub type MCPError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDeviceList {
    _unused: [u8; 0],
}
pub mod MCPAppType {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_APP_TYPE_GAME_UPDATE: Type = 134217755;
    pub const MCP_APP_TYPE_GAME_DLC: Type = 134217742;
    pub const MCP_APP_TYPE_BOOT1: Type = 268435465;
    pub const MCP_APP_TYPE_SYSTEM_LIBRARIES: Type = 268435466;
    pub const MCP_APP_TYPE_BLUETOOTH_FIRMWARE: Type = 268435474;
    pub const MCP_APP_TYPE_DRC_FIRMWARE: Type = 268435475;
    pub const MCP_APP_TYPE_DRH_FIRMWARE: Type = 268435476;
    pub const MCP_APP_TYPE_SYSTEM_VERSION: Type = 268435477;
    pub const MCP_APP_TYPE_DRC_LANGUAGE: Type = 268435482;
    pub const MCP_APP_TYPE_EXCEPTIONS_DATA: Type = 402653200;
    pub const MCP_APP_TYPE_SHARED_DATA: Type = 402653212;
    pub const MCP_APP_TYPE_CERT_STORE: Type = 402653214;
    pub const MCP_APP_TYPE_PATCH_MAP_DATA: Type = 402653219;
    pub const MCP_APP_TYPE_WAGONU_MIGRATION_LIST: Type = 402653225;
    pub const MCP_APP_TYPE_CAFFEINE_TITLE_LIST: Type = 402653232;
    pub const MCP_APP_TYPE_MCP_TITLE_LIST: Type = 402653233;
    pub const MCP_APP_TYPE_GAME: Type = 2147483648;
    pub const MCP_APP_TYPE_GAME_WII: Type = 2147483694;
    pub const MCP_APP_TYPE_SYSTEM_MENU: Type = 2415919105;
    pub const MCP_APP_TYPE_SYSTEM_UPDATER: Type = 2415919115;
    pub const MCP_APP_TYPE_SYSTEM_APPS: Type = 2415919136;
    pub const MCP_APP_TYPE_ACCOUNT_APPS: Type = 2415919137;
    pub const MCP_APP_TYPE_SYSTEM_SETTINGS: Type = 2415919138;
    pub const MCP_APP_TYPE_ECO_PROCESS: Type = 2415919151;
    pub const MCP_APP_TYPE_EMANUAL: Type = 3489660931;
    pub const MCP_APP_TYPE_HOME_MENU: Type = 3489660932;
    pub const MCP_APP_TYPE_ERROR_DISPLAY: Type = 3489660933;
    pub const MCP_APP_TYPE_BROWSER: Type = 3489660934;
    pub const MCP_APP_TYPE_MIIVERSE_POST: Type = 3489660941;
    pub const MCP_APP_TYPE_MIIVERSE: Type = 3489660950;
    pub const MCP_APP_TYPE_ESHOP: Type = 3489660951;
    pub const MCP_APP_TYPE_FRIEND_LIST: Type = 3489660952;
    pub const MCP_APP_TYPE_DOWNLOAD_MANAGEMENT: Type = 3489660953;
    pub const MCP_APP_TYPE_AOC_OVERLAY: Type = 3489660972;
    pub const MCP_APP_TYPE_AMIIBO_SETTINGS: Type = 3489660979;
}
pub mod MCPDeviceType {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_DEVICE_TYPE_AUTO: Type = 1;
    pub const MCP_DEVICE_TYPE_ODD: Type = 2;
    pub const MCP_DEVICE_TYPE_MLC: Type = 3;
    pub const MCP_DEVICE_TYPE_USB: Type = 4;
}
pub mod MCPDeviceFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_DEVICE_FLAG_UNK_1: Type = 1;
    pub const MCP_DEVICE_FLAG_UNK_2: Type = 2;
    pub const MCP_DEVICE_FLAG_UNK_4: Type = 4;
    pub const MCP_DEVICE_FLAG_UNK_8: Type = 8;
}
pub mod MCPInstallTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_INSTALL_TARGET_MLC: Type = 0;
    pub const MCP_INSTALL_TARGET_USB: Type = 1;
}
pub mod MCPRegion {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_REGION_JAPAN: Type = 1;
    pub const MCP_REGION_USA: Type = 2;
    pub const MCP_REGION_EUROPE: Type = 4;
    pub const MCP_REGION_CHINA: Type = 16;
    pub const MCP_REGION_KOREA: Type = 32;
    pub const MCP_REGION_TAIWAN: Type = 64;
}
pub mod MCPCompatAVFile {
    pub type Type = ::core::ffi::c_uint;
    pub const MCP_COMPAT_AV_FILE_DMCU: Type = 0;
    pub const MCP_COMPAT_AV_FILE_DEINT: Type = 1;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPDevice {
    pub type_: [::core::ffi::c_char; 8usize],
    pub unk0x08: [::core::ffi::c_char; 128usize],
    pub filesystem: [::core::ffi::c_char; 8usize],
    pub path: [::core::ffi::c_char; 639usize],
    pub flags: MCPDeviceFlags::Type,
    pub uid: u32,
    pub index: u32,
}
impl Default for MCPDevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallInfo {
    pub __unk69: [::core::ffi::c_char; 639usize],
}
impl Default for MCPInstallInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MCPInstallProgress {
    pub inProgress: u32,
    pub tid: u64,
    pub sizeTotal: u64,
    pub sizeProgress: u64,
    pub contentsTotal: u32,
    pub contentsProgress: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MCPInstallTitleInfo {
    pub __unk70: [::core::ffi::c_char; 639usize],
}
impl Default for MCPInstallTitleInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPSysProdSettings {
    pub product_area: MCPRegion::Type,
    pub eeprom_version: u16,
    pub __unk71: [::core::ffi::c_char; 2usize],
    pub game_region: MCPRegion::Type,
    pub __unk72: [::core::ffi::c_char; 4usize],
    pub ntsc_pal: [::core::ffi::c_char; 5usize],
    pub wifi_5ghz_country_code: [::core::ffi::c_char; 4usize],
    pub wifi_5ghz_country_code_revision: u8,
    pub code_id: [::core::ffi::c_char; 8usize],
    pub serial_id: [::core::ffi::c_char; 12usize],
    pub __unk73: [::core::ffi::c_char; 4usize],
    pub model_number: [::core::ffi::c_char; 16usize],
    pub version: u32,
}
impl Default for MCPSysProdSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MCPSystemVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub region: ::core::ffi::c_char,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCPTitleListType {
    pub titleId: u64,
    pub groupId: u32,
    pub path: [::core::ffi::c_char; 56usize],
    pub appType: MCPAppType::Type,
    pub titleVersion: u16,
    pub osVersion: u64,
    pub sdkVersion: u32,
    pub indexedDevice: [::core::ffi::c_char; 10usize],
    pub unk0x60: u8,
}
impl Default for MCPTitleListType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ACPTitleId = u64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPMetaXml {
    pub title_id: u64,
    pub boss_id: u64,
    pub os_version: u64,
    pub app_size: u64,
    pub common_save_size: u64,
    pub account_save_size: u64,
    pub common_boss_size: u64,
    pub account_boss_size: u64,
    pub join_game_mode_mask: u64,
    pub version: u32,
    pub product_code: [::core::ffi::c_char; 32usize],
    pub content_platform: [::core::ffi::c_char; 32usize],
    pub company_code: [::core::ffi::c_char; 8usize],
    pub mastering_date: [::core::ffi::c_char; 32usize],
    pub logo_type: u32,
    pub app_launch_type: u32,
    pub invisible_flag: u32,
    pub no_managed_flag: u32,
    pub no_event_log: u32,
    pub no_icon_database: u32,
    pub launching_flag: u32,
    pub install_flag: u32,
    pub closing_msg: u32,
    pub title_version: u32,
    pub group_id: u32,
    pub save_no_rollback: u32,
    pub bg_daemon_enable: u32,
    pub join_game_id: u32,
    pub olv_accesskey: u32,
    pub wood_tin: u32,
    pub e_manual: u32,
    pub e_manual_version: u32,
    pub region: u32,
    pub pc_cero: u32,
    pub pc_esrb: u32,
    pub pc_bbfc: u32,
    pub pc_usk: u32,
    pub pc_pegi_gen: u32,
    pub pc_pegi_fin: u32,
    pub pc_pegi_prt: u32,
    pub pc_pegi_bbfc: u32,
    pub pc_cob: u32,
    pub pc_grb: u32,
    pub pc_cgsrr: u32,
    pub pc_oflc: u32,
    pub pc_reserved0: u32,
    pub pc_reserved1: u32,
    pub pc_reserved2: u32,
    pub pc_reserved3: u32,
    pub ext_dev_nunchaku: u32,
    pub ext_dev_classic: u32,
    pub ext_dev_urcc: u32,
    pub ext_dev_board: u32,
    pub ext_dev_usb_keyboard: u32,
    pub ext_dev_etc: u32,
    pub ext_dev_etc_name: [::core::ffi::c_char; 512usize],
    pub eula_version: u32,
    pub drc_use: u32,
    pub network_use: u32,
    pub online_account_use: u32,
    pub direct_boot: u32,
    pub reserved_flag0: u32,
    pub reserved_flag1: u32,
    pub reserved_flag2: u32,
    pub reserved_flag3: u32,
    pub reserved_flag4: u32,
    pub reserved_flag5: u32,
    pub reserved_flag6: u32,
    pub reserved_flag7: u32,
    pub longname_ja: [::core::ffi::c_char; 512usize],
    pub longname_en: [::core::ffi::c_char; 512usize],
    pub longname_fr: [::core::ffi::c_char; 512usize],
    pub longname_de: [::core::ffi::c_char; 512usize],
    pub longname_it: [::core::ffi::c_char; 512usize],
    pub longname_es: [::core::ffi::c_char; 512usize],
    pub longname_zhs: [::core::ffi::c_char; 512usize],
    pub longname_ko: [::core::ffi::c_char; 512usize],
    pub longname_nl: [::core::ffi::c_char; 512usize],
    pub longname_pt: [::core::ffi::c_char; 512usize],
    pub longname_ru: [::core::ffi::c_char; 512usize],
    pub longname_zht: [::core::ffi::c_char; 512usize],
    pub shortname_ja: [::core::ffi::c_char; 256usize],
    pub shortname_en: [::core::ffi::c_char; 256usize],
    pub shortname_fr: [::core::ffi::c_char; 256usize],
    pub shortname_de: [::core::ffi::c_char; 256usize],
    pub shortname_it: [::core::ffi::c_char; 256usize],
    pub shortname_es: [::core::ffi::c_char; 256usize],
    pub shortname_zhs: [::core::ffi::c_char; 256usize],
    pub shortname_ko: [::core::ffi::c_char; 256usize],
    pub shortname_nl: [::core::ffi::c_char; 256usize],
    pub shortname_pt: [::core::ffi::c_char; 256usize],
    pub shortname_ru: [::core::ffi::c_char; 256usize],
    pub shortname_zht: [::core::ffi::c_char; 256usize],
    pub publisher_ja: [::core::ffi::c_char; 256usize],
    pub publisher_en: [::core::ffi::c_char; 256usize],
    pub publisher_fr: [::core::ffi::c_char; 256usize],
    pub publisher_de: [::core::ffi::c_char; 256usize],
    pub publisher_it: [::core::ffi::c_char; 256usize],
    pub publisher_es: [::core::ffi::c_char; 256usize],
    pub publisher_zhs: [::core::ffi::c_char; 256usize],
    pub publisher_ko: [::core::ffi::c_char; 256usize],
    pub publisher_nl: [::core::ffi::c_char; 256usize],
    pub publisher_pt: [::core::ffi::c_char; 256usize],
    pub publisher_ru: [::core::ffi::c_char; 256usize],
    pub publisher_zht: [::core::ffi::c_char; 256usize],
    pub add_on_unique_id: [u32; 32usize],
    pub __unk74: [::core::ffi::c_char; 52usize],
}
impl Default for ACPMetaXml {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ACPDrcLedStatus = u8;
pub type ACPDrcLedPattern = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ACPSaveDirInfo {
    pub __unk75: [::core::ffi::c_char; 8usize],
    pub persistentId: u32,
    pub __unk76: [::core::ffi::c_char; 20usize],
    pub path: [::core::ffi::c_char; 64usize],
    pub __unk77: [::core::ffi::c_char; 32usize],
}
impl Default for ACPSaveDirInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod HPADChan {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_CHAN_0: Type = 0;
    pub const HPAD_CHAN_1: Type = 1;
    pub const HPAD_CHAN_2: Type = 2;
    pub const HPAD_CHAN_3: Type = 3;
    pub const HPAD_CHAN_4: Type = 4;
    pub const HPAD_CHAN_5: Type = 5;
    pub const HPAD_CHAN_6: Type = 6;
    pub const HPAD_CHAN_7: Type = 7;
}
pub mod HPADGGGGChan {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_GGGG_CHAN_0: Type = 0;
    pub const HPAD_GGGG_CHAN_1: Type = 1;
}
pub mod HPADButtons {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_BUTTON_A: Type = 1;
    pub const HPAD_BUTTON_B: Type = 2;
    pub const HPAD_BUTTON_X: Type = 4;
    pub const HPAD_BUTTON_Y: Type = 8;
    pub const HPAD_BUTTON_LEFT: Type = 16;
    pub const HPAD_BUTTON_RIGHT: Type = 32;
    pub const HPAD_BUTTON_DOWN: Type = 64;
    pub const HPAD_BUTTON_UP: Type = 128;
    pub const HPAD_BUTTON_START: Type = 256;
    pub const HPAD_TRIGGER_Z: Type = 512;
    pub const HPAD_TRIGGER_R: Type = 1024;
    pub const HPAD_TRIGGER_L: Type = 2048;
    pub const HPAD_STICK_EMULATION_LEFT: Type = 4096;
    pub const HPAD_STICK_EMULATION_RIGHT: Type = 8192;
    pub const HPAD_STICK_EMULATION_DOWN: Type = 16384;
    pub const HPAD_STICK_EMULATION_UP: Type = 32768;
    pub const HPAD_SUBSTICK_EMULATION_LEFT: Type = 65536;
    pub const HPAD_SUBSTICK_EMULATION_RIGHT: Type = 131072;
    pub const HPAD_SUBSTICK_EMULATION_DOWN: Type = 262144;
    pub const HPAD_SUBSTICK_EMULATION_UP: Type = 524288;
}
pub mod HPADMotorCommand {
    pub type Type = ::core::ffi::c_uint;
    pub const HPAD_MOTOR_COMMAND_STOP: Type = 0;
    pub const HPAD_MOTOR_COMMAND_RUMBLE: Type = 1;
    pub const HPAD_MOTOR_COMMAND_STOP_HARD: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HPADStatus {
    pub hold: i32,
    pub trigger: i32,
    pub release: i32,
    pub stickX: i8,
    pub stickY: i8,
    pub substickX: i8,
    pub substickY: i8,
    pub triggerL: u8,
    pub triggerR: u8,
    pub status: u8,
    pub __unk78: [::core::ffi::c_char; 1usize],
    pub error: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HPADGGGGStatus {
    pub connected: BOOL,
    pub powerSupplyConnected: BOOL,
    pub active: BOOL,
}
pub type HPADConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADChan::Type, status: i32)>;
pub type HPADGGGGConnectCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, connected: BOOL)>;
pub type HPADPowerSupplyCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, connected: BOOL)>;
pub type HPADSamplingCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type)>;
pub type HPADResetCallback =
    ::core::option::Option<unsafe extern "C" fn(chan: HPADGGGGChan::Type, status: i32)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSSpinLock {
    pub owner: u32,
    pub __unk79: [::core::ffi::c_char; 4usize],
    pub recursion: u32,
    pub __unk80: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryLink {
    pub prev: *mut ::core::ffi::c_void,
    pub next: *mut ::core::ffi::c_void,
}
impl Default for MEMMemoryLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMMemoryList {
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
    pub count: u16,
    pub offsetToMemoryLink: u16,
}
impl Default for MEMMemoryList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MEMHeapHandle = *mut MEMHeapHeader;
pub mod MEMBaseHeapType {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_BASE_HEAP_MEM1: Type = 0;
    pub const MEM_BASE_HEAP_MEM2: Type = 1;
    pub const MEM_BASE_HEAP_FG: Type = 8;
}
pub mod MEMHeapFillType {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_HEAP_FILL_TYPE_UNUSED: Type = 0;
    pub const MEM_HEAP_FILL_TYPE_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FILL_TYPE_FREED: Type = 2;
}
pub mod MEMHeapTag {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_BLOCK_HEAP_TAG: Type = 1112296264;
    pub const MEM_EXPANDED_HEAP_TAG: Type = 1163415624;
    pub const MEM_FRAME_HEAP_TAG: Type = 1179798856;
    pub const MEM_UNIT_HEAP_TAG: Type = 1431196744;
    pub const MEM_USER_HEAP_TAG: Type = 1431523912;
}
pub mod MEMHeapFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_HEAP_FLAG_ZERO_ALLOCATED: Type = 1;
    pub const MEM_HEAP_FLAG_DEBUG_MODE: Type = 2;
    pub const MEM_HEAP_FLAG_USE_LOCK: Type = 4;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MEMHeapHeader {
    pub tag: MEMHeapTag::Type,
    pub link: MEMMemoryLink,
    pub list: MEMMemoryList,
    pub dataStart: *mut ::core::ffi::c_void,
    pub dataEnd: *mut ::core::ffi::c_void,
    pub lock: OSSpinLock,
    pub flags: u32,
    pub __unk81: [::core::ffi::c_char; 12usize],
}
impl Default for MEMHeapHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type MEMAllocFromDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut ::core::ffi::c_void>;
pub type MEMAllocFromDefaultHeapExFn = ::core::option::Option<
    unsafe extern "C" fn(size: u32, alignment: i32) -> *mut ::core::ffi::c_void,
>;
pub type MEMFreeToDefaultHeapFn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::core::ffi::c_void)>;
pub type ACConfigId = u32;
pub mod CCRSysPairingState {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_PAIRING_FINISHED: Type = 0;
    pub const CCR_SYS_PAIRING_IN_PROGRESS: Type = 1;
    pub const CCR_SYS_PAIRING_TIMED_OUT: Type = 2;
}
pub mod CCRSysInitBootFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_BOOT_FLAG_NONE: Type = 0;
    pub const CCR_SYS_BOOT_FLAG_FIRST_BOOT: Type = 1;
}
pub mod CCRSysLCDMode {
    pub type Type = ::core::ffi::c_uint;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_1: Type = 1;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_2: Type = 2;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_3: Type = 3;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_4: Type = 4;
    pub const CCR_SYS_LCD_MODE_BRIGHTNESS_5: Type = 5;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CCRSysUpdateState {
    pub state: u32,
    pub progress: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRAppLaunchParam {
    pub launchInfoDatabaseEntryId: u64,
    pub uuid: [::core::ffi::c_char; 16usize],
    pub __unk183: [::core::ffi::c_char; 231usize],
}
impl Default for CCRAppLaunchParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TEMPTargetPreference {
    pub type Type = ::core::ffi::c_uint;
    pub const TEMP_PREF_DEFAULT: Type = 0;
    pub const TEMP_PREF_USB: Type = 1;
}
pub type TEMPDirId = u64;
pub mod SAVEStatus {
    pub type Type = ::core::ffi::c_int;
    pub const SAVE_STATUS_OK: Type = 0;
    pub const SAVE_STATUS_NOT_FOUND: Type = -6;
    pub const SAVE_STATUS_STORAGE_FULL: Type = -12;
}
pub mod CmptScreenType {
    pub type Type = ::core::ffi::c_uint;
    pub const CMPT_SCREEN_TYPE_TV: Type = 1;
    pub const CMPT_SCREEN_TYPE_DRC: Type = 2;
    pub const CMPT_SCREEN_TYPE_BOTH: Type = 3;
}
pub type FILE = __FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEManualArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub titleId: u64,
}
impl Default for SysAppEManualArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppEShopArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub query: *mut ::core::ffi::c_char,
    pub querySize: u32,
}
impl Default for SysAppEShopArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub url: *mut ::core::ffi::c_char,
    pub urlSize: u32,
}
impl Default for SysAppBrowserArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppBrowserArgsWithCallback {
    pub browserArgs: SysAppBrowserArgs,
    pub cbUrl: *mut ::core::ffi::c_char,
    pub cbUrlSize: u32,
    pub hbmDisable: BOOL,
}
impl Default for SysAppBrowserArgsWithCallback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SysAppPFID {
    pub type Type = ::core::ffi::c_uint;
    pub const SYSAPP_PFID_WII_U_MENU: Type = 2;
    pub const SYSAPP_PFID_TVII: Type = 3;
    pub const SYSAPP_PFID_EMANUAL: Type = 4;
    pub const SYSAPP_PFID_HOME_MENU: Type = 5;
    pub const SYSAPP_PFID_MINI_MIIVERSE: Type = 7;
    pub const SYSAPP_PFID_BROWSER: Type = 8;
    pub const SYSAPP_PFID_MIIVERSE: Type = 9;
    pub const SYSAPP_PFID_ESHOP: Type = 10;
    pub const SYSAPP_PFID_FRIENDLIST: Type = 11;
    pub const SYSAPP_PFID_DOWNLOAD_MANAGEMENT: Type = 12;
    pub const SYSAPP_PFID_DOWNLOAD_GAME: Type = 15;
    pub const SYSAPP_PFID_MINTU: Type = 16;
    pub const SYSAPP_PFID_CABINETU: Type = 17;
    pub const SYSAPP_PFID_TEST_OVERLAY: Type = 31;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
impl Default for SysAppMiiMakerArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysAppMiiMakerArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
    pub slotId: u32,
    pub mii: *mut FFLStoreData,
}
impl Default for _SysAppMiiMakerArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SYSSettingsJumpToTarget {
    pub type Type = ::core::ffi::c_uint;
    pub const SYS_SETTINGS_JUMP_TO_NONE: Type = 0;
    pub const SYS_SETTINGS_JUMP_TO_INTERNET: Type = 1;
    pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT: Type = 2;
    pub const SYS_SETTINGS_JUMP_TO_TV_REMOTE: Type = 3;
    pub const SYS_SETTINGS_JUMP_TO_DATE_TIME: Type = 4;
    pub const SYS_SETTINGS_JUMP_TO_COUNTRY: Type = 5;
    pub const SYS_SETTINGS_JUMP_TO_SYSTEM_UPDATE: Type = 6;
    pub const SYS_SETTINGS_JUMP_TO_INITIAL_SETTINGS: Type = 100;
    pub const SYS_SETTINGS_JUMP_TO_UNKNOWN: Type = 101;
    pub const SYS_SETTINGS_JUMP_TO_WIPE_CONSOLE: Type = 102;
    pub const SYS_SETTINGS_JUMP_TO_QUICK_START_SETTINGS: Type = 103;
    pub const SYS_SETTINGS_JUMP_TO_TV_CONNECTION_TYPE: Type = 104;
    pub const SYS_SETTINGS_JUMP_TO_DATA_MANAGEMENT_2: Type = 105;
    pub const SYS_SETTINGS_JUMP_TO_SOFTWARE_TRANSFER: Type = 255;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppSettingsArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub jumpTo: SYSSettingsJumpToTarget::Type,
    pub firstBootKind: u32,
}
impl Default for SysAppSettingsArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppParentalArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub mode: u32,
}
impl Default for SysAppParentalArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysAppNotificationArgs {
    pub stdArgs: SYSStandardArgsIn,
    pub notificationFile: u32,
}
impl Default for SysAppNotificationArgs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SYSTEM_APP_ID {
    pub type Type = ::core::ffi::c_uint;
    pub const SYSTEM_APP_ID_WII_U_MENU: Type = 0;
    pub const SYSTEM_APP_ID_SYSTEM_SETTINGS: Type = 1;
    pub const SYSTEM_APP_ID_PARENTAL_CONTROLS: Type = 2;
    pub const SYSTEM_APP_ID_USER_SETTINGS: Type = 3;
    pub const SYSTEM_APP_ID_MII_MAKER: Type = 4;
    pub const SYSTEM_APP_ID_ACCOUNT_SETTINGS: Type = 5;
    pub const SYSTEM_APP_ID_DAILY_LOG: Type = 6;
    pub const SYSTEM_APP_ID_NOTIFICATIONS: Type = 7;
    pub const SYSTEM_APP_ID_HEALTH_AND_SAFETY: Type = 8;
    pub const SYSTEM_APP_ID_ELECTRONIC_MANUAL: Type = 9;
    pub const SYSTEM_APP_ID_WIIU_CHAT: Type = 10;
    pub const SYSTEM_APP_ID_SOFTWARE_DATA_TRANSFER: Type = 11;
}
pub type LogHandlerFn =
    ::core::option::Option<unsafe extern "C" fn(msg: *const ::core::ffi::c_char)>;
pub mod WHBFileError {
    pub type Type = ::core::ffi::c_int;
    pub const WHB_FILE_OK: Type = 0;
    pub const WHB_FILE_FATAL_ERROR: Type = -1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHBGfxShaderGroup {
    pub fetchShader: GX2FetchShader,
    pub fetchShaderProgram: *mut ::core::ffi::c_void,
    pub pixelShader: *mut GX2PixelShader,
    pub vertexShader: *mut GX2VertexShader,
    pub numAttributes: u32,
    pub attributes: [GX2AttribStream; 16usize],
}
impl Default for WHBGfxShaderGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod TVEPort {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_PORT_HDMI: Type = 0;
    pub const TVE_PORT_COMPONENT: Type = 1;
    pub const TVE_PORT_COMPOSITE: Type = 2;
    pub const TVE_PORT_SCART: Type = 3;
}
pub mod TVEHdmiState {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_HDMI_STATE_NONE: Type = 0;
    pub const TVE_HDMI_STATE_HTPG_OFF: Type = 1;
    pub const TVE_HDMI_STATE_RXWAIT: Type = 2;
    pub const TVE_HDMI_STATE_EDID_COMP: Type = 3;
    pub const TVE_HDMI_STATE_DUMMY_TMDS: Type = 4;
    pub const TVE_HDMI_STATE_W4WK: Type = 5;
    pub const TVE_HDMI_STATE_1STA: Type = 6;
    pub const TVE_HDMI_STATE_2NDA: Type = 7;
    pub const TVE_HDMI_STATE_3RDA: Type = 8;
    pub const TVE_HDMI_STATE_STAV_OFF: Type = 9;
    pub const TVE_HDMI_STATE_DONE: Type = 10;
    pub const TVE_HDMI_STATE_OTHER: Type = 11;
    pub const TVE_HDMI_STATE_TMDSDOWN: Type = 12;
    pub const TVE_HDMI_STATE_SHUTDOWN: Type = 13;
    pub const TVE_HDMI_STATE_WII: Type = 14;
    pub const TVE_HDMI_STATE_ERR_NRESET: Type = 15;
    pub const TVE_HDMI_STATE_ERR_INT_LINE: Type = 16;
    pub const TVE_HDMI_STATE_ERR_KEY_LOAD: Type = 17;
    pub const TVE_HDMI_STATE_ERR_EDID_READ: Type = 18;
    pub const TVE_HDMI_STATE_ERR_HOTPLUG: Type = 19;
    pub const TVE_HDMI_STATE_ERR_VSYNC: Type = 20;
    pub const TVE_HDMI_STATE_ERR_HDCP: Type = 21;
    pub const TVE_HDMI_STATE_ERR_SYS: Type = 22;
    pub const TVE_HDMI_STATE_ERR_CEC: Type = 23;
    pub const TVE_HDMI_STATE_ERR_W41A: Type = 24;
    pub const TVE_HDMI_STATE_ERR_W4ED: Type = 25;
    pub const TVE_HDMI_STATE_UNKNOWN_1A: Type = 26;
}
pub mod TVECECLogicalAddress {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_CEC_DEVICE_TV: Type = 0;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_1: Type = 1;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_2: Type = 2;
    pub const TVE_CEC_DEVICE_TUNER_1: Type = 3;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_1: Type = 4;
    pub const TVE_CEC_DEVICE_AUDIO_SYSTEM: Type = 5;
    pub const TVE_CEC_DEVICE_TUNER_2: Type = 6;
    pub const TVE_CEC_DEVICE_TUNER_3: Type = 7;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_2: Type = 8;
    pub const TVE_CEC_DEVICE_RECORDING_DEVICE_3: Type = 9;
    pub const TVE_CEC_DEVICE_TUNER_4: Type = 10;
    pub const TVE_CEC_DEVICE_PLAYBACK_DEVICE_3: Type = 11;
    pub const TVE_CEC_DEVICE_RESERVED_1: Type = 12;
    pub const TVE_CEC_DEVICE_RESERVED_2: Type = 13;
    pub const TVE_CEC_DEVICE_FREE_USE: Type = 14;
    pub const TVE_CEC_DEVICE_UNREGISTERED: Type = 15;
    pub const TVE_CEC_DEVICE_BROADCAST: Type = 15;
}
pub mod TVECECOpCode {
    pub type Type = ::core::ffi::c_uint;
    pub const TVE_CEC_OPCODE_FEATURE_ABORT: Type = 0;
    pub const TVE_CEC_OPCODE_IMAGE_VIEW_ON: Type = 4;
    pub const TVE_CEC_OPCODE_TUNER_STEP_INCREMENT: Type = 5;
    pub const TVE_CEC_OPCODE_TUNER_STEP_DECREMENT: Type = 6;
    pub const TVE_CEC_OPCODE_TUNER_DEVICE_STATUS: Type = 7;
    pub const TVE_CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: Type = 8;
    pub const TVE_CEC_OPCODE_RECORD_ON: Type = 9;
    pub const TVE_CEC_OPCODE_RECORD_STATUS: Type = 10;
    pub const TVE_CEC_OPCODE_RECORD_OFF: Type = 11;
    pub const TVE_CEC_OPCODE_TEXT_VIEW_ON: Type = 13;
    pub const TVE_CEC_OPCODE_RECORD_TV_SCREEN: Type = 15;
    pub const TVE_CEC_OPCODE_GIVE_DECK_STATUS: Type = 26;
    pub const TVE_CEC_OPCODE_DECK_STATUS: Type = 27;
    pub const TVE_CEC_OPCODE_SET_MENU_LANGUAGE: Type = 50;
    pub const TVE_CEC_OPCODE_CLEAR_ANALOGUE_TIMER: Type = 51;
    pub const TVE_CEC_OPCODE_SET_ANALOGUE_TIMER: Type = 52;
    pub const TVE_CEC_OPCODE_TIMER_STATUS: Type = 53;
    pub const TVE_CEC_OPCODE_STANDBY: Type = 54;
    pub const TVE_CEC_OPCODE_PLAY: Type = 65;
    pub const TVE_CEC_OPCODE_DECK_CONTROL: Type = 66;
    pub const TVE_CEC_OPCODE_TIMER_CLEARED_STATUS: Type = 67;
    pub const TVE_CEC_OPCODE_USER_CONTROL_PRESSED: Type = 68;
    pub const TVE_CEC_OPCODE_USER_CONTROL_RELEASE: Type = 69;
    pub const TVE_CEC_OPCODE_GIVE_OSD_NAME: Type = 70;
    pub const TVE_CEC_OPCODE_SET_OSD_NAME: Type = 71;
    pub const TVE_CEC_OPCODE_SET_OSD_STRING: Type = 100;
    pub const TVE_CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: Type = 103;
    pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: Type = 112;
    pub const TVE_CEC_OPCODE_GIVE_AUDIO_STATUS: Type = 113;
    pub const TVE_CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: Type = 114;
    pub const TVE_CEC_OPCODE_REPORT_AUDIO_STATUS: Type = 122;
    pub const TVE_CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: Type = 125;
    pub const TVE_CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: Type = 126;
    pub const TVE_CEC_OPCODE_ROUTING_CHANGE: Type = 128;
    pub const TVE_CEC_OPCODE_ROUTING_INFORMATION: Type = 129;
    pub const TVE_CEC_OPCODE_ACTIVE_SOURCE: Type = 130;
    pub const TVE_CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: Type = 131;
    pub const TVE_CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: Type = 132;
    pub const TVE_CEC_OPCODE_REQUEST_ACTIVE_SOURCE: Type = 133;
    pub const TVE_CEC_OPCODE_SET_STREAM_PATH: Type = 134;
    pub const TVE_CEC_OPCODE_DEVICE_VENDOR_ID: Type = 135;
    pub const TVE_CEC_OPCODE_VENDOR_COMMAND: Type = 137;
    pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: Type = 138;
    pub const TVE_CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: Type = 139;
    pub const TVE_CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: Type = 140;
    pub const TVE_CEC_OPCODE_MENU_REQUEST: Type = 141;
    pub const TVE_CEC_OPCODE_MENU_STATUS: Type = 142;
    pub const TVE_CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: Type = 143;
    pub const TVE_CEC_OPCODE_REPORT_POWER_STATUS: Type = 144;
    pub const TVE_CEC_OPCODE_GET_MENU_LANGUAGE: Type = 145;
    pub const TVE_CEC_OPCODE_SELECT_ANALOGUE_SERVICE: Type = 146;
    pub const TVE_CEC_OPCODE_SELECT_DIGITAL_SERVICE: Type = 147;
    pub const TVE_CEC_OPCODE_SET_DIGITAL_TIMER: Type = 151;
    pub const TVE_CEC_OPCODE_CLEAR_DIGITAL_TIMER: Type = 153;
    pub const TVE_CEC_OPCODE_SET_AUDIO_RATE: Type = 154;
    pub const TVE_CEC_OPCODE_INACTIVE_SOURCE: Type = 157;
    pub const TVE_CEC_OPCODE_CEC_VERSION: Type = 158;
    pub const TVE_CEC_OPCODE_GET_CEC_VERSION: Type = 159;
    pub const TVE_CEC_OPCODE_VENDOR_COMMAND_WITH_ID: Type = 160;
    pub const TVE_CEC_OPCODE_CLEAR_EXTERNAL_TIMER: Type = 161;
    pub const TVE_CEC_OPCODE_SET_EXTERNAL_TIMER: Type = 162;
    pub const TVE_CEC_OPCODE_ABORT: Type = 255;
}
pub type AXResult = i32;
pub mod AX_RESULT {
    pub type Type = ::core::ffi::c_int;
    pub const AX_RESULT_SUCCESS: Type = 0;
    pub const AX_RESULT_INVALID_DEVICE_TYPE: Type = -1;
    pub const AX_RESULT_INVALID_DRC_VS_MODE: Type = -13;
    pub const AX_RESULT_VOICE_IS_RUNNING: Type = -18;
    pub const AX_RESULT_DELAY_TOO_BIG: Type = -19;
}
pub type AXDRCVSMode = u32;
pub type AXDRCVSOutput = u32;
pub type AXDRCVSLC = u32;
pub type AXDRCVSSpeakerPosition = u32;
pub type AXDRCVSSurroundLevelGain = u32;
pub mod AX_DRC_VS_MODE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_OUTPUT {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_OUTPUT_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_LC {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_LC_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SPEAKER_POS {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_SPEAKER_POS_UNKNOWN: Type = 0;
}
pub mod AX_DRC_VS_SURROUND_GAIN {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DRC_VS_SURROUND_GAIN_UNKNOWN: Type = 0;
}
pub type AXDeviceFinalMixCallback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void),
>;
pub type AXDeviceMode = u32;
pub type AXDeviceType = u32;
pub mod AX_DEVICE_MODE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DEVICE_MODE_UNKNOWN: Type = 0;
}
pub mod AX_DEVICE_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_DEVICE_TYPE_TV: Type = 0;
    pub const AX_DEVICE_TYPE_DRC: Type = 1;
    pub const AX_DEVICE_TYPE_CONTROLLER: Type = 2;
}
pub type AXFrameCallback = ::core::option::Option<unsafe extern "C" fn()>;
pub type AXInitRenderer = u32;
pub type AXInitPipeline = u32;
pub mod AX_INIT_RENDERER {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_INIT_RENDERER_32KHZ: Type = 0;
    pub const AX_INIT_RENDERER_48KHZ: Type = 1;
}
pub mod AX_INIT_PIPELINE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_INIT_PIPELINE_SINGLE: Type = 0;
    pub const AX_INIT_PIPELINE_FOUR_STAGE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXProfile {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXInitParams {
    pub renderer: AXInitRenderer,
    pub __unk198: [::core::ffi::c_char; 4usize],
    pub pipeline: AXInitPipeline,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXTransitionAudioBufferDevice {
    pub mode: AXDeviceMode,
    pub unk1: f32,
    pub unk2: u32,
    pub enabled: BOOL,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AXTransitionAudioBuffer {
    pub unk1: u32,
    pub unk2: u32,
    pub length: u32,
    pub loopPoint: u32,
    pub audioBuffer: *mut ::core::ffi::c_void,
    pub audioBufferLen: u32,
    pub tv: AXTransitionAudioBufferDevice,
    pub drc: AXTransitionAudioBufferDevice,
}
impl Default for AXTransitionAudioBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type AXVoiceFormat = u16;
pub type AXVoiceLoop = u16;
pub type AXVoiceSrcType = u32;
pub type AXVoiceState = u32;
pub type AXVoiceRenderer = u32;
pub type AXVoiceSrcRatioResult = i32;
pub type AXVoiceType = u32;
pub type AXVoiceCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type AXVoiceCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32, arg3: u32),
>;
pub mod AX_VOICE_FORMAT {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_FORMAT_ADPCM: Type = 0;
    pub const AX_VOICE_FORMAT_LPCM16: Type = 10;
    pub const AX_VOICE_FORMAT_LPCM8: Type = 25;
}
pub mod AX_VOICE_LOOP {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_LOOP_DISABLED: Type = 0;
    pub const AX_VOICE_LOOP_ENABLED: Type = 1;
}
pub mod AX_VOICE_RENDERER {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_RENDERER_DSP: Type = 0;
    pub const AX_VOICE_RENDERER_CPU: Type = 1;
    pub const AX_VOICE_RENDERER_AUTO: Type = 2;
}
pub mod AX_VOICE_RATIO_RESULT {
    pub type Type = ::core::ffi::c_int;
    pub const AX_VOICE_RATIO_RESULT_SUCCESS: Type = 0;
    pub const AX_VOICE_RATIO_RESULT_LESS_THAN_ZERO: Type = -1;
    pub const AX_VOICE_RATIO_RESULT_GREATER_THAN_SOMETHING: Type = -2;
}
pub mod AX_VOICE_SRC_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_SRC_TYPE_NONE: Type = 0;
    pub const AX_VOICE_SRC_TYPE_LINEAR: Type = 1;
    pub const AX_VOICE_SRC_TYPE_UNK0: Type = 2;
    pub const AX_VOICE_SRC_TYPE_UNK1: Type = 3;
    pub const AX_VOICE_SRC_TYPE_UNK2: Type = 4;
}
pub mod AX_VOICE_STATE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_STATE_STOPPED: Type = 0;
    pub const AX_VOICE_STATE_PLAYING: Type = 1;
}
pub mod AX_VOICE_TYPE {
    pub type Type = ::core::ffi::c_uint;
    pub const AX_VOICE_TYPE_UNKNOWN: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceLink {
    pub next: *mut AXVoice,
    pub prev: *mut AXVoice,
}
impl Default for AXVoiceLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoiceOffsets {
    pub dataType: AXVoiceFormat,
    pub loopingEnabled: AXVoiceLoop,
    pub loopOffset: u32,
    pub endOffset: u32,
    pub currentOffset: u32,
    pub data: *const ::core::ffi::c_void,
}
impl Default for AXVoiceOffsets {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AXVoice {
    pub index: u32,
    pub state: AXVoiceState,
    pub volume: u32,
    pub renderer: AXVoiceRenderer,
    pub link: AXVoiceLink,
    pub cbNext: *mut AXVoice,
    pub priority: u32,
    pub callback: AXVoiceCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub syncBits: u32,
    pub __unk199: [::core::ffi::c_char; 8usize],
    pub offsets: AXVoiceOffsets,
    pub callbackEx: AXVoiceCallbackExFn,
    pub callbackReason: u32,
    pub unk0: f32,
    pub unk1: f32,
}
impl Default for AXVoice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceDeviceBusMixData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceDeviceMixData {
    pub bus: [AXVoiceDeviceBusMixData; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceVeData {
    pub volume: u16,
    pub delta: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceAdpcmLoopData {
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceAdpcm {
    pub coefficients: [i16; 16usize],
    pub gain: u16,
    pub predScale: u16,
    pub prevSample: [i16; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AXVoiceSrc {
    pub ratio: u32,
    pub currentOffsetFrac: u16,
    pub lastSample: [i16; 4usize],
}
pub type GX2RAllocFunction = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: GX2RResourceFlags::Type,
        arg2: u32,
        arg3: u32,
    ) -> *mut ::core::ffi::c_void,
>;
pub type GX2RFreeFunction = ::core::option::Option<
    unsafe extern "C" fn(arg1: GX2RResourceFlags::Type, arg2: *mut ::core::ffi::c_void),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCRHIDReport {
    pub __unk200: [::core::ffi::c_char; 128usize],
}
impl Default for CCRHIDReport {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NTAGError = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGFormatSettings {
    pub version: u8,
    pub __unk201: [::core::ffi::c_char; 3usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk202: [::core::ffi::c_char; 28usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGNoftHeader {
    pub magic: u32,
    pub version: u8,
    pub writeCount: u16,
    pub unknown: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGInfoHeader {
    pub rwHeaderOffset: u16,
    pub rwSize: u16,
    pub roHeaderOffset: u16,
    pub roSize: u16,
    pub uid: NFCUid,
    pub formatVersion: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGAreaHeader {
    pub magic: u16,
    pub offset: u16,
    pub size: u16,
    pub __unk203: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGAreaInfo {
    pub data: *mut ::core::ffi::c_void,
    pub size: u16,
    pub __unk204: [::core::ffi::c_char; 2usize],
    pub makerCode: u32,
    pub identifyCode: u32,
    pub __unk205: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGAreaInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGData {
    pub uid: NFCUid,
    pub readOnly: u8,
    pub formatVersion: u8,
    pub __unk206: [::core::ffi::c_char; 3usize],
    pub rwInfo: NTAGAreaInfo,
    pub roInfo: NTAGAreaInfo,
    pub __unk207: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGInfoT2T {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub characterID: [u8; 3usize],
    pub numberingID: u16,
    pub figureType: u8,
    pub seriesID: u8,
    pub unknown: u32,
    pub applicationAreaWrites: u16,
    pub crcCounter: u16,
    pub crc: u32,
    pub fontRegion: u8,
    pub name: [u16; 10usize],
    pub mii: FFLStoreData,
    pub country: u8,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub accessID: u32,
    pub titleID: u64,
    pub reserved: [u8; 508usize],
}
impl Default for NTAGInfoT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGApplicationDataT2T {
    pub size: u16,
    pub data: [u8; 216usize],
}
impl Default for NTAGApplicationDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T {
    pub uid: [u8; 9usize],
    pub internal: u8,
    pub lockBytes: [u8; 2usize],
    pub capabilityContainer: [u8; 4usize],
    pub section0: NTAGRawDataT2T__bindgen_ty_1,
    pub section1: NTAGRawDataT2T__bindgen_ty_2,
    pub section2: NTAGRawDataT2T__bindgen_ty_3,
    pub applicationData: [u8; 216usize],
    pub dynamicLock: [u8; 3usize],
    pub reserved0: u8,
    pub cfg0: [u8; 4usize],
    pub cfg1: [u8; 4usize],
    pub pwd: [u8; 4usize],
    pub pack: [u8; 2usize],
    pub reserved1: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_1 {
    pub magic: u8,
    pub writes: u16,
    pub figureVersion: u8,
    pub flags: u8,
    pub country: u8,
    pub crcCounter: u16,
    pub setupDate: u16,
    pub lastWriteDate: u16,
    pub crc: u32,
    pub name: [u16; 10usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_2 {
    pub tagHmac: [u8; 32usize],
    pub characterID: [u8; 3usize],
    pub figureType: u8,
    pub numberingID: u16,
    pub seriesID: u8,
    pub formatVersion: u8,
    pub unknown: u32,
    pub keygenSalt: [u8; 32usize],
    pub dataHmac: [u8; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataT2T__bindgen_ty_3 {
    pub mii: FFLStoreData,
    pub titleID: u64,
    pub applicationAreaWrites: u16,
    pub accessID: u32,
    pub reserved: [u8; 34usize],
}
impl Default for NTAGRawDataT2T__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for NTAGRawDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGRawDataContainerT2T {
    pub size: u16,
    pub data: NTAGRawDataT2T,
}
impl Default for NTAGRawDataContainerT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NTAGDataT2T {
    pub tagInfo: NFCTagInfo,
    pub formatVersion: u8,
    pub info: NTAGInfoT2T,
    pub appData: NTAGApplicationDataT2T,
    pub raw: NTAGRawDataContainerT2T,
    pub __unk208: [::core::ffi::c_char; 32usize],
}
impl Default for NTAGDataT2T {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NTAGCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        data: *mut NTAGData,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        data: *mut NTAGDataT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub type NTAGReadT2TRawDataCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        chan: VPADChan::Type,
        error: NTAGError,
        tagInfo: *mut NFCTagInfo,
        rawData: *mut NTAGRawDataContainerT2T,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
pub mod AVMDrcScanMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_0: Type = 0;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_1: Type = 1;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_3: Type = 3;
    pub const AVM_DRC_SCAN_MODE_UNKNOWN_255: Type = 255;
}
pub mod AVMDrcMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_MODE_NONE: Type = 0;
    pub const AVM_DRC_MODE_SINGLE: Type = 1;
    pub const AVM_DRC_MODE_DOUBLE: Type = 2;
}
pub mod AVMDrcSystemAudioMode {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_0: Type = 0;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_UNKNOWN_1: Type = 1;
    pub const AVM_DRC_SYSTEM_AUDIO_MODE_SURROUND: Type = 2;
}
pub mod AVMTvAspectRatio {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_ASPECT_RATIO_4_3: Type = 0;
    pub const AVM_TV_ASPECT_RATIO_16_9: Type = 1;
}
pub mod AVMTvResolution {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_RESOLUTION_576I: Type = 1;
    pub const AVM_TV_RESOLUTION_480I: Type = 2;
    pub const AVM_TV_RESOLUTION_480P: Type = 3;
    pub const AVM_TV_RESOLUTION_720P: Type = 4;
    pub const AVM_TV_RESOLUTION_720P_3D: Type = 5;
    pub const AVM_TV_RESOLUTION_1080I: Type = 6;
    pub const AVM_TV_RESOLUTION_1080P: Type = 7;
    pub const AVM_TV_RESOLUTION_480I_PAL60: Type = 10;
    pub const AVM_TV_RESOLUTION_576P: Type = 11;
    pub const AVM_TV_RESOLUTION_720P_50HZ: Type = 12;
    pub const AVM_TV_RESOLUTION_1080I_50HZ: Type = 13;
    pub const AVM_TV_RESOLUTION_1080P_50HZ: Type = 14;
}
pub mod AVMTvVideoRegion {
    pub type Type = ::core::ffi::c_uint;
    pub const AVM_TV_VIDEO_REGION_NTSC: Type = 1;
    pub const AVM_TV_VIDEO_REGION_PAL: Type = 2;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsDeviceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUsb: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubclass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsConfigDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub bMaxPower: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsInterfaceDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsSetupPacket {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
}
pub mod UHSStatus {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_STATUS_OK: Type = 0;
    pub const UHS_STATUS_HANDLE_INVALID_ARGS: Type = 4292804605;
    pub const UHS_STATUS_HANDLE_INVALID_STATE: Type = 4292804604;
}
pub mod UHSHandleState {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_HANDLE_STATE_INIT: Type = 0;
    pub const UHS_HANDLE_STATE_OPENING: Type = 1;
    pub const UHS_HANDLE_STATE_OPENED: Type = 2;
    pub const UHS_HANDLE_STATE_CLOSING: Type = 3;
    pub const UHS_HANDLE_STATE_CLOSED: Type = 4;
    pub const UHS_HANDLE_STATE_ERROR: Type = 5;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsConfig {
    pub controller_num: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub buffer_size: u32,
}
impl Default for UhsConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsHandle {
    pub state: UHSHandleState::Type,
    pub ipc_buffer: *mut ::core::ffi::c_void,
    pub __unk209: [::core::ffi::c_char; 4usize],
    pub handle: u32,
    pub config: *mut UhsConfig,
    pub __unk210: [::core::ffi::c_char; 4usize],
}
impl Default for UhsHandle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsInterfaceFilter {
    pub match_params: u16,
    pub vid: u16,
    pub pid: u16,
    pub __unk211: [::core::ffi::c_char; 4usize],
    pub dev_class: u8,
    pub dev_subclass: u8,
    pub dev_protocol: u8,
    pub if_class: u8,
    pub if_subclass: u8,
    pub if_protocol: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UhsEndpointDescriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
    pub __unk212: [::core::ffi::c_char; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UhsInterfaceProfile {
    pub if_handle: u32,
    pub __unk213: [::core::ffi::c_char; 36usize],
    pub dev_desc: UhsDeviceDescriptor,
    pub cfg_desc: UhsConfigDescriptor,
    pub if_desc: UhsInterfaceDescriptor,
    pub in_endpoints: [UhsEndpointDescriptor; 16usize],
    pub out_endpoints: [UhsEndpointDescriptor; 16usize],
}
impl Default for UhsInterfaceProfile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod UHSAdminDevType {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_ADMIN_DEV_RESET: Type = 1;
    pub const UHS_ADMIN_DEV_FREEZE: Type = 2;
    pub const UHS_ADMIN_DEV_SUSPEND: Type = 3;
    pub const UHS_ADMIN_DEV_RESUME: Type = 4;
    pub const UHS_ADMIN_DEV_DESTROY: Type = 5;
}
pub mod UHSAdminEpType {
    pub type Type = ::core::ffi::c_uint;
    pub const UHS_ADMIN_EP_ENABLE: Type = 1;
    pub const UHS_ADMIN_EP_DISABLE: Type = 2;
    pub const UHS_ADMIN_EP_CANCEL: Type = 3;
    pub const UHS_ADMIN_EP_CANCEL_RESET: Type = 4;
}
pub type UHSDrvRegCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, profile: *mut UhsInterfaceProfile),
>;
pub type UhsAcquireInterfaceCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void, arg1: i32, arg2: i32),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::core::ffi::c_char,
    pub h_aliases: *mut *mut ::core::ffi::c_char,
    pub h_addrtype: ::core::ffi::c_int,
    pub h_length: ::core::ffi::c_int,
    pub h_addr_list: *mut *mut ::core::ffi::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::core::ffi::c_char,
    pub s_aliases: *mut *mut ::core::ffi::c_char,
    pub s_port: ::core::ffi::c_int,
    pub s_proto: *mut ::core::ffi::c_char,
}
impl Default for servent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::core::ffi::c_int,
    pub ai_family: ::core::ffi::c_int,
    pub ai_socktype: ::core::ffi::c_int,
    pub ai_protocol: ::core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::core::ffi::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSSemaphore {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk214: [::core::ffi::c_char; 4usize],
    pub count: i32,
    pub queue: OSThreadQueue,
}
impl Default for OSSemaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type OSFiberEntryFn = ::core::option::Option<unsafe extern "C" fn()>;
pub type OSFiberExEntryFn =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32, arg3: u32, arg4: u32)>;
pub type OSDynLoad_Module = *mut ::core::ffi::c_void;
pub mod OSDynLoad_Error {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_OK: Type = 0;
    pub const OS_DYNLOAD_OUT_OF_MEMORY: Type = 3134259202;
    pub const OS_DYNLOAD_INVALID_NOTIFY_PTR: Type = 3134259214;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME_PTR: Type = 3134259215;
    pub const OS_DYNLOAD_INVALID_MODULE_NAME: Type = 3134259216;
    pub const OS_DYNLOAD_INVALID_ACQUIRE_PTR: Type = 3134259217;
    pub const OS_DYNLOAD_EMPTY_MODULE_NAME: Type = 3134259218;
    pub const OS_DYNLOAD_INVALID_ALLOCATOR_PTR: Type = 3134259223;
    pub const OS_DYNLOAD_OUT_OF_SYSTEM_MEMORY: Type = 3134259247;
    pub const OS_DYNLOAD_TLS_ALLOCATOR_LOCKED: Type = 3134259249;
    pub const OS_DYNLOAD_MODULE_NOT_FOUND: Type = 4294967290;
}
pub type OSDynLoadAllocFn = ::core::option::Option<
    unsafe extern "C" fn(
        size: i32,
        align: i32,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type,
>;
pub type OSDynLoadFreeFn =
    ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void)>;
pub mod OSDynLoad_ExportType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_EXPORT_FUNC: Type = 0;
    pub const OS_DYNLOAD_EXPORT_DATA: Type = 1;
}
pub mod OSDynLoad_EntryReason {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_LOADED: Type = 1;
    pub const OS_DYNLOAD_UNLOADED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_NotifyData {
    pub name: *mut ::core::ffi::c_char,
    pub textAddr: u32,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: u32,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub readAddr: u32,
    pub readOffset: u32,
    pub readSize: u32,
}
impl Default for OSDynLoad_NotifyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSDynLoad_LoaderHeapStatistics {
    pub codeHeapUsed: u32,
    pub unk_0x04: u32,
    pub codeHeapFree: u32,
    pub codeHeapLargestFree: u32,
    pub dataHeapUsed: u32,
    pub unk_0x14: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_LoaderUserFileInfo {
    pub size: u32,
    pub magic: u32,
    pub pathStringLength: u32,
    pub pathString: *mut ::core::ffi::c_char,
    pub fileInfoFlags: u32,
    pub tlsModuleIndex: i16,
    pub tlsAlignShift: i16,
    pub tlsAddressStart: *mut ::core::ffi::c_void,
    pub tlsSectionSize: u32,
    pub shstrndx: u32,
    pub titleLocation: u32,
    pub __unk215: [::core::ffi::c_char; 56usize],
}
impl Default for OSDynLoad_LoaderUserFileInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OSDynLoad_LoaderSectionInfo {
    pub type_: u32,
    pub flags: u32,
    pub address: *mut ::core::ffi::c_void,
    pub __bindgen_anon_1: OSDynLoad_LoaderSectionInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSDynLoad_LoaderSectionInfo__bindgen_ty_1 {
    pub size: u32,
    pub name: u32,
}
impl Default for OSDynLoad_LoaderSectionInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for OSDynLoad_LoaderSectionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSDynLoad_InternalData {
    pub handle: u32,
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub moduleName: *mut ::core::ffi::c_char,
    pub moduleNameLen: u32,
    pub sectionInfoCount: u32,
    pub sectionInfo: *mut OSDynLoad_LoaderSectionInfo,
    pub importModules: *mut *mut OSDynLoad_InternalData,
    pub importModuleCount: u32,
    pub userFileInfoSize: u32,
    pub userFileInfo: *mut OSDynLoad_LoaderUserFileInfo,
    pub notifyData: *mut OSDynLoad_NotifyData,
    pub entryPoint: *mut ::core::ffi::c_void,
    pub dataSectionSize: u32,
    pub dataSection: *mut ::core::ffi::c_void,
    pub loadSectionSize: u32,
    pub loadSection: *mut ::core::ffi::c_void,
    pub dynLoadFreeFn: OSDynLoadFreeFn,
    pub codeExports: *mut ::core::ffi::c_void,
    pub numCodeExports: u32,
    pub dataExports: *mut ::core::ffi::c_void,
    pub numDataExports: u32,
    pub next: *mut OSDynLoad_InternalData,
    pub __unk216: [::core::ffi::c_char; 60usize],
}
impl Default for OSDynLoad_InternalData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSDynLoad_NotifyReason {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_DYNLOAD_NOTIFY_UNLOADED: Type = 0;
    pub const OS_DYNLOAD_NOTIFY_LOADED: Type = 1;
}
pub type OSDynLoadNotifyFunc = ::core::option::Option<
    unsafe extern "C" fn(
        module: OSDynLoad_Module,
        userContext: *mut ::core::ffi::c_void,
        notifyReason: OSDynLoad_NotifyReason::Type,
        infos: *mut OSDynLoad_NotifyData,
    ),
>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct OSStopwatch {
    pub lock: OSSpinLock,
    pub name: *const ::core::ffi::c_char,
    pub hitCount: u32,
    pub totalTime: OSTime,
    pub minTime: OSTime,
    pub maxTime: OSTime,
    pub startTime: OSTime,
    pub running: BOOL,
    pub __unk217: [::core::ffi::c_char; 4usize],
}
impl Default for OSStopwatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutexLink {
    pub next: *mut OSMutex,
    pub prev: *mut OSMutex,
}
impl Default for OSMutexLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSMutex {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk218: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
    pub owner: *mut OSThread,
    pub count: i32,
    pub link: OSMutexLink,
}
impl Default for OSMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPoolFIFO {
    pub pushIndex: i32,
    pub popIndex: i32,
    pub count: i32,
    pub maxCount: i32,
    pub messages: *mut *mut ::core::ffi::c_void,
}
impl Default for IPCBufPoolFIFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IPCBufPoolAttributes {
    pub messageSize: u32,
    pub poolSize: u32,
    pub numMessages: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPCBufPool {
    pub magic: u32,
    pub buffer: *mut ::core::ffi::c_void,
    pub size: u32,
    pub unk0x0C: u32,
    pub unk0x10: u32,
    pub messageSize0x14: u32,
    pub messageSize0x18: u32,
    pub messageCount: u32,
    pub messages: *mut ::core::ffi::c_void,
    pub messageIndexSize: *mut u32,
    pub fifo: IPCBufPoolFIFO,
    pub mutex: OSMutex,
    pub __unk219: [::core::ffi::c_char; 4usize],
}
impl Default for IPCBufPool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSRendezvous {
    pub core: [u32; 3usize],
    pub __unk220: [::core::ffi::c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSFastCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk221: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
impl Default for OSFastCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSICICommand {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_ICI_COMMAND_INVALID_IC_RANGE: Type = 1;
    pub const OS_ICI_COMMAND_RESCHEDULE_CORE: Type = 2;
    pub const OS_ICI_COMMAND_HALT_CORE: Type = 3;
    pub const OS_ICI_COMMAND_PROC_EXIT: Type = 4;
    pub const OS_ICI_COMMAND_SET_DABR: Type = 5;
    pub const OS_ICI_COMMAND_PROC_SCHED: Type = 6;
    pub const OS_ICI_COMMAND_FAST_BG_EXIT: Type = 7;
    pub const OS_ICI_COMMAND_IOP_SHELL_CORE_TRACE: Type = 8;
    pub const OS_ICI_COMMAND_SYSTEM_FATAL: Type = 9;
    pub const OS_ICI_COMMAND_SET_IABR: Type = 10;
    pub const OS_ICI_COMMAND_PANIC_0X15: Type = 11;
    pub const OS_ICI_COMMAND_PROC_KILL: Type = 12;
    pub const OS_ICI_COMMAND_PROC_CRASH: Type = 13;
    pub const OS_ICI_COMMAND_UNKNOWN: Type = 14;
    pub const OS_ICI_COMMAND_OVERLAY_ARENA: Type = 15;
}
pub type OSExceptionCallbackExFn = ::core::option::Option<
    unsafe extern "C" fn(
        exceptionType: OSExceptionType::Type,
        interruptedContext: *mut OSContext,
        cbContext: *mut OSContext,
    ),
>;
pub type KernelTimerCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        exception: OSExceptionType::Type,
        interruptedContext: *mut OSContext,
        currentContext: *mut OSContext,
    ),
>;
pub type KernelTimerHandle = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSExceptionChainInfo {
    pub callback: OSExceptionCallbackExFn,
    pub stack: *mut ::core::ffi::c_void,
    pub context: *mut OSContext,
}
impl Default for OSExceptionChainInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0 {
    pub upid: i32,
    pub rampid: i32,
    pub appFlags: u32,
    pub dataAreaStart: *mut ::core::ffi::c_void,
    pub dataAreaEnd: *mut ::core::ffi::c_void,
    pub physDataAreaStart: *mut ::core::ffi::c_void,
    pub physDataAreaEnd: *mut ::core::ffi::c_void,
    pub physAvailStart: *mut ::core::ffi::c_void,
    pub physAvailEnd: *mut ::core::ffi::c_void,
    pub physCodeGenStart: *mut ::core::ffi::c_void,
    pub physCodeGenEnd: *mut ::core::ffi::c_void,
    pub sdaBase: *mut ::core::ffi::c_void,
    pub sda2Base: *mut ::core::ffi::c_void,
    pub systemHeapSize: u32,
    pub stackEnd0: *mut ::core::ffi::c_void,
    pub stackEnd1: *mut ::core::ffi::c_void,
    pub stackEnd2: *mut ::core::ffi::c_void,
    pub stackBase0: *mut ::core::ffi::c_void,
    pub stackBase1: *mut ::core::ffi::c_void,
    pub stackBase2: *mut ::core::ffi::c_void,
    pub exceptionStackEnd0: *mut ::core::ffi::c_void,
    pub exceptionStackEnd1: *mut ::core::ffi::c_void,
    pub exceptionStackEnd2: *mut ::core::ffi::c_void,
    pub exceptionStackBase0: *mut ::core::ffi::c_void,
    pub exceptionStackBase1: *mut ::core::ffi::c_void,
    pub exceptionStackBase2: *mut ::core::ffi::c_void,
    pub lockedCacheBase0: *mut ::core::ffi::c_void,
    pub lockedCacheBase1: *mut ::core::ffi::c_void,
    pub lockedCacheBase2: *mut ::core::ffi::c_void,
    pub coreinit: KernelInfo0_CoreinitInfo,
    pub unk0x9C: u32,
    pub titleId: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo0_CoreinitInfo {
    pub loaderHandle: *mut ::core::ffi::c_void,
    pub textAddr: *mut ::core::ffi::c_void,
    pub textOffset: u32,
    pub textSize: u32,
    pub dataAddr: *mut ::core::ffi::c_void,
    pub dataOffset: u32,
    pub dataSize: u32,
    pub loadAddr: *mut ::core::ffi::c_void,
    pub loadOffset: u32,
    pub loadSize: u32,
}
impl Default for KernelInfo0_CoreinitInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for KernelInfo0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelInfo6 {
    pub osTitleId: u64,
    pub unk0x08: u32,
    pub __unk222: [::core::ffi::c_char; 252usize],
}
impl Default for KernelInfo6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IMEventMask = u32;
pub mod IMPadType {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_PAD_TYPE_NONE: Type = 0;
    pub const IM_PAD_TYPE_WII_REMOTE: Type = 1;
    pub const IM_PAD_TYPE_WIIU_PRO_CONTROLLER: Type = 2;
    pub const IM_PAD_TYPE_WII_REMOTE_EXTENSION: Type = 3;
    pub const IM_PAD_TYPE_WIIU_GAMEPAD: Type = 4;
}
pub mod IMDeviceState {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_DEVICE_STATE_CLEAR: Type = 0;
    pub const IM_DEVICE_STATE_INACTIVE: Type = 1;
    pub const IM_DEVICE_STATE_ACTIVE: Type = 2;
    pub const IM_DEVICE_STATE_HOME: Type = 3;
    pub const IM_DEVICE_STATE_POWER: Type = 4;
    pub const IM_DEVICE_STATE_SYNC: Type = 5;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMRequest {
    pub args: [u8; 128usize],
    pub ioctlVecs: [IOSVec; 2usize],
    pub handle: IOSHandle,
    pub request: i32,
    pub asyncCallback: IOSAsyncCallbackFn,
    pub asyncCallbackContext: *mut ::core::ffi::c_void,
    pub copySrc: *mut ::core::ffi::c_void,
    pub copyDst: *mut ::core::ffi::c_void,
    pub copySize: u32,
}
impl Default for IMRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMHomeButtonParams {
    pub type_: IMPadType::Type,
    pub index: i32,
}
impl Default for IMHomeButtonParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMParameters {
    pub resetEnabled: u32,
    pub dimEnabled: u32,
    pub dimPeriod: u32,
    pub apdEnabled: u32,
    pub apdPeriod: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMDeviceStateEx {
    pub state: IMDeviceState::Type,
    pub params: IMHomeButtonParams,
}
impl Default for IMDeviceStateEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod IMParameter {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_PARAMETER_INACTIVE_SECONDS: Type = 0;
    pub const IM_PARAMETER_DIM_ENABLED: Type = 1;
    pub const IM_PARAMETER_DIM_PERIOD: Type = 2;
    pub const IM_PARAMETER_APD_ENABLED: Type = 3;
    pub const IM_PARAMETER_APD_PERIOD: Type = 4;
    pub const IM_PARAMETER_RESET_ENABLE: Type = 5;
    pub const IM_PARAMETER_RESET_SECONDS: Type = 6;
    pub const IM_PARAMETER_POWER_OFF_ENABLE: Type = 7;
    pub const IM_PARAMETER_APD_OCCURED: Type = 8;
    pub const IM_PARAMETER_DIM_ENABLE_TV: Type = 9;
    pub const IM_PARAMETER_DIM_ENABLE_DRC: Type = 10;
    pub const IM_PARAMETER_MAX: Type = 11;
}
pub mod IMTimer {
    pub type Type = ::core::ffi::c_uint;
    pub const IM_TIMER_DIM: Type = 0;
    pub const IM_TIMER_APD: Type = 1;
}
pub mod IMEvent {
    pub type Type = ::core::ffi::c_int;
    pub const IM_EVENT_ACTIVE: Type = 1;
    pub const IM_EVENT_INACTIVE: Type = 2;
    pub const IM_EVENT_DIM: Type = 4;
    pub const IM_EVENT_UNDIM: Type = 8;
    pub const IM_EVENT_APD: Type = 16;
    pub const IM_EVENT_POWER: Type = 32;
    pub const IM_EVENT_HOME: Type = 64;
    pub const IM_EVENT_SYNC: Type = 128;
    pub const IM_EVENT_RESET: Type = 256;
    pub const IM_EVENT_CANCELLED: Type = -2147483648;
}
pub type IMError = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMBlockHeapTracking {
    pub __unk223: [::core::ffi::c_char; 8usize],
    pub blocks: *mut MEMBlockHeapBlock,
    pub blockCount: u32,
}
impl Default for MEMBlockHeapTracking {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMBlockHeapBlock {
    pub start: *mut ::core::ffi::c_void,
    pub end: *mut ::core::ffi::c_void,
    pub isFree: BOOL,
    pub prev: *mut MEMBlockHeapBlock,
    pub next: *mut MEMBlockHeapBlock,
}
impl Default for MEMBlockHeapBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct MEMBlockHeap {
    pub _bindgen_opaque_blob: [u8; 116usize],
}
impl Default for MEMBlockHeap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSSavedFrameType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SAVED_FRAME_A: Type = 0;
    pub const OS_SAVED_FRAME_B: Type = 1;
}
pub mod OSSavedFrameScreen {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SAVED_FRAME_SCREEN_TV: Type = 2;
    pub const OS_SAVED_FRAME_SCREEN_DRC: Type = 4;
}
pub mod OSInterruptType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_INTERRUPT_TYPE_ERROR: Type = 0;
    pub const OS_INTERRUPT_TYPE_DSP: Type = 1;
    pub const OS_INTERRUPT_TYPE_GPU7: Type = 2;
    pub const OS_INTERRUPT_TYPE_GPIPPC: Type = 3;
    pub const OS_INTERRUPT_TYPE_PRIMARYI2C: Type = 4;
    pub const OS_INTERRUPT_TYPE_DSPAI: Type = 5;
    pub const OS_INTERRUPT_TYPE_DSPAI2: Type = 6;
    pub const OS_INTERRUPT_TYPE_DSPACC: Type = 7;
    pub const OS_INTERRUPT_TYPE_DSPDSP: Type = 8;
    pub const OS_INTERRUPT_TYPE_IPCPPC0: Type = 9;
    pub const OS_INTERRUPT_TYPE_IPCPPC1: Type = 10;
    pub const OS_INTERRUPT_TYPE_IPCPPC2: Type = 11;
    pub const OS_INTERRUPT_TYPE_AHB: Type = 12;
}
pub type OSUserInterruptHandler = ::core::option::Option<
    unsafe extern "C" fn(type_: OSInterruptType::Type, interruptedContext: *mut OSContext),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OSCondition {
    pub tag: u32,
    pub name: *const ::core::ffi::c_char,
    pub __unk224: [::core::ffi::c_char; 4usize],
    pub queue: OSThreadQueue,
}
impl Default for OSCondition {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod COSReportLevel {
    pub type Type = ::core::ffi::c_uint;
    pub const COS_REPORT_LEVEL_ERROR: Type = 0;
    pub const COS_REPORT_LEVEL_WARN: Type = 1;
    pub const COS_REPORT_LEVEL_INFO: Type = 2;
    pub const COS_REPORT_LEVEL_VERBOSE: Type = 3;
}
pub mod COSReportModule {
    pub type Type = ::core::ffi::c_uint;
    pub const COS_REPORT_MODULE_UNKNOWN_0: Type = 0;
    pub const COS_REPORT_MODULE_UNKNOWN_1: Type = 1;
    pub const COS_REPORT_MODULE_UNKNOWN_2: Type = 2;
    pub const COS_REPORT_MODULE_UNKNOWN_5: Type = 5;
}
pub type UCError = i32;
pub type UCHandle = i32;
pub mod UCCommand {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_CMD_READ_SYS_CONFIG: Type = 48;
    pub const UC_CMD_WRITE_SYS_CONFIG: Type = 49;
    pub const UC_CMD_DELETE_SYS_CONFIG: Type = 50;
    pub const UC_CMD_QUERY_SYS_CONFIG: Type = 51;
    pub const UC_CMD_LIST_SYS_CONFIG: Type = 52;
}
pub mod UCDataType {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_DATATYPE_UNDEFINED: Type = 0;
    pub const UC_DATATYPE_UNSIGNED_BYTE: Type = 1;
    pub const UC_DATATYPE_UNSIGNED_SHORT: Type = 2;
    pub const UC_DATATYPE_UNSIGNED_INT: Type = 3;
    pub const UC_DATATYPE_SIGNED_INT: Type = 4;
    pub const UC_DATATYPE_FLOAT: Type = 5;
    pub const UC_DATATYPE_STRING: Type = 6;
    pub const UC_DATATYPE_HEXBINARY: Type = 7;
    pub const UC_DATATYPE_COMPLEX: Type = 8;
    pub const UC_DATATYPE_INVALID: Type = 255;
}
pub mod UCErrors {
    pub type Type = ::core::ffi::c_int;
    pub const UC_ERROR_OK: Type = 0;
    pub const UC_ERROR_ERROR: Type = -1;
    pub const UC_ERROR_OTHER: Type = -2097153;
    pub const UC_ERROR_SYSTEM: Type = -2097154;
    pub const UC_ERROR_ALLOC: Type = -2097155;
    pub const UC_ERROR_OPCODE: Type = -2097156;
    pub const UC_ERROR_INVALID_PARAM: Type = -2097157;
    pub const UC_ERROR_INVALID_TYPE: Type = -2097158;
    pub const UC_ERROR_UNSUPPORTED: Type = -2097159;
    pub const UC_ERROR_NON_LEAF_NODE: Type = -2097160;
    pub const UC_ERROR_KEY_NOT_FOUND: Type = -2097161;
    pub const UC_ERROR_MODIFY: Type = -2097162;
    pub const UC_ERROR_STRING_TOO_LONG: Type = -2097163;
    pub const UC_ERROR_ROOT_KEYS_DIFFER: Type = -2097164;
    pub const UC_ERROR_INVALID_LOCATION: Type = -2097165;
    pub const UC_ERROR_BAD_COMMENT: Type = -2097166;
    pub const UC_ERROR_READ_ACCESS: Type = -2097167;
    pub const UC_ERROR_WRITE_ACCESS: Type = -2097168;
    pub const UC_ERROR_CREATE_ACCESS: Type = -2097169;
    pub const UC_ERROR_FILE_SYS_NAME: Type = -2097170;
    pub const UC_ERROR_FILE_SYS_INIT: Type = -2097171;
    pub const UC_ERROR_FILE_SYS_MOUNT: Type = -2097172;
    pub const UC_ERROR_FILE_OPEN: Type = -2097173;
    pub const UC_ERROR_FILE_STAT: Type = -2097174;
    pub const UC_ERROR_FILE_READ: Type = -2097175;
    pub const UC_ERROR_FILE_WRITE: Type = -2097176;
    pub const UC_ERROR_FILE_TOO_BIG: Type = -2097177;
    pub const UC_ERROR_FILE_REMOVE: Type = -2097178;
    pub const UC_ERROR_FILE_RENAME: Type = -2097179;
    pub const UC_ERROR_FILE_CLOSE: Type = -2097180;
    pub const UC_ERROR_FILE_SEEK: Type = -2097181;
    pub const UC_ERROR_FILE_CONFIRM: Type = -2097182;
    pub const UC_ERROR_FILE_BACKUP: Type = -2097183;
    pub const UC_ERROR_MALFORMED_XML: Type = -2097184;
    pub const UC_ERROR_VERSION: Type = -2097185;
    pub const UC_ERROR_NO_IPC_BUFFERS: Type = -2097186;
    pub const UC_ERROR_FILE_LOCK_NEEDED: Type = -2097188;
    pub const UC_ERROR_SYS_PROT: Type = -2097192;
}
pub mod UCFileSys {
    pub type Type = ::core::ffi::c_uint;
    pub const UC_FILE_SYS_INVALID: Type = 0;
    pub const UC_FILE_SYS_SYS: Type = 1;
    pub const UC_FILE_SYS_SLC: Type = 2;
    pub const UC_FILE_SYS_RAM: Type = 3;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCSysConfig {
    pub name: [::core::ffi::c_char; 64usize],
    pub access: u32,
    pub dataType: UCDataType::Type,
    pub error: UCError,
    pub dataSize: u32,
    pub data: *mut ::core::ffi::c_void,
}
impl Default for UCSysConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type UCAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: UCError,
        command: UCCommand::Type,
        count: u32,
        settings: *mut UCSysConfig,
        context: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct UCAsyncParams {
    pub callback: UCAsyncCallbackFn,
    pub context: *mut ::core::ffi::c_void,
    pub command: UCCommand::Type,
    pub unk0x0C: u32,
    pub count: u32,
    pub settings: *mut UCSysConfig,
    pub vecs: *mut IOSVec,
}
impl Default for UCAsyncParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMUnitHeapFreeBlock {
    pub next: *mut MEMUnitHeapFreeBlock,
}
impl Default for MEMUnitHeapFreeBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct MEMUnitHeap {
    pub _bindgen_opaque_blob: [u8; 72usize],
}
impl Default for MEMUnitHeap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod SmdLockType {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_LOCK_TYPE_MUTEX: Type = 0;
    pub const SMD_LOCK_TYPE_DISABLE_INTERRUPTS: Type = 1;
    pub const SMD_LOCK_TYPE_NONE: Type = 2;
}
pub mod SmdPpcState {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_PPC_STATE_INVALID: Type = 0;
    pub const SMD_PPC_STATE_INITIALIZED: Type = 1;
    pub const SMD_PPC_STATE_CLOSED: Type = 2;
    pub const SMD_PPC_STATE_OPENED: Type = 3;
}
pub mod SmdInterfaceState {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_INTERFACE_STATE_OPENED: Type = 8738;
    pub const SMD_INTERFACE_STATE_CLOSED: Type = 13107;
}
pub mod SmdElementType {
    pub type Type = ::core::ffi::c_uint;
    pub const SMD_ELEMENT_TYPE_MESSAGE: Type = 0;
    pub const SMD_ELEMENT_TYPE_VECTOR_SPEC: Type = 1;
    pub const SMD_ELEMENT_TYPE_VECTOR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVectorSpec {
    pub ptr: *mut ::core::ffi::c_void,
    pub size: u32,
}
impl Default for SmdVectorSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdVector {
    pub command: u32,
    pub count: i32,
    pub vecs: [SmdVectorSpec; 4usize],
}
impl Default for SmdVector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdElement {
    pub type_: SmdElementType::Type,
    pub size: u32,
    pub __bindgen_anon_1: SmdElement__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdElement__bindgen_ty_1 {
    pub data: [u8; 248usize],
    pub spec: SmdVector,
    pub vectorPaddr: u32,
}
impl Default for SmdElement__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SmdElement {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SmdReceiveData {
    pub type_: SmdElementType::Type,
    pub size: u32,
    pub __bindgen_anon_1: SmdReceiveData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SmdReceiveData__bindgen_ty_1 {
    pub message: [u8; 128usize],
    pub spec: SmdVector,
    pub vector: *mut SmdVector,
}
impl Default for SmdReceiveData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SmdReceiveData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdInterface {
    pub state: SmdInterfaceState::Type,
    pub __unk225: [::core::ffi::c_char; 124usize],
    pub elementCount: u32,
    pub __unk226: [::core::ffi::c_char; 124usize],
    pub readOffset: i32,
    pub __unk227: [::core::ffi::c_char; 124usize],
    pub writeOffset: i32,
    pub __unk228: [::core::ffi::c_char; 124usize],
    pub bufPaddr: u32,
    pub __unk229: [::core::ffi::c_char; 124usize],
}
impl Default for SmdInterface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdCtrlTable {
    pub name: [::core::ffi::c_char; 16usize],
    pub reusedCount: u32,
    pub __unk230: [::core::ffi::c_char; 108usize],
    pub iopInterface: SmdInterface,
    pub __unk231: [::core::ffi::c_char; 64usize],
    pub ppcInterface: SmdInterface,
    pub __unk232: [::core::ffi::c_char; 64usize],
}
impl Default for SmdCtrlTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpcCtrlTableVectors {
    pub ctrlTable: *mut SmdCtrlTable,
    pub ctrlTableSize: u32,
    pub writeBuf: *mut SmdElement,
    pub writeBufSize: u32,
    pub readBuf: *mut SmdElement,
    pub readBufSize: u32,
}
impl Default for SmdPpcCtrlTableVectors {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdPpc {
    pub self_: *mut SmdPpc,
    pub ctrlTable: *mut SmdCtrlTable,
    pub lockType: SmdLockType::Type,
    pub mutex: OSMutex,
    pub messageCount: u32,
    pub writeBuf: *mut SmdElement,
    pub readBuf: *mut SmdElement,
    pub state: SmdPpcState::Type,
    pub __unk233: [::core::ffi::c_char; 56usize],
}
impl Default for SmdPpc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmdSimpleBufPool {
    pub self_: *mut SmdSimpleBufPool,
    pub mutex: OSMutex,
    pub poolData: *mut ::core::ffi::c_void,
    pub poolDataSize: u32,
    pub lockType: SmdLockType::Type,
    pub allocSize: u32,
    pub realAllocSize: u32,
    pub maxAllocCount: u32,
    pub allocPoolStart: *mut ::core::ffi::c_void,
    pub allocPoolEnd: *mut ::core::ffi::c_void,
    pub elementsIn: u32,
    pub freeErrorCount: u32,
    pub __unk234: [::core::ffi::c_char; 40usize],
}
impl Default for SmdSimpleBufPool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DisassemblyPrintFn =
    ::core::option::Option<unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, ...)>;
pub type DisassemblyFindSymbolFn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32,
>;
pub mod DisassemblePPCFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const DISASSEMBLE_PPC_FLAGS_NONE: Type = 0;
}
pub type MEMExpHeapBlockVisitor = ::core::option::Option<
    unsafe extern "C" fn(
        block: *mut ::core::ffi::c_void,
        heap: MEMHeapHandle,
        context: *mut ::core::ffi::c_void,
    ),
>;
pub mod MEMExpHeapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_EXP_HEAP_MODE_FIRST_FREE: Type = 0;
    pub const MEM_EXP_HEAP_MODE_NEAREST_SIZE: Type = 1;
}
pub mod MEMExpHeapDirection {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_EXP_HEAP_DIR_FROM_TOP: Type = 0;
    pub const MEM_EXP_HEAP_DIR_FROM_BOTTOM: Type = 1;
}
pub mod MEMExpHeapCheckFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_EXP_HEAP_CHECK_FLAGS_NONE: Type = 0;
    pub const MEM_EXP_HEAP_CHECK_FLAGS_LOG_ERRORS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMExpHeapBlock {
    pub attribs: u32,
    pub blockSize: u32,
    pub prev: *mut MEMExpHeapBlock,
    pub next: *mut MEMExpHeapBlock,
    pub tag: u16,
    pub __unk235: [::core::ffi::c_char; 2usize],
}
impl Default for MEMExpHeapBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMExpHeapBlockList {
    pub head: *mut MEMExpHeapBlock,
    pub tail: *mut MEMExpHeapBlock,
}
impl Default for MEMExpHeapBlockList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct MEMExpHeap {
    pub _bindgen_opaque_blob: [u8; 84usize],
}
impl Default for MEMExpHeap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BSPError = i32;
pub type BSPHardwareVersion = u32;
pub type BSPConsoleTypeRaw = u32;
pub mod BSPErrors {
    pub type Type = ::core::ffi::c_uint;
    pub const BSP_ERROR_OK: Type = 0;
    pub const BSP_ERROR_IOS_ERROR: Type = 64;
    pub const BSP_ERROR_RESPONSE_TOO_LARGE: Type = 128;
}
pub mod BSPHardwareVersions {
    pub type Type = ::core::ffi::c_uint;
    pub const BSP_HARDWARE_VERSION_UNKNOWN: Type = 0;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_1: Type = 1;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_ENG_SAMPLE_2: Type = 268435457;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_PROD_FOR_WII: Type = 269484033;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO: Type = 269484040;
    pub const BSP_HARDWARE_VERSION_HOLLYWOOD_CORTADO_ESPRESSO: Type = 269484044;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD: Type = 536870913;
    pub const BSP_HARDWARE_VERSION_BOLLYWOOD_PROD_FOR_WII: Type = 537919489;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_EV: Type = 554696720;
    pub const BSP_HARDWARE_VERSION_LATTE_A11_CAT: Type = 554696736;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_EV: Type = 555745296;
    pub const BSP_HARDWARE_VERSION_LATTE_A12_CAT: Type = 555745312;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_EV: Type = 571473936;
    pub const BSP_HARDWARE_VERSION_LATTE_A2X_CAT: Type = 571473952;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_EV: Type = 588251152;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAT: Type = 588251168;
    pub const BSP_HARDWARE_VERSION_LATTE_A3X_CAFE: Type = 588251176;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_EV: Type = 605028368;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAT: Type = 605028384;
    pub const BSP_HARDWARE_VERSION_LATTE_A4X_CAFE: Type = 605028392;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV: Type = 621805584;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_EV_Y: Type = 621805585;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAT: Type = 621805600;
    pub const BSP_HARDWARE_VERSION_LATTE_A5X_CAFE: Type = 621805608;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV: Type = 638582800;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_EV_Y: Type = 638582801;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAT: Type = 638582816;
    pub const BSP_HARDWARE_VERSION_LATTE_B1X_CAFE: Type = 638582824;
}
pub type MPTaskFunc = ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg2: u32) -> u32>;
pub mod MPTaskState {
    pub type Type = ::core::ffi::c_uint;
    pub const MP_TASK_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_STATE_READY: Type = 2;
    pub const MP_TASK_STATE_RUNNING: Type = 4;
    pub const MP_TASK_STATE_FINISHED: Type = 8;
}
pub mod MPTaskQueueState {
    pub type Type = ::core::ffi::c_uint;
    pub const MP_TASK_QUEUE_STATE_INITIALISED: Type = 1;
    pub const MP_TASK_QUEUE_STATE_READY: Type = 2;
    pub const MP_TASK_QUEUE_STATE_STOPPING: Type = 4;
    pub const MP_TASK_QUEUE_STATE_STOPPED: Type = 8;
    pub const MP_TASK_QUEUE_STATE_FINISHED: Type = 16;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskInfo {
    pub state: MPTaskState::Type,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
}
impl Default for MPTaskInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MPTask {
    pub self_: *mut MPTask,
    pub queue: *mut MPTaskQueue,
    pub state: MPTaskState::Type,
    pub func: MPTaskFunc,
    pub userArg1: u32,
    pub userArg2: u32,
    pub result: u32,
    pub coreID: u32,
    pub duration: OSTime,
    pub userData: *mut ::core::ffi::c_void,
}
impl Default for MPTask {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueueInfo {
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub tasksFinished: u32,
}
impl Default for MPTaskQueueInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MPTaskQueue {
    pub self_: *mut MPTaskQueue,
    pub state: MPTaskQueueState::Type,
    pub tasks: u32,
    pub tasksReady: u32,
    pub tasksRunning: u32,
    pub __unk236: [::core::ffi::c_char; 4usize],
    pub tasksFinished: u32,
    pub __unk237: [::core::ffi::c_char; 8usize],
    pub queueIndex: u32,
    pub __unk238: [::core::ffi::c_char; 8usize],
    pub queueSize: u32,
    pub __unk239: [::core::ffi::c_char; 4usize],
    pub queue: *mut *mut MPTask,
    pub queueMaxSize: u32,
    pub lock: OSSpinLock,
}
impl Default for MPTaskQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSMemoryMapMode {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MAP_MEMORY_INVALID: Type = 0;
    pub const OS_MAP_MEMORY_READ_ONLY: Type = 1;
    pub const OS_MAP_MEMORY_READ_WRITE: Type = 2;
    pub const OS_MAP_MEMORY_FREE: Type = 3;
    pub const OS_MAP_MEMORY_ALLOCATED: Type = 4;
}
pub type FSACommand = u32;
pub type FSAIpcRequestType = u16;
pub type FSAClientHandle = IOSHandle;
pub type FSAFileHandle = u32;
pub type FSADirectoryHandle = u32;
pub type FSAEntryNum = u32;
pub type FSADirectoryEntry = FSDirectoryEntry;
pub type FSAStat = FSStat;
pub type FSAFilePosition = u32;
pub type FSAVolumeInfo = FSVolumeInfo;
pub type FSAAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError::Type,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSABlockInfo {
    pub __unk240: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSADeviceInfo {
    pub __unk241: [::core::ffi::c_char; 8usize],
    pub deviceSizeInSectors: u64,
    pub deviceSectorSize: u32,
    pub __unk242: [::core::ffi::c_char; 20usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAFileSystemInfo {
    pub __unk243: [::core::ffi::c_char; 30usize],
}
pub mod FSAMountPriority {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_MOUNT_PRIORITY_BASE: Type = 1;
    pub const FSA_MOUNT_PRIORITY_RAM_DISK_CACHE: Type = 4;
    pub const FSA_MOUNT_PRIORITY_TITLE_UPDATE: Type = 9;
    pub const FSA_MOUNT_PRIORITY_UNMOUNT_ALL: Type = 2147483648;
}
pub mod FSAQueryInfoType {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_QUERY_INFO_FREE_SPACE_SIZE: Type = 0;
    pub const FSA_QUERY_INFO_DIR_SIZE: Type = 1;
    pub const FSA_QUERY_INFO_ENTRY_NUM: Type = 2;
    pub const FSA_QUERY_INFO_FILE_SYSTEM_INFO: Type = 3;
    pub const FSA_QUERY_INFO_DEVICE_INFO: Type = 4;
    pub const FSA_QUERY_INFO_STAT: Type = 5;
    pub const FSA_QUERY_INFO_BAD_BLOCK_INFO: Type = 6;
    pub const FSA_QUERY_INFO_JOURNAL_FREE_SPACE_SIZE: Type = 7;
    pub const FSA_QUERY_INFO_FRAGMENT_BLOCK_INFO: Type = 8;
}
pub mod FSAReadFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_READ_FLAG_NONE: Type = 0;
    pub const FSA_READ_FLAG_READ_WITH_POS: Type = 1;
}
pub mod FSAWriteFlag {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_WRITE_FLAG_NONE: Type = 0;
    pub const FSA_WRITE_FLAG_READ_WITH_POS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAProcessInfo {
    pub titleId: u64,
    pub processId: u32,
    pub groupId: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRawOpen {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRawOpen {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawClose {
    pub handle: i32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawRead {
    pub __unk244: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRawWrite {
    pub __unk245: [::core::ffi::c_char; 4usize],
    pub blocks_offset: u64,
    pub count: u32,
    pub size: u32,
    pub device_handle: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestAppendFile {
    pub size: u32,
    pub count: u32,
    pub handle: FSAFileHandle,
    pub unk0x0C: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeDir {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestChangeDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeMode {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode1: u32,
    pub mode2: u32,
}
impl Default for FSARequestChangeMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestCloseDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestCloseFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestFlushFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestFlushQuota {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestFlushQuota {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestGetInfoByQuery {
    pub path: [::core::ffi::c_char; 640usize],
    pub type_: FSAQueryInfoType::Type,
}
impl Default for FSARequestGetInfoByQuery {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestGetPosFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestIsEof {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeDir {
    pub path: [::core::ffi::c_char; 640usize],
    pub permission: u32,
}
impl Default for FSARequestMakeDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMakeQuota {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: u32,
    pub size: u64,
}
impl Default for FSARequestMakeQuota {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMount {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub unk0x500: u32,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
impl Default for FSARequestMount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestMountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub target: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority::Type,
    pub process: FSAProcessInfo,
    pub unkBuf: *mut ::core::ffi::c_void,
    pub unkBufLen: u32,
}
impl Default for FSARequestMountWithProcess {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenDir {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestOpenDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestOpenFile {
    pub path: [::core::ffi::c_char; 640usize],
    pub mode: [::core::ffi::c_char; 16usize],
    pub unk0x290: u32,
    pub unk0x294: u32,
    pub unk0x298: u32,
}
impl Default for FSARequestOpenFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestReadDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestReadFile {
    pub buffer: *mut u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub readFlags: FSAReadFlag::Type,
}
impl Default for FSARequestReadFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRemove {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRemove {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestRename {
    pub oldPath: [::core::ffi::c_char; 640usize],
    pub newPath: [::core::ffi::c_char; 640usize],
}
impl Default for FSARequestRename {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestRewindDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestSetPosFile {
    pub handle: FSAFileHandle,
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestStatFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSARequestTruncateFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmount {
    pub path: [::core::ffi::c_char; 640usize],
    pub unk0x280: u32,
}
impl Default for FSARequestUnmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestUnmountWithProcess {
    pub path: [::core::ffi::c_char; 640usize],
    pub priority: FSAMountPriority::Type,
    pub process: FSAProcessInfo,
}
impl Default for FSARequestUnmountWithProcess {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestWriteFile {
    pub buffer: *const u8,
    pub size: u32,
    pub count: u32,
    pub pos: FSAFilePosition,
    pub handle: FSAFileHandle,
    pub writeFlags: FSAWriteFlag::Type,
}
impl Default for FSARequestWriteFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSARequestChangeOwner {
    pub path: [::core::ffi::c_char; 640usize],
    pub __unk246: [::core::ffi::c_char; 4usize],
    pub owner: u32,
    pub __unk247: [::core::ffi::c_char; 4usize],
    pub group: u32,
}
impl Default for FSARequestChangeOwner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSARequest {
    pub emulatedError: FSError::Type,
    pub __bindgen_anon_1: FSARequest__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSARequest__bindgen_ty_1 {
    pub rawOpen: FSARequestRawOpen,
    pub rawClose: FSARequestRawClose,
    pub rawRead: FSARequestRawRead,
    pub rawWrite: FSARequestRawWrite,
    pub appendFile: FSARequestAppendFile,
    pub changeDir: FSARequestChangeDir,
    pub changeMode: FSARequestChangeMode,
    pub closeDir: FSARequestCloseDir,
    pub closeFile: FSARequestCloseFile,
    pub flushFile: FSARequestFlushFile,
    pub flushQuota: FSARequestFlushQuota,
    pub getInfoByQuery: FSARequestGetInfoByQuery,
    pub getPosFile: FSARequestGetPosFile,
    pub isEof: FSARequestIsEof,
    pub makeDir: FSARequestMakeDir,
    pub makeQuota: FSARequestMakeQuota,
    pub mount: FSARequestMount,
    pub mountWithProcess: FSARequestMountWithProcess,
    pub openDir: FSARequestOpenDir,
    pub openFile: FSARequestOpenFile,
    pub readDir: FSARequestReadDir,
    pub readFile: FSARequestReadFile,
    pub remove: FSARequestRemove,
    pub rename: FSARequestRename,
    pub rewindDir: FSARequestRewindDir,
    pub setPosFile: FSARequestSetPosFile,
    pub statFile: FSARequestStatFile,
    pub truncateFile: FSARequestTruncateFile,
    pub unmount: FSARequestUnmount,
    pub unmountWithProcess: FSARequestUnmountWithProcess,
    pub writeFile: FSARequestWriteFile,
    pub changeOwner: FSARequestChangeOwner,
    pub __unk248: [::core::ffi::c_char; 1308usize],
}
impl Default for FSARequest__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSARequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseRawOpen {
    pub handle: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetCwd {
    pub path: [::core::ffi::c_char; 640usize],
}
impl Default for FSAResponseGetCwd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseGetFileBlockAddress {
    pub address: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseGetPosFile {
    pub pos: FSAFilePosition,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseGetVolumeInfo {
    pub volumeInfo: FSAVolumeInfo,
}
impl Default for FSAResponseGetVolumeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponseGetInfoByQuery {
    pub __bindgen_anon_1: FSAResponseGetInfoByQuery__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponseGetInfoByQuery__bindgen_ty_1 {
    pub badBlockInfo: FSABlockInfo,
    pub deviceInfo: FSADeviceInfo,
    pub dirSize: u64,
    pub entryNum: FSAEntryNum,
    pub fileSystemInfo: FSAFileSystemInfo,
    pub fragmentBlockInfo: FSABlockInfo,
    pub freeSpaceSize: u64,
    pub journalFreeSpaceSize: u64,
    pub stat: FSAStat,
}
impl Default for FSAResponseGetInfoByQuery__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSAResponseGetInfoByQuery {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseOpenFile {
    pub handle: FSAFileHandle,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSAResponseOpenDir {
    pub handle: FSADirectoryHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseReadDir {
    pub entry: FSADirectoryEntry,
}
impl Default for FSAResponseReadDir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAResponseStatFile {
    pub stat: FSAStat,
}
impl Default for FSAResponseStatFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAResponse {
    pub word0: u32,
    pub __bindgen_anon_1: FSAResponse__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FSAResponse__bindgen_ty_1 {
    pub rawOpen: FSAResponseRawOpen,
    pub getCwd: FSAResponseGetCwd,
    pub getFileBlockAddress: FSAResponseGetFileBlockAddress,
    pub getPosFile: FSAResponseGetPosFile,
    pub getVolumeInfo: FSAResponseGetVolumeInfo,
    pub getInfoByQuery: FSAResponseGetInfoByQuery,
    pub openDir: FSAResponseOpenDir,
    pub openFile: FSAResponseOpenFile,
    pub readDir: FSAResponseReadDir,
    pub statFile: FSAResponseStatFile,
    pub __unk249: [::core::ffi::c_char; 655usize],
}
impl Default for FSAResponse__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FSAResponse {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod FSACommandEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_COMMAND_INVALID: Type = 0;
    pub const FSA_COMMAND_MOUNT: Type = 1;
    pub const FSA_COMMAND_UNMOUNT: Type = 2;
    pub const FSA_COMMAND_GET_VOLUME_INFO: Type = 3;
    pub const FSA_COMMAND_GET_ATTACH: Type = 4;
    pub const FSA_COMMAND_CHANGE_DIR: Type = 5;
    pub const FSA_COMMAND_GET_CWD: Type = 6;
    pub const FSA_COMMAND_MAKE_DIR: Type = 7;
    pub const FSA_COMMAND_REMOVE: Type = 8;
    pub const FSA_COMMAND_RENAME: Type = 9;
    pub const FSA_COMMAND_OPEN_DIR: Type = 10;
    pub const FSA_COMMAND_READ_DIR: Type = 11;
    pub const FSA_COMMAND_REWIND_DIR: Type = 12;
    pub const FSA_COMMAND_CLOSE_DIR: Type = 13;
    pub const FSA_COMMAND_OPEN_FILE: Type = 14;
    pub const FSA_COMMAND_READ_FILE: Type = 15;
    pub const FSA_COMMAND_WRITE_FILE: Type = 16;
    pub const FSA_COMMAND_GET_POS_FILE: Type = 17;
    pub const FSA_COMMAND_SET_POS_FILE: Type = 18;
    pub const FSA_COMMAND_IS_EOF: Type = 19;
    pub const FSA_COMMAND_STAT_FILE: Type = 20;
    pub const FSA_COMMAND_CLOSE_FILE: Type = 21;
    pub const FSA_COMMAND_GET_ERROR: Type = 22;
    pub const FSA_COMMAND_FLUSH_FILE: Type = 23;
    pub const FSA_COMMAND_GET_INFO_BY_QUERY: Type = 24;
    pub const FSA_COMMAND_APPEND_FILE: Type = 25;
    pub const FSA_COMMAND_TRUNCATE_FILE: Type = 26;
    pub const FSA_COMMAND_FLUSH_VOLUME: Type = 27;
    pub const FSA_COMMAND_ROLLBACK_VOLUME: Type = 28;
    pub const FSA_COMMAND_MAKE_QUOTA: Type = 29;
    pub const FSA_COMMAND_FLUSH_QUOTA: Type = 30;
    pub const FSA_COMMAND_ROLLBACK_QUOTA: Type = 31;
    pub const FSA_COMMAND_CHANGE_MODE: Type = 32;
    pub const FSA_COMMAND_OPEN_FILE_BY_STAT: Type = 33;
    pub const FSA_COMMAND_REGISTER_FLUSH_QUOTA: Type = 34;
    pub const FSA_COMMAND_FLUSH_MULTI_QUOTA: Type = 35;
    pub const FSA_COMMAND_GET_FILE_BLOCK_ADDRESS: Type = 37;
    pub const FSA_COMMAND_ADD_USER_PROCESS: Type = 101;
    pub const FSA_COMMAND_DEL_USER_PROCESS: Type = 102;
    pub const FSA_COMMAND_MOUNT_WITH_PROCESS: Type = 103;
    pub const FSA_COMMAND_UNMOUNT_WITH_PROCESS: Type = 104;
    pub const FSA_COMMAND_FORMAT: Type = 105;
    pub const FSA_COMMAND_RAW_OPEN: Type = 106;
    pub const FSA_COMMAND_RAW_READ: Type = 107;
    pub const FSA_COMMAND_RAW_WRITE: Type = 108;
    pub const FSA_COMMAND_RAW_CLOSE: Type = 109;
    pub const FSA_COMMAND_GET_LAST_FAILED_VOLUME: Type = 110;
    pub const FSA_COMMAND_GET_VOLUME_EXISTENCE: Type = 111;
    pub const FSA_COMMAND_CHANGE_OWNER: Type = 112;
    pub const FSA_COMMAND_CANCEL_GET_ATTACH: Type = 113;
    pub const FSA_COMMAND_REMOVE_QUOTA: Type = 114;
    pub const FSA_COMMAND_SET_CLIENT_PRIORITY: Type = 115;
    pub const FSA_COMMAND_APPLY_MEMORY_CACHE: Type = 116;
    pub const FSA_COMMAND_MAKE_LINK: Type = 117;
    pub const FSA_COMMAND_XFER_PARAMS: Type = 118;
    pub const FSA_COMMAND_EXEC_DEBUG_PROC: Type = 120;
    pub const FSA_COMMAND_DEBUG_SET_TITLE_ID: Type = 121;
    pub const FSA_COMMAND_DEBUG_SET_CAPABILITY: Type = 122;
    pub const FSA_COMMAND_SET_PROCESS_CONFIG: Type = 130;
    pub const FSA_COMMAND_CONFIG_SET_MEMORY_CACHE: Type = 131;
    pub const FSA_COMMAND_CONFIG_UNSET_MEMORY_CACHE: Type = 132;
    pub const FSA_COMMAND_CONFIG_SET_PRF2_CHAR_CODE: Type = 133;
    pub const FSA_COMMAND_GET_PROC_RESOURCE_USAGE: Type = 140;
    pub const FSA_COMMAND_GET_ALL_RESOURCE_USAGE: Type = 141;
    pub const FSA_COMMAND_SEND_PROFILE_CMD: Type = 142;
}
pub mod FSAIpcRequestTypeEnum {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_IPC_REQUEST_IOCTL: Type = 0;
    pub const FSA_IPC_REQUEST_IOCTLV: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAAsyncResult {
    pub ioMsgQueue: *mut OSMessageQueue,
    pub msg: FSMessage,
    pub userCallback: FSAAsyncCallbackFn,
    pub error: FSError::Type,
    pub command: FSACommand,
    pub request: *mut FSARequest,
    pub response: *mut FSAResponse,
    pub userContext: *mut ::core::ffi::c_void,
}
impl Default for FSAAsyncResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FSAShimBuffer {
    pub request: FSARequest,
    pub __unk250: [::core::ffi::c_char; 96usize],
    pub response: FSAResponse,
    pub __unk251: [::core::ffi::c_char; 109usize],
    pub ioctlvVec: [IOSVec; 3usize],
    pub __unk252: [::core::ffi::c_char; 92usize],
    pub command: FSACommand,
    pub clientHandle: u32,
    pub ipcReqType: FSAIpcRequestType,
    pub ioctlvVecIn: u8,
    pub ioctlvVecOut: u8,
    pub fsaAsyncResult: FSAAsyncResult,
}
impl Default for FSAShimBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FSAClientAttachAsyncCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        result: FSError::Type,
        command: FSACommand,
        request: *mut FSARequest,
        response: *mut FSAResponse,
        userContext: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSAClientAttachAsyncData {
    pub userCallback: FSAClientAttachAsyncCallbackFn,
    pub userContext: *mut ::core::ffi::c_void,
    pub ioMsgQueue: *mut OSMessageQueue,
}
impl Default for FSAClientAttachAsyncData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod FSAMountFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_MOUNT_FLAG_LOCAL_MOUNT: Type = 0;
    pub const FSA_MOUNT_FLAG_BIND_MOUNT: Type = 1;
    pub const FSA_MOUNT_FLAG_GLOBAL_MOUNT: Type = 2;
}
pub mod FSAUnmountFlags {
    pub type Type = ::core::ffi::c_uint;
    pub const FSA_UNMOUNT_FLAG_NONE: Type = 0;
    pub const FSA_UNMOUNT_FLAG_FORCE: Type = 2;
    pub const FSA_UNMOUNT_FLAG_BIND_MOUNT: Type = 2147483648;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSStopWatchAtomic {
    pub startTime: OSTime,
    pub totalTime: OSTime,
}
pub mod OSPerfMonArg {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_ARG_MMCR0: Type = 1;
    pub const OS_PM_ARG_MMCR1: Type = 2;
    pub const OS_PM_ARG_PMC1: Type = 4;
    pub const OS_PM_ARG_PMC2: Type = 8;
    pub const OS_PM_ARG_PMC3: Type = 16;
    pub const OS_PM_ARG_PMC4: Type = 32;
}
pub mod OSPerfMonMMCR0Flags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_MMCR0_PMC1_CURRENT: Type = 0;
    pub const OS_PM_MMCR0_PMC1_CPU_CYCLES: Type = 64;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED: Type = 128;
    pub const OS_PM_MMCR0_PMC1_TBL_RISING_TRANSITIONS: Type = 192;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_DISPATCHED: Type = 256;
    pub const OS_PM_MMCR0_PMC1_EIEIO_INSTRUCTIONS_COMPLETED: Type = 320;
    pub const OS_PM_MMCR0_PMC1_ITLB_SEARCH_CYCLES: Type = 384;
    pub const OS_PM_MMCR0_PMC1_L2_HITS: Type = 448;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_EA_DELIVERED: Type = 512;
    pub const OS_PM_MMCR0_PMC1_INSTRUCTIONS_COMPLETED_MATCHES_IABR: Type = 576;
    pub const OS_PM_MMCR0_PMC1_SLOW_L1_MISSES: Type = 640;
    pub const OS_PM_MMCR0_PMC1_UNRESOLVED_BRANCHES: Type = 704;
    pub const OS_PM_MMCR0_PMC1_UNRESOLVED_STALL_CYCLES: Type = 768;
    pub const OS_PM_MMCR0_PMC1_L1_SHARED_STORES: Type = 896;
    pub const OS_PM_MMCR0_PMC1_L2_SHARED_INTERVENTIONS: Type = 960;
    pub const OS_PM_MMCR0_PMC1_CACHE_PARADOXES: Type = 1024;
    pub const OS_PM_MMCR0_PMC1_CIU_LOAD_REQUESTS: Type = 1280;
    pub const OS_PM_MMCR0_PMC1_BIU_ADDRESS_ONLY_REQUESTS: Type = 1344;
    pub const OS_PM_MMCR0_PMC1_CIU_PARADOXES: Type = 1408;
    pub const OS_PM_MMCR0_PMC1_60XE_BUS_DATA_BEATS: Type = 1472;
    pub const OS_PM_MMCR0_PMC2_CURRENT: Type = 0;
    pub const OS_PM_MMCR0_PMC2_CPU_CYCLES: Type = 1;
    pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_COMPLETED: Type = 2;
    pub const OS_PM_MMCR0_PMC2_TBL_RISING_TRANSITIONS: Type = 3;
    pub const OS_PM_MMCR0_PMC2_INSTRUCTIONS_DISPATCHED: Type = 4;
    pub const OS_PM_MMCR0_PMC2_L1_ICACHE_MISSES: Type = 5;
    pub const OS_PM_MMCR0_PMC2_ITLB_MISSES: Type = 6;
    pub const OS_PM_MMCR0_PMC2_L2_INSTRUCTION_MISSES: Type = 7;
    pub const OS_PM_MMCR0_PMC2_PRED_BRANCHES_NOT_TAKEN: Type = 8;
    pub const OS_PM_MMCR0_PMC2_RESERVED_LOADS: Type = 10;
    pub const OS_PM_MMCR0_PMC2_LOADS_AND_STORES: Type = 11;
    pub const OS_PM_MMCR0_PMC2_CACHE_SNOOPS: Type = 12;
    pub const OS_PM_MMCR0_PMC2_L1_TO_L2_CASTOUTS: Type = 13;
    pub const OS_PM_MMCR0_PMC2_SYSTEM_UNIT_INSTRUCTIONS: Type = 14;
    pub const OS_PM_MMCR0_PMC2_L1_INSTRUCTION_MISS_CYCLES: Type = 15;
    pub const OS_PM_MMCR0_PMC2_FIRST_SPECULATIVE_BRANCH_RESOLVES: Type = 16;
    pub const OS_PM_MMCR0_PMC2_L2_SHARED_STORES: Type = 17;
    pub const OS_PM_MMCR0_PMC2_L1_SHARED_INTERVENTIONS: Type = 18;
    pub const OS_PM_MMCR0_PMC2_CIU_STORE_REQUESTS: Type = 20;
    pub const OS_PM_MMCR0_PMC2_SLOW_OUTSTANDING_BIU_TRANSACTIONS: Type = 21;
    pub const OS_PM_MMCR0_PMC2_CIU_MODIFIED_INTERVENTIONS: Type = 22;
}
pub mod OSPerfMonMMCR1Flags {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_PM_MMCR1_PMC3_CURRENT: Type = 0;
    pub const OS_PM_MMCR1_PMC3_CPU_CYCLES: Type = 134217728;
    pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_COMPLETED: Type = 268435456;
    pub const OS_PM_MMCR1_PMC3_TBL_RISING_TRANSITIONS: Type = 402653184;
    pub const OS_PM_MMCR1_PMC3_INSTRUCTIONS_DISPATCHED: Type = 536870912;
    pub const OS_PM_MMCR1_PMC3_L1_DCACHE_MISSES: Type = 671088640;
    pub const OS_PM_MMCR1_PMC3_DTLB_MISSES: Type = 805306368;
    pub const OS_PM_MMCR1_PMC3_L2_DATA_MISSES: Type = 939524096;
    pub const OS_PM_MMCR1_PMC3_PRED_BRANCHES_TAKEN: Type = 1073741824;
    pub const OS_PM_MMCR1_PMC3_COND_STORES_COMPLETED: Type = 1342177280;
    pub const OS_PM_MMCR1_PMC3_FPU_INSTRUCTIONS_COMPLETED: Type = 1476395008;
    pub const OS_PM_MMCR1_PMC3_L2_CASTOUTS_BY_SNOOPS: Type = 1610612736;
    pub const OS_PM_MMCR1_PMC3_L2_CACHE_OPERATIONS: Type = 1744830464;
    pub const OS_PM_MMCR1_PMC3_L1_LOAD_MISS_CYCLES: Type = 2013265920;
    pub const OS_PM_MMCR1_PMC3_SECOND_SPECULATIVE_BRANCH_RESOLVES: Type = 2147483648;
    pub const OS_PM_MMCR1_PMC3_BPU_STALL_LR_CR_CYCLES: Type = 2281701376;
    pub const OS_PM_MMCR1_PMC3_L1_MODIFIED_INTERVENTIONS: Type = 2415919104;
    pub const OS_PM_MMCR1_PMC3_ICBI_SNOOPS: Type = 2550136832;
    pub const OS_PM_MMCR1_PMC3_CIU_ADDRESS_ONLY_REQUESTS: Type = 2684354560;
    pub const OS_PM_MMCR1_PMC3_BIU_LOAD_REQUESTS: Type = 2818572288;
    pub const OS_PM_MMCR1_PMC3_CIU_SHARED_INTERVENTIONS: Type = 2952790016;
    pub const OS_PM_MMCR1_PMC4_CURRENT: Type = 0;
    pub const OS_PM_MMCR1_PMC4_CPU_CYCLES: Type = 4194304;
    pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_COMPLETED: Type = 8388608;
    pub const OS_PM_MMCR1_PMC4_TBL_RISING_TRANSITIONS: Type = 12582912;
    pub const OS_PM_MMCR1_PMC4_INSTRUCTIONS_DISPATCHED: Type = 16777216;
    pub const OS_PM_MMCR1_PMC4_L2_CASTOUTS: Type = 20971520;
    pub const OS_PM_MMCR1_PMC4_DTLB_SEARCH_CYCLES: Type = 25165824;
    pub const OS_PM_MMCR1_PMC4_BRANCHES_MISPREDICTED: Type = 33554432;
    pub const OS_PM_MMCR1_PMC4_INTACT_COND_STORES_COMPLETED: Type = 41943040;
    pub const OS_PM_MMCR1_PMC4_SYNC_INSTRUCTIONS_COMPLETED: Type = 46137344;
    pub const OS_PM_MMCR1_PMC4_SNOOP_RETRIES: Type = 50331648;
    pub const OS_PM_MMCR1_PMC4_INTEGER_OPERATIONS: Type = 54525952;
    pub const OS_PM_MMCR1_PMC4_BPU_STALL_TWO_BRANCHES_CYCLES: Type = 58720256;
    pub const OS_PM_MMCR1_PMC4_L2_MODIFIED_INTERVENTIONS: Type = 67108864;
    pub const OS_PM_MMCR1_PMC4_TLBIE_SNOOPS: Type = 71303168;
    pub const OS_PM_MMCR1_PMC4_L2_BANK_REFRESH_OVERFLOWS: Type = 75497472;
    pub const OS_PM_MMCR1_PMC4_CIU_ARTRY_COUNT: Type = 83886080;
    pub const OS_PM_MMCR1_PMC4_BIU_STORE_REQUESTS: Type = 88080384;
    pub const OS_PM_MMCR1_PMC4_CIU_TWO_CORE_SHARED_INTERVENTIONS: Type = 92274688;
}
pub mod MEMFrmHeapFreeMode {
    pub type Type = ::core::ffi::c_uint;
    pub const MEM_FRM_HEAP_FREE_HEAD: Type = 1;
    pub const MEM_FRM_HEAP_FREE_TAIL: Type = 2;
    pub const MEM_FRM_HEAP_FREE_ALL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEMFrmHeapState {
    pub tag: u32,
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
    pub previous: *mut MEMFrmHeapState,
}
impl Default for MEMFrmHeapState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(1))]
pub struct MEMFrmHeap {
    pub _bindgen_opaque_blob: [u8; 76usize],
}
impl Default for MEMFrmHeap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod OSCodegenSecMode {
    pub type Type = ::core::ffi::c_uint;
    pub const CODEGEN_RW_: Type = 0;
    pub const CODEGEN_R_X: Type = 1;
}
pub mod OSMemoryType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_MEM1: Type = 1;
    pub const OS_MEM2: Type = 2;
}
pub mod OSSharedDataType {
    pub type Type = ::core::ffi::c_uint;
    pub const OS_SHAREDDATATYPE_FONT_CHINESE: Type = 0;
    pub const OS_SHAREDDATATYPE_FONT_KOREAN: Type = 1;
    pub const OS_SHAREDDATATYPE_FONT_STANDARD: Type = 2;
    pub const OS_SHAREDDATATYPE_FONT_TAIWANESE: Type = 3;
    pub const OS_SHAREDDATATYPE_FONT_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OSCoroutine {
    pub nia: u32,
    pub cr: u32,
    pub ugqr1: u32,
    pub stack: u32,
    pub sda2Base: u32,
    pub sdaBase: u32,
    pub gpr: [u32; 18usize],
    pub fpr: [f64; 18usize],
    pub psr: [f64; 18usize],
}
pub mod OSScreenID {
    pub type Type = ::core::ffi::c_uint;
    pub const SCREEN_TV: Type = 0;
    pub const SCREEN_DRC: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
extern "C" {
    pub fn close(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn __errno() -> *mut ::core::ffi::c_int;
    pub fn OSInitThreadQueue(queue: *mut OSThreadQueue);
    pub fn OSInitThreadQueueEx(queue: *mut OSThreadQueue, parent: *mut ::core::ffi::c_void);
    pub fn OSInitMessageQueue(queue: *mut OSMessageQueue, messages: *mut OSMessage, size: i32);
    pub fn OSInitMessageQueueEx(
        queue: *mut OSMessageQueue,
        messages: *mut OSMessage,
        size: i32,
        name: *const ::core::ffi::c_char,
    );
    pub fn OSSendMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
    pub fn OSReceiveMessage(
        queue: *mut OSMessageQueue,
        message: *mut OSMessage,
        flags: OSMessageFlags::Type,
    ) -> BOOL;
    pub fn OSPeekMessage(queue: *mut OSMessageQueue, message: *mut OSMessage) -> BOOL;
    pub fn OSGetSystemMessageQueue() -> *mut OSMessageQueue;
    pub fn OSGetDefaultAppIOQueue() -> *mut OSMessageQueue;
    pub fn OSGetSystemInfo() -> *mut OSSystemInfo;
    pub fn OSEnableHomeButtonMenu(enable: BOOL) -> BOOL;
    pub fn OSIsHomeButtonMenuEnabled() -> BOOL;
    pub fn OSGetOSID() -> u64;
    pub fn __OSGetProcessSDKVersion() -> u32;
    pub fn OSGetTime() -> OSTime;
    pub fn OSGetSystemTime() -> OSTime;
    pub fn OSGetTick() -> OSTick;
    pub fn OSGetSystemTick() -> OSTick;
    pub fn OSCalendarTimeToTicks(calendarTime: *mut OSCalendarTime) -> OSTime;
    pub fn OSTicksToCalendarTime(time: OSTime, calendarTime: *mut OSCalendarTime);
    pub fn __OSSetAbsoluteSystemTime(time: OSTime) -> BOOL;
    pub fn IOS_Open(device: *const ::core::ffi::c_char, mode: IOSOpenMode::Type) -> IOSError::Type;
    pub fn IOS_OpenAsync(
        device: *const ::core::ffi::c_char,
        mode: IOSOpenMode::Type,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IOS_Close(handle: IOSHandle) -> IOSError::Type;
    pub fn IOS_CloseAsync(
        handle: IOSHandle,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IOS_Ioctl(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
    ) -> IOSError::Type;
    pub fn IOS_IoctlAsync(
        handle: IOSHandle,
        request: u32,
        inBuf: *mut ::core::ffi::c_void,
        inLen: u32,
        outBuf: *mut ::core::ffi::c_void,
        outLen: u32,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IOS_Ioctlv(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
    ) -> IOSError::Type;
    pub fn IOS_IoctlvAsync(
        handle: IOSHandle,
        request: u32,
        vecIn: u32,
        vecOut: u32,
        vec: *mut IOSVec,
        callback: IOSAsyncCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn OSFastMutex_Init(mutex: *mut OSFastMutex, name: *const ::core::ffi::c_char);
    pub fn OSFastMutex_Lock(mutex: *mut OSFastMutex);
    pub fn OSFastMutex_Unlock(mutex: *mut OSFastMutex);
    pub fn OSFastMutex_TryLock(mutex: *mut OSFastMutex) -> BOOL;
    pub fn OSInitContext(
        context: *mut OSContext,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
    pub fn OSDumpContext(context: *mut OSContext);
    pub fn OSLoadContext(context: *mut OSContext);
    pub fn OSSaveContext(context: *mut OSContext) -> u32;
    pub fn OSLoadFPUContext(context: *mut OSContext);
    pub fn OSSaveFPUContext(context: *mut OSContext);
    pub fn OSGetCurrentContext() -> *mut OSContext;
    pub fn OSSetCurrentContext(context: *mut OSContext);
    pub fn OSSwitchStack(stack: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
    pub fn __OSSetCurrentUserContext(context: *mut OSContext);
    pub fn __OSSetAndLoadContext(context: *mut OSContext);
    pub fn OSCancelAlarm(alarm: *mut OSAlarm) -> BOOL;
    pub fn OSCancelAlarms(group: u32);
    pub fn OSCreateAlarm(alarm: *mut OSAlarm);
    pub fn OSCreateAlarmEx(alarm: *mut OSAlarm, name: *const ::core::ffi::c_char);
    pub fn OSGetAlarmUserData(alarm: *mut OSAlarm) -> *mut ::core::ffi::c_void;
    pub fn OSInitAlarmQueue(queue: *mut OSAlarmQueue);
    pub fn OSInitAlarmQueueEx(queue: *mut OSAlarmQueue, name: *const ::core::ffi::c_char);
    pub fn OSSetAlarm(alarm: *mut OSAlarm, time: OSTime, callback: OSAlarmCallback) -> BOOL;
    pub fn OSSetPeriodicAlarm(
        alarm: *mut OSAlarm,
        start: OSTime,
        interval: OSTime,
        callback: OSAlarmCallback,
    ) -> BOOL;
    pub fn OSSetAlarmTag(alarm: *mut OSAlarm, group: u32);
    pub fn OSSetAlarmUserData(alarm: *mut OSAlarm, data: *mut ::core::ffi::c_void);
    pub fn OSWaitAlarm(alarm: *mut OSAlarm) -> BOOL;
    pub fn FSInit();
    pub fn FSShutdown();
    pub fn FSAddClient(client: *mut FSClient, errorMask: FSErrorFlag::Type) -> FSStatus::Type;
    pub fn FSDelClient(client: *mut FSClient, errorMask: FSErrorFlag::Type) -> FSStatus::Type;
    pub fn FSGetClientNum() -> u32;
    pub fn FSInitCmdBlock(block: *mut FSCmdBlock);
    pub fn FSSetCmdPriority(block: *mut FSCmdBlock, priority: FSPriority) -> FSStatus::Type;
    pub fn FSSetStateChangeNotification(client: *mut FSClient, info: *mut FSStateChangeParams);
    pub fn FSGetCwd(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSGetAsyncResult(message: *mut FSMessage) -> *mut FSAsyncResult;
    pub fn FSGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSCloseFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSCloseFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSOpenFileEx(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSOpenFileExAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSReadDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSReadDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        entry: *mut FSDirectoryEntry,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSRewindDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSCloseDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetVolumeInfo(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetVolumeInfoAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        volumeInfo: *mut FSVolumeInfo,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSCloseDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSChangeMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        modeMask: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSChangeModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        modeMask: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        path: *const ::core::ffi::c_char,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSGetStatFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetStatFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSReadFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSReadFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSReadFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSReadFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSWriteFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSWriteFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSWriteFileWithPos(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSWriteFileWithPosAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        buffer: *mut u8,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSFileHandle,
        unk1: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSGetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSGetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        fileHandle: FSFileHandle,
        pos: *mut u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSSetPosFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSSetPosFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        pos: u32,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSFlushFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSFlushFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSTruncateFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSTruncateFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        handle: FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn FSGetVolumeState(client: *mut FSClient) -> FSVolumeState::Type;
    pub fn FSGetLastError(client: *mut FSClient) -> FSError::Type;
    pub fn FSGetLastErrorCodeForViewer(client: *mut FSClient) -> FSError::Type;
    pub fn FSGetMountSource(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        type_: FSMountSourceType::Type,
        out: *mut FSMountSource,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *mut FSMountSource,
        target: *const ::core::ffi::c_char,
        bytes: u32,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSBindMount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSBindUnmount(
        client: *mut FSClient,
        cmd: *mut FSCmdBlock,
        target: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn FSTimeToCalendarTime(time: FSTime, outCalendarTime: *mut OSCalendarTime);
    #[link_name = "\u{1}_ZN2nn5swkbd15AppearInputFormERKNS0_9AppearArgE"]
    pub fn nn_swkbd_AppearInputForm(args: *const nn_swkbd_AppearArg) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd14AppearKeyboardERKNS0_11KeyboardArgE"]
    pub fn nn_swkbd_AppearKeyboard(args: *const nn_swkbd_KeyboardArg) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd17CalcSubThreadFontEv"]
    pub fn nn_swkbd_CalcSubThreadFont();
    #[link_name = "\u{1}_ZN2nn5swkbd20CalcSubThreadPredictEv"]
    pub fn nn_swkbd_CalcSubThreadPredict();
    #[link_name = "\u{1}_ZN2nn5swkbd4CalcERKNS0_14ControllerInfoE"]
    pub fn nn_swkbd_Calc(controllerInfo: *const nn_swkbd_ControllerInfo);
    #[link_name = "\u{1}_ZN2nn5swkbd15ConfirmUnfixAllEv"]
    pub fn nn_swkbd_ConfirmUnfixAll();
    #[link_name = "\u{1}_ZN2nn5swkbd6CreateERKNS0_9CreateArgE"]
    pub fn nn_swkbd_Create(args: *const nn_swkbd_CreateArg) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd7DestroyEv"]
    pub fn nn_swkbd_Destroy();
    #[link_name = "\u{1}_ZN2nn5swkbd18DisappearInputFormEv"]
    pub fn nn_swkbd_DisappearInputForm() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd17DisappearKeyboardEv"]
    pub fn nn_swkbd_DisappearKeyboard() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd7DrawDRCEv"]
    pub fn nn_swkbd_DrawDRC();
    #[link_name = "\u{1}_ZN2nn5swkbd6DrawTVEv"]
    pub fn nn_swkbd_DrawTV();
    #[link_name = "\u{1}_ZN2nn5swkbd17GetDrawStringInfoEPNS0_14DrawStringInfoE"]
    pub fn nn_swkbd_GetDrawStringInfo(drawStringInfo: *mut nn_swkbd_DrawStringInfo);
    #[link_name = "\u{1}_ZN2nn5swkbd18GetInputFormStringEv"]
    pub fn nn_swkbd_GetInputFormString() -> *const u16;
    #[link_name = "\u{1}_ZN2nn5swkbd20GetKeyboardConditionEPNS0_17KeyboardConditionE"]
    pub fn nn_swkbd_GetKeyboardCondition(keyboardCondition: *mut nn_swkbd_KeyboardCondition);
    #[link_name = "\u{1}_ZN2nn5swkbd17GetStateInputFormEv"]
    pub fn nn_swkbd_GetStateInputForm() -> nn_swkbd_State::Type;
    #[link_name = "\u{1}_ZN2nn5swkbd16GetStateKeyboardEv"]
    pub fn nn_swkbd_GetStateKeyboard() -> nn_swkbd_State::Type;
    #[link_name = "\u{1}_ZN2nn5swkbd17GetWorkMemorySizeEj"]
    pub fn nn_swkbd_GetWorkMemorySize(unk: u32) -> u32;
    #[link_name = "\u{1}_ZN2nn5swkbd22InactivateSelectCursorEv"]
    pub fn nn_swkbd_InactivateSelectCursor();
    #[link_name = "\u{1}_ZN2nn5swkbd12InitLearnDicEPv"]
    pub fn nn_swkbd_InitLearnDic(dictionary: *mut ::core::ffi::c_void) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd22IsCoveredWithSubWindowEv"]
    pub fn nn_swkbd_IsCoveredWithSubWindow() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd20IsDecideCancelButtonEPb"]
    pub fn nn_swkbd_IsDecideCancelButton(outIsSelected: *mut bool) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd16IsDecideOkButtonEPb"]
    pub fn nn_swkbd_IsDecideOkButton(outIsSelected: *mut bool) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd16IsKeyboardTargetEPNS0_14IEventReceiverE"]
    pub fn nn_swkbd_IsKeyboardTarget(eventReceiver: *mut nn_swkbd_IEventReceiver) -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd23IsNeedCalcSubThreadFontEv"]
    pub fn nn_swkbd_IsNeedCalcSubThreadFont() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd26IsNeedCalcSubThreadPredictEv"]
    pub fn nn_swkbd_IsNeedCalcSubThreadPredict() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd20IsSelectCursorActiveEv"]
    pub fn nn_swkbd_IsSelectCursorActive() -> bool;
    #[link_name = "\u{1}_ZN2nn5swkbd12MuteAllSoundEb"]
    pub fn nn_swkbd_MuteAllSound(muted: bool);
    #[link_name = "\u{1}_ZN2nn5swkbd17SetControllerRemoENS0_14ControllerTypeE"]
    pub fn nn_swkbd_SetControllerRemo(type_: nn_swkbd_ControllerType::Type);
    #[link_name = "\u{1}_ZN2nn5swkbd12SetCursorPosEi"]
    pub fn nn_swkbd_SetCursorPos(pos: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN2nn5swkbd17SetEnableOkButtonEb"]
    pub fn nn_swkbd_SetEnableOkButton(enable: bool);
    #[link_name = "\u{1}_ZN2nn5swkbd18SetInputFormStringEPKDs"]
    pub fn nn_swkbd_SetInputFormString(str_: *const u16);
    #[link_name = "\u{1}_ZN2nn5swkbd11SetReceiverERKNS0_11ReceiverArgE"]
    pub fn nn_swkbd_SetReceiver(receiver: *const nn_swkbd_ReceiverArg);
    #[link_name = "\u{1}_ZN2nn5swkbd13SetSelectFromEi"]
    pub fn nn_swkbd_SetSelectFrom(arg1: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN2nn5swkbd25SetUserControllerEventObjEPNS0_19IControllerEventObjE"]
    pub fn nn_swkbd_SetUserControllerEventObj(
        controllerEventObj: *mut nn_swkbd_IControllerEventObj,
    );
    #[link_name = "\u{1}_ZN2nn5swkbd15SetUserSoundObjEPNS0_9ISoundObjE"]
    pub fn nn_swkbd_SetUserSoundObj(soundObj: *mut nn_swkbd_ISoundObj);
    #[link_name = "\u{1}_ZN2nn7erreula17AppearErrorViewerERKNS0_9AppearArgE"]
    pub fn nn_erreula_AppearErrorViewer(arg: *const nn_erreula_AppearArg);
    #[link_name = "\u{1}_ZN2nn7erreula17AppearHomeNixSignERKNS0_14HomeNixSignArgE"]
    pub fn nn_erreula_AppearHomeNixSign(arg: *const nn_erreula_HomeNixSignArg);
    #[link_name = "\u{1}_ZN2nn7erreula4CalcERKNS0_14ControllerInfoE"]
    pub fn nn_erreula_Calc(controllerInfo: *const nn_erreula_ControllerInfo);
    #[link_name = "\u{1}_ZN2nn7erreula15ChangeLangErrorENS0_8LangTypeE"]
    pub fn nn_erreula_ChangeLangError(languageType: nn_erreula_LangType::Type);
    #[link_name = "\u{1}_ZN2nn7erreula6CreateERKNS0_9CreateArgE"]
    pub fn nn_erreula_Create(args: *const nn_erreula_CreateArg) -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula7DestroyEv"]
    pub fn nn_erreula_Destroy();
    #[link_name = "\u{1}_ZN2nn7erreula20DisappearErrorViewerEv"]
    pub fn nn_erreula_DisappearErrorViewer();
    #[link_name = "\u{1}_ZN2nn7erreula20DisappearHomeNixSignEv"]
    pub fn nn_erreula_DisappearHomeNixSign();
    #[link_name = "\u{1}_ZN2nn7erreula7DrawDRCEv"]
    pub fn nn_erreula_DrawDRC();
    #[link_name = "\u{1}_ZN2nn7erreula6DrawTVEv"]
    pub fn nn_erreula_DrawTV();
    #[link_name = "\u{1}_ZN2nn7erreula13GetResultCodeEv"]
    pub fn nn_erreula_GetResultCode() -> i32;
    #[link_name = "\u{1}_ZN2nn7erreula13GetResultTypeEv"]
    pub fn nn_erreula_GetResultType() -> nn_erreula_ResultType::Type;
    #[link_name = "\u{1}_ZN2nn7erreula23GetSelectButtonNumErrorEv"]
    pub fn nn_erreula_GetSelectButtonNumError() -> i32;
    #[link_name = "\u{1}_ZN2nn7erreula19GetStateErrorViewerEv"]
    pub fn nn_erreula_GetStateErrorViewer() -> nn_erreula_State::Type;
    #[link_name = "\u{1}_ZN2nn7erreula17GetWorkMemorySizeEv"]
    pub fn nn_erreula_GetWorkMemorySize() -> u32;
    #[link_name = "\u{1}_ZN2nn7erreula19IsAppearHomeNixSignEv"]
    pub fn nn_erreula_IsAppearHomeNixSign() -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula25IsDecideSelectButtonErrorEv"]
    pub fn nn_erreula_IsDecideSelectButtonError() -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula29IsDecideSelectLeftButtonErrorEv"]
    pub fn nn_erreula_IsDecideSelectLeftButtonError() -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula30IsDecideSelectRightButtonErrorEv"]
    pub fn nn_erreula_IsDecideSelectRightButtonError() -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula20IsSelectCursorActiveEv"]
    pub fn nn_erreula_IsSelectCursorActive() -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula4JumpEPKcj"]
    pub fn nn_erreula_Jump(buffer: *const ::core::ffi::c_char, bufferSize: u32) -> bool;
    #[link_name = "\u{1}_ZN2nn7erreula12PlayAppearSEEb"]
    pub fn nn_erreula_PlayAppearSE(playAppearSoundEffect: bool);
    #[link_name = "\u{1}_ZN2nn7erreula17SetControllerRemoENS0_14ControllerTypeE"]
    pub fn nn_erreula_SetControllerRemo(controller: nn_erreula_ControllerType::Type);
    #[link_name = "\u{1}GetNfpState__Q2_2nn3nfpFv"]
    pub fn nn_nfp_GetNfpState() -> nn_nfp_NfpState::Type;
    #[link_name = "\u{1}Initialize__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Initialize() -> nn_Result;
    #[link_name = "\u{1}Finalize__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Finalize() -> nn_Result;
    #[link_name = "\u{1}AntennaCheck__Q2_2nn3nfpFv"]
    pub fn nn_nfp_AntennaCheck() -> nn_Result;
    #[link_name = "\u{1}SetActivateEvent__Q2_2nn3nfpFP7OSEvent"]
    pub fn nn_nfp_SetActivateEvent(event: *mut OSEvent) -> nn_Result;
    #[link_name = "\u{1}SetDeactivateEvent__Q2_2nn3nfpFP7OSEvent"]
    pub fn nn_nfp_SetDeactivateEvent(event: *mut OSEvent) -> nn_Result;
    #[link_name = "\u{1}StartDetection__Q2_2nn3nfpFv"]
    pub fn nn_nfp_StartDetection() -> nn_Result;
    #[link_name = "\u{1}StopDetection__Q2_2nn3nfpFv"]
    pub fn nn_nfp_StopDetection() -> nn_Result;
    #[link_name = "\u{1}Mount__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Mount() -> nn_Result;
    #[link_name = "\u{1}MountReadOnly__Q2_2nn3nfpFv"]
    pub fn nn_nfp_MountReadOnly() -> nn_Result;
    #[link_name = "\u{1}MountRom__Q2_2nn3nfpFv"]
    pub fn nn_nfp_MountRom() -> nn_Result;
    #[link_name = "\u{1}Flush__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Flush() -> nn_Result;
    #[link_name = "\u{1}Unmount__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Unmount() -> nn_Result;
    #[link_name = "\u{1}IsExistApplicationArea__Q2_2nn3nfpFv"]
    pub fn nn_nfp_IsExistApplicationArea() -> bool;
    #[link_name = "\u{1}InitializeCreateInfo__Q2_2nn3nfpFPQ3_2nn3nfp25ApplicationAreaCreateInfo"]
    pub fn nn_nfp_InitializeCreateInfo(info: *mut nn_nfp_ApplicationAreaCreateInfo) -> nn_Result;
    #[link_name = "\u{1}CreateApplicationArea__Q2_2nn3nfpFRCQ3_2nn3nfp25ApplicationAreaCreateInfo"]
    pub fn nn_nfp_CreateApplicationArea(
        createInfo: *const nn_nfp_ApplicationAreaCreateInfo,
    ) -> nn_Result;
    #[link_name = "\u{1}OpenApplicationArea__Q2_2nn3nfpFUi"]
    pub fn nn_nfp_OpenApplicationArea(accessID: u32) -> nn_Result;
    #[link_name = "\u{1}DeleteApplicationArea__Q2_2nn3nfpFv"]
    pub fn nn_nfp_DeleteApplicationArea() -> nn_Result;
    #[link_name = "\u{1}WriteApplicationArea__Q2_2nn3nfpFPCvUiRCQ3_2nn3nfp5TagId"]
    pub fn nn_nfp_WriteApplicationArea(
        data: *const ::core::ffi::c_void,
        size: u32,
        id: *const nn_nfp_TagId,
    ) -> nn_Result;
    #[link_name = "\u{1}ReadApplicationArea__Q2_2nn3nfpFPvUi"]
    pub fn nn_nfp_ReadApplicationArea(outData: *mut ::core::ffi::c_void, size: u32) -> nn_Result;
    #[link_name = "\u{1}InitializeRegisterInfoSet__Q2_2nn3nfpFPQ3_2nn3nfp15RegisterInfoSet"]
    pub fn nn_nfp_InitializeRegisterInfoSet(infoSet: *mut nn_nfp_RegisterInfoSet) -> nn_Result;
    #[link_name = "\u{1}SetNfpRegisterInfo__Q2_2nn3nfpFRCQ3_2nn3nfp15RegisterInfoSet"]
    pub fn nn_nfp_SetNfpRegisterInfo(info: *const nn_nfp_RegisterInfoSet) -> nn_Result;
    #[link_name = "\u{1}GetNfpRegisterInfo__Q2_2nn3nfpFPQ3_2nn3nfp12RegisterInfo"]
    pub fn nn_nfp_GetNfpRegisterInfo(outInfo: *mut nn_nfp_RegisterInfo) -> nn_Result;
    #[link_name = "\u{1}DeleteNfpRegisterInfo__Q2_2nn3nfpFv"]
    pub fn nn_nfp_DeleteNfpRegisterInfo() -> nn_Result;
    #[link_name = "\u{1}GetNfpCommonInfo__Q2_2nn3nfpFPQ3_2nn3nfp10CommonInfo"]
    pub fn nn_nfp_GetNfpCommonInfo(outInfo: *mut nn_nfp_CommonInfo) -> nn_Result;
    #[link_name = "\u{1}GetNfpReadOnlyInfo__Q2_2nn3nfpFPQ3_2nn3nfp12ReadOnlyInfo"]
    pub fn nn_nfp_GetNfpReadOnlyInfo(outInfo: *mut nn_nfp_ReadOnlyInfo) -> nn_Result;
    #[link_name = "\u{1}GetNfpAdminInfo__Q2_2nn3nfpFPQ3_2nn3nfp9AdminInfo"]
    pub fn nn_nfp_GetNfpAdminInfo(outInfo: *mut nn_nfp_AdminInfo) -> nn_Result;
    #[link_name = "\u{1}GetNfpRomInfo__Q2_2nn3nfpFPQ3_2nn3nfp7RomInfo"]
    pub fn nn_nfp_GetNfpRomInfo(outInfo: *mut nn_nfp_RomInfo) -> nn_Result;
    #[link_name = "\u{1}GetTagInfo__Q2_2nn3nfpFPQ3_2nn3nfp7TagInfo"]
    pub fn nn_nfp_GetTagInfo(outInfo: *mut nn_nfp_TagInfo) -> nn_Result;
    #[link_name = "\u{1}Format__Q2_2nn3nfpFPCUci"]
    pub fn nn_nfp_Format(data: *const u8, size: i32) -> nn_Result;
    #[link_name = "\u{1}Restore__Q2_2nn3nfpFv"]
    pub fn nn_nfp_Restore() -> nn_Result;
    #[link_name = "\u{1}GetErrorCode__Q2_2nn3nfpFRCQ2_2nn6Result"]
    pub fn nn_nfp_GetErrorCode(res: *const nn_Result) -> u32;
    #[link_name = "\u{1}InitializeAmiiboSettingsArgsIn__Q2_2nn3nfpFPQ3_2nn3nfp20AmiiboSettingsArgsIn"]
    pub fn nn_nfp_InitializeAmiiboSettingsArgsIn(
        args: *mut nn_nfp_AmiiboSettingsArgsIn,
    ) -> nn_Result;
    #[link_name = "\u{1}SwitchToAmiiboSettings__Q2_2nn3nfpFRCQ3_2nn3nfp20AmiiboSettingsArgsInPCcUi"]
    pub fn nn_nfp_SwitchToAmiiboSettings(
        args: *const nn_nfp_AmiiboSettingsArgsIn,
        standardArg: *const ::core::ffi::c_char,
        standardArgSize: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}SwitchToAmiiboSettings__Q2_2nn3nfpFRCQ3_2nn3nfp20AmiiboSettingsArgsIn"]
    pub fn nn_nfp_SwitchToAmiiboSettings1(args: *const nn_nfp_AmiiboSettingsArgsIn) -> nn_Result;
    #[link_name = "\u{1}GetAmiiboSettingsResult__Q2_2nn3nfpFPQ3_2nn3nfp20AmiiboSettingsResultRC15SysArgDataBlock"]
    pub fn nn_nfp_GetAmiiboSettingsResult(
        outResult: *mut nn_nfp_AmiiboSettingsResult,
        block: *const SYSArgDataBlock,
    ) -> nn_Result;
    #[link_name = "\u{1}ReturnToCallerWithAmiiboSettingsResult__Q2_2nn3nfpFRCQ3_2nn3nfp20AmiiboSettingsResult"]
    pub fn nn_nfp_ReturnToCallerWithAmiiboSettingsResult(
        result: *const nn_nfp_AmiiboSettingsResult,
    ) -> nn_Result;
    #[link_name = "\u{1}GetAmiiboSettingsArgs__Q2_2nn3nfpFPQ3_2nn3nfp18AmiiboSettingsArgs"]
    pub fn nn_nfp_GetAmiiboSettingsArgs(outArgs: *mut nn_nfp_AmiiboSettingsArgs) -> nn_Result;
    #[link_name = "\u{1}GetDrcLedStatusOfPattern__Q2_2nn3acpFPQ3_2nn3acp12DrcLedStatusQ3_2nn3acp13DrcLedPattern"]
    pub fn nn_acp_GetDrcLedStatusOfPattern(
        ledStatus: *mut nn_acp_DrcLedStatus,
        pattern: nn_acp_DrcLedPattern,
    );
    #[link_name = "\u{1}SetDrcLedDummyPowerStat__Q2_2nn3acpFUc"]
    pub fn nn_acp_SetDrcLedDummyPowerStat(unk1: u8);
    #[link_name = "\u{1}SetDrcLedTimerLength__Q2_2nn3acpFULT1"]
    pub fn nn_acp_SetDrcLedTimerLength(unk1: u64, unk2: u64);
    #[link_name = "\u{1}SetDrcLedTimerSpeed__Q2_2nn3acpFUi"]
    pub fn nn_acp_SetDrcLedTimerSpeed(speed: u32);
    #[link_name = "\u{1}TurnOffDrcLed__Q2_2nn3acpFv"]
    pub fn nn_acp_TurnOffDrcLed();
    #[link_name = "\u{1}TurnOffDrcLedTest__Q2_2nn3acpFUc"]
    pub fn nn_acp_TurnOffDrcLedTest(unk1: u8);
    #[link_name = "\u{1}TurnOnDrcLed__Q2_2nn3acpFUiQ3_2nn3acp13DrcLedPattern"]
    pub fn nn_acp_TurnOnDrcLed(unk1: u32, pattern: nn_acp_DrcLedPattern);
    #[link_name = "\u{1}TurnOnDrcLedTest__Q2_2nn3acpFUcUiQ3_2nn3acp13DrcLedPattern"]
    pub fn nn_acp_TurnOnDrcLedTest(unk1: u8, unk2: u32, pattern: nn_acp_DrcLedPattern);
    #[link_name = "\u{1}GetDefaultDatabasePath__Q2_2nn2slFPcUiUL"]
    pub fn nn_sl_GetDefaultDatabasePath(
        arg1: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        titleId: u64,
    );
    #[link_name = "\u{1}GetDefaultDatabasePath__Q2_2nn2slFPcUi"]
    pub fn nn_sl_GetDefaultDatabasePath1(arg1: *mut ::core::ffi::c_char, size: ::core::ffi::c_int);
    #[link_name = "\u{1}GetDefaultKillerNotificationTransferRecordPath__Q2_2nn2slFPcUiUL"]
    pub fn nn_sl_GetDefaultKillerNotificationTransferRecordPath(
        arg1: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        titleId: u64,
        arg2: *const ::core::ffi::c_char,
    );
    #[link_name = "\u{1}Initialize__Q2_2nn2slFPFUiT1_PvPFPv_v"]
    pub fn nn_sl_Initialize(arg1: MEMAllocFromDefaultHeapExFn, arg2: MEMFreeToDefaultHeapFn);
    #[link_name = "\u{1}Finalize__Q2_2nn2slFv"]
    pub fn nn_sl_Finalize();
    #[link_name = "\u{1}FinalizeForEcoProcess__Q2_2nn2slFv"]
    pub fn nn_sl_FinalizeForEcoProcess();
    #[link_name = "\u{1}InitializeForEcoProcess__Q2_2nn2slFPFUiT1_PvPFPv_v"]
    pub fn nn_sl_InitializeForEcoProcess(
        allocFn: MEMAllocFromDefaultHeapExFn,
        freeFn: MEMFreeToDefaultHeapFn,
    );
    #[link_name = "\u{1}__CPR81__CheckEmptyValue__Q3_2nn2sl18KillerNotificationSFPbPCQ3_2nn2slJ26J"]
    pub fn nn_sl_details___CPR81__CheckEmptyValue__Q3_2nn2sl18KillerNotificationSFPbPCQ3_2nn2slJ26J(
        u1: *mut bool,
        u2: *const nn_sl_KillerNotification,
    ) -> nn_Result;
    #[link_name = "\u{1}__CPR76__GetEmptyValue__Q3_2nn2sl18KillerNotificationSFPQ3_2nn2slJ24J"]
    pub fn nn_sl_details___CPR76__GetEmptyValue__Q3_2nn2sl18KillerNotificationSFPQ3_2nn2slJ24J(
        u1: *mut nn_sl_KillerNotification,
    );
    #[link_name = "\u{1}Initialize__Q3_2nn2sl10FileStreamFP8FSClientP10FSCmdBlockPCcT3"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl10FileStreamFP8FSClientP10FSCmdBlockPCcT3(
        arg1: *mut nn_sl_details_FileStreamInternal,
        arg2: *mut FSClient,
        arg3: *mut FSCmdBlock,
        arg4: *const ::core::ffi::c_char,
        arg5: *const ::core::ffi::c_char,
    ) -> nn_Result;
    #[link_name = "\u{1}__ct__Q3_2nn2sl10FileStreamFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl10FileStreamFv(
        arg1: *mut nn_sl_details_FileStreamInternal,
    ) -> *mut nn_sl_details_FileStreamInternal;
    #[link_name = "\u{1}__dt__Q3_2nn2sl10FileStreamFv"]
    pub fn nn_sl_details___dt__Q3_2nn2sl10FileStreamFv(
        arg1: *mut nn_sl_details_FileStreamInternal,
        arg2: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}__ct__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    ) -> *mut nn_sl_details_IKillerNotificationTransferRecordManagerIntern;
    #[link_name = "\u{1}__dt__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv"]
    pub fn nn_sl_details___dt__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "\u{1}Finalize__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv"]
    pub fn nn_sl_details_Finalize__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    );
    #[link_name = "\u{1}Load__Q3_2nn2sl39KillerNotificationTransferRecordManagerFRQ3_2nn2sl7IStream"]
    pub fn nn_sl_details_Load__Q3_2nn2sl39KillerNotificationTransferRecordManagerFRQ3_2nn2sl7IStream(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        arg2: *mut nn_sl_details_IStreamInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}LoadInitial__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv"]
    pub fn nn_sl_details_LoadInitial__Q3_2nn2sl39KillerNotificationTransferRecordManagerFv(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}GetRecordCount__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFv"]
    pub fn nn_sl_details_GetRecordCount__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFv(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    ) -> u32;
    #[link_name = "\u{1}GetRecords__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFPQ3_2nn2sl32KillerNotificationTransferRecordUi"]
    pub fn nn_sl_details_GetRecords__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFPQ3_2nn2sl32KillerNotificationTransferRecordUi(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        arg2: *mut nn_sl_KillerNotificationTransferRecord,
        arg3: u32,
    ) -> u32;
    #[link_name = "\u{1}RegisterRecords__Q3_2nn2sl39KillerNotificationTransferRecordManagerFPCQ3_2nn2sl32KillerNotificationTransferRecordUi"]
    pub fn nn_sl_details_RegisterRecords__Q3_2nn2sl39KillerNotificationTransferRecordManagerFPCQ3_2nn2sl32KillerNotificationTransferRecordUi(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        arg2: *const nn_sl_KillerNotificationTransferRecord,
        arg3: u32,
    );
    #[link_name = "\u{1}Store__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFRQ3_2nn2sl7IStream"]
    pub fn nn_sl_details_Store__Q3_2nn2sl39KillerNotificationTransferRecordManagerCFRQ3_2nn2sl7IStream(
        arg1: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
        arg2: *mut nn_sl_details_IStreamInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}__ct__Q3_2nn2sl47KillerNotificationTransferRecordManagerInternalFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl47KillerNotificationTransferRecordManagerInternalFv(
        arg1: *mut nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal,
    ) -> *mut nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal;
    #[link_name = "\u{1}__dt__Q3_2nn2sl47KillerNotificationTransferRecordManagerInternalFv"]
    pub fn nn_sl_details___dt__Q3_2nn2sl47KillerNotificationTransferRecordManagerInternalFv(
        arg1: *mut nn_sl_details_KillerNotificationTransferRecordManagerInternalInternal,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    #[link_name = "\u{1}__ct__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    ) -> *mut nn_sl_details_ITitleListCacheInternal;
    #[link_name = "\u{1}Finalize__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details_Finalize__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    );
    #[link_name = "\u{1}Load__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details_Load__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}Update__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details_Update__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdateIfNeeded__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details_UpdateIfNeeded__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}Store__Q3_2nn2sl14TitleListCacheFv"]
    pub fn nn_sl_details_Store__Q3_2nn2sl14TitleListCacheFv(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleListCacheFiT1"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleListCacheFiT1(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleListCacheFiN21"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleListCacheFiN21(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleListCacheFiT1RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfo"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleListCacheFiT1RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfo(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut nn_sl_details_ITitleListAccessorInternal,
        arg5: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
        arg6: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
        arg7: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
        arg8: *mut nn_sl_details_ISerializerInternal,
    );
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleListCacheFiN21RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfo"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleListCacheFiN21RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfo(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut nn_sl_details_ITitleListAccessorInternal,
        arg6: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
        arg7: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
        arg8: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
        arg9: *mut nn_sl_details_ISerializerInternal,
    );
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleListCacheFiN21RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfoRQ3_2nn2sl13ITimeAccessorRQ3_2nn2sl17IMetaInfoAccessor"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleListCacheFiN21RQ3_2nn2sl18ITitleListAccessorRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IInstalledTitleListAccessorRQ3_2nn2sl24IDiscCachedTitleAccessorRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfoRQ3_2nn2sl13ITimeAccessorRQ3_2nn2sl17IMetaInfoAccessor(
        arg1: *mut nn_sl_details_ITitleListCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut nn_sl_details_ITitleListAccessorInternal,
        arg6: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
        arg7: *mut nn_sl_details_IInstalledTitleListAccessorInternal,
        arg8: *mut nn_sl_details_IDiscCachedTitleAccessorInternal,
        arg9: *mut nn_sl_details_ISerializerInternal,
        arg10: *mut nn_sl_details_ITimeAccessorInternal,
        arg11: *mut nn_sl_details_IMetaInfoAccessorInternal,
    );
    #[link_name = "\u{1}__ct__Q3_2nn2sl26KillerNotificationSelectorFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl26KillerNotificationSelectorFv(
        arg1: *mut nn_sl_details_KillerNotificationSelectorInternal,
    ) -> *mut nn_sl_details_KillerNotificationSelectorInternal;
    #[link_name = "\u{1}__dt__Q3_2nn2sl26KillerNotificationSelectorFv"]
    pub fn nn_sl_details___dt__Q3_2nn2sl26KillerNotificationSelectorFv(
        arg1: *mut nn_sl_details_KillerNotificationSelectorInternal,
        arg2: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}Select__Q3_2nn2sl26KillerNotificationSelectorFPQ3_2nn2sl18KillerNotificationPQ3_2nn2sl9TitleInfoPb"]
    pub fn nn_sl_details_Select__Q3_2nn2sl26KillerNotificationSelectorFPQ3_2nn2sl18KillerNotificationPQ3_2nn2sl9TitleInfoPb(
        arg1: *mut nn_sl_details_KillerNotificationSelectorInternal,
        arg2: *mut nn_sl_KillerNotification,
        arg3: *mut nn_sl_TitleInfo,
        arg4: *mut bool,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl26KillerNotificationSelectorFRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IKillerNotificationAccessorRQ3_2nn2sl14TitleListCacheRQ3_2nn2sl49ISerializer__tm__30_Q3_2nn2sl18KillerNotificationRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl20IAccountInfoAccessorRQ3_2nn2sl13ITimeAccessorRQ3_2nn2sl40IKillerNotificationTransferRecordManager"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl26KillerNotificationSelectorFRQ3_2nn2sl26ILaunchedTitleListAccessorRQ3_2nn2sl27IKillerNotificationAccessorRQ3_2nn2sl14TitleListCacheRQ3_2nn2sl49ISerializer__tm__30_Q3_2nn2sl18KillerNotificationRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl20IAccountInfoAccessorRQ3_2nn2sl13ITimeAccessorRQ3_2nn2sl40IKillerNotificationTransferRecordManager(
        arg1: *mut nn_sl_details_KillerNotificationSelectorInternal,
        arg2: *mut nn_sl_details_ILaunchedTitleListAccessorInternal,
        arg3: *mut nn_sl_details_IKillerNotificationAccessorInternal,
        arg4: *mut nn_sl_details_ITitleListCacheInternal,
        arg5: *mut nn_sl_details_ISerializerInternal,
        arg6: *mut nn_sl_details_ISettingAccessorInternal,
        arg7: *mut nn_sl_details_IAccountInfoAccessorInternal,
        arg8: *mut nn_sl_details_ITimeAccessorInternal,
        arg9: *mut nn_sl_details_IKillerNotificationTransferRecordManagerInternal,
    );
    #[link_name = "\u{1}__ct__Q3_2nn2sl10DrcManagerFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl10DrcManagerFv(
        arg1: *mut nn_sl_details_DrcManagerInternal,
    ) -> *mut nn_sl_details_DrcManagerInternal;
    #[link_name = "\u{1}CancelTransfer__Q3_2nn2sl10DrcManagerFv"]
    pub fn nn_sl_details_CancelTransfer__Q3_2nn2sl10DrcManagerFv(
        arg1: *mut nn_sl_details_DrcManagerInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}PushNotification__Q3_2nn2sl10DrcManagerFPbPCQ3_2nn2sl18KillerNotificationbT3L"]
    pub fn nn_sl_details_PushNotification__Q3_2nn2sl10DrcManagerFPbPCQ3_2nn2sl18KillerNotificationbT3L(
        arg1: *mut nn_sl_details_DrcManagerInternal,
        arg2: *mut bool,
        arg3: *const nn_sl_KillerNotification,
        arg4: bool,
        arg5: bool,
        arg6: u64,
    ) -> nn_Result;
    #[link_name = "\u{1}Transfer__Q3_2nn2sl10DrcManagerFRCQ3_2nn2sl16TransferableInfobQ4_2nn2sl12ITransferrer12TransferMode"]
    pub fn nn_sl_details_Transfer__Q3_2nn2sl10DrcManagerFRCQ3_2nn2sl16TransferableInfobQ4_2nn2sl12ITransferrer12TransferMode(
        arg1: *mut nn_sl_details_DrcManagerInternal,
        arg2: *mut nn_sl_TransferableInfo,
        arg3: bool,
        arg4: nn_sl_TransferMode::Type,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl10DrcManagerFRQ3_2nn2sl12ITransferrerRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl13ITimeAccessor"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl10DrcManagerFRQ3_2nn2sl12ITransferrerRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl13ITimeAccessor(
        arg1: *mut nn_sl_details_DrcManagerInternal,
        arg2: *mut nn_sl_details_ITransferrerInternal,
        arg3: *mut nn_sl_details_ISettingAccessorInternal,
        arg4: *mut nn_sl_details_ITimeAccessorInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}__ct__Q3_2nn2sl29QuickStartApplicationSelectorFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl29QuickStartApplicationSelectorFv(
        arg1: *mut nn_sl_details_QuickStartApplicationSelectorInternal,
    ) -> *mut nn_sl_details_QuickStartApplicationSelectorInternal;
    #[link_name = "\u{1}Select__Q3_2nn2sl29QuickStartApplicationSelectorFPQ3_2nn2sl9TitleInfoi"]
    pub fn nn_sl_details_Select__Q3_2nn2sl29QuickStartApplicationSelectorFPQ3_2nn2sl9TitleInfoi(
        arg1: *mut nn_sl_details_QuickStartApplicationSelectorInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: ::core::ffi::c_int,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl29QuickStartApplicationSelectorFRQ3_2nn2sl26IPreferentialTitleAccessorRQ3_2nn2sl21IDefaultTitleAccessorRQ3_2nn2sl18IWhiteListAccessorRQ3_2nn2sl14TitleListCacheRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl18IBlackListAccessor"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl29QuickStartApplicationSelectorFRQ3_2nn2sl26IPreferentialTitleAccessorRQ3_2nn2sl21IDefaultTitleAccessorRQ3_2nn2sl18IWhiteListAccessorRQ3_2nn2sl14TitleListCacheRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl18IBlackListAccessor(
        arg1: *mut nn_sl_details_QuickStartApplicationSelectorInternal,
        arg2: *mut nn_sl_details_IPreferentialTitleAccessorInternal,
        arg3: *mut nn_sl_details_IDefaultTitleAccessorInternal,
        arg4: *mut nn_sl_details_IWhiteListAccessorInternal,
        arg5: *mut nn_sl_details_ITitleListCacheInternal,
        arg6: *mut nn_sl_details_ISettingAccessorInternal,
        arg7: *mut nn_sl_details_IBlackListAccessorInternal,
    );
    #[link_name = "\u{1}__ct__Q3_2nn2sl18LaunchInfoDatabaseFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl18LaunchInfoDatabaseFv(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
    ) -> *mut nn_sl_details_LaunchInfoDatabaseInternal;
    #[link_name = "\u{1}Store__Q3_2nn2sl18LaunchInfoDatabaseCFRQ3_2nn2sl7IStream"]
    pub fn nn_sl_details_Store__Q3_2nn2sl18LaunchInfoDatabaseCFRQ3_2nn2sl7IStream(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: *mut nn_sl_details_IStreamInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}Load__Q3_2nn2sl18LaunchInfoDatabaseFRQ3_2nn2sl7IStreamQ3_2nn2sl6Region"]
    pub fn nn_sl_details_Load__Q3_2nn2sl18LaunchInfoDatabaseFRQ3_2nn2sl7IStreamQ3_2nn2sl6Region(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: *mut nn_sl_details_IStreamInternal,
        arg3: nn_sl_Region::Type,
    ) -> nn_Result;
    #[link_name = "\u{1}LoadInitial__Q3_2nn2sl18LaunchInfoDatabaseFUiQ3_2nn2sl6Region"]
    pub fn nn_sl_details_LoadInitial__Q3_2nn2sl18LaunchInfoDatabaseFUiQ3_2nn2sl6Region(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: ::core::ffi::c_int,
        arg3: nn_sl_Region::Type,
    ) -> nn_Result;
    #[link_name = "\u{1}GetLaunchInfoById__Q3_2nn2sl18LaunchInfoDatabaseCFPQ3_2nn2sl10LaunchInfoUL"]
    pub fn nn_sl_details_GetLaunchInfoById__Q3_2nn2sl18LaunchInfoDatabaseCFPQ3_2nn2sl10LaunchInfoUL(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: *mut nn_sl_LaunchInfo,
        titleId: u64,
    ) -> nn_Result;
    #[link_name = "\u{1}Finalize__Q3_2nn2sl18LaunchInfoDatabaseFv"]
    pub fn nn_sl_details_Finalize__Q3_2nn2sl18LaunchInfoDatabaseFv(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
    );
    #[link_name = "\u{1}GetEntryCount__Q3_2nn2sl18LaunchInfoDatabaseCFv"]
    pub fn nn_sl_details_GetEntryCount__Q3_2nn2sl18LaunchInfoDatabaseCFv(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
    ) -> u32;
    #[link_name = "\u{1}Clear__Q3_2nn2sl18LaunchInfoDatabaseFv"]
    pub fn nn_sl_details_Clear__Q3_2nn2sl18LaunchInfoDatabaseFv(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
    );
    #[link_name = "\u{1}GetCurrentId__Q3_2nn2sl18LaunchInfoDatabaseCFv"]
    pub fn nn_sl_details_GetCurrentId__Q3_2nn2sl18LaunchInfoDatabaseCFv(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
    ) -> u64;
    #[link_name = "\u{1}Register__Q3_2nn2sl18LaunchInfoDatabaseFRCQ3_2nn2sl10LaunchInfo"]
    pub fn nn_sl_details_Register__Q3_2nn2sl18LaunchInfoDatabaseFRCQ3_2nn2sl10LaunchInfo(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: *const nn_sl_LaunchInfo,
    ) -> u64;
    #[link_name = "\u{1}Unregister__Q3_2nn2sl18LaunchInfoDatabaseFUL"]
    pub fn nn_sl_details_Unregister__Q3_2nn2sl18LaunchInfoDatabaseFUL(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        arg2: u64,
    ) -> nn_Result;
    #[link_name = "\u{1}__CPR84__LoadInitial__Q3_2nn2sl18LaunchInfoDatabaseFUiPCQ4_2nn2slJ22J5EntryT1"]
    pub fn nn_sl_details___CPR84__LoadInitial__Q3_2nn2sl18LaunchInfoDatabaseFUiPCQ4_2nn2slJ22J5EntryT1(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        max_entries: u32,
        defaultEntries: *mut nn_sl_LaunchInfoDatabaseEntry,
        defaultEntryNum: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}__CPR86__ListLaunchInfos__Q3_2nn2sl18LaunchInfoDatabaseCFPQ4_2nn2slJ26J5EntryUi"]
    pub fn nn_sl_details___CPR86__ListLaunchInfos__Q3_2nn2sl18LaunchInfoDatabaseCFPQ4_2nn2slJ26J5EntryUi(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        entriesOut: *mut nn_sl_LaunchInfoDatabaseEntry,
        num: u32,
    ) -> u32;
    #[link_name = "\u{1}__CPR93__Load__Q3_2nn2sl18LaunchInfoDatabaseFRQ3_2nn2sl7IStreamPCQ4_2nn2slJ15J5EntryUi"]
    pub fn nn_sl_details___CPR93__Load__Q3_2nn2sl18LaunchInfoDatabaseFRQ3_2nn2sl7IStreamPCQ4_2nn2slJ15J5EntryUi(
        arg1: *mut nn_sl_details_LaunchInfoDatabaseInternal,
        stream: *mut nn_sl_details_IStreamInternal,
        defaultEntries: *mut nn_sl_LaunchInfoDatabaseEntry,
        defaultEntryNum: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}__ct__Q3_2nn2sl11DataCreatorFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl11DataCreatorFv(
        arg1: *mut nn_sl_details_DataCreatorInternal,
    ) -> *mut nn_sl_details_DataCreatorInternal;
    #[link_name = "\u{1}Create__Q3_2nn2sl11DataCreatorFPQ3_2nn2sl16TransferableInfoPCQ3_2nn2sl9TitleInfoiRCQ3_2nn2sl18KillerNotificationRCQ3_2nn2sl9TitleInfoRQ3_2nn2sl18LaunchInfoDatabase"]
    pub fn nn_sl_details_Create__Q3_2nn2sl11DataCreatorFPQ3_2nn2sl16TransferableInfoPCQ3_2nn2sl9TitleInfoiRCQ3_2nn2sl18KillerNotificationRCQ3_2nn2sl9TitleInfoRQ3_2nn2sl18LaunchInfoDatabase(
        arg1: *mut nn_sl_details_DataCreatorInternal,
        arg2: *mut nn_sl_TransferableInfo,
        arg3: *const nn_sl_TitleInfo,
        arg4: ::core::ffi::c_int,
        arg5: *const nn_sl_KillerNotification,
        arg6: *const nn_sl_TitleInfo,
        arg7: *mut nn_sl_LaunchInfoDatabase,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl11DataCreatorFRQ3_2nn2sl17IIconInfoAccessorRQ3_2nn2sl20IAccountInfoAccessorRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl15ITitleIconCache"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl11DataCreatorFRQ3_2nn2sl17IIconInfoAccessorRQ3_2nn2sl20IAccountInfoAccessorRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl15ITitleIconCache(
        arg1: *mut nn_sl_details_DataCreatorInternal,
        arg2: *mut nn_sl_details_IIconInfoAccessorInternal,
        arg3: *mut nn_sl_details_IAccountInfoAccessorInternal,
        arg4: *mut nn_sl_details_ISettingAccessorInternal,
        arg5: *mut nn_sl_details_ITitleIconCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}GetDefaultUpdatePackageAccessor__Q2_2nn2slFv"]
    pub fn nn_sl_details_GetDefaultUpdatePackageAccessor__Q2_2nn2slFv(
    ) -> *mut nn_sl_details_IUpdatePackageAccessorInternal;
    #[link_name = "\u{1}__ct__Q3_2nn2sl9ConditionFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl9ConditionFv(
        arg1: *mut nn_sl_details_ConditionInternal,
    ) -> *mut nn_sl_details_ConditionInternal;
    #[link_name = "\u{1}GetEnability__Q3_2nn2sl9ConditionCFv"]
    pub fn nn_sl_details_GetEnability__Q3_2nn2sl9ConditionCFv(
        arg1: *mut nn_sl_details_ConditionInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}StoreCurrentTimeAsPreviousSendingTime__Q3_2nn2sl9ConditionCFv"]
    pub fn nn_sl_details_StoreCurrentTimeAsPreviousSendingTime__Q3_2nn2sl9ConditionCFv(
        arg1: *mut nn_sl_details_ConditionInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}NeedsUpdate__Q3_2nn2sl9ConditionCFv"]
    pub fn nn_sl_details_NeedsUpdate__Q3_2nn2sl9ConditionCFv(
        arg1: *mut nn_sl_details_ConditionInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}GetPreviousSendingTime__Q3_2nn2sl9ConditionCFPL"]
    pub fn nn_sl_details_GetPreviousSendingTime__Q3_2nn2sl9ConditionCFPL(
        arg1: *mut nn_sl_details_ConditionInternal,
        outTime: *mut i64,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl9ConditionFRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl22IUpdatePackageAccessorRQ3_2nn2sl20ISerializer__tm__2_LRQ3_2nn2sl13ITimeAccessor"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl9ConditionFRQ3_2nn2sl16ISettingAccessorRQ3_2nn2sl22IUpdatePackageAccessorRQ3_2nn2sl20ISerializer__tm__2_LRQ3_2nn2sl13ITimeAccessor(
        arg1: *mut nn_sl_details_ConditionInternal,
        arg2: *mut nn_sl_details_ISettingAccessorInternal,
        arg3: *mut nn_sl_details_IUpdatePackageAccessorInternal,
        arg4: *mut nn_sl_details_ISerializerInternal,
        arg5: *mut nn_sl_details_ITimeAccessorInternal,
    );
    #[link_name = "\u{1}__ct__Q3_2nn2sl14TitleIconCacheFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl14TitleIconCacheFv(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
    ) -> *mut nn_sl_details_ITitleIconCacheInternal;
    #[link_name = "\u{1}__dt__Q3_2nn2sl14TitleIconCacheFv"]
    pub fn nn_sl_details___dt__Q3_2nn2sl14TitleIconCacheFv(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
        arg2: ::core::ffi::c_int,
    ) -> *mut nn_sl_details_ITitleIconCacheInternal;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleIconCacheFi"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleIconCacheFi(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
        arg2: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}Initialize__Q3_2nn2sl14TitleIconCacheFiRQ3_2nn2sl17IIconInfoAccessorRQ3_2nn2sl38ISerializer__tm__19_Q3_2nn2sl8IconInfoRQ3_2nn2sl16ISettingAccessor"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl14TitleIconCacheFiRQ3_2nn2sl17IIconInfoAccessorRQ3_2nn2sl38ISerializer__tm__19_Q3_2nn2sl8IconInfoRQ3_2nn2sl16ISettingAccessor(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
        arg2: ::core::ffi::c_int,
        arg3: *mut nn_sl_details_IIconInfoAccessorInternal,
        arg4: *mut nn_sl_details_ISerializerInternal,
        arg5: *mut nn_sl_details_ISettingAccessorInternal,
    );
    #[link_name = "\u{1}Finalize__Q3_2nn2sl14TitleIconCacheFv"]
    pub fn nn_sl_details_Finalize__Q3_2nn2sl14TitleIconCacheFv(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
    );
    #[link_name = "\u{1}Get__Q3_2nn2sl14TitleIconCacheCFPQ3_2nn2sl8IconInfoi"]
    pub fn nn_sl_details_Get__Q3_2nn2sl14TitleIconCacheCFPQ3_2nn2sl8IconInfoi(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
        iconInfos: *mut nn_sl_IconInfo,
        num: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}Load__Q3_2nn2sl14TitleIconCacheFv"]
    pub fn nn_sl_details_Load__Q3_2nn2sl14TitleIconCacheFv(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}Update__Q3_2nn2sl14TitleIconCacheFPCQ3_2nn2sl9TitleInfoi"]
    pub fn nn_sl_details_Update__Q3_2nn2sl14TitleIconCacheFPCQ3_2nn2sl9TitleInfoi(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: ::core::ffi::c_int,
    ) -> nn_Result;
    #[link_name = "\u{1}Store__Q3_2nn2sl14TitleIconCacheCFv"]
    pub fn nn_sl_details_Store__Q3_2nn2sl14TitleIconCacheCFv(
        arg1: *mut nn_sl_details_TitleIconCacheInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}__ct__Q3_2nn2sl12CacheManagerFv"]
    pub fn nn_sl_details___ct__Q3_2nn2sl12CacheManagerFv(
        arg1: *mut nn_sl_details_CacheManagerInternal,
    ) -> *mut nn_sl_details_CacheManagerInternal;
    #[link_name = "\u{1}SetupInitialCache__Q3_2nn2sl12CacheManagerFv"]
    pub fn nn_sl_details_SetupInitialCache__Q3_2nn2sl12CacheManagerFv(
        arg1: *mut nn_sl_details_CacheManagerInternal,
    );
    #[link_name = "\u{1}GetKillerNotificationCache__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl18KillerNotificationPQ3_2nn2sl9TitleInfo"]
    pub fn nn_sl_details_GetKillerNotificationCache__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl18KillerNotificationPQ3_2nn2sl9TitleInfo(
        arg1: *mut nn_sl_details_CacheManagerInternal,
        arg2: *mut nn_sl_KillerNotification,
        arg3: *mut nn_sl_TitleInfo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetQuickStartCache__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl9TitleInfoi"]
    pub fn nn_sl_details_GetQuickStartCache__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl9TitleInfoi(
        arg1: *mut nn_sl_details_CacheManagerInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: ::core::ffi::c_int,
    ) -> nn_Result;
    #[link_name = "\u{1}Get__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl9TitleInfoiPQ3_2nn2sl18KillerNotificationT1"]
    pub fn nn_sl_details_Get__Q3_2nn2sl12CacheManagerFPQ3_2nn2sl9TitleInfoiPQ3_2nn2sl18KillerNotificationT1(
        arg1: *mut nn_sl_details_CacheManagerInternal,
        arg2: *mut nn_sl_TitleInfo,
        arg3: ::core::ffi::c_int,
        arg4: *mut nn_sl_KillerNotification,
        arg5: *mut nn_sl_TitleInfo,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn2sl12CacheManagerFRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfoRQ3_2nn2sl49ISerializer__tm__30_Q3_2nn2sl18KillerNotificationT1"]
    pub fn nn_sl_details_Initialize__Q3_2nn2sl12CacheManagerFRQ3_2nn2sl39ISerializer__tm__20_Q3_2nn2sl9TitleInfoRQ3_2nn2sl49ISerializer__tm__30_Q3_2nn2sl18KillerNotificationT1(
        arg1: *mut nn_sl_details_CacheManagerInternal,
        arg2: *mut nn_sl_details_ISerializerInternal,
        arg3: *mut nn_sl_details_ISerializerInternal,
        arg4: *mut nn_sl_details_ISerializerInternal,
    ) -> nn_Result;
    #[link_name = "\u{1}_ZN2nn2sl29GetDefaultAccountInfoAccessorEv"]
    pub fn nn_sl_GetDefaultAccountInfoAccessor() -> *mut nn_sl_details_IAccountInfoAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl36GetDefaultKillerNotificationAccessorEv"]
    pub fn nn_sl_GetDefaultKillerNotificationAccessor(
    ) -> *mut nn_sl_details_IKillerNotificationAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl35GetDefaultLaunchedTitleListAccessorENS0_29LaunchedTitleListAccessorTypeE"]
    pub fn nn_sl_GetDefaultLaunchedTitleListAccessor(
        type_: nn_sl_LaunchedTitleListAccessorType::Type,
    ) -> *mut nn_sl_details_ILaunchedTitleListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl35GetDefaultLaunchedTitleListAccessorEv"]
    pub fn nn_sl_GetDefaultLaunchedTitleListAccessor1(
    ) -> *mut nn_sl_details_ILaunchedTitleListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl28GetDefaultIconInfoSerializerEv"]
    pub fn nn_sl_GetDefaultIconInfoSerializer() -> *mut nn_sl_details_ISerializerBase;
    #[link_name = "\u{1}_ZN2nn2sl39GetDefaultQuickStartTitleInfoSerializerEv"]
    pub fn nn_sl_GetDefaultQuickStartTitleInfoSerializer() -> *mut nn_sl_details_ISerializerBase;
    #[link_name = "\u{1}_ZN2nn2sl38GetDefaultKillerNotificationSerializerEv"]
    pub fn nn_sl_GetDefaultKillerNotificationSerializer() -> *mut nn_sl_details_ISerializerBase;
    #[link_name = "\u{1}_ZN2nn2sl33GetDefaultJumpTitleInfoSerializerEv"]
    pub fn nn_sl_GetDefaultJumpTitleInfoSerializer() -> *mut nn_sl_details_ISerializerBase;
    #[link_name = "\u{1}_ZN2nn2sl39GetDefaultPreviousSendingTimeSerializerEv"]
    pub fn nn_sl_GetDefaultPreviousSendingTimeSerializer() -> *mut nn_sl_details_ISerializerBase;
    #[link_name = "\u{1}_ZN2nn2sl25GetDefaultSettingAccessorEv"]
    pub fn nn_sl_GetDefaultSettingAccessor() -> *mut nn_sl_details_ISettingAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl22GetDefaultTimeAccessorEv"]
    pub fn nn_sl_GetDefaultTimeAccessor() -> *mut nn_sl_details_ITimeAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl49GetDefaultKillerNotificationTransferRecordManagerEv"]
    pub fn nn_sl_GetDefaultKillerNotificationTransferRecordManager(
    ) -> *mut nn_sl_details_IKillerNotificationTransferRecordManagerBase;
    #[link_name = "\u{1}_ZN2nn2sl33GetDefaultDiscCachedTitleAccessorEv"]
    pub fn nn_sl_GetDefaultDiscCachedTitleAccessor(
    ) -> *mut nn_sl_details_IDiscCachedTitleAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl36GetDefaultInstalledTitleListAccessorEv"]
    pub fn nn_sl_GetDefaultInstalledTitleListAccessor(
    ) -> *mut nn_sl_details_IInstalledTitleListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl26GetDefaultMetaInfoAccessorEv"]
    pub fn nn_sl_GetDefaultMetaInfoAccessor() -> *mut nn_sl_details_IMetaInfoAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl27GetDefaultTitleListAccessorEv"]
    pub fn nn_sl_GetDefaultTitleListAccessor() -> *mut nn_sl_details_ITitleListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl24GetDefaultTitleListCacheEv"]
    pub fn nn_sl_GetDefaultTitleListCache() -> *mut nn_sl_details_ITitleListCacheBase;
    #[link_name = "\u{1}_ZN2nn2sl17GetDrcTransferrerEv"]
    pub fn nn_sl_GetDrcTransferrer() -> *mut nn_sl_details_ITransferrerBase;
    #[link_name = "\u{1}_ZN2nn2sl35GetDefaultPreferentialTitleAccessorEv"]
    pub fn nn_sl_GetDefaultPreferentialTitleAccessor(
    ) -> *mut nn_sl_details_IPreferentialTitleAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl27GetDefaultBlackListAccessorEv"]
    pub fn nn_sl_GetDefaultBlackListAccessor() -> *mut nn_sl_details_IBlackListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl30GetDefaultDefaultTitleAccessorEv"]
    pub fn nn_sl_GetDefaultDefaultTitleAccessor() -> *mut nn_sl_details_IDefaultTitleAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl27GetDefaultWhiteListAccessorEv"]
    pub fn nn_sl_GetDefaultWhiteListAccessor() -> *mut nn_sl_details_IWhiteListAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl26GetDefaultIconInfoAccessorEv"]
    pub fn nn_sl_GetDefaultIconInfoAccessor() -> *mut nn_sl_details_IIconInfoAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl24GetDefaultTitleIconCacheEv"]
    pub fn nn_sl_GetDefaultTitleIconCache() -> *mut nn_sl_details_ITitleIconCacheBase;
    #[link_name = "\u{1}_ZN2nn2sl31GetDefaultUpdatePackageAccessorEv"]
    pub fn nn_sl_GetDefaultUpdatePackageAccessor() -> *mut nn_sl_details_IUpdatePackageAccessorBase;
    #[link_name = "\u{1}_ZN2nn2sl48GetDefaultKillerNotificationTransferRecordStreamEv"]
    pub fn nn_sl_GetDefaultKillerNotificationTransferRecordStream() -> *mut nn_sl_details_IStreamBase;
    #[link_name = "\u{1}Compare__Q3_2nn3spm8VolumeIdCFRCQ3_2nn3spm8VolumeId"]
    pub fn nn_spm_VolumeId_Compare(
        this: *const nn_spm_VolumeId,
        other: *const nn_spm_VolumeId,
    ) -> i32;
    #[link_name = "\u{1}Initialize__Q2_2nn3spmFv"]
    pub fn nn_spm_Initialize();
    #[link_name = "\u{1}Finalize__Q2_2nn3spmFv"]
    pub fn nn_spm_Finalize();
    #[link_name = "\u{1}SetAutoFatal__Q2_2nn3spmFb"]
    pub fn nn_spm_SetAutoFatal(enabled: bool);
    #[link_name = "\u{1}SetExtendedStorage__Q2_2nn3spmFQ3_2nn3spm12StorageIndex"]
    pub fn nn_spm_SetExtendedStorage(index: *mut nn_spm_StorageIndex) -> i32;
    #[link_name = "\u{1}SetDefaultExtendedStorageVolumeId__Q2_2nn3spmFRCQ3_2nn3spm8VolumeId"]
    pub fn nn_spm_SetDefaultExtendedStorageVolumeId(id: *const nn_spm_VolumeId);
    #[link_name = "\u{1}GetDefaultExtendedStorageVolumeId__Q2_2nn3spmFv"]
    pub fn nn_spm_GetDefaultExtendedStorageVolumeId(id: *mut nn_spm_VolumeId);
    #[link_name = "\u{1}GetPreviousExtendedStorageVolumeId__Q2_2nn3spmFPbPQ3_2nn3spm8VolumeId"]
    pub fn nn_spm_GetPreviousExtendedStorageVolumeId(
        arg1: *mut bool,
        outVolumeId: *mut nn_spm_VolumeId,
    ) -> bool;
    #[link_name = "\u{1}FindStorageByVolumeId__Q2_2nn3spmFPQ3_2nn3spm12StorageIndexRCQ3_2nn3spm8VolumeId"]
    pub fn nn_spm_FindStorageByVolumeId(
        outIndex: *mut nn_spm_StorageIndex,
        volumeId: *const nn_spm_VolumeId,
    ) -> bool;
    #[link_name = "\u{1}GetExtendedStorageIndex__Q2_2nn3spmFPQ3_2nn3spm12StorageIndex"]
    pub fn nn_spm_GetExtendedStorageIndex(outIndex: *mut nn_spm_StorageIndex) -> i32;
    #[link_name = "\u{1}GetStorageList__Q2_2nn3spmFPQ3_2nn3spm15StorageListItemUi"]
    pub fn nn_spm_GetStorageList(items: *mut nn_spm_StorageListItem, maxNumItems: u32) -> i32;
    #[link_name = "\u{1}GetStorageInfo__Q2_2nn3spmFPQ3_2nn3spm11StorageInfoQ3_2nn3spm12StorageIndex"]
    pub fn nn_spm_GetStorageInfo(
        outInfo: *mut nn_spm_StorageInfo,
        index: *mut nn_spm_StorageIndex,
    ) -> i32;
    #[link_name = "\u{1}ReadRawStorageHead512__Q2_2nn3spmFQ3_2nn3spm12StorageIndexPc"]
    pub fn nn_spm_ReadRawStorageHead512(
        index: *mut nn_spm_StorageIndex,
        outBuffer: *mut ::core::ffi::c_char,
    ) -> i32;
    #[link_name = "\u{1}IsStorageMaybePcFormatted__Q2_2nn3spmFPbQ3_2nn3spm12StorageIndex"]
    pub fn nn_spm_IsStorageMaybePcFormatted(
        isPcFormatted: *mut bool,
        index: *mut nn_spm_StorageIndex,
    ) -> i32;
    #[link_name = "\u{1}IsStorageMaybeWfsFormatted__Q2_2nn3spmFPbQ3_2nn3spm12StorageIndex"]
    pub fn nn_spm_IsStorageMaybeWfsFormatted(
        isWfsFormatted: *mut bool,
        index: *mut nn_spm_StorageIndex,
    ) -> i32;
    #[link_name = "\u{1}Initialize__Q2_2nn2acFv"]
    pub fn nn_ac_detail_Initialize__Q2_2nn2acFv() -> nn_Result;
    #[link_name = "\u{1}Finalize__Q2_2nn2acFv"]
    pub fn nn_ac_detail_Finalize__Q2_2nn2acFv();
    #[link_name = "\u{1}Connect__Q2_2nn2acFv"]
    pub fn nn_ac_detail_Connect__Q2_2nn2acFv() -> nn_Result;
    #[link_name = "\u{1}ConnectAsync__Q2_2nn2acFv"]
    pub fn nn_ac_detail_ConnectAsync__Q2_2nn2acFv() -> nn_Result;
    #[link_name = "\u{1}Close__Q2_2nn2acFv"]
    pub fn nn_ac_detail_Close__Q2_2nn2acFv() -> nn_Result;
    #[link_name = "\u{1}GetCloseStatus__Q2_2nn2acFPQ3_2nn2ac6Status"]
    pub fn nn_ac_detail_GetCloseStatus__Q2_2nn2acFPQ3_2nn2ac6Status() -> nn_Result;
    #[link_name = "\u{1}GetStartupId__Q2_2nn2acFPQ3_2nn2ac11ConfigIdNum"]
    pub fn nn_ac_detail_GetStartupId__Q2_2nn2acFPQ3_2nn2ac11ConfigIdNum(
        id: *mut nn_ac_ConfigIdNum,
    ) -> nn_Result;
    #[link_name = "\u{1}Connect__Q2_2nn2acFQ3_2nn2ac11ConfigIdNum"]
    pub fn nn_ac_detail_Connect__Q2_2nn2acFQ3_2nn2ac11ConfigIdNum(
        id: nn_ac_ConfigIdNum,
    ) -> nn_Result;
    #[link_name = "\u{1}GetAssignedAddress__Q2_2nn2acFPUl"]
    pub fn nn_ac_detail_GetAssignedAddress__Q2_2nn2acFPUl(ip: *mut u32) -> nn_Result;
    #[link_name = "\u{1}AllowToConnect__Q3_2nn3uds4CafeFv"]
    pub fn nn_uds_Cafe_AllowToConnect() -> nn_Result;
    #[link_name = "\u{1}AllowToSpectate__Q3_2nn3uds4CafeFv"]
    pub fn nn_uds_Cafe_AllowToSpectate() -> nn_Result;
    #[link_name = "\u{1}Attach__Q3_2nn3uds4CafeFPQ4_2nn3uds4Cafe18EndpointDescriptorUsUcUi"]
    pub fn nn_uds_Cafe_Attach(
        fd: *mut nn_uds_Cafe_EndpointDescriptor,
        networkNodeId: u16,
        dataChannel: u8,
        recvBufferSize: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}CreateLocalCommunicationId__Q3_2nn3uds4CafeFUib"]
    pub fn nn_uds_Cafe_CreateLocalCommunicationId(uniqueId: u32, unknown: bool) -> u32;
    #[link_name = "\u{1}CreateEndpoint__Q3_2nn3uds4CafeFPQ4_2nn3uds4Cafe18EndpointDescriptor"]
    pub fn nn_uds_Cafe_CreateEndpoint(fd: *mut nn_uds_Cafe_EndpointDescriptor) -> nn_Result;
    #[link_name = "\u{1}CreateNetwork__Q3_2nn3uds4CafeFUcT1UiPCcT3T1"]
    pub fn nn_uds_Cafe_CreateNetwork(
        id8: u8,
        maxNodes: u8,
        localCommunicationId: u32,
        passphrase: *const ::core::ffi::c_char,
        passphraseSize: u32,
        channel: u8,
    ) -> nn_Result;
    #[link_name = "\u{1}CreateNetwork__Q3_2nn3uds4CafeFUcT1UiPCcT3T1PCvT3"]
    pub fn nn_uds_Cafe_CreateNetwork1(
        id8: u8,
        maxNodes: u8,
        localCommunicationId: u32,
        passphrase: *const ::core::ffi::c_char,
        passphraseSize: u32,
        channel: u8,
        appData: *const ::core::ffi::c_void,
        appDataSize: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}CreateNetwork__Q3_2nn3uds4CafeFUcT1UiPCcT3bT1PCvT3"]
    pub fn nn_uds_Cafe_CreateNetwork2(
        id8: u8,
        maxNodes: u8,
        localCommunicationId: u32,
        passphrase: *const ::core::ffi::c_char,
        passphraseSize: u32,
        unused: bool,
        channel: u8,
        appData: *const ::core::ffi::c_void,
        appDataSize: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}DestroyEndpoint__Q3_2nn3uds4CafeFPQ4_2nn3uds4Cafe18EndpointDescriptor"]
    pub fn nn_uds_Cafe_DestroyEndpoint(fd: *mut nn_uds_Cafe_EndpointDescriptor) -> nn_Result;
    #[link_name = "\u{1}DestroyNetwork__Q3_2nn3uds4CafeFv"]
    pub fn nn_uds_Cafe_DestroyNetwork() -> nn_Result;
    #[link_name = "\u{1}DisallowToConnect__Q3_2nn3uds4CafeFb"]
    pub fn nn_uds_Cafe_DisallowToConnect(unknown: bool) -> nn_Result;
    #[link_name = "\u{1}EjectClient__Q3_2nn3uds4CafeFUs"]
    pub fn nn_uds_Cafe_EjectClient(networkNodeId: u16) -> nn_Result;
    #[link_name = "\u{1}EjectSpectator__Q3_2nn3uds4CafeFv"]
    pub fn nn_uds_Cafe_EjectSpectator() -> nn_Result;
    #[link_name = "\u{1}Finalize__Q3_2nn3uds4CafeFv"]
    pub fn nn_uds_Cafe_Finalize();
    #[link_name = "\u{1}GetApplicationDataFromBeacon__Q3_2nn3uds4CafeFPvPUiUi"]
    pub fn nn_uds_Cafe_GetApplicationDataFromBeacon(
        appData: *mut ::core::ffi::c_void,
        readSize: *mut u32,
        size: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}GetChannel__Q3_2nn3uds4CafeFPUc"]
    pub fn nn_uds_Cafe_GetChannel(channel: *mut u8) -> nn_Result;
    #[link_name = "\u{1}GetConnectionStatus__Q3_2nn3uds4CafeFPQ4_2nn3uds4Cafe16ConnectionStatus"]
    pub fn nn_uds_Cafe_GetConnectionStatus(status: *mut nn_uds_Cafe_ConnectionStatus) -> nn_Result;
    #[link_name = "\u{1}GetNodeInformation__Q3_2nn3uds4CafeFPQ4_2nn3uds4Cafe15NodeInformationUs"]
    pub fn nn_uds_Cafe_GetNodeInformation(
        info: *mut nn_uds_Cafe_NodeInformation,
        networkNodeId: u16,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn3uds4CafeFPvUi"]
    pub fn nn_uds_Cafe_Initialize(
        workMemory: *mut ::core::ffi::c_void,
        workMemorySize: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q3_2nn3uds4CafeFPvUiPQ4_2nn3cfg3CTR8UserName"]
    pub fn nn_uds_Cafe_Initialize1(
        workMemory: *mut ::core::ffi::c_void,
        workMemorySize: u32,
        username: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result;
    #[link_name = "\u{1}PollStateChange__Q3_2nn3uds4CafeFUc"]
    pub fn nn_uds_Cafe_PollStateChange(flags: u8) -> nn_Result;
    #[link_name = "\u{1}ReceiveFrom__Q3_2nn3uds4CafeFRCQ4_2nn3uds4Cafe18EndpointDescriptorPvPUiPUsUiUc"]
    pub fn nn_uds_Cafe_ReceiveFrom(
        fd: *const nn_uds_Cafe_EndpointDescriptor,
        buf: *mut ::core::ffi::c_void,
        receivedSize: *mut u32,
        networkNodeId: *mut u16,
        size: u32,
        flags: u8,
    ) -> nn_Result;
    #[link_name = "\u{1}Receive__Q3_2nn3uds4CafeFRCQ4_2nn3uds4Cafe18EndpointDescriptorPvPUiUiUc"]
    pub fn nn_uds_Cafe_Receive(
        fd: *const nn_uds_Cafe_EndpointDescriptor,
        buf: *mut ::core::ffi::c_void,
        receivedSize: *mut u32,
        size: u32,
        flags: u8,
    ) -> nn_Result;
    #[link_name = "\u{1}SendTo__Q3_2nn3uds4CafeFRCQ4_2nn3uds4Cafe18EndpointDescriptorPCvUiUsUcT5"]
    pub fn nn_uds_Cafe_SendTo(
        fd: *const nn_uds_Cafe_EndpointDescriptor,
        buf: *const ::core::ffi::c_void,
        size: u32,
        destNodeId: u16,
        dataChannel: u8,
        flags: u8,
    ) -> nn_Result;
    #[link_name = "\u{1}SetApplicationDataToBeacon__Q3_2nn3uds4CafeFPCvUi"]
    pub fn nn_uds_Cafe_SetApplicationDataToBeacon(
        appData: *const ::core::ffi::c_void,
        size: u32,
    ) -> nn_Result;
    #[link_name = "\u{1}AcceptClient__Q4_2nn3dlp4Cafe6ServerSFUs"]
    pub fn nn_dlp_Cafe_Server_AcceptClient(nodeId: u16) -> nn_Result;
    #[link_name = "\u{1}CloseSessions__Q4_2nn3dlp4Cafe6ServerSFv"]
    pub fn nn_dlp_Cafe_Server_CloseSessions() -> nn_Result;
    #[link_name = "\u{1}DisconnectClient__Q4_2nn3dlp4Cafe6ServerSFUs"]
    pub fn nn_dlp_Cafe_Server_DisconnectClient(nodeId: u16) -> nn_Result;
    #[link_name = "\u{1}Finalize__Q4_2nn3dlp4Cafe6ServerSFv"]
    pub fn nn_dlp_Cafe_Server_Finalize() -> nn_Result;
    #[link_name = "\u{1}GetClientInfo__Q4_2nn3dlp4Cafe6ServerSFPQ4_2nn3uds4Cafe15NodeInformationUs"]
    pub fn nn_dlp_Cafe_Server_GetClientInfo(
        clientInfo: *mut nn_uds_Cafe_NodeInformation,
        nodeId: u16,
    ) -> nn_Result;
    #[link_name = "\u{1}GetClientState__Q4_2nn3dlp4Cafe6ServerSFPQ4_2nn3dlp4Cafe11ClientStateUs"]
    pub fn nn_dlp_Cafe_Server_GetClientState(
        state: *mut nn_dlp_Cafe_ClientState::Type,
        nodeId: u16,
    ) -> nn_Result;
    #[link_name = "\u{1}GetClientState__Q4_2nn3dlp4Cafe6ServerSFPQ4_2nn3dlp4Cafe11ClientStatePUiT2Us"]
    pub fn nn_dlp_Cafe_Server_GetClientState1(
        state: *mut nn_dlp_Cafe_ClientState::Type,
        unitsTotal: *mut u32,
        unitsReceived: *mut u32,
        nodeId: u16,
    ) -> nn_Result;
    #[link_name = "\u{1}GetConnectingClients__Q4_2nn3dlp4Cafe6ServerSFPUsT1Us"]
    pub fn nn_dlp_Cafe_Server_GetConnectingClients(
        receivedLength: *mut u16,
        connectingClients: *mut u16,
        length: u16,
    ) -> nn_Result;
    #[link_name = "\u{1}GetState__Q4_2nn3dlp4Cafe6ServerSFPQ4_2nn3dlp4Cafe11ServerState"]
    pub fn nn_dlp_Cafe_Server_GetState(state: *mut nn_dlp_Cafe_ServerState::Type) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q4_2nn3dlp4Cafe6ServerSFUcUiT1PQ4_2nn3cfg3CTR8UserName"]
    pub fn nn_dlp_Cafe_Server_Initialize(
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q4_2nn3dlp4Cafe6ServerSFPbUcUiT2PQ4_2nn3cfg3CTR8UserName"]
    pub fn nn_dlp_Cafe_Server_Initialize1(
        dupNoticeNeed: *mut bool,
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result;
    #[link_name = "\u{1}OpenSessions__Q4_2nn3dlp4Cafe6ServerSFbUc"]
    pub fn nn_dlp_Cafe_Server_OpenSessions(isManualAccept: bool, channel: u8) -> nn_Result;
    #[link_name = "\u{1}PollStateChange__Q4_2nn3dlp4Cafe6ServerSFUc"]
    pub fn nn_dlp_Cafe_Server_PollStateChange(flags: u8) -> nn_Result;
    #[link_name = "\u{1}RebootAllClients__Q4_2nn3dlp4Cafe6ServerSFPCc"]
    pub fn nn_dlp_Cafe_Server_RebootAllClients(passPhrase: *const ::core::ffi::c_char)
        -> nn_Result;
    #[link_name = "\u{1}StartDistribute__Q4_2nn3dlp4Cafe6ServerSFv"]
    pub fn nn_dlp_Cafe_Server_StartDistribution() -> nn_Result;
    #[link_name = "\u{1}GetInternalState__Q4_2nn3dlp4Cafe13ServerPrivateSFPQ4_2nn3dlp4Cafe11ServerState"]
    pub fn nn_dlp_Cafe_ServerPrivate_GetInternalState(
        state: *mut nn_dlp_Cafe_ServerState::Type,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q4_2nn3dlp4Cafe13ServerPrivateSFUcUiT1N22PQ4_2nn3cfg3CTR8UserName"]
    pub fn nn_dlp_Cafe_ServerPrivate_Initialize(
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        blockBufferSize: u32,
        blockBufferNum: u32,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q4_2nn3dlp4Cafe13ServerPrivateSFPbUcUiT2N23PQ4_2nn3cfg3CTR8UserName"]
    pub fn nn_dlp_Cafe_ServerPrivate_Initialize1(
        dupNoticeNeed: *mut bool,
        maxClientNum: u8,
        uniqueId: u32,
        childIndex: u8,
        blockBufferSize: u32,
        blockBufferNum: u32,
        userName: *mut nn_cfg_CTR_UserName,
    ) -> nn_Result;
    #[link_name = "\u{1}Initialize__Q2_2nn3pdmFv"]
    pub fn nn_pdm_Initialize() -> u32;
    #[link_name = "\u{1}Finalize__Q2_2nn3pdmFv"]
    pub fn nn_pdm_Finalize();
    #[link_name = "\u{1}CloseAllFiles__Q2_2nn3pdmFv"]
    pub fn nn_pdm_CloseAllFiles();
    #[link_name = "\u{1}Convert__Q2_2nn3pdmFi"]
    pub fn nn_pdm_Convert(userId: u32) -> u32;
    #[link_name = "\u{1}WaitForConvertDone__Q2_2nn3pdmFv"]
    pub fn nn_pdm_WaitForConvertDone() -> u32;
    #[link_name = "\u{1}GetPlayDiaryMaxLength__Q2_2nn3pdmFPi"]
    pub fn nn_pdm_GetPlayDiaryMaxLength(outMaxLength: *mut u32) -> u32;
    #[link_name = "\u{1}GetPlayDiaryLength__Q2_2nn3pdmFPii"]
    pub fn nn_pdm_GetPlayDiaryLength(outLength: *mut u32, userId: u32) -> u32;
    #[link_name = "\u{1}GetPlayDiaryStart__Q2_2nn3pdmFPii"]
    pub fn nn_pdm_GetPlayDiaryStart(outStart: *mut u32, userId: u32) -> u32;
    #[link_name = "\u{1}GetPlayDiary__Q2_2nn3pdmFPiPQ3_2nn3pdm9PlayDiaryiT3"]
    pub fn nn_pdm_GetPlayDiary(
        outAmount: *mut u32,
        outPlayDiaries: *mut nn_pdm_PlayDiary,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}GetPlayDiary__Q2_2nn3pdmFPQ3_2nn3pdm9PlayDiaryiT2"]
    pub fn nn_pdm_GetPlayDiary1(
        outPlayDiaries: *mut nn_pdm_PlayDiary,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}GetPlayEventMaxLength__Q2_2nn3pdmFPi"]
    pub fn nn_pdm_GetPlayEventMaxLength(outMaxLength: *mut u32) -> u32;
    #[link_name = "\u{1}GetPlayEvent__Q2_2nn3pdmFPiPQ3_2nn3pdm9PlayEventiT3"]
    pub fn nn_pdm_GetPlayEvent(
        outAmount: *mut u32,
        outPlayEvents: *mut nn_pdm_PlayEvent,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}GetPlayLogMaxLength__Q2_2nn3pdmFPi"]
    pub fn nn_pdm_GetPlayLogMaxLength(outMaxLength: *mut u32) -> u32;
    #[link_name = "\u{1}GetPlayLogLength__Q2_2nn3pdmFPii"]
    pub fn nn_pdm_GetPlayLogLength(outLength: *mut u32, userId: u32) -> u32;
    #[link_name = "\u{1}GetPlayLogStart__Q2_2nn3pdmFPii"]
    pub fn nn_pdm_GetPlayLogStart(outStart: *mut u32, userId: u32) -> u32;
    #[link_name = "\u{1}GetPlayLog__Q2_2nn3pdmFPiPQ3_2nn3pdm7PlayLogiT3"]
    pub fn nn_pdm_GetPlayLog(
        outAmount: *mut u32,
        outPlayLogs: *mut nn_pdm_PlayLog,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}GetPlayLog__Q2_2nn3pdmFPQ3_2nn3pdm7PlayLogiT2"]
    pub fn nn_pdm_GetPlayLog1(outPlayLogs: *mut nn_pdm_PlayLog, userId: u32, amount: u32) -> u32;
    #[link_name = "\u{1}GetPlayStatsMaxLength__Q2_2nn3pdmFPi"]
    pub fn nn_pdm_GetPlayStatsMaxLength(outMaxLength: *mut u32) -> u32;
    #[link_name = "\u{1}GetPlayStatsLength__Q2_2nn3pdmFPii"]
    pub fn nn_pdm_GetPlayStatsLength(outLength: *mut u32, userId: u32) -> u32;
    #[link_name = "\u{1}GetPlayStatsOfTitleId__Q2_2nn3pdmFPQ3_2nn3pdm9PlayStatsiUL"]
    pub fn nn_pdm_GetPlayStatsOfTitleId(
        outPlayStats: *mut nn_pdm_PlayStats,
        userId: u32,
        titleId: u64,
    ) -> u32;
    #[link_name = "\u{1}GetPlayStats__Q2_2nn3pdmFPiPQ3_2nn3pdm9PlayStatsiT3"]
    pub fn nn_pdm_GetPlayStats(
        outAmount: *mut u32,
        outPlayStats: *mut nn_pdm_PlayStats,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}GetPlayStats__Q2_2nn3pdmFPQ3_2nn3pdm9PlayStatsiT2"]
    pub fn nn_pdm_GetPlayStats1(
        outPlayStats: *mut nn_pdm_PlayStats,
        userId: u32,
        amount: u32,
    ) -> u32;
    #[link_name = "\u{1}NotifySetTimeBeginEvent__Q2_2nn3pdmFv"]
    pub fn nn_pdm_NotifySetTimeBeginEvent();
    #[link_name = "\u{1}NotifySetTimeEndEvent__Q2_2nn3pdmFv"]
    pub fn nn_pdm_NotifySetTimeEndEvent();
    #[link_name = "\u{1}Initialize__Q2_2nn3actFv"]
    pub fn nn_act_Initialize() -> nn_Result;
    #[link_name = "\u{1}Finalize__Q2_2nn3actFv"]
    pub fn nn_act_Finalize() -> nn_Result;
    #[link_name = "\u{1}GetAccountId__Q2_2nn3actFPc"]
    pub fn nn_act_GetAccountId(outAccountId: *mut ::core::ffi::c_char) -> nn_Result;
    #[link_name = "\u{1}GetAccountIdEx__Q2_2nn3actFPcUc"]
    pub fn nn_act_GetAccountIdEx(
        outAccountId: *mut ::core::ffi::c_char,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetBirthday__Q2_2nn3actFPUsPUcT2"]
    pub fn nn_act_GetBirthday(outYear: *mut u16, outMonth: *mut u8, outDay: *mut u8) -> nn_Result;
    #[link_name = "\u{1}GetBirthdayEx__Q2_2nn3actFPUsPUcT2Uc"]
    pub fn nn_act_GetBirthdayEx(
        outYear: *mut u16,
        outMonth: *mut u8,
        outDay: *mut u8,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetDefaultAccount__Q2_2nn3actFv"]
    pub fn nn_act_GetDefaultAccount() -> nn_act_SlotNo;
    #[link_name = "\u{1}GetDeviceHash__Q2_2nn3actFPUL"]
    pub fn nn_act_GetDeviceHash(outHash: *mut ::core::ffi::c_char) -> nn_Result;
    #[link_name = "\u{1}LoadConsoleAccount__Q2_2nn3actFUc13ACTLoadOptionPCcb"]
    pub fn nn_act_LoadConsoleAccount(
        slot: nn_act_SlotNo,
        unk1: nn_act_ACTLoadOption,
        unk2: *const ::core::ffi::c_char,
        unk3: bool,
    ) -> nn_Result;
    #[link_name = "\u{1}GetMii__Q2_2nn3actFP12FFLStoreData"]
    pub fn nn_act_GetMii(mii: *mut FFLStoreData) -> nn_Result;
    #[link_name = "\u{1}GetMiiEx__Q2_2nn3actFP12FFLStoreDataUc"]
    pub fn nn_act_GetMiiEx(mii: *mut FFLStoreData, slot: nn_act_SlotNo) -> nn_Result;
    #[link_name = "\u{1}GetMiiImageEx__Q2_2nn3actFPUiPvUi15ACTMiiImageTypeUc"]
    pub fn nn_act_GetMiiImageEx(
        outImageSize: *mut usize,
        buffer: *mut ::core::ffi::c_void,
        bufferSize: usize,
        unk: ::core::ffi::c_int,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetMiiName__Q2_2nn3actFPw"]
    pub fn nn_act_GetMiiName(outName: *mut i16) -> nn_Result;
    #[link_name = "\u{1}GetMiiNameEx__Q2_2nn3actFPwUc"]
    pub fn nn_act_GetMiiNameEx(outName: *mut i16, slot: nn_act_SlotNo) -> nn_Result;
    #[link_name = "\u{1}GetNfsPassword__Q2_2nn3actFPc"]
    pub fn nn_act_GetNfsPassword(outPassword: *mut ::core::ffi::c_char) -> nn_Result;
    #[link_name = "\u{1}GetNfsPasswordEx__Q2_2nn3actFPcUc"]
    pub fn nn_act_GetNfsPasswordEx(
        outPassword: *mut ::core::ffi::c_char,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetNumOfAccounts__Q2_2nn3actFv"]
    pub fn nn_act_GetNumOfAccounts() -> u8;
    #[link_name = "\u{1}GetParentalControlSlotNo__Q2_2nn3actFv"]
    pub fn nn_act_GetParentalControlsSlotNo() -> nn_act_SlotNo;
    #[link_name = "\u{1}GetParentalControlSlotNoEx__Q2_2nn3actFPUcUc"]
    pub fn nn_act_GetParentalControlsSlotNoEx(
        outSlotNo: *mut nn_act_SlotNo,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetPersistentId__Q2_2nn3actFv"]
    pub fn nn_act_GetPersistentId() -> nn_act_PersistentId;
    #[link_name = "\u{1}GetPersistentIdEx__Q2_2nn3actFUc"]
    pub fn nn_act_GetPersistentIdEx(slot: nn_act_SlotNo) -> nn_act_PersistentId;
    #[link_name = "\u{1}GetPrincipalId__Q2_2nn3actFv"]
    pub fn nn_act_GetPrincipalId() -> nn_act_PrincipalId;
    #[link_name = "\u{1}GetPrincipalIdEx__Q2_2nn3actFPUiUc"]
    pub fn nn_act_GetPrincipalIdEx(
        outId: *mut nn_act_PrincipalId,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetSimpleAddressId__Q2_2nn3actFv"]
    pub fn nn_act_GetSimpleAddressId() -> nn_act_SimpleAddressId;
    #[link_name = "\u{1}GetSimpleAddressIdEx__Q2_2nn3actFPUiUc"]
    pub fn nn_act_GetSimpleAddressId1(
        outId: *mut nn_act_SimpleAddressId,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetSlotNo__Q2_2nn3actFv"]
    pub fn nn_act_GetSlotNo() -> nn_act_SlotNo;
    #[link_name = "\u{1}GetTransferableId__Q2_2nn3actFUi"]
    pub fn nn_act_GetTransferableId(unk1: u32) -> nn_act_TransferrableId;
    #[link_name = "\u{1}GetTransferableIdEx__Q2_2nn3actFPULUiUc"]
    pub fn nn_act_GetTransferableIdEx(
        outId: *mut nn_act_TransferrableId,
        unk1: u32,
        slot: nn_act_SlotNo,
    ) -> nn_Result;
    #[link_name = "\u{1}GetUuidEx__Q2_2nn3actFP7ACTUuidUcUi"]
    pub fn nn_act_GetUuidEx(
        outUuid: *mut ::core::ffi::c_char,
        slot: nn_act_SlotNo,
        unk1: i32,
    ) -> nn_Result;
    #[link_name = "\u{1}GetUuidEx__Q2_2nn3actFP7ACTUuidUc"]
    pub fn nn_act_GetUuidEx1(outUuid: *mut ::core::ffi::c_char, slot: nn_act_SlotNo) -> nn_Result;
    #[link_name = "\u{1}GetUuid__Q2_2nn3actFP7ACTUuidUi"]
    pub fn nn_act_GetUuid(outUuid: *mut ::core::ffi::c_char, unk1: i32) -> nn_Result;
    #[link_name = "\u{1}GetUuid__Q2_2nn3actFP7ACTUuid"]
    pub fn nn_act_GetUuid1(outUuid: *mut ::core::ffi::c_char) -> nn_Result;
    #[link_name = "\u{1}HasNfsAccount__Q2_2nn3actFv"]
    pub fn nn_act_HasNfsAccount() -> BOOL;
    #[link_name = "\u{1}IsCommitted__Q2_2nn3actFv"]
    pub fn nn_act_IsCommitted() -> BOOL;
    #[link_name = "\u{1}IsCommittedEx__Q2_2nn3actFUc"]
    pub fn nn_act_IsCommittedEx(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}IsPasswordCacheEnabled__Q2_2nn3actFv"]
    pub fn nn_act_IsPasswordCacheEnabled() -> BOOL;
    #[link_name = "\u{1}IsPasswordCacheEnabledEx__Q2_2nn3actFUc"]
    pub fn nn_act_IsPasswordCacheEnabledEx(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}IsNetworkAccount__Q2_2nn3actFv"]
    pub fn nn_act_IsNetworkAccount() -> BOOL;
    #[link_name = "\u{1}IsNetworkAccountEx__Q2_2nn3actFUc"]
    pub fn nn_act_IsNetworkAccountEx(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}IsServerAccountActive__Q2_2nn3actFv"]
    pub fn nn_act_IsServerAccountActive() -> BOOL;
    #[link_name = "\u{1}IsServerAccountActiveEx__Q2_2nn3actFUc"]
    pub fn nn_act_IsServerAccountActiveEx(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}IsServerAccountDeleted__Q2_2nn3actFv"]
    pub fn nn_act_IsServerAccountDeleted() -> BOOL;
    #[link_name = "\u{1}IsServerAccountDeletedEx__Q2_2nn3actFUc"]
    pub fn nn_act_IsServerAccountDeletedEx(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}IsSlotOccupied__Q2_2nn3actFUc"]
    pub fn nn_act_IsSlotOccupied(slot: nn_act_SlotNo) -> BOOL;
    #[link_name = "\u{1}AcceptFriendRequestAsync__Q2_2nn2fpFULPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AcceptFriendRequestAsync(
        arg1: nn_act_LocalFriendCode,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddBlackListAsync__Q2_2nn2fpFUiPCQ3_2nn2fp7GameKeyPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddBlackListAsync(
        arg1: nn_act_PrincipalId,
        arg2: *mut nn_fp_GameKey,
        arg3: nn_fp_FPAsyncCallback,
        arg4: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddBlackListAsync__Q2_2nn2fpFUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddBlackListAsync1(
        arg1: nn_act_PrincipalId,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddFriendAsync__Q2_2nn2fpFPCcPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddFriendAsync(
        nnid: *mut ::core::ffi::c_char,
        arg1: nn_fp_FPAsyncCallback,
        arg2: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddFriendAsync__Q2_2nn2fpFUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddFriendAsync1(
        arg1: nn_act_PrincipalId,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddFriendRequestAsync__Q2_2nn2fpFPCQ3_2nn2fp18RecentPlayRecordExPCwPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddFriendRequestAsync(
        arg1: *const nn_fp_RecentPlayRecordEx,
        arg2: *const u16,
        arg3: nn_fp_FPAsyncCallback,
        arg4: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddFriendRequestAsync__Q2_2nn2fpFUiUcPCwT2T3PFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddFriendRequestAsync1(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uchar,
        arg3: *const u16,
        arg4: ::core::ffi::c_uchar,
        arg5: *const u16,
        arg6: nn_fp_FPAsyncCallback,
        arg7: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddFriendRequestNoTitleAsync__Q2_2nn2fpFUiUcPCwT2T3PFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_AddFriendRequestNoTitleAsync(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uchar,
        arg3: *const u16,
        arg4: ::core::ffi::c_uchar,
        arg5: *const u16,
        arg6: nn_fp_FPAsyncCallback,
        arg7: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}AddRecentPlayRecordEx__Q2_2nn2fpFPCQ3_2nn2fp18RecentPlayRecordExUi"]
    pub fn nn_fp_AddRecentPlayRecordEx(
        arg1: *const nn_fp_RecentPlayRecordEx,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}AddRecentPlayRecord__Q2_2nn2fpFPCQ3_2nn2fp16RecentPlayRecordUi"]
    pub fn nn_fp_AddRecentPlayRecord(
        arg1: *const nn_fp_RecentPlayRecord,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}CancelFriendRequestAsync__Q2_2nn2fpFULPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_CancelFriendRequestAsync(
        arg1: nn_act_LocalFriendCode,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}CheckSettingStatusAsync__Q2_2nn2fpFPUcPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_CheckSettingStatusAsync(
        arg1: *mut ::core::ffi::c_uchar,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}ClearLedEvent__Q2_2nn2fpFv"]
    pub fn nn_fp_ClearLedEvent() -> nn_Result;
    #[link_name = "\u{1}DeleteFriendFlagsAsync__Q2_2nn2fpFPCUiUiT2PFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_DeleteFriendFlagsAsync(
        arg1: *const ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
        arg4: nn_fp_FPAsyncCallback,
        arg5: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}DeleteFriendRequestAsync__Q2_2nn2fpFULPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_DeleteFriendRequestAsync(
        arg1: nn_act_LocalFriendCode,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}DeleteRecentPlayRecordAll__Q2_2nn2fpFv"]
    pub fn nn_fp_DeleteRecentPlayRecordAll() -> nn_Result;
    #[link_name = "\u{1}DeleteSaveDirectory__Q2_2nn2fpFUi"]
    pub fn nn_fp_DeleteSaveDirectory(arg1: ::core::ffi::c_uint) -> nn_Result;
    #[link_name = "\u{1}DenyFriendRequestAsync__Q2_2nn2fpFULPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_DenyFriendRequestAsync(
        arg1: nn_act_LocalFriendCode,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}DetectNatPropertiesAsync__Q2_2nn2fpFPUcT1PUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_DetectNatPropertiesAsync(
        arg1: *mut ::core::ffi::c_uchar,
        arg2: *mut ::core::ffi::c_uchar,
        arg3: *mut ::core::ffi::c_uint,
        arg4: nn_fp_FPAsyncCallback,
        arg5: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}FinalizeAdmin__Q2_2nn2fpFv"]
    pub fn nn_fp_FinalizeAdmin() -> nn_Result;
    #[link_name = "\u{1}Finalize__Q2_2nn2fpFv"]
    pub fn nn_fp_Finalize() -> nn_Result;
    #[link_name = "\u{1}GetBasicInfoAsync__Q2_2nn2fpFPQ3_2nn2fp9BasicInfoPCUiUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_GetBasicInfoAsync(
        arg1: *mut nn_fp_BasicInfo,
        arg2: *mut ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
        arg4: nn_fp_FPAsyncCallback,
        arg5: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}GetBlackListAccountId__Q2_2nn2fpFPA17_cPCUiUi"]
    pub fn nn_fp_GetBlackListAccountId(
        outAccountIds: *mut ::core::ffi::c_char,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetBlackListAdditionalTime__Q2_2nn2fpFPQ3_2nn2fp8DateTimePCUiUi"]
    pub fn nn_fp_GetBlackListAdditionalTime(
        arg1: *mut nn_fp_DateTime,
        arg2: *mut ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetBlackListEx__Q2_2nn2fpFPQ3_2nn2fp20BlackListedPrincipalPCUiUi"]
    pub fn nn_fp_GetBlackListEx(
        outBlackList: *mut nn_fp_BlackListedPrincipal,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetBlackList__Q2_2nn2fpFPUiT1UiT3"]
    pub fn nn_fp_GetBlackList(
        outBlackListPrincipalBuffer: *mut nn_act_PrincipalId,
        outBlackListPrincipalBufferSize: *mut ::core::ffi::c_uint,
        arg1: ::core::ffi::c_uint,
        maxReadCount: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendAccountId__Q2_2nn2fpFPA17_cPCUiUi"]
    pub fn nn_fp_GetFriendAccountId(
        outAccountIdBuffer: *mut ::core::ffi::c_char,
        principalBuffer: *mut nn_act_PrincipalId,
        accountIdBufferSize: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendApprovalTime__Q2_2nn2fpFPQ3_2nn2fp8DateTimePCUiUi"]
    pub fn nn_fp_GetFriendApprovalTime(
        outDateTime: *mut nn_fp_DateTime,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendComment__Q2_2nn2fpFPQ3_2nn2fp7CommentPCUiUi"]
    pub fn nn_fp_GetFriendComment(
        outComment: *mut nn_fp_Comment,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendListAll__Q2_2nn2fpFPUiT1UiT3"]
    pub fn nn_fp_GetFriendListAll(
        arg1: *mut ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
        arg4: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendListEx__Q2_2nn2fpFPQ3_2nn2fp10FriendDataPCUiUi"]
    pub fn nn_fp_GetFriendListEx(
        outFriendData: *mut nn_fp_FriendData,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendList__Q2_2nn2fpFPUiT1UiT3"]
    pub fn nn_fp_GetFriendList(
        outPrincipalBuffer: *mut nn_act_PrincipalId,
        outPrincipalBufferReadCount: *mut ::core::ffi::c_uint,
        unkn: ::core::ffi::c_uint,
        principalBufferSize: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendMii__Q2_2nn2fpFP12FFLStoreDataPCUiUi"]
    pub fn nn_fp_GetFriendMii(
        outMiiData: *mut FFLStoreData,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendPlayingGame__Q2_2nn2fpFPQ3_2nn2fp7GameKeyPQ3_2nn2fp19GameModeDescriptionPCUiUi"]
    pub fn nn_fp_GetFriendPlayingGame(
        outGameKey: *mut nn_fp_GameKey,
        outGameModeDescription: *mut nn_fp_GameModeDescription,
        principalBuffer: *mut nn_act_PrincipalId,
        maxReadCount: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendPresenceEx__Q2_2nn2fpFPQ3_2nn2fp14FriendPresencePCUiUi"]
    pub fn nn_fp_GetFriendPresenceEx(
        arg1: *mut nn_fp_FriendPresence,
        principalBuffer: *mut nn_act_PrincipalId,
        maxReadCount: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendPresence__Q2_2nn2fpFPQ3_2nn2fp14FriendPresencePCUiUi"]
    pub fn nn_fp_GetFriendPresence(
        arg1: *mut nn_fp_FriendPresence,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendProfile__Q2_2nn2fpFPQ3_2nn2fp7ProfilePCUiUi"]
    pub fn nn_fp_GetFriendProfile(
        arg1: *mut nn_fp_Profile,
        principalBuffer: *mut nn_act_PrincipalId,
        readCount: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendRelationship__Q2_2nn2fpFPUcPCUiUi"]
    pub fn nn_fp_GetFriendRelationship(
        outRelationshipNum: *mut u8,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendRequestAccountId__Q2_2nn2fpFPA17_cPCUiUi"]
    pub fn nn_fp_GetFriendRequestAccountId(
        outAccountIds: *mut ::core::ffi::c_char,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendRequestListEx__Q2_2nn2fpFPQ3_2nn2fp13FriendRequestPCUiUi"]
    pub fn nn_fp_GetFriendRequestListEx(
        arg1: *mut nn_fp_FriendRequest,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendRequestList__Q2_2nn2fpFPUiT1UiT3"]
    pub fn nn_fp_GetFriendRequestList(
        outBuffer: *mut nn_act_PrincipalId,
        outReadCount: *mut ::core::ffi::c_uint,
        arg1: ::core::ffi::c_uint,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendRequestMessageId__Q2_2nn2fpFPULPCUiUi"]
    pub fn nn_fp_GetFriendRequestMessageId(
        outMessageIds: *mut ::core::ffi::c_ulonglong,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendScreenName__Q2_2nn2fpFPA11_wPCUiUibPUc"]
    pub fn nn_fp_GetFriendScreenName(
        outScreenName: *mut u16,
        arg1: *mut ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
        arg3: bool,
        arg4: *mut ::core::ffi::c_uchar,
    ) -> nn_Result;
    #[link_name = "\u{1}GetFriendSortTime__Q2_2nn2fpFPQ3_2nn2fp8DateTimePCUiUi"]
    pub fn nn_fp_GetFriendSortTime(
        arg1: *mut nn_fp_DateTime,
        principalBuffer: *mut nn_act_PrincipalId,
        count: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetLastLedEvent__Q2_2nn2fpFPUiT1"]
    pub fn nn_fp_GetLastLedEvent(
        arg1: *mut ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetMyAccountId__Q2_2nn2fpFPc"]
    pub fn nn_fp_GetMyAccountId(outAccountId: *mut ::core::ffi::c_char) -> nn_Result;
    #[link_name = "\u{1}GetMyComment__Q2_2nn2fpFPQ3_2nn2fp7Comment"]
    pub fn nn_fp_GetMyComment(outComment: *mut nn_fp_Comment) -> nn_Result;
    #[link_name = "\u{1}GetMyMii__Q2_2nn2fpFP12FFLStoreData"]
    pub fn nn_fp_GetMyMii(outMiiData: *mut FFLStoreData) -> nn_Result;
    #[link_name = "\u{1}GetMyPlayingGame__Q2_2nn2fpFPQ3_2nn2fp7GameKey"]
    pub fn nn_fp_GetMyPlayingGame(outPlayingGmae: *mut nn_fp_GameKey) -> nn_Result;
    #[link_name = "\u{1}GetMyPreference__Q2_2nn2fpFPQ3_2nn2fp10Preference"]
    pub fn nn_fp_GetMyPreference(outPreference: *mut nn_fp_Preference) -> nn_Result;
    #[link_name = "\u{1}GetMyPresence__Q2_2nn2fpFPQ3_2nn2fp10MyPresence"]
    pub fn nn_fp_GetMyPresence(outMyPresence: *mut nn_fp_MyPresence) -> nn_Result;
    #[link_name = "\u{1}GetMyPrincipalId__Q2_2nn2fpFv"]
    pub fn nn_fp_GetMyPrincipalId() -> nn_act_PrincipalId;
    #[link_name = "\u{1}GetMyProfile__Q2_2nn2fpFPQ3_2nn2fp7Profile"]
    pub fn nn_fp_GetMyProfile(outProfile: *mut nn_fp_Profile) -> nn_Result;
    #[link_name = "\u{1}GetMyScreenName__Q2_2nn2fpFPw"]
    pub fn nn_fp_GetMyScreenName(outScreenName: *mut u16) -> nn_Result;
    #[link_name = "\u{1}GetRecentPlayRecord__Q2_2nn2fpFPQ3_2nn2fp18RecentPlayRecordExPUiUiT3"]
    pub fn nn_fp_GetRecentPlayRecord(
        outPlayRecordBuffer: *mut nn_fp_RecentPlayRecordEx,
        outPlayRecordBufferSize: *mut ::core::ffi::c_uint,
        arg1: ::core::ffi::c_uint,
        maxReadCount: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}GetRequestBlockSettingAsync__Q2_2nn2fpFPUcPCUiUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_GetRequestBlockSettingAsync(
        arg1: *mut ::core::ffi::c_uchar,
        arg2: *mut ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
        arg4: nn_fp_FPAsyncCallback,
        arg5: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}HasLoggedIn__Q2_2nn2fpFv"]
    pub fn nn_fp_HasLoggedIn() -> bool;
    #[link_name = "\u{1}InitializeAdmin__Q2_2nn2fpFv"]
    pub fn nn_fp_InitializeAdmin() -> nn_Result;
    #[link_name = "\u{1}Initialize__Q2_2nn2fpFv"]
    pub fn nn_fp_Initialize() -> nn_Result;
    #[link_name = "\u{1}IsFriendRequestAllowed__Q2_2nn2fpFv"]
    pub fn nn_fp_IsFriendRequestAllowed() -> bool;
    #[link_name = "\u{1}IsInitializedAdmin__Q2_2nn2fpFv"]
    pub fn nn_fp_IsInitializedAdmin() -> bool;
    #[link_name = "\u{1}IsInitialized__Q2_2nn2fpFv"]
    pub fn nn_fp_IsInitialized() -> bool;
    #[link_name = "\u{1}IsInvitation__Q2_2nn2fpFPCQ3_2nn2fp8GameModeUiT2"]
    pub fn nn_fp_IsInvitation(
        arg1: *mut nn_fp_GameMode,
        myPrincipalId: nn_act_PrincipalId,
        arg2: ::core::ffi::c_uint,
    ) -> bool;
    #[link_name = "\u{1}IsJoinableForFriendListViewer__Q2_2nn2fpFPCQ3_2nn2fp14FriendPresenceUiUL"]
    pub fn nn_fp_IsJoinableForFriendListViewer(
        arg1: *mut nn_fp_FriendPresence,
        arg2: ::core::ffi::c_uint,
        arg3: ::core::ffi::c_ulonglong,
    ) -> bool;
    #[link_name = "\u{1}IsJoinableForFriendListViewer__Q2_2nn2fpFPCQ3_2nn2fp8PresenceUiUL"]
    pub fn nn_fp_IsJoinableForFriendListViewer1(
        arg1: *mut nn_fp_Presence,
        arg2: ::core::ffi::c_uint,
        arg3: ::core::ffi::c_ulonglong,
    ) -> bool;
    #[link_name = "\u{1}IsJoinable__Q2_2nn2fpFPCQ3_2nn2fp14FriendPresenceUL"]
    pub fn nn_fp_IsJoinable(
        arg1: *mut nn_fp_FriendPresence,
        arg2: ::core::ffi::c_ulonglong,
    ) -> bool;
    #[link_name = "\u{1}IsOnline__Q2_2nn2fpFv"]
    pub fn nn_fp_IsOnline() -> bool;
    #[link_name = "\u{1}IsPreferenceValid__Q2_2nn2fpFv"]
    pub fn nn_fp_IsPreferenceValid() -> bool;
    #[link_name = "\u{1}IsRecentPlayRecordCorrupted__Q2_2nn2fpFv"]
    pub fn nn_fp_IsRecentPlayRecordCorrupted() -> bool;
    #[link_name = "\u{1}IsRequestBlockForced__Q2_2nn2fpFv"]
    pub fn nn_fp_IsRequestBlockForced() -> bool;
    #[link_name = "\u{1}LoginAsync__Q2_2nn2fpFPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_LoginAsync(
        arg1: nn_fp_FPAsyncCallback,
        arg2: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}Logout__Q2_2nn2fpFv"]
    pub fn nn_fp_Logout() -> nn_Result;
    #[link_name = "\u{1}MarkFriendRequestsAsReceivedAsync__Q2_2nn2fpFPCULUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_MarkFriendRequestsAsReceivedAsync(
        arg1: *mut ::core::ffi::c_ulonglong,
        arg2: ::core::ffi::c_uint,
        arg3: nn_fp_FPAsyncCallback,
        arg4: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}RegisterAccountAsync__Q2_2nn2fpFPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_RegisterAccountAsync(
        arg1: nn_fp_FPAsyncCallback,
        arg2: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}RemoveBlackListAsync__Q2_2nn2fpFUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_RemoveBlackListAsync(
        arg1: ::core::ffi::c_uint,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}RemoveFriendAsync__Q2_2nn2fpFUiPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_RemoveFriendAsync(
        arg1: ::core::ffi::c_uint,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}ResultToErrorCode__Q2_2nn2fpFQ2_2nn6Result"]
    pub fn nn_fp_ResultToErrorCode(arg1: nn_Result) -> u32;
    #[link_name = "\u{1}SetInvitationParameter__Q2_2nn2fpFPQ3_2nn2fp8GameModePCUiUib"]
    pub fn nn_fp_SetInvitationParameter(
        arg1: *mut nn_fp_GameMode,
        arg2: *mut ::core::ffi::c_uint,
        arg3: ::core::ffi::c_uint,
        arg4: bool,
    ) -> nn_Result;
    #[link_name = "\u{1}SetLedEventMask__Q2_2nn2fpFUi"]
    pub fn nn_fp_SetLedEventMask(arg1: u32) -> nn_Result;
    #[link_name = "\u{1}SetNotificationHandler__Q2_2nn2fpFUiPFQ3_2nn2fp16NotificationTypeUiPv_vPv"]
    pub fn nn_fp_SetNotificationHandler(
        arg1: u32,
        arg2: nn_fp_NotificationHandlerFn,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}UnlockParentalControlTemporarily__Q2_2nn2fpFPCc"]
    pub fn nn_fp_UnlockParentalControlTemporarily(pinCode: *const ::core::ffi::c_char)
        -> nn_Result;
    #[link_name = "\u{1}UpdateCommentAsync__Q2_2nn2fpFPCwPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_UpdateCommentAsync(
        arg1: *const u16,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdateGameModeDescription__Q2_2nn2fpFPCw"]
    pub fn nn_fp_UpdateGameModeDescription(description: *const u16) -> nn_Result;
    #[link_name = "\u{1}UpdateGameModeEx__Q2_2nn2fpFPCQ3_2nn2fp8GameModePCw"]
    pub fn nn_fp_UpdateGameModeEx(arg1: *mut nn_fp_GameMode, arg2: *const u16) -> nn_Result;
    #[link_name = "\u{1}UpdateGameModeForOverlayApplication__Q2_2nn2fpFPCQ3_2nn2fp8GameModePCw"]
    pub fn nn_fp_UpdateGameModeForOverlayApplication(
        arg1: *mut nn_fp_GameMode,
        arg2: *const u16,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdateGameMode__Q2_2nn2fpFPCQ3_2nn2fp8GameModePCw"]
    pub fn nn_fp_UpdateGameMode(arg1: *mut nn_fp_GameMode, arg2: *const u16) -> nn_Result;
    #[link_name = "\u{1}UpdateGameMode__Q2_2nn2fpFPCQ3_2nn2fp8GameModePCwUi"]
    pub fn nn_fp_UpdateGameMode1(
        arg1: *mut nn_fp_GameMode,
        arg2: *const u16,
        arg3: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdateMiiAsync__Q2_2nn2fpFPC12FFLStoreDataPCwPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_UpdateMiiAsync(
        arg1: *mut FFLStoreData,
        arg2: *mut u16,
        arg3: nn_fp_FPAsyncCallback,
        arg4: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdateMiiAsync__Q2_2nn2fpFPC12FFLStoreDataPFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_UpdateMiiAsync1(
        miiData: *mut FFLStoreData,
        arg1: nn_fp_FPAsyncCallback,
        arg2: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdatePlayingGame__Q2_2nn2fpFPCQ3_2nn2fp7GameKeyUi"]
    pub fn nn_fp_UpdatePlayingGame(
        arg1: *mut nn_fp_GameKey,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdatePlayingOverlayApplication__Q2_2nn2fpFPCQ3_2nn2fp7GameKeyUi"]
    pub fn nn_fp_UpdatePlayingOverlayApplication(
        arg1: *mut nn_fp_GameKey,
        arg2: ::core::ffi::c_uint,
    ) -> nn_Result;
    #[link_name = "\u{1}UpdatePreferenceAsync__Q2_2nn2fpFPCQ3_2nn2fp10PreferencePFQ2_2nn6ResultPv_vPv"]
    pub fn nn_fp_UpdatePreferenceAsync(
        arg1: *mut nn_fp_Preference,
        arg2: nn_fp_FPAsyncCallback,
        arg3: *mut ::core::ffi::c_void,
    ) -> nn_Result;
    #[link_name = "\u{1}_ZNK2nn3idb9IDBReader19LoadIconDataFromIdbEyRNS0_11IconDataRawE"]
    pub fn nn_idb_IDBReader_LoadIconDataFromIdb(
        this: *const nn_idb_IDBReader,
        titleId: u64,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> nn_Result;
    #[link_name = "\u{1}_ZNK2nn3idb9IDBReader18SearchFromDataBaseERNS0_11IconDataKeyERj"]
    pub fn nn_idb_IDBReader_SearchFromDataBase(
        this: *const nn_idb_IDBReader,
        key: *mut nn_idb_IconDataKey,
        outIndex: *mut u32,
    ) -> bool;
    #[link_name = "\u{1}_ZNK2nn3idb9IDBReader24LoadIconDataFromDatabaseEjRNS0_11IconDataRawE"]
    pub fn nn_idb_IDBReader_LoadIconDataFromDatabase(
        this: *const nn_idb_IDBReader,
        index: u32,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> bool;
    #[link_name = "\u{1}_ZNK2nn3idb9IDBReader12LoadIconDataEyjRNS0_11IconDataRawE"]
    pub fn nn_idb_IDBReader_LoadIconData(
        this: *const nn_idb_IDBReader,
        titleId: u64,
        u1: u32,
        iconData: *mut nn_idb_IconDataRaw,
    ) -> bool;
    #[link_name = "\u{1}_ZN2nn3idb9IDBReader10InitializeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn nn_idb_IDBReader_Initialize(
        this: *mut nn_idb_IDBReader,
        path: *const std_string,
    ) -> bool;
    #[link_name = "\u{1}_ZN2nn3idb9IDBReader10InitializeEv"]
    pub fn nn_idb_IDBReader_Initialize1(this: *mut nn_idb_IDBReader) -> bool;
    #[link_name = "\u{1}_ZN2nn3idb9IDBReader8FinalizeEv"]
    pub fn nn_idb_IDBReader_Finalize(this: *mut nn_idb_IDBReader);
    #[link_name = "\u{1}_ZN2nn3idb9IDBReaderD1Ev"]
    pub fn nn_idb_IDBReader_IDBReader_destructor(this: *mut nn_idb_IDBReader);
    pub fn WPADInit();
    pub fn WPADShutdown();
    pub fn WPADDisconnect(chan: WPADChan::Type);
    pub fn WPADProbe(chan: WPADChan::Type, outExtensionType: *mut WPADExtensionType::Type) -> i32;
    pub fn WPADSetDataFormat(chan: WPADChan::Type, format: WPADDataFormat::Type) -> i32;
    pub fn WPADGetDataFormat(chan: WPADChan::Type) -> WPADDataFormat::Type;
    pub fn WPADRead(chan: WPADChan::Type, data: *mut ::core::ffi::c_void);
    pub fn WPADControlLed(
        channel: WPADChan::Type,
        led: WPADLed::Type,
        callback: WPADControlLedCallback,
    ) -> i32;
    pub fn WPADControlDpd(
        channel: WPADChan::Type,
        mode: WPADDpdFormat::Type,
        callback: WPADControlDpdCallback,
    ) -> i32;
    pub fn WPADGetDpdFormat(chan: WPADChan::Type) -> WPADDpdFormat::Type;
    pub fn WPADControlMotor(chan: WPADChan::Type, motorEnabled: BOOL);
    pub fn WPADControlSpeaker(
        chan: WPADChan::Type,
        mode: WPADSpeakerCmd::Type,
        arg1: WPADControlSpeakerCallback,
    ) -> i32;
    pub fn WPADIsSpeakerEnabled(chan: WPADChan::Type) -> BOOL;
    pub fn WPADCanSendStreamData(chan: WPADChan::Type) -> BOOL;
    pub fn WPADSendStreamData(
        chan: WPADChan::Type,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
    pub fn WPADGetSpeakerVolume() -> u8;
    pub fn WPADSetSpeakerVolume(volume: u8);
    pub fn WPADIsMplsAttached(
        channel: WPADChan::Type,
        enabled: *mut BOOL,
        callback: WPADIsMplsAttachedCallback,
    ) -> i32;
    pub fn WPADIsMplsIntegrated(channel: WPADChan::Type) -> i32;
    pub fn WPADGetInfo(channel: WPADChan::Type, outInfo: *mut WPADInfo) -> i32;
    pub fn WPADGetInfoAsync(
        channel: WPADChan::Type,
        outInfo: *mut WPADInfo,
        arg1: WPADGetInfoCallback,
    ) -> i32;
    pub fn WPADReadMemoryAsync(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
    pub fn WPADWriteMemoryAsync(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
    pub fn WPADReadExtReg(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        peripheral: WPADPeripheralSpace::Type,
        address: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
    pub fn WPADWriteExtReg(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u32,
        peripheral: WPADPeripheralSpace::Type,
        address: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
    pub fn WPADGetBLCalibration(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        address: u32,
        size: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
    pub fn WPADSetPowerSaveMode(chan: WPADChan::Type, powerSave: BOOL);
    pub fn WPADGetPowerSaveMode(chan: WPADChan::Type) -> BOOL;
    pub fn WPADGetAddress(chan: WPADChan::Type, outAddress: *mut WPADAddress);
    pub fn WPADEnableMotor(enable: BOOL);
    pub fn WPADIsMotorEnabled() -> BOOL;
    pub fn WPADEnableURCC(enable: BOOL);
    pub fn WPADIsEnabledURC() -> BOOL;
    pub fn WPADEnableWBC(enable: BOOL);
    pub fn WPADIsEnableWBC() -> BOOL;
    pub fn WPADEnableWiiRemote(enable: BOOL);
    pub fn WPADSetAutoSleepTime(time: u8);
    pub fn WPADStartSyncDevice() -> BOOL;
    pub fn WPADStartSyncDeviceEx(
        deviceAddress: *mut WPADAddress,
        deviceName: *const ::core::ffi::c_char,
    ) -> BOOL;
    pub fn WPADSetConnectCallback(
        chan: WPADChan::Type,
        callback: WPADConnectCallback,
    ) -> WPADConnectCallback;
    pub fn WPADSetExtensionCallback(
        chan: WPADChan::Type,
        callback: WPADExtensionCallback,
    ) -> WPADExtensionCallback;
    pub fn WPADSetSamplingCallback(
        chan: WPADChan::Type,
        callback: WPADSamplingCallback,
    ) -> WPADSamplingCallback;
    pub fn WPADiShutdown();
    pub fn WPADiClearQueue(queue: *mut WPADiQueue);
    pub fn WPADiIsAvailableCmdQueue(queue: *mut WPADiQueue, count: u32) -> bool;
    pub fn WPADiHIDParser(channel: WPADChan::Type, hidData: *mut u8) -> i32;
    pub fn WPADiSendSetVibrator(cmdQueue: *mut WPADiQueue) -> BOOL;
    pub fn WPADiSendSetPort(
        cmdQueue: *mut WPADiQueue,
        led: WPADLed::Type,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendSetReportType(
        cmdQueue: *mut WPADiQueue,
        dataFormat: WPADDataFormat::Type,
        powerSave: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendGetContStat(
        cmdQueue: *mut WPADiQueue,
        outInfo: *mut WPADInfo,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendEnableDPD(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendEnableDPDCSB(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendEnableSpeaker(
        cmdQueue: *mut WPADiQueue,
        enable: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendMuteSpeaker(
        cmdQueue: *mut WPADiQueue,
        mute: BOOL,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendStreamData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
    pub fn WPADiSendWriteDataCmd(
        cmdQueue: *mut WPADiQueue,
        byte: u8,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendWriteData(
        cmdQueue: *mut WPADiQueue,
        source: *mut ::core::ffi::c_void,
        size: u32,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiSendReadData(
        cmdQueue: *mut WPADiQueue,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        address: u32,
        callback: WPADiSendCallback,
    ) -> BOOL;
    pub fn WPADiGetGameCode() -> *mut u32;
    pub fn WPADiGetGameType() -> u8;
    pub fn WPADSetGameTitleUtf16(title: *mut u16);
    pub fn WPADGetGameTitleUtf16(chan: WPADChan::Type, outTitle: *mut *mut u16) -> i32;
    pub fn WPADGetGameDataTimestamp(chan: WPADChan::Type, timestamp: *mut OSTime) -> i32;
    pub fn WPADiWriteGameData(
        channel: WPADChan::Type,
        source: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADWriteMemoryCallback,
    ) -> i32;
    pub fn WPADiReadGameData(
        channel: WPADChan::Type,
        destination: *mut ::core::ffi::c_void,
        size: u16,
        offset: u32,
        callback: WPADReadMemoryCallback,
    ) -> i32;
    pub fn WPADiGetMplsStatus() -> WPADMplsMode::Type;
    pub fn KPADInit();
    pub fn KPADShutdown();
    pub fn KPADRead(chan: KPADChan, data: *mut KPADStatus, size: u32) -> i32;
    pub fn KPADReadEx(
        chan: KPADChan,
        data: *mut KPADStatus,
        size: u32,
        error: *mut KPADError::Type,
    ) -> i32;
    pub fn KPADSetMaxControllers(maxControllers: u32) -> i32;
    pub fn KPADGetMaxControllers() -> u32;
    pub fn KPADGetGameMaxControllers() -> u32;
    pub fn KPADSetConnectCallback(
        chan: KPADChan,
        callback: KPADConnectCallback,
    ) -> KPADConnectCallback;
    pub fn KPADEnableMpls(channel: KPADChan, mode: KPADMplsMode);
    pub fn KPADDisableMpls(channel: KPADChan);
    pub fn KPADGetMplsStatus(chan: KPADChan) -> KPADMplsMode;
    pub fn KPADEnableDPD(chan: KPADChan);
    pub fn KPADDisableDPD(chan: KPADChan);
    pub fn VPADBASEInit();
    pub fn VPADBASEShutdown();
    pub fn VPADBASEIsInit() -> BOOL;
    pub fn VPADBASEGetMotorOnRemainingCount(chan: VPADChan::Type) -> i32;
    pub fn VPADBASESetMotorOnRemainingCount(chan: VPADChan::Type, counter: i32) -> i32;
    pub fn VPADBASESetSensorBarSetting(chan: VPADChan::Type, setting: i8);
    pub fn VPADBASEGetSensorBarSetting(chan: VPADChan::Type, outSetting: *mut i8);
    pub fn VPADBASEGetHeadphoneStatus(chan: VPADChan::Type) -> i32;
    pub fn VPADBASEGetGameControllerMode(chan: VPADChan::Type, mode: *mut i32);
    pub fn VPADBASESetGameControllerMode(chan: VPADChan::Type, mode: i32);
    pub fn VPADBASEGetPowerButtonPressStatus(
        chan: VPADChan::Type,
        tick: *mut u32,
        status: *mut u32,
    );
    pub fn VPADBASESetPowerButtonPressStatus(chan: VPADChan::Type, tick: u32, status: u32);
    pub fn VPADBASESetPowerButtonDisableMode(chan: VPADChan::Type, mode: u32);
    pub fn VPADBASEClearIRCEvent(chan: VPADChan::Type);
    pub fn VPADBASEGetIRCStatus(chan: VPADChan::Type) -> VPADIRCStatusFlags::Type;
    pub fn VPADInit();
    pub fn VPADShutdown();
    pub fn VPADRead(
        chan: VPADChan::Type,
        buffers: *mut VPADStatus,
        count: u32,
        outError: *mut VPADReadError::Type,
    ) -> i32;
    pub fn VPADGetTPCalibrationParam(
        chan: VPADChan::Type,
        outParam: *mut VPADTouchCalibrationParam,
    );
    pub fn VPADSetTPCalibrationParam(chan: VPADChan::Type, param: *const VPADTouchCalibrationParam);
    pub fn VPADGetTPCalibratedPoint(
        chan: VPADChan::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
    pub fn VPADGetTPCalibratedPointEx(
        chan: VPADChan::Type,
        tpResolution: VPADTouchPadResolution::Type,
        calibratedData: *mut VPADTouchData,
        uncalibratedData: *const VPADTouchData,
    );
    pub fn VPADSetAccParam(chan: VPADChan::Type, playRadius: f32, sensitivity: f32);
    pub fn VPADGetAccParam(chan: VPADChan::Type, outPlayRadius: *mut f32, outSensitivity: *mut f32);
    pub fn VPADSetBtnRepeat(chan: VPADChan::Type, delaySec: f32, pulseSec: f32);
    pub fn VPADEnableStickCrossClamp(chan: VPADChan::Type);
    pub fn VPADDisableStickCrossClamp(chan: VPADChan::Type);
    pub fn VPADSetLStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
    pub fn VPADSetRStickClampThreshold(chan: VPADChan::Type, max: i32, min: i32);
    pub fn VPADGetGyroDirReviseParam(chan: VPADChan::Type, param: *mut f32);
    pub fn VPADGetGyroZeroDriftMode(chan: VPADChan::Type, mode: *mut VPADGyroZeroDriftMode::Type);
    pub fn VPADGetLStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
    pub fn VPADGetRStickClampThreshold(chan: VPADChan::Type, max: *mut i32, min: *mut i32);
    pub fn VPADSetStickOrigin(chan: VPADChan::Type);
    pub fn VPADDisableLStickZeroClamp(chan: VPADChan::Type);
    pub fn VPADDisableRStickZeroClamp(chan: VPADChan::Type);
    pub fn VPADEnableLStickZeroClamp(chan: VPADChan::Type);
    pub fn VPADEnableRStickZeroClamp(chan: VPADChan::Type);
    pub fn VPADSetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
    pub fn VPADSetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        rotationDegree: f32,
        range: f32,
        radius: f32,
    );
    pub fn VPADGetCrossStickEmulationParamsL(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
    pub fn VPADGetCrossStickEmulationParamsR(
        chan: VPADChan::Type,
        outRotationDegree: *mut f32,
        outRange: *mut f32,
        outRadius: *mut f32,
    );
    pub fn VPADSetGyroAngle(chan: VPADChan::Type, ax: f32, ay: f32, az: f32);
    pub fn VPADSetGyroDirReviseBase(chan: VPADChan::Type, base: *mut VPADDirection);
    pub fn VPADSetGyroDirReviseParam(chan: VPADChan::Type, param: f32);
    pub fn VPADSetGyroDirection(chan: VPADChan::Type, dir: *mut VPADDirection);
    pub fn VPADSetGyroDirectionMag(chan: VPADChan::Type, mag: f32);
    pub fn VPADSetGyroMagnification(chan: VPADChan::Type, pitch: f32, yaw: f32, roll: f32);
    pub fn VPADSetGyroZeroDriftMode(chan: VPADChan::Type, mode: VPADGyroZeroDriftMode::Type);
    pub fn VPADEnableGyroZeroPlay(chan: VPADChan::Type);
    pub fn VPADEnableGyroDirRevise(chan: VPADChan::Type);
    pub fn VPADEnableGyroAccRevise(chan: VPADChan::Type);
    pub fn VPADDisableGyroZeroPlay(chan: VPADChan::Type);
    pub fn VPADDisableGyroDirRevise(chan: VPADChan::Type);
    pub fn VPADDisableGyroAccRevise(chan: VPADChan::Type);
    pub fn VPADIsEnableGyroZeroPlay(chan: VPADChan::Type) -> f32;
    pub fn VPADIsEnableGyroZeroDrift(chan: VPADChan::Type) -> f32;
    pub fn VPADIsEnableGyroDirRevise(chan: VPADChan::Type) -> f32;
    pub fn VPADIsEnableGyroAccRevise(chan: VPADChan::Type) -> f32;
    pub fn VPADSetGyroZeroPlayParam(chan: VPADChan::Type, radius: f32);
    pub fn VPADInitGyroZeroPlayParam(chan: VPADChan::Type);
    pub fn VPADInitGyroDirReviseParam(chan: VPADChan::Type);
    pub fn VPADInitGyroAccReviseParam(chan: VPADChan::Type);
    pub fn VPADStartGyroMagRevise(chan: VPADChan::Type);
    pub fn VPADStopGyroMagRevise(chan: VPADChan::Type);
    pub fn VPADInitGyroZeroDriftMode(chan: VPADChan::Type);
    pub fn VPADGetTVMenuStatus(chan: VPADChan::Type) -> BOOL;
    pub fn VPADSetTVMenuInvalid(chan: VPADChan::Type, invalid: BOOL);
    pub fn VPADDisablePowerButton(chan: VPADChan::Type);
    pub fn VPADEnablePowerButton(chan: VPADChan::Type);
    pub fn VPADControlMotor(chan: VPADChan::Type, pattern: *mut u8, length: u8) -> i32;
    pub fn VPADStopMotor(chan: VPADChan::Type);
    pub fn VPADSetLcdMode(chan: VPADChan::Type, lcdMode: VPADLcdMode::Type) -> i32;
    pub fn VPADGetLcdMode(chan: VPADChan::Type, outLcdMode: *mut VPADLcdMode::Type) -> i32;
    pub fn VPADSetSensorBar(chan: VPADChan::Type, on: BOOL) -> i32;
    pub fn VPADSetSamplingCallback(
        chan: VPADChan::Type,
        callback: VPADSamplingCallback,
    ) -> VPADSamplingCallback;
    pub fn VPADGetButtonProcMode(chan: VPADChan::Type) -> BOOL;
    #[link_name = "\u{1}_ZN3Rpl20SwkbdAppearInputFormERKN2nn5swkbd9AppearArgE"]
    pub fn Rpl_SwkbdAppearInputForm(appearArg: *const nn_swkbd_AppearArg) -> bool;
    #[link_name = "\u{1}_ZN3Rpl19SwkbdAppearKeyboardERKN2nn5swkbd11KeyboardArgE"]
    pub fn Rpl_SwkbdAppearKeyboard(keyboardArg: *const nn_swkbd_KeyboardArg) -> bool;
    #[link_name = "\u{1}_ZN3Rpl22SwkbdCalcSubThreadFontEv"]
    pub fn Rpl_SwkbdCalcSubThreadFont();
    #[link_name = "\u{1}_ZN3Rpl25SwkbdCalcSubThreadPredictEv"]
    pub fn Rpl_SwkbdCalcSubThreadPredict();
    #[link_name = "\u{1}_ZN3Rpl9SwkbdCalcERKN2nn5swkbd14ControllerInfoE"]
    pub fn Rpl_SwkbdCalc(controllerInfo: *const nn_swkbd_ControllerInfo);
    #[link_name = "\u{1}_ZN3Rpl20SwkbdConfirmUnfixAllEv"]
    pub fn Rpl_SwkbdConfirmUnfixAll();
    #[link_name = "\u{1}_ZN3Rpl11SwkbdCreateEPvN2nn5swkbd10RegionTypeEjP8FSClient"]
    pub fn Rpl_SwkbdCreate(
        buffer: *mut ::core::ffi::c_void,
        regionType: nn_swkbd_RegionType::Type,
        unk: u32,
        fsClient: *mut FSClient,
    );
    #[link_name = "\u{1}_ZN3Rpl12SwkbdDestroyEv"]
    pub fn Rpl_SwkbdDestroy();
    #[link_name = "\u{1}_ZN3Rpl23SwkbdDisappearInputFormEv"]
    pub fn Rpl_SwkbdDisappearInputForm() -> bool;
    #[link_name = "\u{1}_ZN3Rpl22SwkbdDisappearKeyboardEv"]
    pub fn Rpl_SwkbdDisappearKeyboard() -> bool;
    #[link_name = "\u{1}_ZN3Rpl12SwkbdDrawDRCEv"]
    pub fn Rpl_SwkbdDrawDRC();
    #[link_name = "\u{1}_ZN3Rpl11SwkbdDrawTVEv"]
    pub fn Rpl_SwkbdDrawTV();
    #[link_name = "\u{1}_ZN3Rpl22SwkbdGetDrawStringInfoEPN2nn5swkbd14DrawStringInfoE"]
    pub fn Rpl_SwkbdGetDrawStringInfo(drawStringInfo: *mut nn_swkbd_DrawStringInfo);
    #[link_name = "\u{1}_ZN3Rpl23SwkbdGetInputFormStringEv"]
    pub fn Rpl_SwkbdGetInputFormString() -> *const u16;
    #[link_name = "\u{1}_ZN3Rpl25SwkbdGetKeyboardConditionEPN2nn5swkbd17KeyboardConditionE"]
    pub fn Rpl_SwkbdGetKeyboardCondition(keyboardCondition: *mut nn_swkbd_KeyboardCondition);
    #[link_name = "\u{1}_ZN3Rpl22SwkbdGetStateInputFormEv"]
    pub fn Rpl_SwkbdGetStateInputForm() -> nn_swkbd_State::Type;
    #[link_name = "\u{1}_ZN3Rpl21SwkbdGetStateKeyboardEv"]
    pub fn Rpl_SwkbdGetStateKeyboard() -> nn_swkbd_State::Type;
    #[link_name = "\u{1}_ZN3Rpl27SwkbdInactivateSelectCursorEv"]
    pub fn Rpl_SwkbdInactivateSelectCursor();
    #[link_name = "\u{1}_ZN3Rpl17SwkbdInitLearnDicEPv"]
    pub fn Rpl_SwkbdInitLearnDic(buffer: *mut ::core::ffi::c_void) -> bool;
    #[link_name = "\u{1}_ZN3Rpl27SwkbdIsCoveredWithSubWindowEv"]
    pub fn Rpl_SwkbdIsCoveredWithSubWindow() -> bool;
    #[link_name = "\u{1}_ZN3Rpl25SwkbdIsDecideCancelButtonEPb"]
    pub fn Rpl_SwkbdIsDecideCancelButton(outIsSelectCursor: *mut bool) -> bool;
    #[link_name = "\u{1}_ZN3Rpl21SwkbdIsDecideOkButtonEPb"]
    pub fn Rpl_SwkbdIsDecideOkButton(outIsSelectCursor: *mut bool) -> bool;
    #[link_name = "\u{1}_ZN3Rpl21SwkbdIsKeyboardTargetEPN2nn5swkbd14IEventReceiverE"]
    pub fn Rpl_SwkbdIsKeyboardTarget(eventReceiver: *mut nn_swkbd_IEventReceiver) -> bool;
    #[link_name = "\u{1}_ZN3Rpl28SwkbdIsNeedCalcSubThreadFontEv"]
    pub fn Rpl_SwkbdIsNeedCalcSubThreadFont() -> bool;
    #[link_name = "\u{1}_ZN3Rpl31SwkbdIsNeedCalcSubThreadPredictEv"]
    pub fn Rpl_SwkbdIsNeedCalcSubThreadPredict() -> bool;
    #[link_name = "\u{1}_ZN3Rpl25SwkbdIsSelectCursorActiveEv"]
    pub fn Rpl_SwkbdIsSelectCursorActive() -> bool;
    #[link_name = "\u{1}_ZN3Rpl17SwkbdMuteAllSoundEb"]
    pub fn Rpl_SwkbdMuteAllSound(muted: bool);
    #[link_name = "\u{1}_ZN3Rpl22SwkbdSetControllerRemoEN2nn5swkbd14ControllerTypeE"]
    pub fn Rpl_SwkbdSetControllerRemo(type_: nn_swkbd_ControllerType::Type);
    #[link_name = "\u{1}_ZN3Rpl17SwkbdSetCursorPosEi"]
    pub fn Rpl_SwkbdSetCursorPos(pos: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN3Rpl22SwkbdSetEnableOkButtonEb"]
    pub fn Rpl_SwkbdSetEnableOkButton(enable: bool);
    #[link_name = "\u{1}_ZN3Rpl23SwkbdSetInputFormStringEPKDs"]
    pub fn Rpl_SwkbdSetInputFormString(str_: *const u16);
    #[link_name = "\u{1}_ZN3Rpl16SwkbdSetReceiverERKN2nn5swkbd11ReceiverArgE"]
    pub fn Rpl_SwkbdSetReceiver(receiver: *const nn_swkbd_ReceiverArg);
    #[link_name = "\u{1}_ZN3Rpl18SwkbdSetSelectFromEi"]
    pub fn Rpl_SwkbdSetSelectFrom(from: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN3Rpl30SwkbdSetUserControllerEventObjEPN2nn5swkbd19IControllerEventObjE"]
    pub fn Rpl_SwkbdSetUserControllerEventObj(
        userControllerEventObj: *mut nn_swkbd_IControllerEventObj,
    );
    #[link_name = "\u{1}_ZN3Rpl20SwkbdSetUserSoundObjEPN2nn5swkbd9ISoundObjE"]
    pub fn Rpl_SwkbdSetUserSoundObj(userSoundObj: *mut nn_swkbd_ISoundObj);
    #[link_name = "\u{1}_ZN3Rpl15SwkbdSetVersionEi"]
    pub fn Rpl_SwkbdSetVersion(version: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN3Rpl17ErrEulaSetVersionEi"]
    pub fn Rpl_ErrEulaSetVersion(version: ::core::ffi::c_int);
    #[link_name = "\u{1}_ZN3Rpl11ErrEulaJumpEPKcj"]
    pub fn Rpl_ErrEulaJump(buffer: *const ::core::ffi::c_char, bufferSize: u32) -> bool;
    #[link_name = "\u{1}_ZN3Rpl19ErrEulaPlayAppearSEEb"]
    pub fn Rpl_ErrEulaPlayAppearSE(playAppearSoundEffect: bool);
    #[link_name = "\u{1}_ZN3Rpl27ErrEulaIsSelectCursorActiveEv"]
    pub fn Rpl_ErrEulaIsSelectCursorActive() -> bool;
    #[link_name = "\u{1}_ZN3Rpl17ErrEulaChangeLangEN2nn7erreula8LangTypeE"]
    pub fn Rpl_ErrEulaChangeLang(language: nn_erreula_LangType::Type);
    #[link_name = "\u{1}_ZN3Rpl27ErrEulaDisappearHomeNixSignEv"]
    pub fn Rpl_ErrEulaDisappearHomeNixSign();
    #[link_name = "\u{1}_ZN3Rpl26ErrEulaIsAppearHomeNixSignEv"]
    pub fn Rpl_ErrEulaIsAppearHomeNixSign() -> bool;
    #[link_name = "\u{1}_ZN3Rpl24ErrEulaAppearHomeNixSignERKN2nn7erreula14HomeNixSignArgE"]
    pub fn Rpl_ErrEulaAppearHomeNixSign(arg: *const nn_erreula_HomeNixSignArg);
    #[link_name = "\u{1}_ZN3Rpl24ErrEulaSetControllerRemoEN2nn7erreula14ControllerTypeE"]
    pub fn Rpl_ErrEulaSetControllerRemo(controller: nn_erreula_ControllerType::Type);
    #[link_name = "\u{1}_ZN3Rpl30ErrEulaGetSelectButtonNumErrorEv"]
    pub fn Rpl_ErrEulaGetSelectButtonNumError() -> i32;
    #[link_name = "\u{1}_ZN3Rpl20ErrEulaGetResultCodeEv"]
    pub fn Rpl_ErrEulaGetResultCode() -> i32;
    #[link_name = "\u{1}_ZN3Rpl20ErrEulaGetResultTypeEv"]
    pub fn Rpl_ErrEulaGetResultType() -> nn_erreula_ResultType::Type;
    #[link_name = "\u{1}_ZN3Rpl26ErrEulaGetStateErrorViewerEv"]
    pub fn Rpl_ErrEulaGetStateErrorViewer() -> nn_erreula_State::Type;
    #[link_name = "\u{1}_ZN3Rpl37ErrEulaIsDecideSelectRightButtonErrorEv"]
    pub fn Rpl_ErrEulaIsDecideSelectRightButtonError() -> bool;
    #[link_name = "\u{1}_ZN3Rpl36ErrEulaIsDecideSelectLeftButtonErrorEv"]
    pub fn Rpl_ErrEulaIsDecideSelectLeftButtonError() -> bool;
    #[link_name = "\u{1}_ZN3Rpl32ErrEulaIsDecideSelectButtonErrorEv"]
    pub fn Rpl_ErrEulaIsDecideSelectButtonError() -> bool;
    #[link_name = "\u{1}_ZN3Rpl21ErrEulaDisappearErrorEv"]
    pub fn Rpl_ErrEulaDisappearError();
    #[link_name = "\u{1}_ZN3Rpl18ErrEulaAppearErrorERKN2nn7erreula9AppearArgE"]
    pub fn Rpl_ErrEulaAppearError(arg: *const nn_erreula_AppearArg);
    #[link_name = "\u{1}_ZN3Rpl11ErrEulaCalcERKN2nn7erreula14ControllerInfoE"]
    pub fn Rpl_ErrEulaCalc(controllerInfo: *const nn_erreula_ControllerInfo);
    #[link_name = "\u{1}_ZN3Rpl14ErrEulaDrawDRCEv"]
    pub fn Rpl_ErrEulaDrawDRC();
    #[link_name = "\u{1}_ZN3Rpl13ErrEulaDrawTVEv"]
    pub fn Rpl_ErrEulaDrawTV();
    #[link_name = "\u{1}_ZN3Rpl14ErrEulaDestroyEv"]
    pub fn Rpl_ErrEulaDestroy();
    #[link_name = "\u{1}_ZN3Rpl13ErrEulaCreateEPvN2nn7erreula10RegionTypeENS2_8LangTypeEP8FSClient"]
    pub fn Rpl_ErrEulaCreate(
        workMemory: *mut ::core::ffi::c_void,
        region: nn_erreula_RegionType::Type,
        language: nn_erreula_LangType::Type,
        fsClient: *mut FSClient,
    );
    pub fn MICInit(
        instance: MICInstance::Type,
        unused: ::core::ffi::c_int,
        workMemory: *mut MICWorkMemory,
        outError: *mut MICError::Type,
    ) -> MICHandle;
    pub fn MICOpen(handle: MICHandle) -> MICError::Type;
    pub fn MICGetState(
        handle: MICHandle,
        state: ::core::ffi::c_int,
        outStateVal: *mut u32,
    ) -> MICError::Type;
    pub fn MICSetState(
        handle: MICHandle,
        state: ::core::ffi::c_int,
        stateVal: u32,
    ) -> MICError::Type;
    pub fn MICGetStatus(handle: MICHandle, outStatus: *mut MICStatus) -> MICError::Type;
    pub fn MICSetDataConsumed(
        handle: MICHandle,
        dataAmountConsumed: ::core::ffi::c_int,
    ) -> MICError::Type;
    pub fn MICClose(handle: MICHandle) -> MICError::Type;
    pub fn MICUninit(handle: MICHandle) -> MICError::Type;
    pub fn NFCInit(chan: VPADChan::Type) -> NFCError;
    pub fn NFCInitEx(chan: VPADChan::Type, powerMode: u32) -> NFCError;
    pub fn NFCShutdown(chan: VPADChan::Type) -> NFCError;
    pub fn NFCIsInit(chan: VPADChan::Type) -> BOOL;
    pub fn NFCProc(chan: VPADChan::Type);
    pub fn NFCSetTagDetectCallback(
        chan: VPADChan::Type,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
    pub fn NFCGetMode(chan: VPADChan::Type) -> NFCMode::Type;
    pub fn NFCSetMode(chan: VPADChan::Type, mode: NFCMode::Type) -> NFCError;
    pub fn NFCAbort(
        chan: VPADChan::Type,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCAntennaCheck(
        chan: VPADChan::Type,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCDetect(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSetLockBitsForT1T(
        chan: VPADChan::Type,
        numBlocks: u8,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCRead(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCWrite(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        size: u32,
        data: *mut ::core::ffi::c_void,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawData(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawDataEx(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawDataEx2(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        disableCRC: BOOL,
        techMask: NFCTechnologyMask,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawDataWithPrePolling(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawDataWithPrePollingEx(
        chan: VPADChan::Type,
        startDiscovery: BOOL,
        discoveryTimeout: u32,
        commandTimeout: u32,
        commandSize: u32,
        responseSize: u32,
        commandData: *mut ::core::ffi::c_void,
        callback: NFCRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSendRawDataTwice(
        chan: VPADChan::Type,
        command0Timeout: u32,
        command0Size: u32,
        response0Size: u32,
        command0Data: *mut ::core::ffi::c_void,
        command1Timeout: u32,
        command1Size: u32,
        response1Size: u32,
        command1Data: *mut ::core::ffi::c_void,
        callback: NFCRawDataTwiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCFormat(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCGetTagInfo(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCGetTagInfoMulti(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        callback: NFCGetTagInfoMultiCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCIsTagPresent(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCSetReadOnly(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCReadT2T(
        chan: VPADChan::Type,
        discoveryTimeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numReads: u8,
        read0Start: u8,
        read0End: u8,
        read1Start: u8,
        read1End: u8,
        read2Start: u8,
        read2End: u8,
        read3Start: u8,
        read3End: u8,
        authenticate: u8,
        callback: NFCReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCWriteT2T(
        chan: VPADChan::Type,
        discoveryTimeout: u16,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        version: *mut NFCNTAGVersion,
        commandTimeout: u32,
        numWrites: u8,
        write0Start: u8,
        write0Size: u8,
        write0Data: *mut ::core::ffi::c_void,
        write1Start: u8,
        write1Size: u8,
        write1Data: *mut ::core::ffi::c_void,
        write2Start: u8,
        write2Size: u8,
        write2Data: *mut ::core::ffi::c_void,
        write3Start: u8,
        write3Size: u8,
        write3Data: *mut ::core::ffi::c_void,
        activationStart: u8,
        deactivationData: *mut u32,
        activationData: *mut u32,
        authenticate: u8,
        activate: u8,
        callback: NFCCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NFCError;
    pub fn NFCGetUIDFromActivationEventData(
        data: *mut ::core::ffi::c_void,
        outProtocol: *mut NFCProtocol,
        outTechnology: *mut NFCTechnology,
        outUidSize: *mut u8,
        outUid: *mut u8,
    );
    pub fn __NFCSystemAbort(chan: VPADChan::Type) -> NFCError;
    pub fn GX2InitSampler(
        sampler: *mut GX2Sampler,
        clampMode: GX2TexClampMode::Type,
        minMagFilterMode: GX2TexXYFilterMode::Type,
    );
    pub fn GX2InitSamplerBorderType(sampler: *mut GX2Sampler, borderType: GX2TexBorderType::Type);
    pub fn GX2InitSamplerClamping(
        sampler: *mut GX2Sampler,
        clampX: GX2TexClampMode::Type,
        clampY: GX2TexClampMode::Type,
        clampZ: GX2TexClampMode::Type,
    );
    pub fn GX2InitSamplerDepthCompare(
        sampler: *mut GX2Sampler,
        depthCompare: GX2CompareFunction::Type,
    );
    pub fn GX2InitSamplerFilterAdjust(
        sampler: *mut GX2Sampler,
        highPrecision: BOOL,
        perfMip: GX2TexMipPerfMode::Type,
        perfZ: GX2TexZPerfMode::Type,
    );
    pub fn GX2InitSamplerLOD(sampler: *mut GX2Sampler, lodMin: f32, lodMax: f32, lodBias: f32);
    pub fn GX2InitSamplerLODAdjust(sampler: *mut GX2Sampler, unk1: f32, unk2: BOOL);
    pub fn GX2InitSamplerRoundingMode(
        sampler: *mut GX2Sampler,
        roundingMode: GX2RoundingMode::Type,
    );
    pub fn GX2InitSamplerXYFilter(
        sampler: *mut GX2Sampler,
        filterMag: GX2TexXYFilterMode::Type,
        filterMin: GX2TexXYFilterMode::Type,
        maxAniso: GX2TexAnisoRatio::Type,
    );
    pub fn GX2InitSamplerZMFilter(
        sampler: *mut GX2Sampler,
        filterZ: GX2TexZFilterMode::Type,
        filterMip: GX2TexMipFilterMode::Type,
    );
    pub fn GX2RBufferExists(buffer: *mut GX2RBuffer) -> BOOL;
    pub fn GX2RCreateBuffer(buffer: *mut GX2RBuffer) -> BOOL;
    pub fn GX2RCreateBufferUserMemory(
        buffer: *mut GX2RBuffer,
        memory: *mut ::core::ffi::c_void,
        size: u32,
    ) -> BOOL;
    pub fn GX2RDestroyBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
    pub fn GX2RGetBufferAlignment(flags: GX2RResourceFlags::Type) -> u32;
    pub fn GX2RGetBufferAllocationSize(buffer: *mut GX2RBuffer) -> u32;
    pub fn GX2RInvalidateBuffer(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
    pub fn GX2RLockBufferEx(
        buffer: *mut GX2RBuffer,
        flags: GX2RResourceFlags::Type,
    ) -> *mut ::core::ffi::c_void;
    pub fn GX2RUnlockBufferEx(buffer: *mut GX2RBuffer, flags: GX2RResourceFlags::Type);
    pub fn GX2RSetVertexUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
    pub fn GX2RSetPixelUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
    pub fn GX2RSetGeometryUniformBlock(buffer: *mut GX2RBuffer, location: u32, offset: u32);
    pub fn GX2CalcGeometryShaderInputRingBufferSize(ringItemSize: u32) -> u32;
    pub fn GX2CalcGeometryShaderOutputRingBufferSize(ringItemSize: u32) -> u32;
    pub fn GX2CalcFetchShaderSizeEx(
        attribs: u32,
        fetchShaderType: GX2FetchShaderType::Type,
        tesellationMode: GX2TessellationMode::Type,
    ) -> u32;
    pub fn GX2InitFetchShaderEx(
        fetchShader: *mut GX2FetchShader,
        buffer: *mut u8,
        attribCount: u32,
        attribs: *const GX2AttribStream,
        type_: GX2FetchShaderType::Type,
        tessMode: GX2TessellationMode::Type,
    );
    pub fn GX2SetFetchShader(shader: *const GX2FetchShader);
    pub fn GX2SetVertexShader(shader: *const GX2VertexShader);
    pub fn GX2SetPixelShader(shader: *const GX2PixelShader);
    pub fn GX2SetGeometryShader(shader: *const GX2GeometryShader);
    pub fn GX2SetVertexSampler(sampler: *const GX2Sampler, id: u32);
    pub fn GX2SetPixelSampler(sampler: *const GX2Sampler, id: u32);
    pub fn GX2SetGeometrySampler(sampler: *const GX2Sampler, id: u32);
    pub fn GX2SetVertexUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
    pub fn GX2SetPixelUniformReg(offset: u32, count: u32, data: *const ::core::ffi::c_void);
    pub fn GX2SetVertexUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
    pub fn GX2SetPixelUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
    pub fn GX2SetGeometryUniformBlock(location: u32, size: u32, data: *const ::core::ffi::c_void);
    pub fn GX2SetShaderModeEx(
        mode: GX2ShaderMode::Type,
        numVsGpr: u32,
        numVsStackEntries: u32,
        numGsGpr: u32,
        numGsStackEntries: u32,
        numPsGpr: u32,
        numPsStackEntries: u32,
    );
    pub fn GX2SetStreamOutEnable(enable: BOOL);
    pub fn GX2SetGeometryShaderInputRingBuffer(buffer: *const ::core::ffi::c_void, size: u32);
    pub fn GX2SetGeometryShaderOutputRingBuffer(buffer: *mut ::core::ffi::c_void, size: u32);
    pub fn GX2GetPixelShaderGPRs(shader: *const GX2PixelShader) -> u32;
    pub fn GX2GetPixelShaderStackEntries(shader: *const GX2PixelShader) -> u32;
    pub fn GX2GetVertexShaderGPRs(shader: *const GX2VertexShader) -> u32;
    pub fn GX2GetVertexShaderStackEntries(shader: *const GX2VertexShader) -> u32;
    pub fn GX2GetGeometryShaderGPRs(shader: *const GX2GeometryShader) -> u32;
    pub fn GX2GetGeometryShaderStackEntries(shader: *const GX2GeometryShader) -> u32;
    pub fn GX2CalcSurfaceSizeAndAlignment(surface: *mut GX2Surface);
    pub fn GX2CalcDepthBufferHiZInfo(
        depthBuffer: *mut GX2DepthBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
    pub fn GX2CalcColorBufferAuxInfo(
        surface: *mut GX2ColorBuffer,
        outSize: *mut u32,
        outAlignment: *mut u32,
    );
    pub fn GX2SetColorBuffer(colorBuffer: *const GX2ColorBuffer, target: GX2RenderTarget::Type);
    pub fn GX2SetDepthBuffer(depthBuffer: *const GX2DepthBuffer);
    pub fn GX2InitColorBufferRegs(colorBuffer: *mut GX2ColorBuffer);
    pub fn GX2InitDepthBufferRegs(depthBuffer: *mut GX2DepthBuffer);
    pub fn GX2InitDepthBufferHiZEnable(depthBuffer: *mut GX2DepthBuffer, enable: BOOL);
    pub fn GX2GetSurfaceSwizzle(surface: *const GX2Surface) -> u32;
    pub fn GX2SetSurfaceSwizzle(surface: *mut GX2Surface, swizzle: u32);
    pub fn GX2CopySurface(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
    );
    pub fn GX2CopySurfaceEx(
        src: *const GX2Surface,
        srcLevel: u32,
        srcDepth: u32,
        dst: *mut GX2Surface,
        dstLevel: u32,
        dstDepth: u32,
        numRects: u32,
        srcRects: *mut GX2Rect,
        dstPoints: *mut GX2Point,
    );
    pub fn GX2ResolveAAColorBuffer(
        srcColorBuffer: *const GX2ColorBuffer,
        dstSurface: *mut GX2Surface,
        dstMip: u32,
        dstSlice: u32,
    );
    pub fn GX2InitTextureRegs(texture: *mut GX2Texture);
    pub fn GX2SetPixelTexture(texture: *const GX2Texture, unit: u32);
    pub fn GX2SetVertexTexture(texture: *const GX2Texture, unit: u32);
    pub fn GX2SetGeometryTexture(texture: *const GX2Texture, unit: u32);
    pub fn GFDGetLastErrorString() -> *mut ::core::ffi::c_char;
    pub fn GFDGetGeometryShaderCount(file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetGeometryShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetGeometryShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetGeometryShaderCopyProgramSize(index: u32, file: *const ::core::ffi::c_void)
        -> u32;
    pub fn GFDGetGeometryShader(
        shader: *mut GX2GeometryShader,
        program: *mut ::core::ffi::c_void,
        copyProgram: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn GFDGetPixelShaderCount(file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetPixelShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetPixelShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetPixelShader(
        shader: *mut GX2PixelShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn GFDGetVertexShaderCount(file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetVertexShaderHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetVertexShaderProgramSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetVertexShader(
        shader: *mut GX2VertexShader,
        program: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn GFDGetTextureCount(file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetTextureHeaderSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetTextureImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetTextureMipImageSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetTextureAlignmentSize(index: u32, file: *const ::core::ffi::c_void) -> u32;
    pub fn GFDGetTexture(
        texture: *mut GX2Texture,
        image: *mut ::core::ffi::c_void,
        mipmap: *mut ::core::ffi::c_void,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn GFDGetGX2RTexture(
        texture: *mut GX2Texture,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn GFDGetTexturePointer(index: u32, file: *const ::core::ffi::c_void) -> *const GX2Texture;
    pub fn ioctl(fd: ::core::ffi::c_int, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
    pub fn accept(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn bind(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn connect(
        sockfd: ::core::ffi::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn getpeername(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn getsockname(
        sockfd: ::core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn getsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *mut ::core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn listen(sockfd: ::core::ffi::c_int, backlog: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn recv(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
    pub fn recvfrom(
        sockfd: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
    pub fn send(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
    ) -> isize;
    pub fn sendto(
        sockfd: ::core::ffi::c_int,
        buf: *const ::core::ffi::c_void,
        len: usize,
        flags: ::core::ffi::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
    pub fn setsockopt(
        sockfd: ::core::ffi::c_int,
        level: ::core::ffi::c_int,
        optname: ::core::ffi::c_int,
        optval: *const ::core::ffi::c_void,
        optlen: socklen_t,
    ) -> ::core::ffi::c_int;
    pub fn shutdown(sockfd: ::core::ffi::c_int, how: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn socket(
        domain: ::core::ffi::c_int,
        type_: ::core::ffi::c_int,
        protocol: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sockatmark(sockfd: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn GX2SetTessellation(
        tessellationMode: GX2TessellationMode::Type,
        primitiveMode: GX2PrimitiveMode::Type,
        indexType: GX2IndexType::Type,
    );
    pub fn GX2SetMinTessellationLevel(min: f32);
    pub fn GX2SetMaxTessellationLevel(max: f32);
    pub fn GX2ClearColor(
        colorBuffer: *mut GX2ColorBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
    pub fn GX2ClearDepthStencilEx(
        depthBuffer: *mut GX2DepthBuffer,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
    pub fn GX2ClearBuffersEx(
        colorBuffer: *mut GX2ColorBuffer,
        depthBuffer: *mut GX2DepthBuffer,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
        depth: f32,
        stencil: u8,
        clearMode: GX2ClearFlags::Type,
    );
    pub fn GX2SetClearDepth(depthBuffer: *mut GX2DepthBuffer, depth: f32);
    pub fn GX2SetClearStencil(depthBuffer: *mut GX2DepthBuffer, stencil: u8);
    pub fn GX2SetClearDepthStencil(depthBuffer: *mut GX2DepthBuffer, depth: f32, stencil: u8);
    pub fn GX2SetupContextStateEx(state: *mut GX2ContextState, unk1: BOOL);
    pub fn GX2GetContextStateDisplayList(
        state: *const GX2ContextState,
        outDisplayList: *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
    pub fn GX2SetContextState(state: *mut GX2ContextState);
    pub fn GX2SetDefaultState();
    pub fn GX2CopyColorBufferToScanBuffer(
        buffer: *const GX2ColorBuffer,
        scanTarget: GX2ScanTarget::Type,
    );
    pub fn GX2SwapScanBuffers();
    pub fn GX2GetLastFrame(scanTarget: GX2ScanTarget::Type, texture: *mut GX2Texture) -> BOOL;
    pub fn GX2GetLastFrameGamma(scanTarget: GX2ScanTarget::Type, gammaOut: *mut f32) -> BOOL;
    pub fn GX2GetSwapInterval() -> u32;
    pub fn GX2SetSwapInterval(interval: u32);
    pub fn GX2SetTVEnable(enable: BOOL);
    pub fn GX2SetDRCEnable(enable: BOOL);
    pub fn GX2CalcTVSize(
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
    pub fn GX2CalcDRCSize(
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
        size: *mut u32,
        unkOut: *mut u32,
    );
    pub fn GX2SetTVBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        tvRenderMode: GX2TVRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
    pub fn GX2SetDRCBuffer(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        drcRenderMode: GX2DrcRenderMode::Type,
        surfaceFormat: GX2SurfaceFormat::Type,
        bufferingMode: GX2BufferingMode::Type,
    );
    pub fn GX2SetTVScale(x: u32, y: u32);
    pub fn GX2SetDRCScale(x: u32, y: u32);
    pub fn GX2GetSystemTVAspectRatio() -> GX2AspectRatio::Type;
    pub fn GX2GetSystemTVScanMode() -> GX2TVScanMode::Type;
    pub fn GX2GetSystemDRCScanMode() -> GX2DrcRenderMode::Type;
    pub fn GX2GetSystemDRCMode() -> GX2DrcRenderMode::Type;
    pub fn GX2SetDRCConnectCallback(
        drcSlot: u32,
        callback: GX2DRCConnectCallback,
    ) -> GX2DRCConnectCallback;
    pub fn GX2Init(attributes: *mut u32);
    pub fn GX2Shutdown();
    pub fn GX2Flush();
    pub fn GX2ResetGPU(unknown: u32);
    pub fn GX2GetMainCoreId() -> ::core::ffi::c_int;
    pub fn GX2TempGetGPUVersion() -> u32;
    pub fn _GX2DebugSetCaptureInterface(interface: *mut GX2DebugCaptureInterface) -> BOOL;
    pub fn GX2DebugCaptureStart(
        filename: *const ::core::ffi::c_char,
        flags: GX2DebugCaptureStartFlags::Type,
    );
    pub fn GX2DebugCaptureEnd(flags: GX2DebugCaptureEndFlags::Type);
    pub fn GX2DebugCaptureFrame(filename: *const ::core::ffi::c_char);
    pub fn GX2DebugCaptureFrames(filename: *const ::core::ffi::c_char, count: u32);
    pub fn GX2SetAttribBuffer(
        index: u32,
        size: u32,
        stride: u32,
        buffer: *const ::core::ffi::c_void,
    );
    pub fn GX2DrawEx(mode: GX2PrimitiveMode::Type, count: u32, offset: u32, numInstances: u32);
    pub fn GX2DrawEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
    pub fn GX2DrawIndexedEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
    pub fn GX2DrawIndexedEx2(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
        baseInstance: u32,
    );
    pub fn GX2DrawIndexedImmediateEx(
        mode: GX2PrimitiveMode::Type,
        count: u32,
        indexType: GX2IndexType::Type,
        indices: *const ::core::ffi::c_void,
        offset: u32,
        numInstances: u32,
    );
    pub fn GX2SetPrimitiveRestartIndex(index: u32);
    pub fn GX2BeginDisplayListEx(displayList: *mut ::core::ffi::c_void, bytes: u32, unk1: BOOL);
    pub fn GX2EndDisplayList(displayList: *mut ::core::ffi::c_void) -> u32;
    pub fn GX2DirectCallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
    pub fn GX2CallDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
    pub fn GX2GetDisplayListWriteStatus() -> BOOL;
    pub fn GX2GetCurrentDisplayList(
        outDisplayList: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
    pub fn GX2CopyDisplayList(displayList: *const ::core::ffi::c_void, bytes: u32);
    pub fn GX2DrawDone() -> BOOL;
    pub fn GX2WaitForVsync();
    pub fn GX2WaitForFlip();
    pub fn GX2SetEventCallback(
        type_: GX2EventType::Type,
        func: GX2EventCallbackFunction,
        userData: *mut ::core::ffi::c_void,
    );
    pub fn GX2GetEventCallback(
        type_: GX2EventType::Type,
        funcOut: *mut GX2EventCallbackFunction,
        userDataOut: *mut *mut ::core::ffi::c_void,
    );
    pub fn GX2GetRetiredTimeStamp() -> OSTime;
    pub fn GX2GetLastSubmittedTimeStamp() -> OSTime;
    pub fn GX2GetSwapStatus(
        swapCount: *mut u32,
        flipCount: *mut u32,
        lastFlip: *mut OSTime,
        lastVsync: *mut OSTime,
    );
    pub fn GX2WaitTimeStamp(time: OSTime) -> BOOL;
    pub fn GX2Invalidate(
        mode: GX2InvalidateMode::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
    );
    pub fn GX2AllocateTilingApertureEx(
        surface: *mut GX2Surface,
        level: u32,
        depth: u32,
        endian: GX2EndianSwapMode::Type,
        outHandle: *mut GX2ApertureHandle,
        outAddress: *mut *mut ::core::ffi::c_void,
    );
    pub fn GX2FreeTilingAperture(handle: GX2ApertureHandle);
    pub fn GX2SetAAMask(upperLeft: u8, upperRight: u8, lowerLeft: u8, lowerRight: u8);
    pub fn GX2InitAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: u8,
        upperRight: u8,
        lowerLeft: u8,
        lowerRight: u8,
    );
    pub fn GX2GetAAMaskReg(
        reg: *mut GX2AAMaskReg,
        upperLeft: *mut u8,
        upperRight: *mut u8,
        lowerLeft: *mut u8,
        lowerRight: *mut u8,
    );
    pub fn GX2SetAAMaskReg(reg: *const GX2AAMaskReg);
    pub fn GX2SetAlphaTest(alphaTest: BOOL, func: GX2CompareFunction::Type, ref_: f32);
    pub fn GX2InitAlphaTestReg(
        reg: *mut GX2AlphaTestReg,
        alphaTest: BOOL,
        func: GX2CompareFunction::Type,
        ref_: f32,
    );
    pub fn GX2GetAlphaTestReg(
        reg: *const GX2AlphaTestReg,
        alphaTest: *mut BOOL,
        func: *mut GX2CompareFunction::Type,
        ref_: *mut f32,
    );
    pub fn GX2SetAlphaTestReg(reg: *const GX2AlphaTestReg);
    pub fn GX2SetAlphaToMask(alphaToMask: BOOL, mode: GX2AlphaToMaskMode::Type);
    pub fn GX2InitAlphaToMaskReg(
        reg: *mut GX2AlphaToMaskReg,
        alphaToMask: BOOL,
        mode: GX2AlphaToMaskMode::Type,
    );
    pub fn GX2GetAlphaToMaskReg(
        reg: *const GX2AlphaToMaskReg,
        alphaToMask: *mut BOOL,
        mode: *mut GX2AlphaToMaskMode::Type,
    );
    pub fn GX2SetAlphaToMaskReg(reg: *const GX2AlphaToMaskReg);
    pub fn GX2SetBlendConstantColor(red: f32, green: f32, blue: f32, alpha: f32);
    pub fn GX2InitBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: f32,
        green: f32,
        blue: f32,
        alpha: f32,
    );
    pub fn GX2GetBlendConstantColorReg(
        reg: *mut GX2BlendConstantColorReg,
        red: *mut f32,
        green: *mut f32,
        blue: *mut f32,
        alpha: *mut f32,
    );
    pub fn GX2SetBlendConstantColorReg(reg: *const GX2BlendConstantColorReg);
    pub fn GX2SetBlendControl(
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
    pub fn GX2InitBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: GX2RenderTarget::Type,
        colorSrcBlend: GX2BlendMode::Type,
        colorDstBlend: GX2BlendMode::Type,
        colorCombine: GX2BlendCombineMode::Type,
        useAlphaBlend: BOOL,
        alphaSrcBlend: GX2BlendMode::Type,
        alphaDstBlend: GX2BlendMode::Type,
        alphaCombine: GX2BlendCombineMode::Type,
    );
    pub fn GX2GetBlendControlReg(
        reg: *mut GX2BlendControlReg,
        target: *mut GX2RenderTarget::Type,
        colorSrcBlend: *mut GX2BlendMode::Type,
        colorDstBlend: *mut GX2BlendMode::Type,
        colorCombine: *mut GX2BlendCombineMode::Type,
        useAlphaBlend: *mut BOOL,
        alphaSrcBlend: *mut GX2BlendMode::Type,
        alphaDstBlend: *mut GX2BlendMode::Type,
        alphaCombine: *mut GX2BlendCombineMode::Type,
    );
    pub fn GX2SetBlendControlReg(reg: *const GX2BlendControlReg);
    pub fn GX2SetColorControl(
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
    pub fn GX2InitColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: GX2LogicOp::Type,
        targetBlendEnable: u8,
        multiWriteEnable: BOOL,
        colorWriteEnable: BOOL,
    );
    pub fn GX2GetColorControlReg(
        reg: *mut GX2ColorControlReg,
        rop3: *mut GX2LogicOp::Type,
        targetBlendEnable: *mut u8,
        multiWriteEnable: *mut BOOL,
        colorWriteEnable: *mut BOOL,
    );
    pub fn GX2SetColorControlReg(reg: *const GX2ColorControlReg);
    pub fn GX2SetDepthOnlyControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
    );
    pub fn GX2SetDepthStencilControl(
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
    pub fn GX2InitDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: BOOL,
        depthWrite: BOOL,
        depthCompare: GX2CompareFunction::Type,
        stencilTest: BOOL,
        backfaceStencil: BOOL,
        frontStencilFunc: GX2CompareFunction::Type,
        frontStencilZPass: GX2StencilFunction::Type,
        frontStencilZFail: GX2StencilFunction::Type,
        frontStencilFail: GX2StencilFunction::Type,
        backStencilFunc: GX2CompareFunction::Type,
        backStencilZPass: GX2StencilFunction::Type,
        backStencilZFail: GX2StencilFunction::Type,
        backStencilFail: GX2StencilFunction::Type,
    );
    pub fn GX2GetDepthStencilControlReg(
        reg: *mut GX2DepthStencilControlReg,
        depthTest: *mut BOOL,
        depthWrite: *mut BOOL,
        depthCompare: *mut GX2CompareFunction::Type,
        stencilTest: *mut BOOL,
        backfaceStencil: *mut BOOL,
        frontStencilFunc: *mut GX2CompareFunction::Type,
        frontStencilZPass: *mut GX2StencilFunction::Type,
        frontStencilZFail: *mut GX2StencilFunction::Type,
        frontStencilFail: *mut GX2StencilFunction::Type,
        backStencilFunc: *mut GX2CompareFunction::Type,
        backStencilZPass: *mut GX2StencilFunction::Type,
        backStencilZFail: *mut GX2StencilFunction::Type,
        backStencilFail: *mut GX2StencilFunction::Type,
    );
    pub fn GX2SetDepthStencilControlReg(reg: *const GX2DepthStencilControlReg);
    pub fn GX2SetStencilMask(
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
    pub fn GX2InitStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: u8,
        frontWriteMask: u8,
        frontRef: u8,
        backMask: u8,
        backWriteMask: u8,
        backRef: u8,
    );
    pub fn GX2GetStencilMaskReg(
        reg: *mut GX2StencilMaskReg,
        frontMask: *mut u8,
        frontWriteMask: *mut u8,
        frontRef: *mut u8,
        backMask: *mut u8,
        backWriteMask: *mut u8,
        backRef: *mut u8,
    );
    pub fn GX2SetStencilMaskReg(reg: *const GX2StencilMaskReg);
    pub fn GX2SetLineWidth(width: f32);
    pub fn GX2InitLineWidthReg(reg: *mut GX2LineWidthReg, width: f32);
    pub fn GX2GetLineWidthReg(reg: *mut GX2LineWidthReg, width: *mut f32);
    pub fn GX2SetLineWidthReg(reg: *const GX2LineWidthReg);
    pub fn GX2SetPointSize(width: f32, height: f32);
    pub fn GX2InitPointSizeReg(reg: *mut GX2PointSizeReg, width: f32, height: f32);
    pub fn GX2GetPointSizeReg(reg: *mut GX2PointSizeReg, width: *mut f32, height: *mut f32);
    pub fn GX2SetPointSizeReg(reg: *const GX2PointSizeReg);
    pub fn GX2SetPointLimits(min: f32, max: f32);
    pub fn GX2InitPointLimitsReg(reg: *mut GX2PointLimitsReg, min: f32, max: f32);
    pub fn GX2GetPointLimitsReg(reg: *mut GX2PointLimitsReg, min: *mut f32, max: *mut f32);
    pub fn GX2SetPointLimitsReg(reg: *const GX2PointLimitsReg);
    pub fn GX2SetCullOnlyControl(frontFace: GX2FrontFace::Type, cullFront: BOOL, cullBack: BOOL);
    pub fn GX2SetPolygonControl(
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
    pub fn GX2InitPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: GX2FrontFace::Type,
        cullFront: BOOL,
        cullBack: BOOL,
        polyMode: BOOL,
        polyModeFront: GX2PolygonMode::Type,
        polyModeBack: GX2PolygonMode::Type,
        polyOffsetFrontEnable: BOOL,
        polyOffsetBackEnable: BOOL,
        polyOffsetParaEnable: BOOL,
    );
    pub fn GX2GetPolygonControlReg(
        reg: *mut GX2PolygonControlReg,
        frontFace: *mut GX2FrontFace::Type,
        cullFront: *mut BOOL,
        cullBack: *mut BOOL,
        polyMode: *mut BOOL,
        polyModeFront: *mut GX2PolygonMode::Type,
        polyModeBack: *mut GX2PolygonMode::Type,
        polyOffsetFrontEnable: *mut BOOL,
        polyOffsetBackEnable: *mut BOOL,
        polyOffsetParaEnable: *mut BOOL,
    );
    pub fn GX2SetPolygonControlReg(reg: *const GX2PolygonControlReg);
    pub fn GX2SetPolygonOffset(
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
    pub fn GX2InitPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: f32,
        frontScale: f32,
        backOffset: f32,
        backScale: f32,
        clamp: f32,
    );
    pub fn GX2GetPolygonOffsetReg(
        reg: *mut GX2PolygonOffsetReg,
        frontOffset: *mut f32,
        frontScale: *mut f32,
        backOffset: *mut f32,
        backScale: *mut f32,
        clamp: *mut f32,
    );
    pub fn GX2SetPolygonOffsetReg(reg: *const GX2PolygonOffsetReg);
    pub fn GX2SetScissor(x: u32, y: u32, width: u32, height: u32);
    pub fn GX2InitScissorReg(reg: *mut GX2ScissorReg, x: u32, y: u32, width: u32, height: u32);
    pub fn GX2GetScissorReg(
        reg: *mut GX2ScissorReg,
        x: *mut u32,
        y: *mut u32,
        width: *mut u32,
        height: *mut u32,
    );
    pub fn GX2SetScissorReg(reg: *const GX2ScissorReg);
    pub fn GX2SetTargetChannelMasks(
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
    pub fn GX2InitTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: GX2ChannelMask::Type,
        mask1: GX2ChannelMask::Type,
        mask2: GX2ChannelMask::Type,
        mask3: GX2ChannelMask::Type,
        mask4: GX2ChannelMask::Type,
        mask5: GX2ChannelMask::Type,
        mask6: GX2ChannelMask::Type,
        mask7: GX2ChannelMask::Type,
    );
    pub fn GX2GetTargetChannelMasksReg(
        reg: *mut GX2TargetChannelMaskReg,
        mask0: *mut GX2ChannelMask::Type,
        mask1: *mut GX2ChannelMask::Type,
        mask2: *mut GX2ChannelMask::Type,
        mask3: *mut GX2ChannelMask::Type,
        mask4: *mut GX2ChannelMask::Type,
        mask5: *mut GX2ChannelMask::Type,
        mask6: *mut GX2ChannelMask::Type,
        mask7: *mut GX2ChannelMask::Type,
    );
    pub fn GX2SetTargetChannelMasksReg(reg: *const GX2TargetChannelMaskReg);
    pub fn GX2SetViewport(x: f32, y: f32, width: f32, height: f32, nearZ: f32, farZ: f32);
    pub fn GX2InitViewportReg(
        reg: *mut GX2ViewportReg,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        nearZ: f32,
        farZ: f32,
    );
    pub fn GX2GetViewportReg(
        reg: *mut GX2ViewportReg,
        x: *mut f32,
        y: *mut f32,
        width: *mut f32,
        height: *mut f32,
        nearZ: *mut f32,
        farZ: *mut f32,
    );
    pub fn GX2SetViewportReg(reg: *const GX2ViewportReg);
    pub fn GX2SetRasterizerClipControl(rasterizer: BOOL, zclipEnable: BOOL);
    pub fn GX2SetRasterizerClipControlEx(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
    pub fn GX2SetRasterizerClipControlHalfZ(rasterizer: BOOL, zclipEnable: BOOL, halfZ: BOOL);
    pub fn H264DECCheckDecunitLength(
        memory: *mut ::core::ffi::c_void,
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outLength: *mut i32,
    ) -> H264Error::Type;
    pub fn H264DECCheckSkipableFrame(
        buffer: *const u8,
        bufferLength: i32,
        outSkippable: *mut BOOL,
    ) -> H264Error::Type;
    pub fn H264DECFindDecstartpoint(
        buffer: *const u8,
        bufferLength: i32,
        outOffset: *mut i32,
    ) -> H264Error::Type;
    pub fn H264DECFindIdrpoint(buffer: *const u8, bufferLength: i32, outOffset: *mut i32) -> i32;
    pub fn H264DECGetImageSize(
        buffer: *const u8,
        bufferLength: i32,
        offset: i32,
        outWidth: *mut i32,
        outHeight: *mut i32,
    ) -> H264Error::Type;
    pub fn H264DECMemoryRequirement(
        profile: i32,
        level: i32,
        maxWidth: i32,
        maxHeight: i32,
        outMemoryRequirement: *mut u32,
    ) -> H264Error::Type;
    pub fn H264DECInitParam(memorySize: i32, memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn H264DECSetParam(
        memory: *mut ::core::ffi::c_void,
        parameter: H264Parameter::Type,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
    pub fn H264DECSetParam_FPTR_OUTPUT(
        memory: *mut ::core::ffi::c_void,
        value: H264DECFptrOutputFn,
    ) -> H264Error::Type;
    pub fn H264DECSetParam_OUTPUT_PER_FRAME(
        memory: *mut ::core::ffi::c_void,
        value: u32,
    ) -> H264Error::Type;
    pub fn H264DECSetParam_USER_MEMORY(
        memory: *mut ::core::ffi::c_void,
        value: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
    pub fn H264DECCheckMemSegmentation(
        memory: *mut ::core::ffi::c_void,
        size: u32,
    ) -> H264Error::Type;
    pub fn H264DECOpen(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn H264DECBegin(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn H264DECSetBitstream(
        memory: *mut ::core::ffi::c_void,
        buffer: *mut u8,
        bufferLength: u32,
        timestamp: f64,
    ) -> H264Error::Type;
    pub fn H264DECExecute(
        memory: *mut ::core::ffi::c_void,
        frameBuffer: *mut ::core::ffi::c_void,
    ) -> H264Error::Type;
    pub fn H264DECFlush(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn H264DECEnd(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn H264DECClose(memory: *mut ::core::ffi::c_void) -> H264Error::Type;
    pub fn HIDSetup() -> i32;
    pub fn HIDTeardown() -> i32;
    pub fn HIDAddClient(client: *mut HIDClient, attachCallback: HIDAttachCallback) -> i32;
    pub fn HIDDelClient(client: *mut HIDClient) -> i32;
    pub fn HIDGetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDSetDescriptor(
        handle: u32,
        descriptorType: u8,
        descriptorIndex: u8,
        languageId: u16,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDGetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDSetReport(
        handle: u32,
        reportType: u8,
        reportId: u8,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDGetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDSetIdle(
        handle: u32,
        interfaceIndex: u8,
        reportId: u8,
        duration: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDSetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDGetProtocol(
        handle: u32,
        interfaceIndex: u8,
        protocol: *mut u8,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDRead(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        callback: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn HIDWrite(
        handle: u32,
        buffer: *mut u8,
        bufferLength: u32,
        hc: HIDCallback,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn OSSetExceptionCallback(
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
    pub fn OSSetExceptionCallbackEx(
        mode: OSExceptionMode::Type,
        exceptionType: OSExceptionType::Type,
        callback: OSExceptionCallbackFn,
    ) -> OSExceptionCallbackFn;
    pub fn OSCancelThread(thread: *mut OSThread);
    pub fn OSCheckActiveThreads() -> i32;
    pub fn OSCheckThreadStackUsage(thread: *mut OSThread) -> i32;
    pub fn OSClearThreadStackUsage(thread: *mut OSThread);
    pub fn OSContinueThread(thread: *mut OSThread);
    pub fn OSCreateThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: i32,
        argv: *mut ::core::ffi::c_char,
        stack: *mut ::core::ffi::c_void,
        stackSize: u32,
        priority: i32,
        attributes: OSThreadAttributes,
    ) -> BOOL;
    pub fn OSDetachThread(thread: *mut OSThread);
    pub fn OSExitThread(result: i32);
    pub fn OSGetActiveThreadLink(thread: *mut OSThread, link: *mut OSThreadLink);
    pub fn OSGetCurrentThread() -> *mut OSThread;
    pub fn OSGetDefaultThread(coreID: u32) -> *mut OSThread;
    pub fn OSGetStackPointer() -> u32;
    pub fn OSGetThreadAffinity(thread: *mut OSThread) -> u32;
    pub fn OSGetThreadName(thread: *mut OSThread) -> *const ::core::ffi::c_char;
    pub fn OSGetThreadPriority(thread: *mut OSThread) -> i32;
    pub fn OSGetThreadSpecific(id: OSThreadSpecificID::Type) -> *mut ::core::ffi::c_void;
    pub fn OSIsThreadSuspended(thread: *mut OSThread) -> BOOL;
    pub fn OSIsThreadTerminated(thread: *mut OSThread) -> BOOL;
    pub fn OSJoinThread(thread: *mut OSThread, threadResult: *mut ::core::ffi::c_int) -> BOOL;
    pub fn OSResumeThread(thread: *mut OSThread) -> i32;
    pub fn OSRunThread(
        thread: *mut OSThread,
        entry: OSThreadEntryPointFn,
        argc: ::core::ffi::c_int,
        argv: *mut *const ::core::ffi::c_char,
    ) -> BOOL;
    pub fn OSSetThreadAffinity(thread: *mut OSThread, affinity: u32) -> BOOL;
    pub fn OSSetThreadCancelState(state: BOOL) -> BOOL;
    pub fn OSSetThreadCleanupCallback(
        thread: *mut OSThread,
        callback: OSThreadCleanupCallbackFn,
    ) -> OSThreadCleanupCallbackFn;
    pub fn OSSetThreadDeallocator(
        thread: *mut OSThread,
        deallocator: OSThreadDeallocatorFn,
    ) -> OSThreadDeallocatorFn;
    pub fn OSSetThreadName(thread: *mut OSThread, name: *const ::core::ffi::c_char);
    pub fn OSSetThreadPriority(thread: *mut OSThread, priority: i32) -> BOOL;
    pub fn OSSetThreadRunQuantum(thread: *mut OSThread, quantum: u32) -> BOOL;
    pub fn OSSetThreadSpecific(id: OSThreadSpecificID::Type, value: *mut ::core::ffi::c_void);
    pub fn OSSetThreadStackUsage(thread: *mut OSThread) -> BOOL;
    pub fn OSSleepThread(queue: *mut OSThreadQueue);
    pub fn OSSleepTicks(ticks: OSTime);
    pub fn OSSuspendThread(thread: *mut OSThread) -> u32;
    pub fn __OSSuspendThreadNolock(thread: *mut OSThread);
    pub fn OSTestThreadCancel();
    pub fn OSWakeupThread(queue: *mut OSThreadQueue);
    pub fn OSYieldThread();
    pub fn CAMInit(
        instance: ::core::ffi::c_int,
        setupInfo: *mut CAMSetupInfo,
        err: *mut CAMError,
    ) -> CAMHandle;
    pub fn CAMExit(handle: CAMHandle);
    pub fn CAMOpen(handle: CAMHandle) -> CAMError;
    pub fn CAMClose(handle: CAMHandle) -> CAMError;
    pub fn CAMGetMemReq(streamInfo: *mut CAMStreamInfo) -> i32;
    pub fn CAMSubmitTargetSurface(handle: CAMHandle, surface: *mut CAMSurface) -> CAMError;
    pub fn CAMCheckMemSegmentation(pMem: *mut ::core::ffi::c_void, size: u32) -> CAMError;
    pub fn ProcUIClearCallbacks();
    pub fn ProcUIDrawDoneRelease();
    pub fn ProcUIInForeground() -> BOOL;
    pub fn ProcUIInShutdown() -> BOOL;
    pub fn ProcUIInit(saveCallback: ProcUISaveCallback);
    pub fn ProcUIInitEx(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
    pub fn ProcUIIsRunning() -> BOOL;
    pub fn ProcUIProcessMessages(block: BOOL) -> ProcUIStatus::Type;
    pub fn ProcUIRegisterCallback(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
    );
    pub fn ProcUIRegisterCallbackCore(
        type_: ProcUICallbackType::Type,
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        priority: u32,
        core: u32,
    );
    pub fn ProcUIRegisterBackgroundCallback(
        callback: ProcUICallback,
        param: *mut ::core::ffi::c_void,
        interval: OSTime,
    );
    pub fn ProcUISetSaveCallback(saveCallback: ProcUISaveCallbackEx, arg: *mut ::core::ffi::c_void);
    pub fn ProcUIShutdown();
    pub fn ProcUISubProcessMessages(block: BOOL) -> ProcUIStatus::Type;
    pub fn ProcUICalcMemorySize(numCallbacks: u32) -> u32;
    pub fn ProcUISetMemoryPool(pool: *mut ::core::ffi::c_void, size: u32) -> i32;
    pub fn ProcUISetCallbackStackSize(size: u32);
    pub fn ProcUISetBucketStorage(buf: *mut ::core::ffi::c_void, size: u32);
    pub fn ProcUISetMEM1Storage(buf: *mut ::core::ffi::c_void, size: u32);
    pub fn CCRCDCCommand(
        unk: u8,
        fragment: u8,
        dest: CCRCDCDestination,
        flags0: u8,
        flags1: u8,
        service: u8,
        method: u8,
        payload: *mut ::core::ffi::c_void,
        payloadSize: u32,
        reply: *mut ::core::ffi::c_void,
        replySize: u32,
    ) -> i32;
    pub fn CCRCDCDevicePing(dest: CCRCDCDestination) -> i32;
    pub fn CCRCDCSetStationId(id: *mut CCRCDCMacAddress) -> i32;
    pub fn CCRCDCGetMacAddress(dest: CCRCDCDestination, mac: *mut CCRCDCMacAddress) -> i32;
    pub fn CCRCDCGetMultiDrc(numDrcs: *mut u8) -> i32;
    pub fn CCRCDCSetMultiDrc(numDrcs: u8) -> i32;
    pub fn CCRCDCSysGetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
    pub fn CCRCDCSysSetDrcState(dest: CCRCDCDestination, state: *mut CCRCDCDrcState) -> i32;
    pub fn CCRCDCSysGetDrhState(state: *mut CCRCDCDrhState) -> i32;
    pub fn CCRCDCSysSetDrhState(state: *mut CCRCDCDrhState) -> i32;
    pub fn CCRCDCWpsStart() -> i32;
    pub fn CCRCDCWpsStartEx(args: *mut CCRCDCWpsArgs) -> i32;
    pub fn CCRCDCWpsStatus(status: *mut CCRCDCWpsStatusType) -> i32;
    pub fn CCRCDCWpsStop() -> i32;
    pub fn CCRCDCSysGetInfo(dest: CCRCDCDestination, info: *mut CCRCDCSysInfo) -> i32;
    pub fn CCRCDCSysDrcDisplayMessage(
        dest: CCRCDCDestination,
        message: *mut CCRCDCSysMessage,
    ) -> i32;
    pub fn CCRCDCPerGetUicEeprom(dest: CCRCDCDestination, eeprom: *mut CCRCDCEepromData) -> i32;
    pub fn CCRCDCPerGetUicEepromEx(
        dest: CCRCDCDestination,
        eeprom: *mut CCRCDCEepromData,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCSysConsoleShutdownInd(dest: CCRCDCDestination) -> i32;
    pub fn CCRCDCWowlWakeDrc(arg: *mut CCRCDCWowlWakeDrcArg) -> i32;
    pub fn CCRCDCPerClearUicConfig(dest: CCRCDCDestination) -> i32;
    pub fn CCRCDCPerSetUicConfig(dest: CCRCDCDestination, config: *mut CCRCDCUicConfig) -> i32;
    pub fn CCRCDCCalcCRC16(data: *mut ::core::ffi::c_void, dataSize: u32) -> u16;
    pub fn CCRCDCGetFWInfo(dest: CCRCDCDestination, outInfo: *mut CCRCDCFWInfo) -> i32;
    pub fn CCRCDCSoftwareGetVersion(
        dest: CCRCDCDestination,
        outVersion: *mut CCRCDCSoftwareVersion,
    ) -> i32;
    pub fn CCRCDCSoftwareUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCSoftwareAbort(dest: CCRCDCDestination) -> i32;
    pub fn CCRCDCSoftwareActivate(dest: CCRCDCDestination) -> i32;
    pub fn CCRCDCSoftwareLangUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        outVersion: *mut u32,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCSoftwareLangActivate(
        dest: CCRCDCDestination,
        version: u32,
        outActivationResult: *mut u32,
    ) -> i32;
    pub fn CCRCDCSoftwareGetExtId(
        dest: CCRCDCDestination,
        ext: CCRCDCExt::Type,
        outId: *mut u32,
    ) -> i32;
    pub fn CCRCDCSoftwareExtUpdate(
        dest: CCRCDCDestination,
        path: *const ::core::ffi::c_char,
        imageSize: u32,
        extId: u32,
        ext: CCRCDCExt::Type,
        callback: IOSAsyncCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterAOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterCFGAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterHIDAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterSYSAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterUACAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterUVCAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCRegisterVOAttachCallback(
        callback: CCRCDCRegisterCallbackFn,
        context: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRCDCPerIrdaControl(
        dest: CCRCDCDestination,
        request: *mut ::core::ffi::c_void,
        requestSize: u32,
        response: *mut ::core::ffi::c_void,
        responseSize: u32,
    ) -> i32;
    pub fn __CCRCDCIRCConnect(
        drcIndex: i32,
        result: *mut u8,
        timeout: u16,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        targetId: u8,
        type_: CCRCDCIrdaConnectionType,
    ) -> i32;
    pub fn __CCRCDCIRCSend(
        drcIndex: i32,
        result: *mut u8,
        size: u32,
        receiveSize: u32,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn __CCRCDCIRCReceive(
        drcIndex: i32,
        result: *mut u8,
        receivedSize: *mut u16,
        data: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn __CCRCDCIRCDisconnect(drcIndex: i32, result: *mut u8) -> i32;
    pub fn IRCInit(channel: VPADChan::Type, targetId: u8) -> BOOL;
    pub fn IRCConnect(
        channel: VPADChan::Type,
        timeout: u16,
        type_: CCRCDCIrdaConnectionType,
        bitrate: CCRCDCIrdaBitrate,
        receiveSize: u32,
        callback: IRCConnectCallback,
    ) -> IRCResult::Type;
    pub fn IRCProc(channel: VPADChan::Type) -> IRCResult::Type;
    pub fn IRCSend(
        channel: VPADChan::Type,
        data: *mut ::core::ffi::c_void,
        dataSize: u32,
        receiveSize: u32,
    ) -> IRCResult::Type;
    pub fn IRCIsConnect(channel: VPADChan::Type) -> BOOL;
    pub fn IRCDisconnect(channel: VPADChan::Type) -> IRCResult::Type;
    pub fn IRCSetReceiveCallback(
        channel: VPADChan::Type,
        receiveCallback: IRCReceiveCallback,
    ) -> IRCReceiveCallback;
    pub fn KBDInit(
        unused: u32,
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError::Type;
    pub fn KBDSetup(
        attachCallback: KDBAttachCallback,
        detachCallback: KDBAttachCallback,
        keyCallback: KDBKeyCallback,
    ) -> KDBError::Type;
    pub fn KBDTeardown() -> KDBError::Type;
    pub fn KBDSetCountry(channel: u8, country: KDBCountry::Type) -> KDBError::Type;
    pub fn poll(fds: *mut pollfd, nfds: nfds_t, timeout: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn DMAEWaitDone(timestamp: DMAETimeStamp) -> BOOL;
    pub fn DMAECopyMem(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        wordCount: u32,
        swap: DMAESwapMode::Type,
    ) -> DMAETimeStamp;
    pub fn DMAEFillMem(dst: *mut ::core::ffi::c_void, val: u32, wordCount: u32) -> DMAETimeStamp;
    pub fn DMAEFillMemPhys(
        dst: *mut ::core::ffi::c_void,
        val: u32,
        wordCount: u32,
    ) -> DMAETimeStamp;
    pub fn htonl(hostlong: u32) -> u32;
    pub fn htons(hostshort: u16) -> u16;
    pub fn ntohl(netlong: u32) -> u32;
    pub fn ntohs(netshort: u16) -> u16;
    pub fn inet_addr(cp: *const ::core::ffi::c_char) -> in_addr_t;
    pub fn inet_aton(cp: *const ::core::ffi::c_char, inp: *mut in_addr) -> ::core::ffi::c_int;
    pub fn inet_ntoa(in_: in_addr) -> *mut ::core::ffi::c_char;
    pub fn inet_ntoa_r(in_: in_addr, buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn inet_ntop(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_char,
        size: socklen_t,
    ) -> *const ::core::ffi::c_char;
    pub fn inet_pton(
        af: ::core::ffi::c_int,
        src: *const ::core::ffi::c_char,
        dst: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn somemopt(
        request: SOMemOptRequest::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags::Type,
    ) -> ::core::ffi::c_int;
    pub fn __rplwrap_somemopt(
        request: SOMemOptRequest::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        flags: SOMemOptFlags::Type,
    ) -> ::core::ffi::c_int;
    pub fn OSInitEvent(event: *mut OSEvent, value: BOOL, mode: OSEventMode::Type);
    pub fn OSInitEventEx(
        event: *mut OSEvent,
        value: BOOL,
        mode: OSEventMode::Type,
        name: *mut ::core::ffi::c_char,
    );
    pub fn OSSignalEvent(event: *mut OSEvent);
    pub fn OSSignalEventAll(event: *mut OSEvent);
    pub fn OSWaitEvent(event: *mut OSEvent);
    pub fn OSResetEvent(event: *mut OSEvent);
    pub fn OSWaitEventWithTimeout(event: *mut OSEvent, timeout: OSTime) -> BOOL;
    pub fn SYSGetArguments(args: *mut SYSArgDataBlock, callerInfo: *mut SYSCallerInfo) -> i32;
    pub fn SYSGetStandardArgs(stdArgs: *mut SYSStandardArgs) -> i32;
    pub fn SYSClearSysArgs();
    pub fn SYSPackArgs() -> i32;
    pub fn SYSSerializeSysArgs(
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        size: u32,
    ) -> i32;
    pub fn SYSSerializeSysArgsToBuffer(
        buffer: *mut ::core::ffi::c_char,
        bytesWritten: *mut u32,
        bufferSize: u32,
        argName: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        dataSize: u32,
    ) -> i32;
    pub fn SYSDeserializeSysArgs(
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn SYSDeserializeSysArgsFromBlock(
        block: *mut ::core::ffi::c_void,
        blockSize: u32,
        callback: SYSDeserializeCallback,
        userArg: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn _SYSDirectlyReturnToCaller(arg: *mut SYSStandardArgsOut) -> i32;
    pub fn _SYSSerializeStandardArgsIn(arg: *mut SYSStandardArgsIn) -> i32;
    pub fn _SYSDeserializeStandardArg(
        deserializeArg: *mut SYSDeserializeArg,
        standardArg: *mut SYSStandardArgs,
    ) -> BOOL;
    pub fn ACPCheckApplicationDeviceEmulation(emulation: *mut BOOL) -> ACPResult::Type;
    pub fn MCP_Open() -> MCPError;
    pub fn MCP_Close(handle: ::core::ffi::c_int) -> MCPError;
    pub fn MCP_DeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
    pub fn MCP_FullDeviceList(
        handle: ::core::ffi::c_int,
        numDevices: *mut ::core::ffi::c_int,
        outDeviceList: *mut MCPDevice,
        deviceListSizeInBytes: u32,
    ) -> MCPError;
    pub fn MCP_GetOwnTitleInfo(handle: i32, titleInfo: *mut MCPTitleListType) -> MCPError;
    pub fn MCP_GetSysProdSettings(handle: i32, settings: *mut MCPSysProdSettings) -> MCPError;
    pub fn MCP_GetSystemVersion(handle: i32, systemVersion: *mut MCPSystemVersion) -> MCPError;
    pub fn MCP_GetTitleId(handle: i32, outTitleId: *mut u64) -> MCPError;
    pub fn MCP_GetTitleInfo(
        handle: i32,
        titleId: u64,
        titleInfo: *mut MCPTitleListType,
    ) -> MCPError;
    pub fn MCP_InstallSetTargetDevice(
        handle: ::core::ffi::c_int,
        device: MCPInstallTarget::Type,
    ) -> MCPError;
    pub fn MCP_InstallGetTargetDevice(
        handle: ::core::ffi::c_int,
        deviceOut: *mut MCPInstallTarget::Type,
    ) -> MCPError;
    pub fn MCP_InstallSetTargetUsb(handle: ::core::ffi::c_int, usb: ::core::ffi::c_int)
        -> MCPError;
    pub fn MCP_InstallGetInfo(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallInfo,
    ) -> MCPError;
    pub fn MCP_InstallTitleAsync(
        handle: ::core::ffi::c_int,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
    pub fn MCP_InstallGetProgress(
        handle: ::core::ffi::c_int,
        installProgressOut: *mut MCPInstallProgress,
    ) -> MCPError;
    pub fn MCP_InstallTitleAbort(handle: ::core::ffi::c_int) -> MCPError;
    pub fn MCP_TitleCount(handle: i32) -> MCPError;
    pub fn MCP_TitleList(
        handle: i32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByAppType(
        handle: i32,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByUniqueId(
        handle: i32,
        uniqueId: u32,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByDevice(
        handle: i32,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByDeviceType(
        handle: i32,
        deviceType: MCPDeviceType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByAppAndDevice(
        handle: i32,
        appType: MCPAppType::Type,
        deviceName: *const ::core::ffi::c_char,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByAppAndDeviceType(
        handle: i32,
        appType: MCPAppType::Type,
        deviceType: MCPDeviceType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_TitleListByUniqueIdAndIndexedDeviceAndAppType(
        handle: i32,
        uniqueId: u32,
        indexedDevice: *const ::core::ffi::c_char,
        unk0x60: u8,
        appType: MCPAppType::Type,
        outTitleCount: *mut u32,
        titleList: *mut MCPTitleListType,
        titleListSizeBytes: u32,
    ) -> MCPError;
    pub fn MCP_UninstallTitleAsync(
        handle: i32,
        path: *const ::core::ffi::c_char,
        out: *mut MCPInstallTitleInfo,
    ) -> MCPError;
    pub fn MCP_CompatLoadAVFile(
        handle: i32,
        ptr: *mut ::core::ffi::c_void,
        size: *mut u32,
        file: MCPCompatAVFile::Type,
    ) -> MCPError;
    pub fn MCP_TriggerCrashLogCollection(handle: i32) -> MCPError;
    pub fn MCP_ChangeEcoSettings(
        handle: i32,
        enable: u32,
        maxOnTime: u32,
        defaultOffTime: u16,
    ) -> MCPError;
    pub fn ACPAssignTitlePatch(titleInfo: *mut MCPTitleListType) -> ACPResult::Type;
    pub fn ACPGetTitleIdOfMainApplication(titleId: *mut ACPTitleId) -> ACPResult::Type;
    pub fn __rplwrap_ACPGetTitleMetaXml(
        titleId: ACPTitleId,
        metaXml: *mut ACPMetaXml,
    ) -> ACPResult::Type;
    pub fn __rplwrap_ACPGetTitleSaveMetaXml(
        titleId: u64,
        metaXml: *mut ACPMetaXml,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
    pub fn ACPGetTitleMetaDir(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult::Type;
    pub fn ACPGetTitleMetaDirByDevice(
        titleId: ACPTitleId,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
    pub fn ACPGetTitleMetaDirByTitleListType(
        titleListType: MCPTitleListType,
        directory: *mut ::core::ffi::c_char,
        directoryLen: usize,
    ) -> ACPResult::Type;
    pub fn ACPDrcLedStartTest();
    pub fn ACPDrcLedStopTest();
    pub fn ACPGetDrcLedStat(ledStatus: *mut ACPDrcLedStatus);
    pub fn ACPGetDrcLedStatusOfPattern(ledStatus: *mut ACPDrcLedStatus, pattern: ACPDrcLedPattern);
    pub fn ACPSetDrcLedDummyPowerStat(unk1: u8);
    pub fn ACPSetDrcLedTimerLength(unk1: u64, unk2: u64);
    pub fn ACPSetDrcLedTimerSpeed(speed: u32);
    pub fn ACPTurnOffDrcLed();
    pub fn ACPTurnOffDrcLedTest(unk1: u8);
    pub fn ACPTurnOnDrcLed(unk1: u32, pattern: ACPDrcLedPattern);
    pub fn ACPTurnOnDrcLedTest(unk1: u8, unk2: u32, pattern: ACPDrcLedPattern);
    pub fn ACPInitialize();
    pub fn ACPFinalize();
    pub fn ACPCreateSaveDir(persistentId: u32, deviceType: ACPDeviceType::Type) -> ACPResult::Type;
    pub fn ACPIsExternalStorageRequired(required: *mut BOOL) -> ACPResult::Type;
    pub fn ACPMountExternalStorage() -> ACPResult::Type;
    pub fn ACPMountSaveDir() -> ACPResult::Type;
    pub fn ACPRemoveSaveDir(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
    pub fn ACPRemoveSaveDirWithoutFlush(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
    pub fn ACPRemoveSaveDirWithoutMetaCheck(
        persistentId: u32,
        titleId: u64,
        deviceType: ACPDeviceType::Type,
    ) -> ACPResult::Type;
    pub fn ACPRepairSaveMetaDir() -> ACPResult::Type;
    pub fn ACPUnmountExternalStorage() -> ACPResult::Type;
    pub fn ACPUnmountSaveDir() -> ACPResult::Type;
    pub fn ACPGetSaveDataTitleIdList(
        deviceType: ACPDeviceType::Type,
        titlesOut: *mut u64,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
    pub fn ACPGetTitleSaveDirEx(
        titleId: u64,
        deviceType: ACPDeviceType::Type,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
    pub fn ACPGetTitleSaveDirExWithoutMetaCheck(
        titleId: u64,
        deviceType: ACPDeviceType::Type,
        u1: u32,
        saveDirInfo: *mut ACPSaveDirInfo,
        maxCount: u32,
        countOut: *mut u32,
    ) -> ACPResult::Type;
    pub fn HPADInit() -> i32;
    pub fn HPADShutdown() -> i32;
    pub fn __rplwrap_HPADRead(chan: HPADChan::Type, buffers: *mut HPADStatus, count: i32) -> i32;
    pub fn HPADControlMotor(chan: HPADChan::Type, command: HPADMotorCommand::Type) -> i32;
    pub fn HPADRecalibrate(chan: HPADChan::Type) -> i32;
    pub fn HPADSetConnectCallback(
        chan: HPADChan::Type,
        callback: HPADConnectCallback,
    ) -> HPADConnectCallback;
    pub fn HPADGetGGGGStatus(chan: HPADGGGGChan::Type, status: *mut HPADGGGGStatus) -> i32;
    pub fn HPADSetGgggConnectCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADGGGGConnectCallback,
    ) -> HPADGGGGConnectCallback;
    pub fn HPADSetPowerSupplyCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADPowerSupplyCallback,
    ) -> HPADPowerSupplyCallback;
    pub fn HPADSetSamplingCallback(
        chan: HPADGGGGChan::Type,
        callback: HPADSamplingCallback,
    ) -> HPADSamplingCallback;
    pub fn HPADResetDevice(chan: HPADGGGGChan::Type, callback: HPADResetCallback) -> i32;
    pub fn BETA_DEBUG_DUMP();
    pub fn BETA_DEBUG_GET_QUEUE_SIZE(chan: HPADGGGGChan::Type) -> i32;
    pub fn BETA_DEBUG_SEND_REPT_ID(chan: HPADGGGGChan::Type, reptId: u32);
    pub fn BETA_DEBUG_GET_RAW_DATA();
    pub fn BETA_DEBUG_SET_DUMP_MODE();
    pub fn OSInitSpinLock(spinlock: *mut OSSpinLock);
    pub fn OSAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn OSTryAcquireSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn OSTryAcquireSpinLockWithTimeout(spinlock: *mut OSSpinLock, timeout: OSTime) -> BOOL;
    pub fn OSReleaseSpinLock(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn OSUninterruptibleSpinLock_Acquire(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn OSUninterruptibleSpinLock_TryAcquire(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn OSUninterruptibleSpinLock_TryAcquireWithTimeout(
        spinlock: *mut OSSpinLock,
        timeout: OSTime,
    ) -> BOOL;
    pub fn OSUninterruptibleSpinLock_Release(spinlock: *mut OSSpinLock) -> BOOL;
    pub fn MEMInitList(list: *mut MEMMemoryList, offsetToMemoryLink: u16);
    pub fn MEMAppendListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
    pub fn MEMPrependListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
    pub fn MEMInsertListObject(
        list: *mut MEMMemoryList,
        before: *mut ::core::ffi::c_void,
        object: *mut ::core::ffi::c_void,
    );
    pub fn MEMRemoveListObject(list: *mut MEMMemoryList, object: *mut ::core::ffi::c_void);
    pub fn MEMGetNextListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMGetPrevListObject(
        list: *mut MEMMemoryList,
        object: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMGetNthListObject(list: *mut MEMMemoryList, n: u16) -> *mut ::core::ffi::c_void;
    pub fn MEMGetArena(handle: MEMHeapHandle) -> MEMBaseHeapType::Type;
    pub fn MEMGetBaseHeapHandle(type_: MEMBaseHeapType::Type) -> MEMHeapHandle;
    pub fn MEMSetBaseHeapHandle(
        type_: MEMBaseHeapType::Type,
        handle: MEMHeapHandle,
    ) -> MEMHeapHandle;
    pub fn MEMCreateUserHeapHandle(heap: *mut ::core::ffi::c_void, size: u32) -> MEMHeapHandle;
    pub fn MEMDumpHeap(heap: MEMHeapHandle);
    pub fn MEMFindContainHeap(block: *mut ::core::ffi::c_void) -> *mut MEMHeapHeader;
    pub fn MEMFindParentHeap(handle: MEMHeapHandle) -> MEMHeapHandle;
    pub fn MEMGetFillValForHeap(type_: MEMHeapFillType::Type) -> u32;
    pub fn MEMSetFillValForHeap(type_: MEMHeapFillType::Type, value: u32);
    pub fn MEMCheckHeap(handle: MEMHeapHandle) -> BOOL;
    pub static mut MEMAllocFromDefaultHeap: MEMAllocFromDefaultHeapFn;
    pub static mut MEMAllocFromDefaultHeapEx: MEMAllocFromDefaultHeapExFn;
    pub static mut MEMFreeToDefaultHeap: MEMFreeToDefaultHeapFn;
    pub fn CoreInitDefaultHeap(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
    pub fn __preinit_user(
        outMem1: *mut MEMHeapHandle,
        outFG: *mut MEMHeapHandle,
        outMem2: *mut MEMHeapHandle,
    );
    pub fn ACInitialize() -> NNResult;
    pub fn ACFinalize();
    pub fn ACConnect() -> NNResult;
    pub fn ACConnectAsync() -> NNResult;
    pub fn ACClose() -> NNResult;
    pub fn ACGetCloseStatus() -> NNResult;
    pub fn ACIsApplicationConnected(connected: *mut BOOL) -> NNResult;
    pub fn ACGetStartupId(configId: *mut ACConfigId) -> NNResult;
    pub fn ACConnectWithConfigId(configId: ACConfigId) -> NNResult;
    pub fn ACGetAssignedAddress(ip: *mut u32) -> NNResult;
    pub fn CCRSysInit();
    pub fn CCRSysExit();
    pub fn CCRSysDRCShutdown() -> i32;
    pub fn CCRSysInvalidatePairing() -> i32;
    pub fn __CCRSysDRCIsAttached(drcSlot: u32) -> BOOL;
    pub fn CCRSysStartPairing(drcSlot: u32, timeout: u32) -> i32;
    pub fn CCRSysStopPairing() -> i32;
    pub fn CCRSysGetPairingState() -> CCRSysPairingState::Type;
    pub fn CCRSysGetPincode(pin: *mut u32) -> i32;
    pub fn CCRSysSetSystemTime(time: OSTime) -> i32;
    pub fn CCRSysNeedsDRCFWUpdate(drcSlot: u32, outNeedsUpdate: *mut BOOL) -> i32;
    pub fn __CCRSysNeedsDRCFWUpdate(
        drcSlot: u32,
        outNeedsUpdate: *mut BOOL,
        allowDowngrade: BOOL,
    ) -> i32;
    pub fn CCRSysDRCFWUpdate(drcSlot: u32) -> i32;
    pub fn __CCRSysDRCFWUpdate(drcSlot: u32, allowDowngrade: BOOL) -> i32;
    pub fn CCRSysDRCFWUpdateForward();
    pub fn CCRSysGetUpdateState(outUpdateState: *mut CCRSysUpdateState);
    pub fn __CCRSysInitReattach(drcSlot: u32);
    pub fn __CCRSysWaitReattach(drcSlot: u32, unknown: BOOL) -> i32;
    pub fn CCRSysGetVersionCheckFlag(outFlag: *mut u32) -> i32;
    pub fn CCRSysSetVersionCheckFlag(flag: u32) -> i32;
    pub fn CCRSysCaffeineSetCaffeineSlot(slot: u32) -> i32;
    pub fn CCRSysSetInitBootFlag(flag: CCRSysInitBootFlag::Type) -> i32;
    pub fn CCRSysInitializeSettings() -> i32;
    pub fn CCRSysSetCurrentLCDMode(mode: CCRSysLCDMode::Type) -> i32;
    pub fn CCRSysGetCurrentLCDMode(mode: *mut CCRSysLCDMode::Type) -> i32;
    pub fn CCRSysCaffeineGetAppLaunchParam(data: *mut CCRAppLaunchParam);
    pub fn CCRSysCaffeineBootCheck() -> u32;
    pub fn CCRSysCaffeineBootCheckAbort();
    pub fn CCRSysCaffeineSetDRCEnableFlag(enabled: i32) -> i32;
    pub fn CCRSysCaffeineSetEnableFlag(enabled: i32) -> i32;
    pub fn TEMPInit() -> FSStatus::Type;
    pub fn TEMPShutdown();
    pub fn TEMPCreateAndInitTempDir(
        maxSize: u32,
        pref: TEMPTargetPreference::Type,
        outDir: *mut TEMPDirId,
    ) -> FSStatus::Type;
    pub fn TEMPShutdownTempDir(tempId: TEMPDirId) -> FSStatus::Type;
    pub fn TEMPGetDirGlobalPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus::Type;
    pub fn TEMPGetDirPath(
        dirId: TEMPDirId,
        path: *mut ::core::ffi::c_char,
        pathLen: u32,
    ) -> FSStatus::Type;
    pub fn TEMPChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPChangeOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPChangeOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPRemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPRemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPRename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn TEMPRenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        dirId: TEMPDirId,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn TEMPMountTempDir(dirId: TEMPDirId) -> FSStatus::Type;
    pub fn TEMPUnmountTempDir(dirId: TEMPDirId) -> FSStatus::Type;
    pub fn TEMPOpenNewFile() -> FSStatus::Type;
    pub fn TEMPOpenNewFileAsync() -> FSStatus::Type;
    pub fn PDMInitialize() -> u32;
    pub fn PDMFinalize();
    pub fn PDMCloseAllFiles();
    pub fn PDMNotifySetTimeBeginEvent();
    pub fn PDMNotifySetTimeEndEvent();
    pub fn SAVEInit() -> SAVEStatus::Type;
    pub fn SAVEShutdown();
    pub fn SAVEInitSaveDir(slotNo: u8) -> SAVEStatus::Type;
    pub fn SAVEInitCommonSaveDir() -> SAVEStatus::Type;
    pub fn SAVEInitAccountSaveDir(slotNo: u8) -> SAVEStatus::Type;
    pub fn SAVEInitNoDeleteGroupSaveDir();
    pub fn SAVEUpdateSaveDir() -> SAVEStatus::Type;
    pub fn SAVEChangeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEChangeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEChangeGroupAndOthersMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEChangeGroupAndOthersModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEChangeGroupMode(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEChangeGroupModeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVECheckSaveDirRequiredUpdate(
        unk1: *mut ::core::ffi::c_int,
        unk2: *mut u64,
    ) -> SAVEStatus::Type;
    pub fn SAVEFlushQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEFlushQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetFreeSpaceSize(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut u64,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetFreeSpaceSizeAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        outSize: *mut i64,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetFreeSpaceSizeOfDevice(deviceType: ACPDeviceType::Type) -> SAVEStatus::Type;
    pub fn SAVEGetNoDeleteGroupSaveDirPath(
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
    pub fn SAVEGetNoDeleteSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
    pub fn SAVEGetSharedDataTitlePath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
    pub fn SAVEGetSharedSaveDataPath(
        titleID: u64,
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
    ) -> SAVEStatus::Type;
    pub fn SAVEGetStat(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEGetStatOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        stat: *mut FSStat,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEInitSaveDirByAppMeta(
        slotNo: u8,
        metaXmlPath: *const ::core::ffi::c_char,
        metaXmlBuffer: *mut u8,
        metaXmlBufferSize: u32,
        iconPath: *const ::core::ffi::c_char,
        iconBuffer: *mut u8,
        iconBufferSize: u32,
    ) -> SAVEStatus::Type;
    pub fn SAVEMakeDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEMakeDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDir(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenDirOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        handle: *mut FSDirectoryHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFile(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        titleId: u64,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherDemoApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherDemoApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherDemoApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherDemoApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherNormalApplication(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherNormalApplicationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherNormalApplicationVariation(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        handle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVEOpenFileOtherNormalApplicationVariationAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        uniqueId: u32,
        variation: u8,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        outHandle: *mut FSFileHandle,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVERemove(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVERemoveAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        path: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVERename(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVERenameAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn SAVERollbackQuota(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
    ) -> FSStatus::Type;
    pub fn SAVERollbackQuotaAsync(
        client: *mut FSClient,
        block: *mut FSCmdBlock,
        slotNo: u8,
        errorMask: FSErrorFlag::Type,
        asyncData: *mut FSAsyncData,
    ) -> FSStatus::Type;
    pub fn CMPTGetDataSize(outSize: *mut u32) -> i32;
    pub fn CMPTLaunchTitle(
        dataBuffer: *mut ::core::ffi::c_void,
        bufferSize: u32,
        titleId: u64,
    ) -> i32;
    pub fn CMPTLaunchMenu(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
    pub fn CMPTLaunchDataManager(dataBuffer: *mut ::core::ffi::c_void, bufferSize: u32) -> i32;
    pub fn CMPTAcctSetScreenType(type_: CmptScreenType::Type) -> i32;
    pub fn CMPTCheckScreenState() -> i32;
    pub fn SYSSwitchToSyncControllerOnHBM() -> i32;
    pub fn SYSSwitchToEManual() -> i32;
    pub fn _SYSSwitchToEManual(arg1: *mut SysAppEManualArgs) -> i32;
    pub fn _SYSSwitchToEManualFromHBM(arg1: *mut SysAppEManualArgs) -> i32;
    pub fn SYSSwitchToEShop(arg1: *mut SysAppEShopArgs) -> i32;
    pub fn SYSSwitchToEShopTicketList(arg1: *mut SYSStandardArgsIn) -> i32;
    pub fn _SYSSwitchToEShopFromHBM(arg1: *mut SysAppEShopArgs) -> i32;
    pub fn _SYSSwitchToMainApp() -> i32;
    pub fn SYSSwitchToBrowser(arg1: *mut SysAppBrowserArgs) -> i32;
    pub fn SYSSwitchToBrowserForViewer(arg1: *mut SysAppBrowserArgs) -> i32;
    pub fn SYSSwitchToBrowserForCallbackURL(arg1: *mut SysAppBrowserArgsWithCallback) -> i32;
    pub fn _SYSSwitchToBrowserForCallbackURLFromHBM(
        arg1: *mut SysAppBrowserArgsWithCallback,
    ) -> i32;
    pub fn _SYSSwitchToHBMWithMode(arg1: i32) -> i32;
    pub fn _SYSSwitchToOverlayFromHBM(arg1: i32) -> i32;
    pub fn SYSSwitchTo(pfid: SysAppPFID::Type) -> i32;
    pub fn _SYSSwitchTo(pfid: SysAppPFID::Type) -> i32;
    pub fn _SYSDirectlySwitchTo(pfid: SysAppPFID::Type) -> i32;
    pub fn SYSRelaunchTitle(argc: u32, pa_Argv: *mut *mut ::core::ffi::c_char);
    pub fn SYSLaunchMenu();
    pub fn SYSLaunchTitle(TitleId: u64);
    pub fn _SYSLaunchTitleWithStdArgsInNoSplash(titleId: u64, stdArgs: *mut SYSStandardArgsIn);
    pub fn _SYSLaunchMenuWithCheckingAccount(slot: u8);
    pub fn SYSLaunchMiiStudio(args: *mut SysAppMiiMakerArgs);
    pub fn _SYSLaunchMiiStudio(args: *mut _SysAppMiiMakerArgs);
    pub fn _SYSLaunchSettings(args: *mut SysAppSettingsArgs);
    pub fn _SYSLaunchParental(args: *mut SysAppParentalArgs);
    pub fn _SYSLaunchNotifications(args: *mut SysAppNotificationArgs);
    pub fn _SYSLaunchTitleByPathFromLauncher(path: *const ::core::ffi::c_char, unused: u32);
    #[link_name = "\u{1}_ZL21SYSTEM_APP_ID_UPDATER"]
    pub static SYSTEM_APP_ID_UPDATER: SYSTEM_APP_ID::Type;
    #[link_name = "\u{1}_ZL23SYSTEM_APP_ID_HOME_MENU"]
    pub static SYSTEM_APP_ID_HOME_MENU: SYSTEM_APP_ID::Type;
    pub fn SYSCheckTitleExists(TitleId: u64) -> BOOL;
    pub fn SYSGetPFIDFromTitleID(TitleId: u64) -> i32;
    pub fn SYSGetUPIDFromTitleID(TitleId: u64) -> i32;
    pub fn SYSGetCallerUPID() -> i32;
    pub fn SYSGetCallerPFID() -> i32;
    pub fn _SYSGetSystemApplicationTitleId(id: SYSTEM_APP_ID::Type) -> u64;
    pub fn _SYSGetSystemApplicationTitleIdByProdArea(
        id: SYSTEM_APP_ID::Type,
        prod_area: MCPRegion::Type,
    ) -> u64;
    pub fn SYSGetCallerTitleId() -> u64;
    pub fn WHBAddLogHandler(fn_: LogHandlerFn) -> BOOL;
    pub fn WHBRemoveLogHandler(fn_: LogHandlerFn) -> BOOL;
    pub fn WHBLogWrite(str_: *const ::core::ffi::c_char) -> BOOL;
    pub fn WHBLogPrint(str_: *const ::core::ffi::c_char) -> BOOL;
    pub fn WHBLogWritef(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
    pub fn WHBLogPrintf(fmt: *const ::core::ffi::c_char, ...) -> BOOL;
    pub fn WHBDeInitFileSystem() -> BOOL;
    pub fn WHBOpenFile(path: *const ::core::ffi::c_char, mode: *const ::core::ffi::c_char) -> i32;
    pub fn WHBGetFileSize(handle: i32) -> u32;
    pub fn WHBReadFile(handle: i32, buf: *mut ::core::ffi::c_void, size: u32, count: u32) -> u32;
    pub fn WHBCloseFile(handle: i32) -> i32;
    pub fn WHBReadWholeFile(
        path: *const ::core::ffi::c_char,
        outSize: *mut u32,
    ) -> *mut ::core::ffi::c_char;
    pub fn WHBFreeWholeFile(file: *mut ::core::ffi::c_char);
    pub fn WHBProcInit();
    pub fn WHBProcShutdown();
    pub fn WHBProcStopRunning();
    pub fn WHBProcIsRunning() -> BOOL;
    pub fn WHBLogConsoleInit() -> BOOL;
    pub fn WHBLogConsoleFree();
    pub fn WHBLogConsoleSetColor(color: u32);
    pub fn WHBLogConsoleDraw();
    pub fn WHBLogModuleInit() -> BOOL;
    pub fn WHBLogModuleDeinit() -> BOOL;
    pub fn WHBMountSdCard() -> BOOL;
    pub fn WHBGetSdCardMountPath() -> *mut ::core::ffi::c_char;
    pub fn WHBUnmountSdCard() -> BOOL;
    pub fn WHBInitializeSocketLibrary();
    pub fn WHBDeinitializeSocketLibrary();
    pub fn WHBLogCafeInit() -> BOOL;
    pub fn WHBLogCafeDeinit() -> BOOL;
    pub fn WHBInitCrashHandler() -> BOOL;
    pub fn WHBLogUdpInit() -> BOOL;
    pub fn WHBLogUdpDeinit() -> BOOL;
    pub fn WHBGfxInit() -> BOOL;
    pub fn WHBGfxShutdown();
    pub fn WHBGfxBeginRender();
    pub fn WHBGfxFinishRender();
    pub fn WHBGfxClearColor(r: f32, g: f32, b: f32, a: f32);
    pub fn WHBGfxBeginRenderDRC();
    pub fn WHBGfxFinishRenderDRC();
    pub fn WHBGfxBeginRenderTV();
    pub fn WHBGfxFinishRenderTV();
    pub fn WHBGfxLoadGFDPixelShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2PixelShader;
    pub fn WHBGfxFreePixelShader(shader: *mut GX2PixelShader) -> BOOL;
    pub fn WHBGfxLoadGFDVertexShader(
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> *mut GX2VertexShader;
    pub fn WHBGfxFreeVertexShader(shader: *mut GX2VertexShader) -> BOOL;
    pub fn WHBGfxLoadGFDShaderGroup(
        group: *mut WHBGfxShaderGroup,
        index: u32,
        file: *const ::core::ffi::c_void,
    ) -> BOOL;
    pub fn WHBGfxInitShaderAttribute(
        group: *mut WHBGfxShaderGroup,
        name: *const ::core::ffi::c_char,
        buffer: u32,
        offset: u32,
        format: GX2AttribFormat::Type,
    ) -> BOOL;
    pub fn WHBGfxInitFetchShader(group: *mut WHBGfxShaderGroup) -> BOOL;
    pub fn WHBGfxFreeShaderGroup(group: *mut WHBGfxShaderGroup) -> BOOL;
    pub fn WHBGfxLoadGFDTexture(index: u32, file: *const ::core::ffi::c_void) -> *mut GX2Texture;
    pub fn WHBGfxFreeTexture(texture: *mut GX2Texture) -> BOOL;
    pub fn WHBGfxGetTVColourBuffer() -> *mut GX2ColorBuffer;
    pub fn WHBGfxGetTVDepthBuffer() -> *mut GX2DepthBuffer;
    pub fn WHBGfxGetTVContextState() -> *mut GX2ContextState;
    pub fn WHBGfxGetDRCColourBuffer() -> *mut GX2ColorBuffer;
    pub fn WHBGfxGetDRCDepthBuffer() -> *mut GX2DepthBuffer;
    pub fn WHBGfxGetDRCContextState() -> *mut GX2ContextState;
    pub fn TVEGetAnalogStat(outState: *mut u32);
    pub fn TVEGetCurrentPort() -> TVEPort::Type;
    pub fn TVEGetHDMIErrorStat(outState: *mut TVEHdmiState::Type);
    pub fn TVECECInit() -> BOOL;
    pub fn TVESetCECEnable(enable: BOOL) -> BOOL;
    pub fn TVEIsCECEnable() -> BOOL;
    pub fn TVECECSendCommand(
        destination: TVECECLogicalAddress::Type,
        opCode: TVECECOpCode::Type,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
    pub fn TVECECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress::Type,
        outOpCode: *mut TVECECOpCode::Type,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
    pub fn AXGetDRCVSMode(mode: *mut AXDRCVSMode) -> AXResult;
    pub fn AXSetDRCVSMode(mode: AXDRCVSMode) -> AXResult;
    pub fn AXSetDRCVSDownmixBalance(output: AXDRCVSOutput, balance: f32) -> AXResult;
    pub fn AXSetDRCVSLC(lc: AXDRCVSLC) -> AXResult;
    pub fn AXSetDRCVSLimiter(limit: BOOL) -> AXResult;
    pub fn AXSetDRCVSLimiterThreshold(threshold: f32) -> AXResult;
    pub fn AXSetDRCVSOutputGain(output: AXDRCVSOutput, gain: f32) -> AXResult;
    pub fn AXSetDRCVSSpeakerPosition(
        output: AXDRCVSOutput,
        pos: AXDRCVSSpeakerPosition,
    ) -> AXResult;
    pub fn AXSetDRCVSSurroundDepth(output: AXDRCVSOutput, depth: f32) -> AXResult;
    pub fn AXSetDRCVSSurroundLevelGain(gain: AXDRCVSSurroundLevelGain) -> AXResult;
    pub fn AXGetDeviceMode(type_: AXDeviceType, mode: *mut AXDeviceMode) -> AXResult;
    pub fn AXGetDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: *mut AXDeviceFinalMixCallback,
    ) -> AXResult;
    pub fn AXRegisterDeviceFinalMixCallback(
        type_: AXDeviceType,
        func: AXDeviceFinalMixCallback,
    ) -> AXResult;
    pub fn AXGetAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: *mut AXAuxCallback,
        userData: *mut *mut ::core::ffi::c_void,
    ) -> AXResult;
    pub fn AXRegisterAuxCallback(
        type_: AXDeviceType,
        unk0: u32,
        unk1: u32,
        callback: AXAuxCallback,
        userData: *mut ::core::ffi::c_void,
    ) -> AXResult;
    pub fn AXSetDeviceLinearUpsampler(type_: AXDeviceType, unk0: u32, unk1: u32) -> AXResult;
    pub fn AXSetDeviceCompressor(type_: AXDeviceType, unk0: u32) -> AXResult;
    pub fn AXSetDeviceUpsampleStage(type_: AXDeviceType, postFinalMix: BOOL) -> AXResult;
    pub fn AXSetDeviceVolume(type_: AXDeviceType, id: u32, volume: u16) -> AXResult;
    pub fn AXInit();
    pub fn AXQuit();
    pub fn AXInitWithParams(params: *mut AXInitParams);
    pub fn AXIsInit() -> BOOL;
    pub fn AXInitProfile(profile: *mut AXProfile, count: u32);
    pub fn AXGetSwapProfile(profile: *mut AXProfile, count: u32) -> u32;
    pub fn AXSetDefaultMixerSelect(unk0: u32) -> AXResult;
    pub fn AXRegisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
    pub fn AXDeregisterAppFrameCallback(callback: AXFrameCallback) -> AXResult;
    pub fn AXRegisterFrameCallback(callback: AXFrameCallback) -> AXFrameCallback;
    pub fn AXGetInputSamplesPerFrame() -> u32;
    pub fn AXGetInputSamplesPerSec() -> u32;
    pub fn AXStartTransitionAudio();
    pub fn AXSetUpTransitionAudio(buffer: *mut AXTransitionAudioBuffer);
    pub fn AXVoiceBegin(v: *mut AXVoice) -> i32;
    pub fn AXVoiceEnd(v: *mut AXVoice) -> i32;
    pub fn AXAcquireVoice(
        priority: u32,
        callback: AXVoiceCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
    pub fn AXAcquireVoiceEx(
        priority: u32,
        callback: AXVoiceCallbackExFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> *mut AXVoice;
    pub fn AXCheckVoiceOffsets(offsets: *mut AXVoiceOffsets) -> BOOL;
    pub fn AXFreeVoice(voice: *mut AXVoice);
    pub fn AXGetMaxVoices() -> u32;
    pub fn AXGetVoiceCurrentOffsetEx(
        voice: *mut AXVoice,
        samples: *const ::core::ffi::c_void,
    ) -> u32;
    pub fn AXGetVoiceLoopCount(voice: *mut AXVoice) -> u32;
    pub fn AXGetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
    pub fn AXIsVoiceRunning(voice: *mut AXVoice) -> BOOL;
    pub fn AXSetVoiceAdpcm(voice: *mut AXVoice, adpcm: *mut AXVoiceAdpcm);
    pub fn AXSetVoiceAdpcmLoop(voice: *mut AXVoice, loopData: *mut AXVoiceAdpcmLoopData);
    pub fn AXSetVoiceCurrentOffset(voice: *mut AXVoice, offset: u32);
    pub fn AXSetVoiceDeviceMix(
        voice: *mut AXVoice,
        type_: AXDeviceType,
        id: u32,
        mixData: *mut AXVoiceDeviceMixData,
    ) -> AXResult;
    pub fn AXSetVoiceEndOffset(voice: *mut AXVoice, offset: u32);
    pub fn AXSetVoiceEndOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
    pub fn AXSetVoiceInitialTimeDelay(voice: *mut AXVoice, delay: u16) -> AXResult;
    pub fn AXSetVoiceLoopOffset(voice: *mut AXVoice, offset: u32);
    pub fn AXSetVoiceLoopOffsetEx(
        voice: *mut AXVoice,
        offset: u32,
        samples: *const ::core::ffi::c_void,
    );
    pub fn AXSetVoiceLoop(voice: *mut AXVoice, loop_: AXVoiceLoop);
    pub fn AXSetVoiceOffsets(voice: *mut AXVoice, offsets: *mut AXVoiceOffsets);
    pub fn AXSetVoicePriority(voice: *mut AXVoice, priority: u32);
    pub fn AXSetVoiceRmtIIRCoefs(voice: *mut AXVoice, filter: u16, ...);
    pub fn AXSetVoiceSrc(voice: *mut AXVoice, src: *mut AXVoiceSrc);
    pub fn AXSetVoiceSrcRatio(voice: *mut AXVoice, ratio: f32) -> AXVoiceSrcRatioResult;
    pub fn AXSetVoiceSrcType(voice: *mut AXVoice, type_: AXVoiceSrcType);
    pub fn AXSetVoiceState(voice: *mut AXVoice, state: AXVoiceState);
    pub fn AXSetVoiceType(voice: *mut AXVoice, type_: AXVoiceType);
    pub fn AXSetVoiceVe(voice: *mut AXVoice, veData: *mut AXVoiceVeData);
    pub fn AXSetVoiceVeDelta(voice: *mut AXVoice, delta: i16);
    pub fn GX2RSetAttributeBuffer(buffer: *mut GX2RBuffer, index: u32, stride: u32, offset: u32);
    pub fn GX2RDrawIndexed(
        mode: GX2PrimitiveMode::Type,
        buffer: *mut GX2RBuffer,
        indexType: GX2IndexType::Type,
        count: u32,
        indexOffset: u32,
        vertexOffset: u32,
        numInstances: u32,
    );
    pub fn GX2RCreateSurface(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
    pub fn GX2RCreateSurfaceUserMemory(
        surface: *mut GX2Surface,
        image: *mut u8,
        mipmap: *mut u8,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
    pub fn GX2RDestroySurfaceEx(surface: *mut GX2Surface, flags: GX2RResourceFlags::Type) -> BOOL;
    pub fn GX2RInvalidateSurface(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> BOOL;
    pub fn GX2RLockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    ) -> *mut ::core::ffi::c_void;
    pub fn GX2RUnlockSurfaceEx(
        surface: *mut GX2Surface,
        level: i32,
        flags: GX2RResourceFlags::Type,
    );
    pub fn GX2RBeginDisplayListEx(
        displayList: *mut GX2RBuffer,
        unknown: u32,
        flags: GX2RResourceFlags::Type,
    );
    pub fn GX2REndDisplayList(displayList: *mut GX2RBuffer) -> u32;
    pub fn GX2RCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
    pub fn GX2RDirectCallDisplayList(displayList: *mut GX2RBuffer, size: u32);
    pub fn GX2RInvalidateMemory(
        flags: GX2RResourceFlags::Type,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
    );
    pub fn GX2RIsUserMemory(flags: GX2RResourceFlags::Type) -> BOOL;
    pub fn GX2RSetAllocator(allocFn: GX2RAllocFunction, freeFn: GX2RFreeFunction);
    pub fn CCRSetCompatMode(compatMode: u32) -> i32;
    pub fn CCRHIDStart(
        drcSlot: u32,
        reportsBuffer: *mut CCRHIDReport,
        numReports: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRHIDStop(
        drcSlot: u32,
        callback: IOSAsyncCallbackFn,
        arg: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn CCRHIDGetData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
    pub fn CCRHIDGetBufferedData(drcSlot: u32, reportData: *mut CCRHIDReport) -> i32;
    pub fn CCRHIDGetFirmwareVersion(report: *mut CCRHIDReport, firmwareVersion: *mut u32) -> i32;
    pub fn CCRHIDGetSequence(report: *mut CCRHIDReport, sequence: *mut u32) -> i32;
    pub fn CCRCFGInit() -> i32;
    pub fn CCRCFGGetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
    pub fn CCRCFGSetCachedEeprom(
        drcSlot: u32,
        offset: u32,
        buf: *mut ::core::ffi::c_void,
        size: u32,
    ) -> i32;
    pub fn CCRCFGGetVersionCheckFlag(outFlag: *mut u32) -> i32;
    pub fn CCRCFGSetVersionCheckFlag(flag: u32) -> i32;
    pub fn NTAGInit(chan: VPADChan::Type) -> NTAGError;
    pub fn NTAGInitEx(chan: VPADChan::Type) -> NTAGError;
    pub fn NTAGIsInit(chan: VPADChan::Type) -> BOOL;
    pub fn NTAGProc(chan: VPADChan::Type);
    pub fn NTAGShutdown(chan: VPADChan::Type) -> NTAGError;
    pub fn NTAGAbort(
        chan: VPADChan::Type,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGFormat(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGSetReadOnly(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        readOnly: BOOL,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGSetTagDetectCallback(
        chan: VPADChan::Type,
        callback: NFCTagDetectCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    );
    pub fn NTAGSetFormatSettings(settings: *mut NTAGFormatSettings);
    pub fn NTAGRead(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGReadT2T(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGReadT2TRawData(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        uidMask: *mut NFCUid,
        callback: NTAGReadT2TRawDataCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWrite(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        rwSize: u32,
        rwData: *mut ::core::ffi::c_void,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWriteT2T(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        dataContainer: *mut NTAGRawDataContainerT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWriteT2TConfigArea(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        cfg0: *mut u32,
        cfg1: *mut u32,
        pwd: *mut u32,
        pack: *mut u16,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWriteT2TLockArea(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        lockBytes: *mut u32,
        dynamicLock: *mut u32,
        cc: *mut u32,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWriteT2TRawData(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGWriteT2TRawDataEx(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGRawDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
        authenticate: u8,
    ) -> NTAGError;
    pub fn NTAGWriteT2TWithConvert(
        chan: VPADChan::Type,
        timeout: u32,
        uid: *mut NFCUid,
        data: *mut NTAGDataT2T,
        callback: NTAGCallbackFn,
        userContext: *mut ::core::ffi::c_void,
    ) -> NTAGError;
    pub fn NTAGConvertT2T(out: *mut NTAGDataT2T, in_: *mut NTAGDataT2T) -> NTAGError;
    pub fn NTAGParseHeader(
        data: *mut ::core::ffi::c_void,
        outNoftHeader: *mut NTAGNoftHeader,
        outInfoHeader: *mut NTAGInfoHeader,
        outRwHeader: *mut NTAGAreaHeader,
        outRoHeader: *mut NTAGAreaHeader,
    ) -> NTAGError;
    pub fn AVMCECInit() -> BOOL;
    pub fn AVMEnableCEC();
    pub fn AVMDisableCEC();
    pub fn AVMCECSendCommand(
        destination: TVECECLogicalAddress::Type,
        opCode: TVECECOpCode::Type,
        parameters: *mut u8,
        numParameters: u8,
    ) -> BOOL;
    pub fn AVMCECReceiveCommand(
        outInitiator: *mut TVECECLogicalAddress::Type,
        outOpCode: *mut TVECECOpCode::Type,
        outParameters: *mut u8,
        outNumParameters: *mut u8,
    ) -> BOOL;
    pub fn AVMGetSystemDRCAudioMode(
        outAudioMode: *mut AVMDrcSystemAudioMode::Type,
    ) -> ::core::ffi::c_int;
    pub fn AVMGetDRCSystemAudioMode(outAudioMode: *mut AVMDrcSystemAudioMode::Type) -> BOOL;
    pub fn AVMGetDRCVertCount() -> u32;
    pub fn AVMIsDRCFirstFlippDone() -> BOOL;
    pub fn AVMGetDRCScanMode(outScanMode: *mut AVMDrcScanMode::Type) -> BOOL;
    pub fn AVMGetDRCMode(outMode: *mut AVMDrcMode::Type) -> BOOL;
    pub fn AVMProbeDRCNum() -> u32;
    pub fn AVMSetDRCEnable(enable: BOOL) -> BOOL;
    pub fn AVMSetDRCGamma(gamma: *mut f32) -> BOOL;
    pub fn AVMDebugIsNTSC() -> BOOL;
    pub fn AVMGetCurrentPort(outPort: *mut TVEPort::Type) -> BOOL;
    pub fn AVMGetHDMIState(outState: *mut TVEHdmiState::Type);
    pub fn AVMGetTVAspectRatio(outAspectRatio: *mut AVMTvAspectRatio::Type) -> BOOL;
    pub fn AVMGetTVScanMode(outResolution: *mut AVMTvResolution::Type) -> BOOL;
    pub fn AVMGetTVUnderScan(outUnderScan: *mut u32) -> i32;
    pub fn AVMIsAVOutReady() -> BOOL;
    pub fn AVMSetTVAspectRatio(aspectRatio: AVMTvAspectRatio::Type) -> BOOL;
    pub fn AVMSetTVEnable(enable: BOOL) -> BOOL;
    pub fn AVMSetTVOutPort(port: TVEPort::Type, resolution: AVMTvResolution::Type) -> i32;
    pub fn AVMSetTVScanMode(
        resolution: AVMTvResolution::Type,
        unknown: u32,
        port: TVEPort::Type,
    ) -> i32;
    pub fn AVMSetTVScanResolution(resolution: AVMTvResolution::Type) -> i32;
    pub fn AVMSetTVUnderScan(underScan: u32) -> i32;
    pub fn AVMSetTVUnderScanParam(underScan: u32) -> i32;
    pub fn AVMSetTVVideoRegion(
        videoRegion: AVMTvVideoRegion::Type,
        port: TVEPort::Type,
        resolution: AVMTvResolution::Type,
    ) -> i32;
    pub fn AVMReadSystemAspectRatioConfig(outAspectRatio: *mut AVMTvAspectRatio::Type) -> i32;
    pub fn AVMReadSystemPortConfig(outPort: *mut TVEPort::Type) -> i32;
    pub fn AVMReadSystemTVUnderScanConfig(outUnderScan: *mut u32) -> i32;
    pub fn AVMReadSystemVideoResConfig(outResolution: *mut AVMTvResolution::Type) -> i32;
    pub fn AVMWriteSystemAspectRatioConfig(aspectRatio: AVMTvAspectRatio::Type) -> i32;
    pub fn AVMWriteSystemTVUnderScanConfig(underScan: u32) -> i32;
    pub fn AVMWriteSystemVideoOutConfig(
        port: TVEPort::Type,
        resolution: AVMTvResolution::Type,
    ) -> i32;
    pub fn AVMWriteSystemVideoResConfig(resolution: AVMTvResolution::Type) -> i32;
    pub fn UhsClientOpen(handle: *mut UhsHandle, config: *mut UhsConfig) -> UHSStatus::Type;
    pub fn UhsClientClose(handle: *mut UhsHandle) -> UHSStatus::Type;
    pub fn UhsClassDrvReg(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        context: *mut ::core::ffi::c_void,
        callback: UHSDrvRegCallback,
    ) -> UHSStatus::Type;
    pub fn UhsClassDrvUnReg(handle: *mut UhsHandle, drv_handle: u32) -> UHSStatus::Type;
    pub fn UhsGetFullConfigDescriptor(
        handle: *mut UhsHandle,
        if_handle: u32,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus::Type;
    pub fn UhsGetDescriptorString(
        handle: *mut UhsHandle,
        if_handle: u32,
        string_index: u8,
        as_unicode: BOOL,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> UHSStatus::Type;
    pub fn UhsQueryInterfaces(
        handle: *mut UhsHandle,
        filter: *mut UhsInterfaceFilter,
        profiles: *mut UhsInterfaceProfile,
        max_profiles: i32,
    ) -> UHSStatus::Type;
    pub fn UhsAcquireInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        context: *mut ::core::ffi::c_void,
        callback: UhsAcquireInterfaceCallback,
    ) -> UHSStatus::Type;
    pub fn UhsReleaseInterface(
        handle: *mut UhsHandle,
        if_handle: u32,
        no_reacquire: bool,
    ) -> UHSStatus::Type;
    pub fn UhsAdministerDevice(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminDevType::Type,
        arg3: i32,
    ) -> UHSStatus::Type;
    pub fn UhsAdministerEndpoint(
        handle: *mut UhsHandle,
        if_handle: u32,
        type_: UHSAdminEpType::Type,
        endpointMask: u32,
        max_pending_requests: u32,
        max_request_size: u32,
    ) -> UHSStatus::Type;
    pub fn UhsClearEndpointHalt(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u32,
        direction: i32,
    ) -> UHSStatus::Type;
    pub fn UhsSubmitControlRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        buffer: *mut ::core::ffi::c_void,
        bRequest: u8,
        bmRequestType: u8,
        wValue: u16,
        wIndex: u16,
        wLength: u16,
        timeout: i32,
    ) -> UHSStatus::Type;
    pub fn UhsSubmitBulkRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus::Type;
    pub fn UhsSubmitInterruptRequest(
        handle: *mut UhsHandle,
        if_handle: u32,
        endpoint: u8,
        direction: i32,
        buffer: *mut ::core::ffi::c_void,
        length: i32,
        timeout: i32,
    ) -> UHSStatus::Type;
    pub static mut h_errno: ::core::ffi::c_int;
    pub fn gethostbyname(name: *const ::core::ffi::c_char) -> *mut hostent;
    pub fn gethostbyaddr(
        addr: *const ::core::ffi::c_void,
        len: socklen_t,
        type_: ::core::ffi::c_int,
    ) -> *mut hostent;
    pub fn gethostent() -> *mut hostent;
    pub fn getservbyname(
        name: *const ::core::ffi::c_char,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
    pub fn getservbyport(
        port: ::core::ffi::c_int,
        proto: *const ::core::ffi::c_char,
    ) -> *mut servent;
    pub fn getservent() -> *mut servent;
    pub fn getaddrinfo(
        node: *const ::core::ffi::c_char,
        service: *const ::core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::core::ffi::c_int;
    pub fn freeaddrinfo(res: *mut addrinfo);
    pub fn getnameinfo(
        addr: *const sockaddr,
        addrlen: socklen_t,
        host: *mut ::core::ffi::c_char,
        hostlen: socklen_t,
        serv: *mut ::core::ffi::c_char,
        servlen: socklen_t,
        flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn gai_strerror(ecode: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    pub fn OSInitSemaphore(semaphore: *mut OSSemaphore, count: i32);
    pub fn OSInitSemaphoreEx(
        semaphore: *mut OSSemaphore,
        count: i32,
        name: *const ::core::ffi::c_char,
    );
    pub fn OSGetSemaphoreCount(semaphore: *mut OSSemaphore) -> i32;
    pub fn OSSignalSemaphore(semaphore: *mut OSSemaphore) -> i32;
    pub fn OSWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
    pub fn OSTryWaitSemaphore(semaphore: *mut OSSemaphore) -> i32;
    pub fn OSSwitchFiber(entry: OSFiberEntryFn, stack: *mut ::core::ffi::c_void) -> i32;
    pub fn OSSwitchFiberEx(
        arg1: u32,
        arg2: u32,
        arg3: u32,
        arg4: u32,
        entry: OSFiberExEntryFn,
        stack: *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn OSDynLoad_Acquire(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_FindExport(
        module: OSDynLoad_Module,
        exportType: OSDynLoad_ExportType::Type,
        name: *const ::core::ffi::c_char,
        outAddr: *mut *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_Release(module: OSDynLoad_Module);
    pub fn OSDynLoad_SetAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_GetAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_SetTLSAllocator(
        allocFn: OSDynLoadAllocFn,
        freeFn: OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_GetTLSAllocator(
        outAllocFn: *mut OSDynLoadAllocFn,
        outFreeFn: *mut OSDynLoadFreeFn,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_GetLoaderHeapStatistics(
        outLoaderHeapStatistics: *mut OSDynLoad_LoaderHeapStatistics,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_GetModuleName(
        module: OSDynLoad_Module,
        nameBuf: *mut ::core::ffi::c_char,
        nameBufSize: *mut i32,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_GetNumberOfRPLs() -> i32;
    pub fn OSDynLoad_GetRPLInfo(
        first: u32,
        count: u32,
        outInfos: *mut OSDynLoad_NotifyData,
    ) -> BOOL;
    pub fn OSDynLoad_IsModuleLoaded(
        name: *const ::core::ffi::c_char,
        outModule: *mut OSDynLoad_Module,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_AddNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
    pub fn OSDynLoad_DelNotifyCallback(
        notifyFn: OSDynLoadNotifyFunc,
        userContext: *mut ::core::ffi::c_void,
    ) -> OSDynLoad_Error::Type;
    pub fn rpl_entry(
        module: OSDynLoad_Module,
        reason: OSDynLoad_EntryReason::Type,
    ) -> ::core::ffi::c_int;
    pub fn OSInitStopwatch(stopwatch: *mut OSStopwatch, name: *const ::core::ffi::c_char);
    pub fn OSResetStopwatch(stopwatch: *mut OSStopwatch);
    pub fn OSStartStopwatch(stopwatch: *mut OSStopwatch);
    pub fn OSStopStopwatch(stopwatch: *mut OSStopwatch);
    pub fn OSCheckStopwatch(stopwatch: *mut OSStopwatch) -> OSTime;
    pub fn OSDumpStopwatch(stopwatch: *mut OSStopwatch);
    pub fn OSInitMutex(mutex: *mut OSMutex);
    pub fn OSInitMutexEx(mutex: *mut OSMutex, name: *const ::core::ffi::c_char);
    pub fn OSLockMutex(mutex: *mut OSMutex);
    pub fn OSTryLockMutex(mutex: *mut OSMutex) -> BOOL;
    pub fn OSUnlockMutex(mutex: *mut OSMutex);
    pub fn IPCBufPoolCreate(
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        messageSize: u32,
        outNumMessages: *mut u32,
        unk0x0c: u32,
    ) -> *mut IPCBufPool;
    pub fn IPCBufPoolAllocate(pool: *mut IPCBufPool, size: u32) -> *mut ::core::ffi::c_void;
    pub fn IPCBufPoolFree(
        pool: *mut IPCBufPool,
        message: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IPCBufPoolGetAttributes(
        pool: *mut IPCBufPool,
        attribs: *mut IPCBufPoolAttributes,
    ) -> IOSError::Type;
    pub fn OSInitRendezvous(rendezvous: *mut OSRendezvous);
    pub fn OSWaitRendezvous(rendezvous: *mut OSRendezvous, coreMask: u32) -> BOOL;
    pub fn OSWaitRendezvousWithTimeout(
        rendezvous: *mut OSRendezvous,
        coreMask: u32,
        timeout: OSTime,
    ) -> BOOL;
    pub fn OSFastCond_Init(condition: *mut OSFastCondition, name: *const ::core::ffi::c_char);
    pub fn OSFastCond_Wait(condition: *mut OSFastCondition, mutex: *mut OSFastMutex);
    pub fn OSFastCond_Signal(condition: *mut OSFastCondition);
    pub fn __KernelSetUserModeExHandler(
        exceptionType: OSExceptionType::Type,
        chainInfo: *mut OSExceptionChainInfo,
        prevChainInfo: *mut OSExceptionChainInfo,
    );
    pub fn __KernelAllocateTimer(
        arg1: KernelTimerCallbackFn,
        exceptionStack: *mut ::core::ffi::c_void,
        context: *mut OSContext,
    ) -> KernelTimerHandle;
    pub fn __KernelPrimeTimer(
        handle: KernelTimerHandle,
        startTimeInTicks: u64,
        intervalInTicks: u64,
        unknown: u32,
    ) -> u32;
    pub fn __KernelSendICI(
        cmd: OSICICommand::Type,
        arg1: *mut ::core::ffi::c_void,
        unknown1: u32,
        unknown2: u32,
    );
    pub fn __KernelGetInfo(
        type_: u32,
        outBuffer: *mut ::core::ffi::c_void,
        outBufferSize: u32,
        core: u32,
    );
    pub fn IM_Open() -> IOSHandle;
    pub fn IM_Close(handle: IOSHandle) -> IOSError::Type;
    pub fn IM_GetHomeButtonParams(
        handle: IOSHandle,
        request: *mut IMRequest,
        output: *mut IMHomeButtonParams,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_GetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_GetParameters(parameters: *mut IMParameters) -> IOSError::Type;
    pub fn IM_GetNvParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_GetNvParameterWithoutHandleAndItb(
        parameter: IMParameter::Type,
        outValue: *mut u32,
    ) -> IOSError::Type;
    pub fn IM_GetRuntimeParameter(
        parameter: IMParameter::Type,
        outValue: *mut u32,
    ) -> IOSError::Type;
    pub fn IM_GetTimerRemaining(
        handle: IOSHandle,
        request: *mut IMRequest,
        timer: IMTimer::Type,
        output: *mut u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_GetTimerRemainingSeconds(
        timer: IMTimer::Type,
        outSeconds: *mut u32,
    ) -> IOSError::Type;
    pub fn IM_SetParameter(
        handle: IOSHandle,
        request: *mut IMRequest,
        parameter: IMParameter::Type,
        value: u32,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_SetRuntimeParameter(parameter: IMParameter::Type, value: u32) -> IOSError::Type;
    pub fn IM_GetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        event: *mut IMEventMask,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_CancelGetEventNotify(
        handle: IOSHandle,
        request: *mut IMRequest,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_SetDeviceState(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: IMDeviceState::Type,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn IM_SetDeviceStateEx(
        handle: IOSHandle,
        request: *mut IMRequest,
        state: *mut IMDeviceStateEx,
        asyncCallback: IOSAsyncCallbackFn,
        asyncCallbackContext: *mut ::core::ffi::c_void,
    ) -> IOSError::Type;
    pub fn __rplwrap_exit(code: ::core::ffi::c_int);
    pub fn _Exit(code: ::core::ffi::c_int) -> !;
    pub fn IMDisableAPD() -> IMError;
    pub fn IMDisableDim() -> IMError;
    pub fn IMEnableAPD() -> IMError;
    pub fn IMEnableDim() -> IMError;
    pub fn IMIsAPDEnabled(outValue: *mut u32) -> IMError;
    pub fn IMIsAPDEnabledBySysSettings(outValue: *mut u32) -> IMError;
    pub fn IMIsDimEnabled(outValue: *mut u32) -> IMError;
    pub fn IMGetDimEnableDRC(outValue: *mut u32) -> IMError;
    pub fn IMGetDimEnableTV(outValue: *mut u32) -> IMError;
    pub fn IMGetDimPeriod(outValue: *mut u32) -> IMError;
    pub fn IMGetTimeBeforeAPD(outSeconds: *mut u32) -> IMError;
    pub fn IMGetTimeBeforeDimming(outSeconds: *mut u32) -> IMError;
    pub fn IMSetDimEnableDRC(value: BOOL) -> IMError;
    pub fn IMSetDimEnableTV(value: BOOL) -> IMError;
    pub fn IMStartAPDVideoMode() -> IMError;
    pub static mut __OSSchedulerLock: *mut ::core::ffi::c_void;
    pub fn __OSEnableScheduler();
    pub fn __OSDisableScheduler();
    pub fn __OSLockScheduler(lockId: *mut ::core::ffi::c_void);
    pub fn __OSUnlockScheduler(lockId: *mut ::core::ffi::c_void);
    pub fn OSIsSchedulerLocked(lockId: *mut ::core::ffi::c_void) -> BOOL;
    pub fn __OSTryLockScheduler(lockId: *mut ::core::ffi::c_void);
    pub fn __OSTouchSchedulerLock();
    pub fn MEMInitBlockHeap(
        heap: *mut MEMBlockHeap,
        start: *mut ::core::ffi::c_void,
        end: *mut ::core::ffi::c_void,
        blocks: *mut MEMBlockHeapTracking,
        size: u32,
        flags: u32,
    ) -> MEMHeapHandle;
    pub fn MEMDestroyBlockHeap(heap: MEMHeapHandle) -> *mut ::core::ffi::c_void;
    pub fn MEMAddBlockHeapTracking(
        heap: MEMHeapHandle,
        tracking: *mut MEMBlockHeapTracking,
        size: u32,
    ) -> ::core::ffi::c_int;
    pub fn MEMAllocFromBlockHeapAt(
        heap: MEMHeapHandle,
        addr: *mut ::core::ffi::c_void,
        size: u32,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMAllocFromBlockHeapEx(
        heap: MEMHeapHandle,
        size: u32,
        align: i32,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMFreeToBlockHeap(heap: MEMHeapHandle, data: *mut ::core::ffi::c_void);
    pub fn MEMGetAllocatableSizeForBlockHeapEx(heap: MEMHeapHandle, align: i32) -> u32;
    pub fn MEMGetTrackingLeftInBlockHeap(heap: MEMHeapHandle) -> u32;
    pub fn MEMGetTotalFreeSizeForBlockHeap(heap: MEMHeapHandle) -> u32;
    pub fn DCInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCFlushRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCStoreRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCFlushRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCStoreRangeNoSync(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCZeroRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn DCTouchRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn ICInvalidateRange(addr: *mut ::core::ffi::c_void, size: u32);
    pub fn OSMemoryBarrier();
    pub fn __OSClearSavedFrame(
        type_: OSSavedFrameType::Type,
        screen: OSSavedFrameScreen::Type,
    ) -> u32;
    pub fn __OSGetSavedFrame(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
    pub fn __OSGetSavedFrameA(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
    pub fn __OSGetSavedFrameB(
        screen: OSSavedFrameScreen::Type,
        outPtr: *mut ::core::ffi::c_void,
        ptr_size: u32,
    );
    pub fn __OSGetSavedFrameGammaA(screen: OSSavedFrameScreen::Type, outGamma: *mut f32) -> BOOL;
    pub fn __OSGetSavedFrameGammaB(screen: OSSavedFrameScreen::Type, outGamma: *mut f32) -> BOOL;
    pub fn __OSGetSavedFramePtr(
        type_: OSSavedFrameType::Type,
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
    pub fn __OSGetSavedFramePtrForRead(
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
    pub fn __OSGetSavedFramePtrForWrite(
        screen: OSSavedFrameScreen::Type,
    ) -> *mut ::core::ffi::c_void;
    pub fn __OSGetSavedFrames() -> u32;
    pub fn __OSGetSavedFramesA() -> u32;
    pub fn __OSGetSavedFramesB() -> u32;
    pub fn __OSResetSavedFrame(screen: OSSavedFrameScreen::Type);
    pub fn __OSSetSavedFrame(
        screen: OSSavedFrameScreen::Type,
        data: *mut ::core::ffi::c_void,
        size: u32,
    ) -> ::core::ffi::c_int;
    pub fn __OSSetSavedFrameGamma(gamma: f32, screen: OSSavedFrameScreen::Type);
    pub fn OSEnableInterrupts() -> BOOL;
    pub fn OSDisableInterrupts() -> BOOL;
    pub fn OSRestoreInterrupts(enable: BOOL) -> BOOL;
    pub fn OSIsInterruptEnabled() -> BOOL;
    pub fn __OSSetInterruptHandler(
        type_: OSInterruptType::Type,
        handler: OSUserInterruptHandler,
    ) -> OSUserInterruptHandler;
    pub fn __OSClearAndEnableInterrupt(type_: OSInterruptType::Type);
    pub fn __OSDisableInterrupt(type_: OSInterruptType::Type);
    pub fn OSInitCond(condition: *mut OSCondition);
    pub fn OSInitCondEx(condition: *mut OSCondition, name: *const ::core::ffi::c_char);
    pub fn OSWaitCond(condition: *mut OSCondition, mutex: *mut OSMutex);
    pub fn OSSignalCond(condition: *mut OSCondition);
    pub fn COSVReport(
        module: COSReportModule::Type,
        level: COSReportLevel::Type,
        fmt: *const ::core::ffi::c_char,
        ...
    );
    pub fn COSError(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
    pub fn COSInfo(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
    pub fn COSVerbose(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
    pub fn COSWarn(module: COSReportModule::Type, fmt: *const ::core::ffi::c_char, ...);
    pub fn UCOpen() -> UCHandle;
    pub fn UCClose(handle: UCHandle) -> UCError;
    pub fn UCDeleteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
    pub fn UCDeleteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
    pub fn UCReadSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
    pub fn UCReadSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
    pub fn UCWriteSysConfig(handle: UCHandle, count: u32, settings: *mut UCSysConfig) -> UCError;
    pub fn UCWriteSysConfigAsync(
        handle: UCHandle,
        count: u32,
        settings: *mut UCSysConfig,
        asyncParams: *mut UCAsyncParams,
    ) -> UCError;
    pub fn __OSClearCopyData();
    pub fn __OSAppendCopyData(data: *const ::core::ffi::c_void, size: u32) -> BOOL;
    pub fn __OSGetCopyDataPtr() -> *mut ::core::ffi::c_void;
    pub fn __OSGetCopyDataSize() -> u32;
    pub fn __OSResizeCopyData(size: u32) -> BOOL;
    pub fn OSCompareAndSwapAtomic(ptr: *mut u32, compare: u32, value: u32) -> BOOL;
    pub fn OSCompareAndSwapAtomicEx(ptr: *mut u32, compare: u32, value: u32, old: *mut u32)
        -> BOOL;
    pub fn OSSwapAtomic(ptr: *mut u32, value: u32) -> u32;
    pub fn OSAddAtomic(ptr: *mut i32, value: i32) -> i32;
    pub fn OSAndAtomic(ptr: *mut u32, value: u32) -> u32;
    pub fn OSOrAtomic(ptr: *mut u32, value: u32) -> u32;
    pub fn OSXorAtomic(ptr: *mut u32, value: u32) -> u32;
    pub fn OSTestAndClearAtomic(ptr: *mut u32, bit: u32) -> BOOL;
    pub fn OSTestAndSetAtomic(ptr: *mut u32, bit: u32) -> BOOL;
    pub fn MEMCreateUnitHeapEx(
        heap: *mut ::core::ffi::c_void,
        size: u32,
        blockSize: u32,
        alignment: i32,
        flags: u16,
    ) -> MEMHeapHandle;
    pub fn MEMDestroyUnitHeap(heap: MEMHeapHandle) -> *mut ::core::ffi::c_void;
    pub fn MEMAllocFromUnitHeap(heap: MEMHeapHandle) -> *mut ::core::ffi::c_void;
    pub fn MEMFreeToUnitHeap(heap: MEMHeapHandle, block: *mut ::core::ffi::c_void);
    pub fn MEMiDumpUnitHeap(heap: MEMHeapHandle);
    pub fn MEMCountFreeBlockForUnitHeap(heap: MEMHeapHandle) -> u32;
    pub fn MEMCalcHeapSizeForUnitHeap(blockSize: u32, count: u32, alignment: i32) -> u32;
    pub fn OSGetCoreCount() -> u32;
    pub fn OSGetCoreId() -> u32;
    pub fn OSGetMainCoreId() -> u32;
    pub fn OSIsMainCore() -> BOOL;
    pub fn smdPpcInit(
        buf: *mut ::core::ffi::c_void,
        bufSize: u32,
        messageCount: u32,
        name: *const ::core::ffi::c_char,
        lockType: SmdLockType::Type,
    ) -> *mut SmdPpc;
    pub fn smdPpcGetCtrlTableVectors(
        smd: *mut SmdPpc,
        outVectors: *mut SmdPpcCtrlTableVectors,
    ) -> i32;
    pub fn smdPpcOpen(smd: *mut SmdPpc) -> i32;
    pub fn smdPpcClose(smd: *mut SmdPpc) -> i32;
    pub fn smdPpcGetInterfaceState(
        smd: *mut SmdPpc,
        outPpcState: *mut SmdInterfaceState::Type,
        outIopState: *mut SmdInterfaceState::Type,
    ) -> i32;
    pub fn smdPpcReceive(smd: *mut SmdPpc, data: *mut SmdReceiveData) -> i32;
    pub fn smdPpcSendMessage(
        smd: *mut SmdPpc,
        message: *mut ::core::ffi::c_void,
        messageSize: u32,
    ) -> i32;
    pub fn smdPpcSendVectorSpec(
        smd: *mut SmdPpc,
        command: u32,
        specs: *mut SmdVectorSpec,
        specsCount: i32,
    ) -> i32;
    pub fn smdPpcSendVector(smd: *mut SmdPpc, vector: *mut SmdVector) -> i32;
    pub fn smdSimpleBufPoolCreate(
        poolData: *mut ::core::ffi::c_void,
        poolDataSize: u32,
        allocSize: u32,
        allocCount: u32,
        lockType: SmdLockType::Type,
    ) -> *mut SmdSimpleBufPool;
    pub fn smdSimpleBufAlloc(
        pool: *mut SmdSimpleBufPool,
        outAlloc: *mut *mut ::core::ffi::c_void,
    ) -> i32;
    pub fn smdSimpleBufFree(pool: *mut SmdSimpleBufPool, alloc: *mut ::core::ffi::c_void) -> i32;
    pub fn smdSimpleBufGetStatistics(
        pool: *mut SmdSimpleBufPool,
        allocCount: *mut u32,
        freeErrorCount: *mut u32,
    ) -> i32;
    pub fn __OSGetSavedAudioFlags() -> ::core::ffi::c_int;
    pub fn __OSGetTransitionAudioBuffer(
        buffer: *mut *mut ::core::ffi::c_void,
        size: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn __OSSetTransitionAudioSize(size: u32);
    pub fn OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
    pub fn __OSConsoleWrite(msg: *const ::core::ffi::c_char, size: u32);
    pub fn OSReport(fmt: *const ::core::ffi::c_char, ...);
    pub fn OSReportVerbose(fmt: *const ::core::ffi::c_char, ...);
    pub fn OSReportInfo(fmt: *const ::core::ffi::c_char, ...);
    pub fn OSReportWarn(fmt: *const ::core::ffi::c_char, ...);
    pub fn OSPanic(
        file: *const ::core::ffi::c_char,
        line: u32,
        fmt: *const ::core::ffi::c_char,
        ...
    );
    pub fn OSFatal(msg: *const ::core::ffi::c_char);
    pub fn OSGetSymbolName(
        addr: u32,
        symbolNameBuf: *mut ::core::ffi::c_char,
        symbolNameBufSize: u32,
    ) -> u32;
    pub fn OSGetUPID() -> u32;
    pub fn OSIsDebuggerInitialized() -> BOOL;
    pub fn OSIsDebuggerPresent() -> BOOL;
    pub fn OSIsECOBoot() -> BOOL;
    pub fn OSIsECOMode() -> BOOL;
    pub fn __OSSetCrashRecovery(crashRecovery: u32);
    pub fn __OSGetCrashRecovery() -> u32;
    pub fn DisassemblePPCOpcode(
        opcode: *mut u32,
        buffer: *mut ::core::ffi::c_char,
        bufferSize: u32,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    ) -> BOOL;
    pub fn DisassemblePPCRange(
        start: *mut ::core::ffi::c_void,
        end: *mut ::core::ffi::c_void,
        printFn: DisassemblyPrintFn,
        findSymbolFn: DisassemblyFindSymbolFn,
        flags: DisassemblePPCFlags::Type,
    );
    pub fn MEMCreateExpHeapEx(
        heap: *mut ::core::ffi::c_void,
        size: u32,
        flags: u16,
    ) -> MEMHeapHandle;
    pub fn MEMDestroyExpHeap(heap: MEMHeapHandle) -> *mut ::core::ffi::c_void;
    pub fn MEMAllocFromExpHeapEx(
        heap: MEMHeapHandle,
        size: u32,
        alignment: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMFreeToExpHeap(heap: MEMHeapHandle, block: *mut ::core::ffi::c_void);
    pub fn MEMSetAllocModeForExpHeap(
        heap: MEMHeapHandle,
        mode: MEMExpHeapMode::Type,
    ) -> MEMExpHeapMode::Type;
    pub fn MEMGetAllocModeForExpHeap(heap: MEMHeapHandle) -> MEMExpHeapMode::Type;
    pub fn MEMAdjustExpHeap(heap: MEMHeapHandle) -> u32;
    pub fn MEMResizeForMBlockExpHeap(
        heap: MEMHeapHandle,
        block: *mut ::core::ffi::c_void,
        size: u32,
    ) -> u32;
    pub fn MEMGetTotalFreeSizeForExpHeap(heap: MEMHeapHandle) -> u32;
    pub fn MEMGetAllocatableSizeForExpHeapEx(
        heap: MEMHeapHandle,
        alignment: ::core::ffi::c_int,
    ) -> u32;
    pub fn MEMSetGroupIDForExpHeap(heap: MEMHeapHandle, id: u16) -> u16;
    pub fn MEMGetGroupIDForExpHeap(heap: MEMHeapHandle) -> u16;
    pub fn MEMGetSizeForMBlockExpHeap(block: *mut ::core::ffi::c_void) -> u32;
    pub fn MEMGetGroupIDForMBlockExpHeap(block: *mut ::core::ffi::c_void) -> u16;
    pub fn MEMGetAllocDirForMBlockExpHeap(
        block: *mut ::core::ffi::c_void,
    ) -> MEMExpHeapDirection::Type;
    pub fn MEMVisitAllocatedForExpHeap(
        heap: MEMHeapHandle,
        callback: MEMExpHeapBlockVisitor,
        context: *mut ::core::ffi::c_void,
    );
    pub fn MEMCheckExpHeap(handle: MEMHeapHandle, mode: MEMExpHeapCheckFlags::Type) -> BOOL;
    pub fn bspInitializeShimInterface() -> BSPError;
    pub fn bspShutdownShimInterface() -> BSPError;
    pub fn bspGetHardwareVersion(version: *mut BSPHardwareVersion) -> BSPError;
    pub fn bspGetConsoleTypeRaw(consoleTypeRaw: *mut BSPConsoleTypeRaw) -> BSPError;
    pub fn bspInitialize(
        entityName: *const ::core::ffi::c_char,
        instance: u32,
        attributeName: *const ::core::ffi::c_char,
        optionSize: u32,
        pOptions: *mut ::core::ffi::c_void,
    ) -> BSPError;
    pub fn bspShutdown(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
    ) -> BSPError;
    pub fn bspGetEntityVersion(
        entityName: *const ::core::ffi::c_char,
        entityVersion: *mut u32,
    ) -> BSPError;
    pub fn bspRead(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
    pub fn bspWrite(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
    pub fn bspQuery(
        entity: *const ::core::ffi::c_char,
        instance: u8,
        attribute: *const ::core::ffi::c_char,
        size: usize,
        ptr: *mut ::core::ffi::c_void,
    ) -> BSPError;
    pub fn OSEnableForegroundExit();
    pub fn OSReleaseForeground();
    pub fn OSSavesDone_ReadyToRelease();
    pub fn OSGetAtomic64(ptr: *mut u64) -> u64;
    pub fn OSSetAtomic64(ptr: *mut u64, value: u64) -> u64;
    pub fn OSCompareAndSwapAtomic64(ptr: *mut u64, compare: u64, value: u64) -> BOOL;
    pub fn OSCompareAndSwapAtomicEx64(
        ptr: *mut u64,
        compare: u64,
        value: u64,
        old: *mut u64,
    ) -> BOOL;
    pub fn OSSwapAtomic64(ptr: *mut u64, value: u64) -> u64;
    pub fn OSAddAtomic64(ptr: *mut i64, value: i64) -> i64;
    pub fn OSAndAtomic64(ptr: *mut u64, value: u64) -> u64;
    pub fn OSOrAtomic64(ptr: *mut u64, value: u64) -> u64;
    pub fn OSXorAtomic64(ptr: *mut u64, value: u64) -> u64;
    pub fn OSTestAndClearAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
    pub fn OSTestAndSetAtomic64(ptr: *mut u64, bit: u32) -> BOOL;
    pub fn __os_snprintf(
        buf: *mut ::core::ffi::c_char,
        n: usize,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn MPInitTaskQ(queue: *mut MPTaskQueue, queueBuffer: *mut *mut MPTask, queueBufferLen: u32);
    pub fn MPTermTaskQ(queue: *mut MPTaskQueue) -> BOOL;
    pub fn MPGetTaskQInfo(queue: *mut MPTaskQueue, info: *mut MPTaskQueueInfo) -> BOOL;
    pub fn MPStartTaskQ(queue: *mut MPTaskQueue) -> BOOL;
    pub fn MPStopTaskQ(queue: *mut MPTaskQueue) -> BOOL;
    pub fn MPResetTaskQ(queue: *mut MPTaskQueue) -> BOOL;
    pub fn MPEnqueTask(queue: *mut MPTaskQueue, task: *mut MPTask) -> BOOL;
    pub fn MPDequeTask(queue: *mut MPTaskQueue) -> *mut MPTask;
    pub fn MPDequeTasks(
        queue: *mut MPTaskQueue,
        queueBuffer: *mut *mut MPTask,
        queueBufferLen: u32,
    ) -> u32;
    pub fn MPWaitTaskQ(queue: *mut MPTaskQueue, mask: MPTaskQueueState::Type) -> BOOL;
    pub fn MPWaitTaskQWithTimeout(
        queue: *mut MPTaskQueue,
        wmask: MPTaskQueueState::Type,
        timeout: OSTime,
    ) -> BOOL;
    pub fn MPPrintTaskQStats(queue: *mut MPTaskQueue, unk: u32) -> BOOL;
    pub fn MPInitTask(task: *mut MPTask, func: MPTaskFunc, userArg1: u32, userArg2: u32);
    pub fn MPTermTask(task: *mut MPTask) -> BOOL;
    pub fn MPGetTaskInfo(task: *mut MPTask, info: *mut MPTaskInfo) -> BOOL;
    pub fn MPGetTaskUserData(task: *mut MPTask) -> *mut ::core::ffi::c_void;
    pub fn MPSetTaskUserData(task: *mut MPTask, userData: *mut ::core::ffi::c_void);
    pub fn MPRunTasksFromTaskQ(queue: *mut MPTaskQueue, count: u32) -> BOOL;
    pub fn MPRunTask(task: *mut MPTask) -> BOOL;
    pub fn OSForceFullRelaunch();
    pub fn OSRestartGame(argc: ::core::ffi::c_int, argv: *mut *mut ::core::ffi::c_char);
    pub fn OSShutdown() -> BOOL;
    pub fn OSLaunchTitleByPathl(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        ...
    );
    pub fn OSLaunchTitleByPathv(
        path: *const ::core::ffi::c_char,
        pathSize: u32,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
    pub fn OSLaunchTitlel(titleId: u64, argc: ::core::ffi::c_int, ...);
    pub fn OSLaunchTitlev(
        titleId: u64,
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    );
    pub fn OSEffectiveToPhysical(virtualAddress: u32) -> u32;
    pub fn __OSPhysicalToEffectiveCached(physicalAddress: u32) -> u32;
    pub fn __OSPhysicalToEffectiveUncached(physicalAddress: u32) -> u32;
    pub fn OSIsAddressValid(virtualAddress: u32) -> BOOL;
    pub fn __OSValidateAddressSpaceRange(
        arg1: ::core::ffi::c_int,
        virtualAddress: u32,
        size: u32,
    ) -> BOOL;
    pub fn OSAllocVirtAddr(virtualAddress: u32, size: u32, align: u32) -> u32;
    pub fn OSFreeVirtAddr(virtualAddress: u32, size: u32) -> BOOL;
    pub fn OSQueryVirtAddr(virtualAddress: u32) -> OSMemoryMapMode::Type;
    pub fn OSMapMemory(
        virtualAddress: u32,
        physicalAddress: u32,
        size: u32,
        mode: OSMemoryMapMode::Type,
    ) -> BOOL;
    pub fn OSUnmapMemory(virtualAddress: u32, size: u32) -> BOOL;
    pub fn OSGetMapVirtAddrRange(outVirtualAddress: *mut u32, outSize: *mut u32);
    pub fn OSGetAvailPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
    pub fn OSGetDataPhysAddrRange(outPhysicalAddress: *mut u32, outSize: *mut u32);
    pub fn FSAInit() -> FSError::Type;
    pub fn FSAShutdown();
    pub fn FSAGetClientNum() -> u32;
    pub fn FSAAddClient(attachAsyncData: *mut FSAClientAttachAsyncData) -> FSAClientHandle;
    pub fn FSADelClient(client: FSAClientHandle) -> FSError::Type;
    pub fn FSAGetStatusStr(error: FSError::Type) -> *const ::core::ffi::c_char;
    pub fn __FSAShimDecodeIosErrorToFsaStatus(
        handle: IOSHandle,
        err: IOSError::Type,
    ) -> FSError::Type;
    pub fn FSAFlushMultiQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSAFlushQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSAFlushVolume(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSAFreeAsyncResult(asyncResult: *mut FSAAsyncResult);
    pub fn FSAGetAsyncResult(asyncResult: *mut OSMessage) -> FSAAsyncResult;
    pub fn FSAMount(
        client: FSAClientHandle,
        source: *const ::core::ffi::c_char,
        target: *const ::core::ffi::c_char,
        flags: FSAMountFlags::Type,
        arg_buf: *mut ::core::ffi::c_void,
        arg_len: u32,
    ) -> FSError::Type;
    pub fn FSAUnmount(
        client: FSAClientHandle,
        mountedTarget: *const ::core::ffi::c_char,
        flags: FSAUnmountFlags::Type,
    ) -> FSError::Type;
    pub fn FSAChangeDir(client: FSAClientHandle, path: *const ::core::ffi::c_char)
        -> FSError::Type;
    pub fn FSAChangeMode(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        permission: FSMode::Type,
    ) -> FSError::Type;
    pub fn FSAOpenFileEx(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        createMode: FSMode::Type,
        openFlag: FSOpenFileFlags::Type,
        preallocSize: u32,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError::Type;
    pub fn FSAOpenFileByStat(
        client: FSAClientHandle,
        stat: *mut FSAStat,
        mode: *const ::core::ffi::c_char,
        path: *const ::core::ffi::c_char,
        outFileHandle: *mut FSAFileHandle,
    ) -> FSError::Type;
    pub fn FSAGetStatFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        stat: *mut FSAStat,
    ) -> FSError::Type;
    pub fn FSAGetStat(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        stat: *mut FSAStat,
    ) -> FSError::Type;
    pub fn FSACloseFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
    pub fn FSAAppendFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
    ) -> FSError::Type;
    pub fn FSAAppendFileEx(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        size: u32,
        count: u32,
        flags: u32,
    ) -> FSError::Type;
    pub fn FSAGetPosFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        outPos: *mut u32,
    ) -> FSError::Type;
    pub fn FSAFlushFile(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
    pub fn FSASetPosFile(
        client: FSAClientHandle,
        fileHandle: FSAFileHandle,
        pos: u32,
    ) -> FSError::Type;
    pub fn FSATruncateFile(client: FSAClientHandle, handle: FSAFileHandle) -> FSError::Type;
    pub fn FSAWriteFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
    pub fn FSAWriteFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
    pub fn FSAIsEof(client: FSAClientHandle, fileHandle: FSAFileHandle) -> FSError::Type;
    pub fn FSAReadFile(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
    pub fn FSAReadFileWithPos(
        client: FSAClientHandle,
        buffer: *mut ::core::ffi::c_void,
        size: u32,
        count: u32,
        pos: u32,
        handle: FSAFileHandle,
        flags: u32,
    ) -> FSError::Type;
    pub fn FSARemove(client: FSAClientHandle, path: *const ::core::ffi::c_char) -> FSError::Type;
    pub fn FSARename(
        client: FSAClientHandle,
        oldPath: *const ::core::ffi::c_char,
        newPath: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSAOpenDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        dirHandle: *mut FSADirectoryHandle,
    ) -> FSError::Type;
    pub fn FSAReadDir(
        client: FSAClientHandle,
        dirHandle: FSADirectoryHandle,
        directoryEntry: *mut FSADirectoryEntry,
    ) -> FSError::Type;
    pub fn FSARewindDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError::Type;
    pub fn FSACloseDir(client: FSAClientHandle, dirHandle: FSADirectoryHandle) -> FSError::Type;
    pub fn FSAMakeDir(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        mode: FSMode::Type,
    ) -> FSError::Type;
    pub fn FSAGetCwd(
        client: FSAClientHandle,
        outPath: *mut ::core::ffi::c_char,
        outPathLen: u32,
    ) -> FSError::Type;
    pub fn FSAGetTransactionBlockPoolAttributes(
        messageSize: *mut u32,
        poolSize: *mut u32,
        numMessages: *mut u32,
    ) -> FSError::Type;
    pub fn FSAGetVolumeInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        outVolumeInfo: *mut FSAVolumeInfo,
    ) -> FSError::Type;
    pub fn FSAMakeQuota(
        client: FSAClientHandle,
        name: *const ::core::ffi::c_char,
        mode: u32,
        quota: u64,
    ) -> FSError::Type;
    pub fn FSARegisterFlushQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSARollbackQuota(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSARollbackQuotaForce(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSARollbackVolume(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
    ) -> FSError::Type;
    pub fn FSAGetFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeSpaceSize: *mut u64,
    ) -> FSError::Type;
    pub fn FSAGetJournalFreeSpaceSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        journalFreeSpaceSize: *mut u64,
    ) -> FSError::Type;
    pub fn FSAGetDirSize(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        freeDirSize: *mut u64,
    ) -> FSError::Type;
    pub fn FSAGetEntryNum(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        entryNum: *mut FSAEntryNum,
    ) -> FSError::Type;
    pub fn FSAGetFileSystemInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSAFileSystemInfo,
    ) -> FSError::Type;
    pub fn FSAGetDeviceInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        fileSystemInfo: *mut FSADeviceInfo,
    ) -> FSError::Type;
    pub fn FSAGetBadBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError::Type;
    pub fn FSAGetFragmentBlockInfo(
        client: FSAClientHandle,
        path: *const ::core::ffi::c_char,
        blockInfo: *mut FSABlockInfo,
    ) -> FSError::Type;
    pub fn OSStopWatchStart(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
    pub fn OSStopWatchStop(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
    pub fn OSStopWatchLap(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
    pub fn OSStopWatchReset(stopWatch: *mut OSStopWatchAtomic) -> OSTime;
    pub fn OSSetPerformanceMonitor(
        arg_mask: u32,
        mmcr0: u32,
        mmcr1: u32,
        pmc1: u32,
        pmc2: u32,
        pmc3: u32,
        pmc4: u32,
    );
    pub fn MEMCreateFrmHeapEx(
        heap: *mut ::core::ffi::c_void,
        size: u32,
        flags: u32,
    ) -> MEMHeapHandle;
    pub fn MEMDestroyFrmHeap(heap: MEMHeapHandle) -> *mut ::core::ffi::c_void;
    pub fn MEMAllocFromFrmHeapEx(
        heap: MEMHeapHandle,
        size: u32,
        alignment: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_void;
    pub fn MEMFreeToFrmHeap(heap: MEMHeapHandle, mode: MEMFrmHeapFreeMode::Type);
    pub fn MEMRecordStateForFrmHeap(heap: MEMHeapHandle, tag: u32) -> BOOL;
    pub fn MEMFreeByStateToFrmHeap(heap: MEMHeapHandle, tag: u32) -> BOOL;
    pub fn MEMAdjustFrmHeap(heap: MEMHeapHandle) -> u32;
    pub fn MEMResizeForMBlockFrmHeap(heap: MEMHeapHandle, addr: u32, size: u32) -> u32;
    pub fn MEMGetAllocatableSizeForFrmHeapEx(
        heap: MEMHeapHandle,
        alignment: ::core::ffi::c_int,
    ) -> u32;
    pub fn OSGetCodegenVirtAddrRange(
        outVirtualAddress: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    );
    pub fn OSGetCodegenCore() -> u32;
    pub fn OSGetCodegenMode() -> u32;
    pub fn OSSwitchSecCodeGenMode(mode: OSCodegenSecMode::Type) -> BOOL;
    pub fn OSGetSecCodeGenMode() -> u32;
    pub fn OSCodegenCopy(
        dst: *mut ::core::ffi::c_void,
        src: *mut ::core::ffi::c_void,
        size: usize,
    ) -> BOOL;
    pub fn OSGetSharedData(
        type_: OSSharedDataType::Type,
        unk_r4: u32,
        outPtr: *mut *mut ::core::ffi::c_void,
        outSize: *mut u32,
    ) -> BOOL;
    pub fn __OSRootLoadShared();
    pub fn OSBlockMove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        size: u32,
        flush: BOOL,
    ) -> *mut ::core::ffi::c_void;
    pub fn OSBlockSet(
        dst: *mut ::core::ffi::c_void,
        val: u8,
        size: u32,
    ) -> *mut ::core::ffi::c_void;
    pub fn OSAllocFromSystem(size: u32, align: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn OSFreeToSystem(ptr: *mut ::core::ffi::c_void);
    pub fn OSGetForegroundBucket(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
    pub fn OSGetForegroundBucketFreeArea(outAddr: *mut u32, outSize: *mut u32) -> BOOL;
    pub fn OSGetMemBound(
        type_: OSMemoryType::Type,
        outAddr: *mut u32,
        outSize: *mut u32,
    ) -> ::core::ffi::c_int;
    pub fn __OSZeroProcessMemory(proccesID: u32);
    pub fn OSGetTitleID() -> u64;
    pub fn OSInitCoroutine(
        coroutine: *mut OSCoroutine,
        entry: *mut ::core::ffi::c_void,
        stack: *mut ::core::ffi::c_void,
    );
    pub fn OSLoadCoroutine(coroutine: *mut OSCoroutine, result: u32) -> u32;
    pub fn OSSaveCoroutine(coroutine: *mut OSCoroutine) -> u32;
    pub fn OSSwitchCoroutine(from: *mut OSCoroutine, to: *mut OSCoroutine);
    pub fn OSScreenInit();
    pub fn OSScreenShutdown();
    pub fn OSScreenGetBufferSizeEx(screen: OSScreenID::Type) -> u32;
    pub fn OSScreenSetBufferEx(screen: OSScreenID::Type, addr: *mut ::core::ffi::c_void);
    pub fn OSScreenClearBufferEx(screen: OSScreenID::Type, colour: u32);
    pub fn OSScreenFlipBuffersEx(screen: OSScreenID::Type);
    pub fn OSScreenPutFontEx(
        screen: OSScreenID::Type,
        column: u32,
        row: u32,
        buffer: *const ::core::ffi::c_char,
    );
    pub fn OSScreenPutPixelEx(screen: OSScreenID::Type, x: u32, y: u32, colour: u32);
    pub fn OSScreenEnableEx(screen: OSScreenID::Type, enable: BOOL);
}
